*      SPITBOL CONDITIONAL ASSEMBLY SYMBOLS FOR USE BY TOKEN.SPT
*      ---------------------------------------------------------
*
*      THIS FILE OF CONDITIONAL SYMBOLS WILL OVERRIDE THE CONDITIONAL
*      DEFINITIONS CONTAINED IN THE SPITBOL MINIMAL FILE.   IN ADDITION,
*      LINES BEGINNING WITH ">" ARE TREATED AS SPITBOL STATEMENTS AND
*      IMMEDIATELY EXECUTED.
*
*      FOR Linux SPITBOL-x86
*
*      IN THE SPITBOL TRANSLATOR, THE FOLLOWING CONDITIONAL
*      ASSEMBLY SYMBOLS ARE REFERRED TO. TO INCORPORATE THE
*      FEATURES REFERRED TO, THE MINIMAL SOURCE SHOULD BE
*      PREFACED BY SUITABLE CONDITIONAL ASSEMBLY SYMBOL
*      DEFINITIONS.
*      IN ALL CASES IT IS PERMISSIBLE TO DEFAULT THE DEFINITIONS
*      IN WHICH CASE THE ADDITIONAL FEATURES WILL BE OMITTED
*      FROM THE TARGET CODE.
*
*
*                            CONDITIONAL OPTIONS
*                            SINCE .UNDEF NOT ALLOWED IF SYMBOL NOT
*                            DEFINED, A FULL COMMENT LINE INDICATES
*                            SYMBOL INITIALLY NOT DEFINED.
*
*      .CAVT                 DEFINE TO INCLUDE VERTICAL TAB
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CENG                 DEFINE TO INCLUDE ENGINE FEATURES
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNCR                 DEFINE TO ENABLE SYSCR ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLD                 DEFINE TO OMIT LOAD() CODE.
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*DEF   .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CRPP                 DEFINE IF RETURN POINTS HAVE ODD PARITY
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CSN5                 DEFINE TO PAD STMT NOS TO 5 CHARS
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*      .CUSR                 DEFINE TO HAVE SET() USE REAL VALUES
*                             (MUST ALSO #DEFINE SETREAL 1 IN SYSTYPE.H)
*
{{TTL{27,L I C E N S E -- SOFTWARE LICENSE FOR THIS PROGRAM{{{{77
*
*     Copyright 1983-2012 Robert B. K. Dewar
*     Copyright 2012-2013 David Shields
*
*     This file is part of Macro SPITBOL.
*
*     Macro SPITBOL is free software: you can redistribute it and/or modify
*     it under the terms of the GNU General Public License as published by
*     the Free Software Foundation, either version 2 of the License, or
*     (at your option) any later version.
*
*     Macro SPITBOL is distributed in the hope that it will be useful,
*     but WITHOUT ANY WARRANTY; without even the implied warranty of
*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*     GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with Macro SPITBOL.  If not, see <http://www.gnu.org/licenses/>.
*
{{TTL{27,S P I T B O L -- NOTES TO IMPLEMENTORS{{{{97
*
*      M A C R O   S P I T B O L     V E R S I O N   13.01
*      ---------------------------------------------------
*
*      DATE OF RELEASE  -  JANUARY 2013
*
*      MACRO SPITBOL IS MAINTAINED BY
*           DR. DAVID SHIELDS
*           260 GARTH RD APT 3H4
*           SCARSDALE, NY 10583
*      E-MAIL - THEDAVESHIELDS AT GMAIL DOT COM
*
*      VERSION 3.7 WAS MAINTAINED BY
*           MARK EMMER
*           CATSPAW, INC.
*           P.O. BOX 1123
*           SALIDA, COLORADO 81021
*           U.S.A
*      E-MAIL - MARKE AT SNOBOL4 DOT COM
*
*      VERSIONS 2.6 THROUGH 3.4 WERE MAINTAINED BY
*           DR. A. P. MCCANN (DECEASED)
*           DEPARTMENT OF COMPUTER STUDIES
*           UNIVERSITY OF LEEDS
*           LEEDS LS2 9JT
*           ENGLAND.
*
*      FROM 1979 THROUGH EARLY 1983 A NUMBER OF FIXES AND
*      ENHANCEMENTS WERE MADE BY STEVE DUFF AND ROBERT GOLDBERG.
*
*
{{TTL{27,S P I T B O L - REVISION HISTORY{{{{129
{{EJC{{{{{130
*      R E V I S I O N   H I S T O R Y
*      -------------------------------
*
*      VERSION 13.01 (JANUARY 2013, DAVID SHIELDS)
*
*      THIS VERSION HAS THE SAME FUNCTIONALITY AS THE PREVIOUS RELEASE, BUT WITH
*      MANY INTERNAL CODE CHANGES.
*      SUPPORT FOR X86-64 HAS BEEN ADDED, BUT IS NOT CURRENTLY WORKING.
*      THE DESCRIPTION OF THE MINIMAL LANGUAGE FORMERLY FOUND HERE AS COMMENTS
*      IS NOW TO BE FOUND IN THE FILE MINIMAL-REFERENCE-MANUAL.HTML
*
*      VERSION 3.8 (JUNE 2012, DAVID SHIELDS)
*      --------------------------------------
*
*	       THIS VERSION IS VERY CLOSE TO V3.7, WITH THE
*              SAME FUNCTIONALITY.
*
*              THE SOURCE IS NOW MAINTAINED USING GIT, SO GOING FORWARD
*              THE DETAILED REVISION HISTORY WILL BE RECORDED IN THE GIT
*              COMMIT LOGS, NOT IN THIS FILE.
*
{{TTL{27,S P I T B O L  -- BASIC INFORMATION{{{{152
{{EJC{{{{{153
*
*      GENERAL STRUCTURE
*      -----------------
*
*      THIS PROGRAM IS A TRANSLATOR FOR A VERSION OF THE SNOBOL4
*      PROGRAMMING LANGUAGE. LANGUAGE DETAILS ARE CONTAINED IN
*      THE MANUAL MACRO SPITBOL BY DEWAR AND MCCANN, TECHNICAL
*      REPORT 90, UNIVERSITY OF LEEDS 1976.
*      THE IMPLEMENTATION IS DISCUSSED IN DEWAR AND MCCANN,
*      MACRO SPITBOL - A SNOBOL4 COMPILER, SOFTWARE PRACTICE AND
*      EXPERIENCE, 7, 95-113, 1977.
*      THE LANGUAGE IS AS IMPLEMENTED BY THE BTL TRANSLATOR
*      (GRISWOLD, POAGE AND POLONSKY, PRENTICE HALL, 1971)
*      WITH THE FOLLOWING PRINCIPAL EXCEPTIONS.
*
*      1)   REDEFINITION OF STANDARD SYSTEM FUNCTIONS AND
*           OPERATORS IS NOT PERMITTED.
*
*      2)   THE VALUE FUNCTION IS NOT PROVIDED.
*
*      3)   ACCESS TRACING IS PROVIDED IN ADDITION TO THE
*           OTHER STANDARD TRACE MODES.
*
*      4)   THE KEYWORD STFCOUNT IS NOT PROVIDED.
*
*      5)   THE KEYWORD FULLSCAN IS NOT PROVIDED AND ALL PATTERN
*           MATCHING TAKES PLACE IN FULLSCAN MODE (I.E. WITH NO
*           HEURISTICS APPLIED).
*
*      6)   A SERIES OF EXPRESSIONS SEPARATED BY COMMAS MAY
*           BE GROUPED WITHIN PARENTHESES TO PROVIDE A SELECTION
*           CAPABILITY. THE SEMANTICS ARE THAT THE SELECTION
*           ASSUMES THE VALUE OF THE FIRST EXPRESSION WITHIN IT
*           WHICH SUCCEEDS AS THEY ARE EVALUATED FROM THE LEFT.
*           IF NO EXPRESSION SUCCEEDS THE ENTIRE STATEMENT FAILS
*
*      7)   AN EXPLICIT PATTERN MATCHING OPERATOR IS PROVIDED.
*           THIS IS THE BINARY QUERY (SEE GIMPEL SIGPLAN OCT 74)
*
*      8)   THE ASSIGNMENT OPERATOR IS INTRODUCED AS IN THE
*           GIMPEL REFERENCE.
*
*      9)   THE EXIT FUNCTION IS PROVIDED FOR GENERATING LOAD
*           MODULES - CF. GIMPELS SITBOL.
*
*
*      THE METHOD USED IN THIS PROGRAM IS TO TRANSLATE THE
*      SOURCE CODE INTO AN INTERNAL PSEUDO-CODE (SEE FOLLOWING
*      SECTION). AN INTERPRETOR IS THEN USED TO EXECUTE THIS
*      GENERATED PSEUDO-CODE. THE NATURE OF THE SNOBOL4 LANGUAGE
*      IS SUCH THAT THE LATTER TASK IS MUCH MORE COMPLEX THAN
*      THE ACTUAL TRANSLATION PHASE. ACCORDINGLY, NEARLY ALL THE
*      CODE IN THE PROGRAM SECTION IS CONCERNED WITH THE ACTUAL
*      EXECUTION OF THE SNOBOL4 PROGRAM.
{{EJC{{{{{208
*
*      INTERPRETIVE CODE FORMAT
*      ------------------------
*
*      THE INTERPRETIVE PSEUDO-CODE CONSISTS OF A SERIES OF
*      ADDRESS POINTERS. THE EXACT FORMAT OF THE CODE IS
*      DESCRIBED IN CONNECTION WITH THE CDBLK FORMAT. THE
*      PURPOSE OF THIS SECTION IS TO GIVE GENERAL INSIGHT INTO
*      THE INTERPRETIVE APPROACH INVOLVED.
*
*      THE BASIC FORM OF THE CODE IS RELATED TO REVERSE POLISH.
*      IN OTHER WORDS, THE OPERANDS PRECEDE THE OPERATORS WHICH
*      ARE ZERO ADDRESS OPERATORS. THERE ARE SOME EXCEPTIONS TO
*      THESE RULES, NOTABLY THE UNARY NOT OPERATOR AND THE
*      SELECTION CONSTRUCTION WHICH CLEARLY REQUIRE ADVANCE
*      KNOWLEDGE OF THE OPERATOR INVOLVED.
*
*      THE OPERANDS ARE MOVED TO THE TOP OF THE MAIN STACK AND
*      THE OPERATORS ARE APPLIED TO THE TOP STACK ENTRIES. LIKE
*      OTHER VERSIONS OF SPITBOL, THIS PROCESSOR DEPENDS ON
*      KNOWING WHETHER OPERANDS ARE REQUIRED BY NAME OR BY VALUE
*      AND MOVES THE APPROPRIATE OBJECT TO THE STACK. THUS NO
*      NAME/VALUE CHECKS ARE INCLUDED IN THE OPERATOR CIRCUITS.
*
*      THE ACTUAL POINTERS IN THE CODE POINT TO A BLOCK WHOSE
*      FIRST WORD IS THE ADDRESS OF THE INTERPRETOR ROUTINE
*      TO BE EXECUTED FOR THE CODE WORD.
*
*      IN THE CASE OF OPERATORS, THE POINTER IS TO A WORD WHICH
*      CONTAINS THE ADDRESS OF THE OPERATOR TO BE EXECUTED. IN
*      THE CASE OF OPERANDS SUCH AS CONSTANTS, THE POINTER IS TO
*      THE OPERAND ITSELF. ACCORDINGLY, ALL OPERANDS CONTAIN
*      A FIELD WHICH POINTS TO THE ROUTINE TO LOAD THE VALUE OF
*      THE OPERAND ONTO THE STACK. IN THE CASE OF A VARIABLE,
*      THERE ARE THREE SUCH POINTERS. ONE TO LOAD THE VALUE,
*      ONE TO STORE THE VALUE AND A THIRD TO JUMP TO THE LABEL.
*
*      THE HANDLING OF FAILURE RETURNS DESERVES SPECIAL COMMENT.
*      THE LOCATION FLPTR CONTAINS THE POINTER TO THE LOCATION
*      ON THE MAIN STACK WHICH CONTAINS THE FAILURE RETURN
*      WHICH IS IN THE FORM OF A BYTE OFFSET IN THE CURRENT
*      CODE BLOCK (CDBLK OR EXBLK). WHEN A FAILURE OCCURS, THE
*      STACK IS POPPED AS INDICATED BY THE SETTING OF FLPTR AND
*      CONTROL IS PASSED TO THE APPROPRIATE LOCATION IN THE
*      CURRENT CODE BLOCK WITH THE STACK POINTER POINTING TO THE
*      FAILURE OFFSET ON THE STACK AND FLPTR UNCHANGED.
{{EJC{{{{{255
*
*      INTERNAL DATA REPRESENTATIONS
*      -----------------------------
*
*      REPRESENTATION OF VALUES
*
*      A VALUE IS REPRESENTED BY A POINTER TO A BLOCK WHICH
*      DESCRIBES THE TYPE AND PARTICULARS OF THE DATA VALUE.
*      IN GENERAL, A VARIABLE IS A LOCATION CONTAINING SUCH A
*      POINTER (ALTHOUGH IN THE CASE OF TRACE ASSOCIATIONS THIS
*      IS MODIFIED, SEE DESCRIPTION OF TRBLK).
*
*      THE FOLLOWING IS A LIST OF POSSIBLE DATATYPES SHOWING THE
*      TYPE OF BLOCK USED TO HOLD THE VALUE. THE DETAILS OF
*      EACH BLOCK FORMAT ARE GIVEN LATER.
*
*      DATATYPE              BLOCK TYPE
*      --------              ----------
*
*      ARRAY                 ARBLK OR VCBLK
*
*      CODE                  CDBLK
*
*      EXPRESSION            EXBLK OR SEBLK
*
*      INTEGER               ICBLK
*
*      NAME                  NMBLK
*
*      PATTERN               P0BLK OR P1BLK OR P2BLK
*
*      REAL                  RCBLK
*
*      STRING                SCBLK
*
*      TABLE                 TBBLK
*
*      PROGRAM DATATYPE      PDBLK
{{EJC{{{{{294
*
*      REPRESENTATION OF VARIABLES
*      ---------------------------
*
*      DURING THE COURSE OF EVALUATING EXPRESSIONS, IT IS
*      NECESSARY TO GENERATE NAMES OF VARIABLES (FOR EXAMPLE
*      ON THE LEFT SIDE OF A BINARY EQUALS OPERATOR). THESE ARE
*      NOT TO BE CONFUSED WITH OBJECTS OF DATATYPE NAME WHICH
*      ARE IN FACT VALUES.
*
*      FROM A LOGICAL POINT OF VIEW, SUCH NAMES COULD BE SIMPLY
*      REPRESENTED BY A POINTER TO THE APPROPRIATE VALUE CELL.
*      HOWEVER IN THE CASE OF ARRAYS AND PROGRAM DEFINED
*      DATATYPES, THIS WOULD VIOLATE THE RULE THAT THERE MUST BE
*      NO POINTERS INTO THE MIDDLE OF A BLOCK IN DYNAMIC STORE.
*      ACCORDINGLY, A NAME IS ALWAYS REPRESENTED BY A BASE AND
*      OFFSET. THE BASE POINTS TO THE START OF THE BLOCK
*      CONTAINING THE VARIABLE VALUE AND THE OFFSET IS THE
*      OFFSET WITHIN THIS BLOCK IN BYTES. THUS THE ADDRESS
*      OF THE ACTUAL VARIABLE IS DETERMINED BY ADDING THE BASE
*      AND OFFSET VALUES.
*
*      THE FOLLOWING ARE THE INSTANCES OF VARIABLES REPRESENTED
*      IN THIS MANNER.
*
*      1)   NATURAL VARIABLE BASE IS PTR TO VRBLK
*                            OFFSET IS *VRVAL
*
*      2)   TABLE ELEMENT    BASE IS PTR TO TEBLK
*                            OFFSET IS *TEVAL
*
*      3)   ARRAY ELEMENT    BASE IS PTR TO ARBLK
*                            OFFSET IS OFFSET TO ELEMENT
*
*      4)   VECTOR ELEMENT   BASE IS PTR TO VCBLK
*                            OFFSET IS OFFSET TO ELEMENT
*
*      5)   PROG DEF DTP     BASE IS PTR TO PDBLK
*                            OFFSET IS OFFSET TO FIELD VALUE
*
*      IN ADDITION THERE ARE TWO CASES OF OBJECTS WHICH ARE
*      LIKE VARIABLES BUT CANNOT BE HANDLED IN THIS MANNER.
*      THESE ARE CALLED PSEUDO-VARIABLES AND ARE REPRESENTED
*      WITH A SPECIAL BASE POINTER AS FOLLOWS=
*
*      EXPRESSION VARIABLE   PTR TO EVBLK (SEE EVBLK)
*
*      KEYWORD VARIABLE      PTR TO KVBLK (SEE KVBLK)
*
*      PSEUDO-VARIABLES ARE HANDLED AS SPECIAL CASES BY THE
*      ACCESS PROCEDURE (ACESS) AND THE ASSIGNMENT PROCEDURE
*      (ASIGN). SEE THESE TWO PROCEDURES FOR DETAILS.
{{EJC{{{{{347
*
*      ORGANIZATION OF DATA AREA
*      -------------------------
*
*      THE DATA AREA IS DIVIDED INTO TWO REGIONS.
*
*      STATIC AREA
*
*      THE STATIC AREA BUILDS UP FROM THE BOTTOM AND CONTAINS
*      DATA AREAS WHICH ARE ALLOCATED DYNAMICALLY BUT ARE NEVER
*      DELETED OR MOVED AROUND. THE MACRO-PROGRAM ITSELF
*      USES THE STATIC AREA FOR THE FOLLOWING.
*
*      1)   ALL VARIABLE BLOCKS (VRBLK).
*
*      2)   THE HASH TABLE FOR VARIABLE BLOCKS.
*
*      3)   MISCELLANEOUS BUFFERS AND WORK AREAS (SEE PROGRAM
*           INITIALIZATION SECTION).
*
*      IN ADDITION, THE SYSTEM PROCEDURES MAY USE THIS AREA FOR
*      INPUT/OUTPUT BUFFERS, EXTERNAL FUNCTIONS ETC. SPACE IN
*      THE STATIC REGION IS ALLOCATED BY CALLING PROCEDURE ALOST
*
*      THE FOLLOWING GLOBAL VARIABLES DEFINE THE CURRENT
*      LOCATION AND SIZE OF THE STATIC AREA.
*
*      STATB                 ADDRESS OF START OF STATIC AREA
*      STATE                 ADDRESS+1 OF LAST WORD IN AREA.
*
*      THE MINIMUM SIZE OF STATIC IS GIVEN APPROXIMATELY BY
*           12 + *E_HNB + *E_STS + SPACE FOR ALPHABET STRING
*           AND STANDARD PRINT BUFFER.
{{EJC{{{{{381
*      DYNAMIC AREA
*
*      THE DYNAMIC AREA IS BUILT UPWARDS IN MEMORY AFTER THE
*      STATIC REGION. DATA IN THIS AREA MUST ALL BE IN STANDARD
*      BLOCK FORMATS SO THAT IT CAN BE PROCESSED BY THE GARBAGE
*      COLLECTOR (PROCEDURE GBCOL). GBCOL COMPACTS BLOCKS DOWN
*      IN THIS REGION AS REQUIRED BY SPACE EXHAUSTION AND CAN
*      ALSO MOVE ALL BLOCKS UP TO ALLOW FOR EXPANSION OF THE
*      STATIC REGION.
*      WITH THE EXCEPTION OF TABLES AND ARRAYS, NO SPITBOL
*      OBJECT ONCE BUILT IN DYNAMIC MEMORY IS EVER SUBSEQUENTLY
*      MODIFIED. OBSERVING THIS RULE NECESSITATES A COPYING
*      ACTION DURING STRING AND PATTERN CONCATENATION.
*
*      GARBAGE COLLECTION IS FUNDAMENTAL TO THE ALLOCATION OF
*      SPACE FOR VALUES. SPITBOL USES A VERY EFFICIENT GARBAGE
*      COLLECTOR WHICH INSISTS THAT POINTERS INTO DYNAMIC STORE
*      SHOULD BE IDENTIFIABLE WITHOUT USE OF BIT TABLES,
*      MARKER BITS ETC. TO SATISFY THIS REQUIREMENT, DYNAMIC
*      MEMORY MUST NOT START AT TOO LOW AN ADDRESS AND LENGTHS
*      OF ARRAYS, TABLES, STRINGS, CODE AND EXPRESSION BLOCKS
*      MAY NOT EXCEED THE NUMERICAL VALUE OF THE LOWEST DYNAMIC
*      ADDRESS.
*
*      TO AVOID EITHER PENALIZING USERS WITH MODEST
*      REQUIREMENTS OR RESTRICTING THOSE WITH GREATER NEEDS ON
*      HOST SYSTEMS WHERE DYNAMIC MEMORY IS ALLOCATED IN LOW
*      ADDRESSES, THE MINIMUM DYNAMIC ADDRESS MAY BE SPECIFIED
*      SUFFICIENTLY HIGH TO PERMIT ARBITRARILY LARGE SPITBOL
*      OBJECTS TO BE CREATED (WITH THE POSSIBILITY IN EXTREME
*      CASES OF WASTING LARGE AMOUNTS OF MEMORY BELOW THE
*      START ADDRESS). THIS MINIMUM VALUE IS MADE AVAILABLE
*      IN VARIABLE MXLEN BY A SYSTEM ROUTINE, SYSMX.
*      ALTERNATIVELY SYSMX MAY INDICATE THAT A
*      DEFAULT MAY BE USED IN WHICH DYNAMIC IS PLACED
*      AT THE LOWEST POSSIBLE ADDRESS FOLLOWING STATIC.
*
*      THE FOLLOWING GLOBAL WORK CELLS DEFINE THE LOCATION AND
*      LENGTH OF THE DYNAMIC AREA.
*
*      DNAMB                 START OF DYNAMIC AREA
*      DNAMP                 NEXT AVAILABLE LOCATION
*      DNAME                 LAST AVAILABLE LOCATION + 1
*
*      DNAMB IS ALWAYS HIGHER THAN STATE SINCE THE ALOST
*      PROCEDURE MAINTAINS SOME EXPANSION SPACE ABOVE STATE.
*      *** DNAMB MUST NEVER BE PERMITTED TO HAVE A VALUE LESS
*      THAN THAT IN MXLEN ***
*
*      SPACE IN THE DYNAMIC REGION IS ALLOCATED BY THE ALLOC
*      PROCEDURE. THE DYNAMIC REGION MAY BE USED BY SYSTEM
*      PROCEDURES PROVIDED THAT ALL THE RULES ARE OBEYED.
*      SOME OF THE RULES ARE SUBTLE SO IT IS PREFERABLE FOR
*      OSINT TO MANAGE ITS OWN MEMORY NEEDS. SPITBOL PROCS
*      OBEY RULES TO ENSURE THAT NO ACTION CAN CAUSE A GARBAGE
*      COLLECTION EXCEPT AT SUCH TIMES AS CONTENTS OF XL, XR
*      AND THE STACK ARE +CLEAN+ (SEE COMMENT BEFORE UTILITY
*      PROCEDURES AND IN GBCOL FOR MORE DETAIL). NOTE
*      THAT CALLS OF ALOST MAY CAUSE GARBAGE COLLECTION (SHIFT
*      OF MEMORY TO FREE SPACE). SPITBOL PROCS WHICH CALL
*      SYSTEM ROUTINES ASSUME THAT THEY CANNOT PRECIPITATE
*      COLLECTION AND THIS MUST BE RESPECTED.
{{EJC{{{{{444
*
*      REGISTER USAGE
*      --------------
*
*      (CP)                  CODE POINTER REGISTER. USED TO
*                            HOLD A POINTER TO THE CURRENT
*                            LOCATION IN THE INTERPRETIVE PSEUDO
*                            CODE (I.E. PTR INTO A CDBLK).
*
*      (XL,XR)               GENERAL INDEX REGISTERS. USUALLY
*                            USED TO HOLD POINTERS TO BLOCKS IN
*                            DYNAMIC STORAGE. AN IMPORTANT
*                            RESTRICTION IS THAT THE VALUE IN
*                            XL MUST BE COLLECTABLE FOR
*                            A GARBAGE COLLECT CALL. A VALUE
*                            IS COLLECTABLE IF IT EITHER POINTS
*                            OUTSIDE THE DYNAMIC AREA, OR IF IT
*                            POINTS TO THE START OF A BLOCK IN
*                            THE DYNAMIC AREA.
*
*      (XS)                  STACK POINTER. USED TO POINT TO
*                            THE STACK FRONT. THE STACK MAY
*                            BUILD UP OR DOWN AND IS USED
*                            TO STACK SUBROUTINE RETURN POINTS
*                            AND OTHER RECURSIVELY SAVED DATA.
*
*      (XT)                  AN ALTERNATIVE NAME FOR XL DURING
*                            ITS USE IN ACCESSING STACKED ITEMS.
*
*      (WA,WB,WC)            GENERAL WORK REGISTERS. CANNOT BE
*                            USED FOR INDEXING, BUT MAY HOLD
*                            VARIOUS TYPES OF DATA.
*
*      (IA)                  USED FOR ALL SIGNED INTEGER
*                            ARITHMETIC, BOTH THAT USED BY THE
*                            TRANSLATOR AND THAT ARISING FROM
*                            USE OF SNOBOL4 ARITHMETIC OPERATORS
*
*      (RA)                  REAL ACCUMULATOR. USED FOR ALL
*                            FLOATING POINT ARITHMETIC.
{{EJC{{{{{485
*
*      SPITBOL CONDITIONAL ASSEMBLY SYMBOLS
*      ------------------------------------
*
*      IN THE SPITBOL TRANSLATOR, THE FOLLOWING CONDITIONAL
*      ASSEMBLY SYMBOLS ARE REFERRED TO. TO INCORPORATE THE
*      FEATURES REFERRED TO, THE MINIMAL SOURCE SHOULD BE
*      PREFACED BY SUITABLE CONDITIONAL ASSEMBLY SYMBOL
*      DEFINITIONS.
*      IN ALL CASES IT IS PERMISSIBLE TO DEFAULT THE DEFINITIONS
*      IN WHICH CASE THE ADDITIONAL FEATURES WILL BE OMITTED
*      FROM THE TARGET CODE.
*
*      .CAEX                 DEFINE TO ALLOW UP ARROW FOR EXPON.
*      .CAHT                 DEFINE TO INCLUDE HORIZONTAL TAB
*      .CASL                 DEFINE TO INCLUDE 26 SHIFTED LETTRS
*      .CAVT                 DEFINE TO INCLUDE VERTICAL TAB
*      .CBYT                 DEFINE FOR STATISTICS IN BYTES
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CCMK                 DEFINE TO INCLUDE COMPARE KEYWORD
*      .CEPP                 DEFINE IF ENTRYS HAVE ODD PARITY
*      .CERA                 DEFINE TO INCLUDE SYSEA FUNCTION
*      .CEXP                 DEFINE IF SPITBOL POPS SYSEX ARGS
*      .CGBC                 DEFINE TO INCLUDE SYSGC FUNCTION
*      .CICC                 DEFINE TO IGNORE BAD CONTROL CARDS
*      .CINC                 DEFINE TO ADD -INCLUDE CONTROL CARD
*      .CIOD                 DEFINE TO NOT USE DEFAULT DELIMITER
*                              IN PROCESSING 3RD ARG OF INPUT()
*                              AND OUTPUT()
*      .CMTH                 DEFINE TO INCLUDE MATH FUNCTIONS
*      .CNBF                 DEFINE TO OMIT BUFFER EXTENSION
*      .CNBT                 DEFINE TO OMIT BATCH INITIALISATION
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNCR                 DEFINE TO ENABLE SYSCR ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLD                 DEFINE TO OMIT LOAD() CODE.
*      .CNLF                 DEFINE TO ADD FILE TYPE FOR LOAD()
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSC                 DEFINE TO NO NUMERIC-STRING COMPARE
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CPOL                 DEFINE IF INTERFACE POLLING DESIRED
*      .CREL                 DEFINE TO INCLUDE RELOC ROUTINES
*      .CRPP                 DEFINE IF RETURNS HAVE ODD PARITY
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CS32                 DEFINE TO INIT STLIM TO 2147483647
*                            OMIT TO TAKE DEFAULT OF 50000
*      .CSAX                 DEFINE IF SYSAX IS TO BE CALLED
*      .CSED                 DEFINE TO USE SEDIMENT IN GBCOL
*      .CSFN                 DEFINE TO TRACK SOURCE FILE NAMES
*      .CSLN                 DEFINE IF LINE NUMBER IN CODE BLOCK
*      .CSN5                 DEFINE TO PAD STMT NOS TO 5 CHARS
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CSN8                 DEFINE TO PAD STMT NOS TO 8 CHARS
*      .CSOU                 DEFINE IF OUTPUT, TERMINAL TO SYSOU
*      .CTET                 DEFINE TO TABLE ENTRY TRACE WANTED
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*      .CUCF                 DEFINE TO INCLUDE CFP_U
*      .CUEJ                 DEFINE TO SUPPRESS NEEDLESS EJECTS
*      .CULK                 DEFINE TO INCLUDE &L/UCASE KEYWORDS
*      .CULC                 DEFINE TO INCLUDE &CASE (LC NAMES)
*                            IF CUCL DEFINED, MUST SUPPORT
*                            MINIMAL OP FLC WREG THAT FOLDS
*                            ARGUMENT TO UPPER CASE
*      .CUST                 DEFINE TO INCLUDE SET() CODE
*
*                            CONDITIONAL OPTIONS
*                            SINCE .UNDEF NOT ALLOWED IF SYMBOL
*                            NOT DEFINED, A FULL COMMENT LINE
*                            INDICATES SYMBOL INITIALLY NOT
*                            DEFINED.
*
*      .CBYT                 DEFINE FOR STATISTICS IN BYTES
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CCMK                 DEFINE TO INCLUDE COMPARE KEYWORD
*      .CEPP                 DEFINE IF ENTRYS HAVE ODD PARITY
*      .CERA                 DEFINE TO INCLUDE SYSEA FUNCTION
*      .CEXP                 DEFINE IF SPITBOL POPS SYSEX ARGS
*      .CICC                 DEFINE TO IGNORE BAD CONTROL CARDS
*      .CINC                 DEFINE TO ADD -INCLUDE CONTROL CARD
*                            IN PROCESSING 3RD ARG OF INPUT()
*                            AND OUTPUT()
*      .CMTH                 DEFINE TO INCLUDE MATH FUNCTIONS
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNCR                 DEFINE TO ENABLE SYSCR ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLF                 DEFINE TO ADD FILE TYPE TO LOAD()
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSC                 DEFINE IF NO NUMERIC-STRING COMPARE
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CPOL                 DEFINE IF INTERFACE POLLING DESIRED
*      .CREL                 DEFINE TO INCLUDE RELOC ROUTINES
*      .CRPP                 DEFINE IF RETURNS HAVE ODD PARITY
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CS32                 DEFINE TO INIT STLIM TO 2147483647
*      .CSED                 DEFINE TO USE SEDIMENT IN GBCOL
*      .CSFN                 DEFINE TO TRACK SOURCE FILE NAMES
*      .CSLN                 DEFINE IF LINE NUMBER IN CODE BLOCK
*      .CSN5                 DEFINE TO PAD STMT NOS TO 5 CHARS
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CSOU                 DEFINE IF OUTPUT, TERMINAL TO SYSOU
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*
*      FORCE DEFINITION OF .CCMK IF .CCMC IS DEFINED
*
{{TTL{27,S P I T B O L -- PROCEDURES SECTION{{{{612
*
*      THIS SECTION STARTS WITH DESCRIPTIONS OF THE OPERATING
*      SYSTEM DEPENDENT PROCEDURES WHICH ARE USED BY THE SPITBOL
*      TRANSLATOR. ALL SUCH PROCEDURES HAVE FIVE LETTER NAMES
*      BEGINNING WITH SYS. THEY ARE LISTED IN ALPHABETICAL
*      ORDER.
*      ALL PROCEDURES HAVE A  SPECIFICATION CONSISTING OF A
*      MODEL CALL, PRECEDED BY A POSSIBLY EMPTY LIST OF REGISTER
*      CONTENTS GIVING PARAMETERS AVAILABLE TO THE PROCEDURE AND
*      FOLLOWED BY A POSSIBLY EMPTY LIST OF REGISTER CONTENTS
*      REQUIRED ON RETURN FROM THE CALL OR WHICH MAY HAVE HAD
*      THEIR CONTENTS DESTROYED. ONLY THOSE REGISTERS EXPLICITLY
*      MENTIONED IN THE LIST AFTER THE CALL MAY HAVE THEIR
*      VALUES CHANGED.
*      THE SEGMENT OF CODE PROVIDING THE EXTERNAL PROCEDURES IS
*      CONVENIENTLY REFERRED TO AS OSINT (OPERATING SYSTEM
*      INTERFACE). THE SYSXX PROCEDURES IT CONTAINS PROVIDE
*      FACILITIES NOT USUALLY AVAILABLE AS PRIMITIVES IN
*      ASSEMBLY LANGUAGES. FOR PARTICULAR TARGET MACHINES,
*      IMPLEMENTORS MAY CHOOSE FOR SOME MINIMAL OPCODES WHICH
*      DO NOT HAVE REASONABLY DIRECT TRANSLATIONS, TO USE CALLS
*      OF ADDITIONAL PROCEDURES WHICH THEY PROVIDE IN OSINT.
*      E.G. MWB OR TRC MIGHT BE TRANSLATED AS JSR SYSMB,
*      JSR SYSTC IN SOME IMPLEMENTATIONS.
*
*      IN THE DESCRIPTIONS, REFERENCE IS MADE TO --BLK
*      FORMATS (-- = A PAIR OF LETTERS). SEE THE SPITBOL
*      DEFINITIONS SECTION FOR DETAILED DESCRIPTIONS OF ALL
*      SUCH BLOCK FORMATS EXCEPT FCBLK FOR WHICH SYSFC SHOULD
*      BE CONSULTED.
*
*      SECTION 0 CONTAINS INP,INR SPECIFICATIONS OF INTERNAL
*      PROCEDURES,ROUTINES. THIS GIVES A SINGLE PASS TRANSLATOR
*      INFORMATION MAKING IT EASY TO GENERATE ALTERNATIVE CALLS
*      IN THE TRANSLATION OF JSR-S FOR PROCEDURES OF DIFFERENT
*      TYPES IF THIS PROVES NECESSARY.
*
{{SEC{{{{START OF PROCEDURES SECTION{650
{{EJC{{{{{652
*
*      SYSAX -- AFTER EXECUTION
*
{SYSAX{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{656
*
*      IF THE CONDITIONAL ASSEMBLY SYMBOL .CSAX IS DEFINED,
*      THIS ROUTINE IS CALLED IMMEDIATELY AFTER EXECUTION AND
*      BEFORE PRINTING OF EXECUTION STATISTICS OR DUMP OUTPUT.
*      PURPOSE OF CALL IS FOR IMPLEMENTOR TO DETERMINE AND
*      IF THE CALL IS NOT REQUIRED IT WILL BE OMITTED IF .CSAX
*      IS UNDEFINED. IN THIS CASE SYSAX NEED NOT BE CODED.
*
*      JSR  SYSAX            CALL AFTER EXECUTION
{{EJC{{{{{668
*
*      SYSBS -- BACKSPACE FILE
*
{SYSBS{EXP{1,3{{{DEFINE EXTERNAL ENTRY POINT{673
*
*      SYSBS IS USED TO IMPLEMENT THE SNOBOL4 FUNCTION BACKSPACE
*      IF THE CONDITIONAL ASSEMBLY SYMBOL .CBSP IS DEFINED.
*      THE MEANING IS SYSTEM DEPENDENT.  IN GENERAL, BACKSPACE
*      REPOSITIONS THE FILE ONE RECORD CLOSER TO THE BEGINNING
*      OF FILE, SUCH THAT A SUBSEQUENT READ OR WRITE WILL
*      OPERATE ON THE PREVIOUS RECORD.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  BACKSPACE ARGUMENT (SCBLK PTR)
*      JSR  SYSBS            CALL TO BACKSPACE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF BACKSPACE NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED FOR FILES FOR WHICH
*      BACKSPACE IS NOT PERMITTED. FOR EXAMPLE, IT MAY BE EXPECTED
*      FILES ON CHARACTER DEVICES ARE IN THIS CATEGORY.
{{EJC{{{{{693
*
*      SYSBX -- BEFORE EXECUTION
*
{SYSBX{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{698
*
*      CALLED AFTER INITIAL SPITBOL COMPILATION AND BEFORE
*      COMMENCING EXECUTION IN CASE OSINT NEEDS
*      TO ASSIGN FILES OR PERFORM OTHER NECESSARY SERVICES.
*      OSINT MAY ALSO CHOOSE TO SEND A MESSAGE TO ONLINE
*      TERMINAL (IF ANY) INDICATING THAT EXECUTION IS STARTING.
*
*      JSR  SYSBX            CALL BEFORE EXECUTION STARTS
{{EJC{{{{{707
*
*      SYSDC -- DATE CHECK
*
{SYSDC{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{801
*
*      SYSDC IS CALLED TO CHECK THAT THE EXPIRY DATE FOR A TRIAL
*      VERSION OF SPITBOL IS UNEXPIRED.
*
*      JSR  SYSDC            CALL TO CHECK DATE
*      RETURN ONLY IF DATE IS OK
{{EJC{{{{{808
*
*      SYSDM  -- DUMP CORE
*
{SYSDM{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{812
*
*      SYSDM IS CALLED BY A SPITBOL PROGRAM CALL OF DUMP(N) WITH
*      N GE 4.  ITS PURPOSE IS TO PROVIDE A CORE DUMP.
*      N COULD HOLD AN ENCODING OF THE START ADRS FOR DUMP AND
*      AMOUNT TO BE DUMPED E.G.  N = 256*A + S , S = START ADRS
*      IN KILOWORDS,  A = KILOWORDS TO DUMP
*
*      (XR)                  PARAMETER N OF CALL DUMP(N)
*      JSR  SYSDM            CALL TO ENTER ROUTINE
{{EJC{{{{{822
*
*      SYSDT -- GET CURRENT DATE
*
{SYSDT{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{826
*
*      SYSDT IS USED TO OBTAIN THE CURRENT DATE. THE DATE IS
*      RETURNED AS A CHARACTER STRING IN ANY FORMAT APPROPRIATE
*      TO THE OPERATING SYSTEM IN USE. IT MAY ALSO CONTAIN THE
*      CURRENT TIME OF DAY. SYSDT IS USED TO IMPLEMENT THE
*      SNOBOL4 FUNCTION DATE().
*
*      (XR)                  PARAMETER N OF CALL DATE(N)
*      JSR  SYSDT            CALL TO GET DATE
*      (XL)                  POINTER TO BLOCK CONTAINING DATE
*
*      THE FORMAT OF THE BLOCK IS LIKE AN SCBLK EXCEPT THAT
*      THE FIRST WORD NEED NOT BE SET. THE RESULT IS COPIED
*      INTO SPITBOL DYNAMIC MEMORY ON RETURN.
{{EJC{{{{{842
*
*      SYSEA -- INFORM OSINT OF COMPILATION AND RUNTIME ERRORS
*
{SYSEA{EXP{1,1{{{DEFINE EXTERNAL ENTRY POINT{846
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS ON
*      ERRORS
*
*      (WA)                  ERROR CODE
*      (WB)                  LINE NUMBER
*      (WC)                  COLUMN NUMBER
*      (XR)                  SYSTEM STAGE
*      (XL)                  FILE NAME (SCBLK)
*      JSR  SYSEA            CALL TO SYSEA FUNCTION
*      PPM  LOC              SUPPRESS PRINTING OF ERROR MESSAGE
*      (XR)                  MESSAGE TO PRINT (SCBLK) OR 0
*
*      SYSEA MAY NOT RETURN IF INTERFACE CHOOSES TO RETAIN
*      CONTROL.  CLOSING FILES VIA THE FCB CHAIN WILL BE THE
*      RESPONSIBILITY OF THE INTERFACE.
*
*      ALL REGISTERS PRESERVED
{{EJC{{{{{868
*
*      SYSEF -- EJECT FILE
*
{SYSEF{EXP{1,3{{{DEFINE EXTERNAL ENTRY POINT{872
*
*      SYSEF IS USED TO WRITE A PAGE EJECT TO A NAMED FILE. IT
*      MAY ONLY BE USED FOR FILES WHERE THIS CONCEPT MAKES
*      SENSE. NOTE THAT SYSEF IS NOT NORMALLY USED FOR THE
*      STANDARD OUTPUT FILE (SEE SYSEP).
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  EJECT ARGUMENT (SCBLK PTR)
*      JSR  SYSEF            CALL TO EJECT FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF INAPPROPRIATE FILE
*      PPM  LOC              RETURN HERE IF I/O ERROR
{{EJC{{{{{885
*
*      SYSEJ -- END OF JOB
*
{SYSEJ{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{889
*
*      SYSEJ IS CALLED ONCE AT THE END OF EXECUTION TO
*      TERMINATE THE RUN. THE SIGNIFICANCE OF THE ABEND AND
*      CODE VALUES IS SYSTEM DEPENDENT. IN GENERAL, THE CODE
*      VALUE SHOULD BE MADE AVAILABLE FOR TESTING, AND THE
*      ABEND VALUE SHOULD CAUSE SOME POST-MORTEM ACTION SUCH AS
*      A DUMP. NOTE THAT SYSEJ DOES NOT RETURN TO ITS CALLER.
*      SEE SYSXI FOR DETAILS OF FCBLK CHAIN
*
*      (WA)                  VALUE OF ABEND KEYWORD
*      (WB)                  VALUE OF CODE KEYWORD
*      (XL)                  O OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSEJ            CALL TO END JOB
*
*      THE FOLLOWING SPECIAL VALUES ARE USED AS CODES IN (WB)
*      999  EXECUTION SUPPRESSED
*      998  STANDARD OUTPUT FILE FULL OR UNAVAILABLE IN A SYSXI
*           LOAD MODULE. IN THESE CASES (WA) CONTAINS THE NUMBER
*           OF THE STATEMENT CAUSING PREMATURE TERMINATION.
{{EJC{{{{{909
*
*      SYSEM -- GET ERROR MESSAGE TEXT
*
{SYSEM{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{913
*
*      SYSEM IS USED TO OBTAIN THE TEXT OF ERR, ERB CALLS IN THE
*      SOURCE PROGRAM GIVEN THE ERROR CODE NUMBER. IT IS ALLOWED
*      TO RETURN A NULL STRING IF THIS FACILITY IS UNAVAILABLE.
*
*      (WA)                  ERROR CODE NUMBER
*      JSR  SYSEM            CALL TO GET TEXT
*      (XR)                  TEXT OF MESSAGE
*
*      THE RETURNED VALUE IS A POINTER TO A BLOCK IN SCBLK
*      FORMAT EXCEPT THAT THE FIRST WORD NEED NOT BE SET. THE
*      STRING IS COPIED INTO DYNAMIC MEMORY ON RETURN.
*      IF THE NULL STRING IS RETURNED EITHER BECAUSE SYSEM DOES
*      NOT PROVIDE ERROR MESSAGE TEXTS OR BECAUSE WA IS OUT OF
*      RANGE, SPITBOL WILL PRINT THE STRING STORED IN ERRTEXT
*      KEYWORD.
{{EJC{{{{{930
*
*      SYSEN -- ENDFILE
*
{SYSEN{EXP{1,3{{{DEFINE EXTERNAL ENTRY POINT{934
*
*      SYSEN IS USED TO IMPLEMENT THE SNOBOL4 FUNCTION ENDFILE.
*      THE MEANING IS SYSTEM DEPENDENT. IN GENERAL, ENDFILE
*      IMPLIES THAT NO FURTHER I/O OPERATIONS WILL BE PERFORMED,
*      BUT DOES NOT GUARANTEE THIS TO BE THE CASE. THE FILE
*      SHOULD BE CLOSED AFTER THE CALL, A SUBSEQUENT READ
*      OR WRITE MAY REOPEN THE FILE AT THE START OR IT MAY BE
*      NECESSARY TO REOPEN THE FILE VIA SYSIO.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  ENDFILE ARGUMENT (SCBLK PTR)
*      JSR  SYSEN            CALL TO ENDFILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF ENDFILE NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED FOR FILES FOR WHICH
*      ENDFILE IS NOT PERMITTED. FOR EXAMPLE, IT MAY BE EXPECTED
*      THAT THE STANDARD INPUT AND OUTPUT FILES ARE IN THIS
*      CATEGORY.
{{EJC{{{{{956
*
*      SYSEP -- EJECT PRINTER PAGE
*
{SYSEP{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{960
*
*      SYSEP IS CALLED TO PERFORM A PAGE EJECT ON THE STANDARD
*      PRINTER OUTPUT FILE (CORRESPONDING TO SYSPR OUTPUT).
*
*      JSR  SYSEP            CALL TO EJECT PRINTER OUTPUT
{{EJC{{{{{966
*
*      SYSEX -- CALL EXTERNAL FUNCTION
*
{SYSEX{EXP{1,3{{{DEFINE EXTERNAL ENTRY POINT{970
*
*      SYSEX IS CALLED TO PASS CONTROL TO AN EXTERNAL FUNCTION
*      PREVIOUSLY LOADED WITH A CALL TO SYSLD.
*
*      (XS)                  POINTER TO ARGUMENTS ON STACK
*      (XL)                  POINTER TO CONTROL BLOCK (EFBLK)
*      (WA)                  NUMBER OF ARGUMENTS ON STACK
*      JSR  SYSEX            CALL TO PASS CONTROL TO FUNCTION
*      PPM  LOC              RETURN HERE IF FUNCTION CALL FAILS
*      PPM  LOC              RETURN HERE IF INSUFFICIENT MEMORY
*      PPM  LOC              RETURN HERE IF BAD ARGUMENT TYPE
*      (XR)                  RESULT RETURNED
*
*      THE ARGUMENTS ARE STORED ON THE STACK WITH
*      THE LAST ARGUMENT AT 0(XS). ON RETURN, XS
*      IS POPPED PAST THE ARGUMENTS.
*
*      THE FORM OF THE ARGUMENTS AS PASSED IS THAT USED IN THE
*      SPITBOL TRANSLATOR (SEE DEFINITIONS AND DATA STRUCTURES
*      SECTION). THE CONTROL BLOCK FORMAT IS ALSO DESCRIBED
*      (UNDER EFBLK) IN THIS SECTION.
*
*      THERE ARE TWO WAYS OF RETURNING A RESULT.
*
*      1)   RETURN A POINTER TO A BLOCK IN DYNAMIC STORAGE. THIS
*           BLOCK MUST BE IN EXACTLY CORRECT FORMAT, INCLUDING
*           THE FIRST WORD. ONLY FUNCTIONS WRITTEN WITH INTIMATE
*           KNOWLEDGE OF THE SYSTEM WILL RETURN IN THIS WAY.
*
*      2)   STRING, INTEGER AND REAL RESULTS MAY BE RETURNED BY
*           POINTING TO A PSEUDO-BLOCK OUTSIDE DYNAMIC MEMORY.
*           THIS BLOCK IS IN ICBLK, RCBLK OR SCBLK FORMAT EXCEPT
*           THAT THE FIRST WORD WILL BE OVERWRITTEN
*           BY A TYPE WORD ON RETURN AND SO NEED NOT
*           BE CORRECTLY SET. SUCH A RESULT IS
*           COPIED INTO MAIN STORAGE BEFORE PROCEEDING.
*           UNCONVERTED RESULTS MAY SIMILARLY BE RETURNED IN A
*           PSEUDO-BLOCK WHICH IS IN CORRECT FORMAT INCLUDING
*           TYPE WORD RECOGNISABLE BY GARBAGE COLLECTOR SINCE
*           BLOCK IS COPIED INTO DYNAMIC MEMORY.
{{EJC{{{{{1015
*
*      SYSFC -- FILE CONTROL BLOCK ROUTINE
*
{SYSFC{EXP{1,2{{{DEFINE EXTERNAL ENTRY POINT{1019
*
*      SEE ALSO SYSIO
*      INPUT AND OUTPUT HAVE 3 ARGUMENTS REFERRED TO AS SHOWN
*           INPUT(VARIABLE NAME,FILE ARG1,FILE ARG2)
*           OUTPUT(VARIABLE NAME,FILE ARG1,FILE ARG2)
*      FILE ARG1 MAY BE AN INTEGER OR STRING USED TO IDENTIFY
*      AN I/O CHANNEL. IT IS CONVERTED TO A STRING FOR CHECKING.
*      THE EXACT SIGNIFICANCE OF FILE ARG2
*      IS NOT RIGOROUSLY PRESCRIBED BUT TO IMPROVE PORTABILITY,
*      THE SCHEME DESCRIBED IN THE SPITBOL USER MANUAL
*      SHOULD BE ADOPTED WHEN POSSIBLE. THE PREFERRED FORM IS
*      A STRING _F_,R_R_,C_C_,I_I_,...,Z_Z_  WHERE
*      _F_ IS AN OPTIONAL FILE NAME WHICH IS PLACED FIRST.
*       REMAINING ITEMS MAY BE OMITTED OR INCLUDED IN ANY ORDER.
*      _R_ IS MAXIMUM RECORD LENGTH
*      _C_ IS A CARRIAGE CONTROL CHARACTER OR CHARACTER STRING
*      _I_ IS SOME FORM OF CHANNEL IDENTIFICATION USED IN THE
*         ABSENCE OF _F_ TO ASSOCIATE THE VARIABLE
*         WITH A FILE ALLOCATED DYNAMICALLY BY JCL COMMANDS AT
*         SPITBOL LOAD TIME.
*      ,...,Z_Z_ ARE ADDITIONAL FIELDS.
*      IF , (COMMA) CANNOT BE USED AS A DELIMITER, .CIOD
*      SHOULD BE DEFINED TO INTRODUCE BY CONDITIONAL ASSEMBLY
*      ANOTHER DELIMITER (SEE
*        IODEL  EQU  *
*      EARLY IN DEFINITIONS SECTION).
*      SYSFC IS CALLED WHEN A VARIABLE IS INPUT OR OUTPUT
*      ASSOCIATED TO CHECK FILE ARG1 AND FILE ARG2 AND
*      TO  REPORT WHETHER AN FCBLK (FILE CONTROL
*      BLOCK) IS NECESSARY AND IF SO WHAT SIZE IT SHOULD BE.
*      THIS MAKES IT POSSIBLE FOR SPITBOL RATHER THAN OSINT TO
*      ALLOCATE SUCH A BLOCK IN DYNAMIC MEMORY IF REQUIRED
*      OR ALTERNATIVELY IN STATIC MEMORY.
*      THE SIGNIFICANCE OF AN FCBLK , IF ONE IS REQUESTED, IS
*      ENTIRELY UP TO THE SYSTEM INTERFACE. THE ONLY RESTRICTION
*      IS THAT IF THE FCBLK SHOULD APPEAR TO LIE IN DYNAMIC
*      MEMORY, POINTERS TO IT SHOULD BE PROPER POINTERS TO
*      THE START OF A RECOGNISABLE AND GARBAGE COLLECTABLE
*      BLOCK (THIS CONDITION WILL BE MET IF SYSFC REQUESTS
*      SPITBOL TO PROVIDE AN FCBLK).
*      AN OPTION IS PROVIDED FOR OSINT TO RETURN A POINTER IN
*      XL TO AN FCBLK WHICH IT PRIVATELY ALLOCATED. THIS PTR
*      WILL BE MADE AVAILABLE WHEN I/O OCCURS LATER.
*      PRIVATE FCBLKS MAY HAVE ARBITRARY CONTENTS AND SPITBOL
*      STORES NOTHING IN THEM.
{{EJC{{{{{1065
*      THE REQUESTED SIZE FOR AN FCBLK IN DYNAMIC MEMORY
*      SHOULD ALLOW A 2 WORD OVERHEAD FOR BLOCK TYPE AND
*      LENGTH FIELDS. INFORMATION SUBSEQUENTLY STORED IN THE
*      REMAINING WORDS MAY BE ARBITRARY IF AN XNBLK (EXTERNAL
*      NON-RELOCATABLE BLOCK) IS REQUESTED. IF THE REQUEST IS
*      FOR AN XRBLK (EXTERNAL RELOCATABLE BLOCK) THE
*      CONTENTS OF WORDS SHOULD BE COLLECTABLE (I.E. ANY
*      APPARENT POINTERS INTO DYNAMIC SHOULD BE GENUINE BLOCK
*      POINTERS). THESE RESTRICTIONS DO NOT APPLY IF AN FCBLK
*      IS ALLOCATED OUTSIDE DYNAMIC OR IS NOT ALLOCATED AT ALL.
*      IF AN FCBLK IS REQUESTED, ITS FIELDS WILL BE INITIALISED
*      TO ZERO BEFORE ENTRY TO SYSIO WITH THE EXCEPTION OF
*      WORDS 0 AND 1 IN WHICH THE BLOCK TYPE AND LENGTH
*      FIELDS ARE PLACED FOR FCBLKS IN DYNAMIC MEMORY ONLY.
*      FOR THE POSSIBLE USE OF SYSEJ AND SYSXI, IF FCBLKS
*      ARE USED, A CHAIN IS BUILT SO THAT THEY MAY ALL BE
*      FOUND - SEE SYSXI FOR DETAILS.
*      IF BOTH FILE ARG1 AND FILE ARG2 ARE NULL, CALLS OF SYSFC
*      AND SYSIO ARE OMITTED.
*      IF FILE ARG1 IS NULL (STANDARD INPUT/OUTPUT FILE), SYSFC
*      IS CALLED TO CHECK NON-NULL FILE ARG2 BUT ANY REQUEST
*      FOR AN FCBLK WILL BE IGNORED, SINCE SPITBOL HANDLES THE
*      STANDARD FILES SPECIALLY AND CANNOT READILY KEEP FCBLK
*      POINTERS FOR THEM.
*      FILEARG1 IS TYPE CHECKED BY SPITBOL SO FURTHER CHECKING
*      MAY BE UNNECCESSARY IN MANY IMPLEMENTATIONS.
*      FILE ARG2 IS PASSED SO THAT SYSFC MAY ANALYSE AND
*      CHECK IT. HOWEVER TO ASSIST IN THIS, SPITBOL ALSO PASSES
*      ON THE STACK THE COMPONENTS OF THIS ARGUMENT WITH
*      FILE NAME, _F_ (OTHERWISE NULL) EXTRACTED AND STACKED
*      FIRST.
*      THE OTHER FIELDS, IF ANY, ARE EXTRACTED AS SUBSTRINGS,
*      POINTERS TO THEM ARE STACKED AND A COUNT OF ALL ITEMS
*      STACKED IS PLACED IN WC. IF AN FCBLK WAS EARLIER
*      ALLOCATED AND POINTED TO VIA FILE ARG1, SYSFC IS ALSO
*      PASSED A POINTER TO THIS FCBLK.
*
*      (XL)                  FILE ARG1 SCBLK PTR (2ND ARG)
*      (XR)                  FILEARG2 (3RD ARG) OR NULL
*      -(XS)...-(XS)         SCBLKS FOR _F_,_R_,_C_,...
*      (WC)                  NO. OF STACKED SCBLKS ABOVE
*      (WA)                  EXISTING FILE ARG1 FCBLK PTR OR 0
*      (WB)                  0/3 FOR INPUT/OUTPUT ASSOCN
*      JSR  SYSFC            CALL TO CHECK NEED FOR FCBLK
*      PPM  LOC              INVALID FILE ARGUMENT
*      PPM  LOC              FCBLK ALREADY IN USE
*      (XS)                  POPPED (WC) TIMES
*      (WA NON ZERO)         BYTE SIZE OF REQUESTED FCBLK
*      (WA=0,XL NON ZERO)    PRIVATE FCBLK PTR IN XL
*      (WA=XL=0)             NO FCBLK WANTED, NO PRIVATE FCBLK
*      (WC)                  0/1/2 REQUEST ALLOC OF XRBLK/XNBLK
*                            /STATIC BLOCK FOR USE AS FCBLK
*      (WB)                  DESTROYED
{{EJC{{{{{1120
*
*      SYSGC -- INFORM INTERFACE OF GARBAGE COLLECTIONS
*
{SYSGC{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{1124
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS
*      PRIOR TO AND AFTER A GARBAGE COLLECTION.
*
*      POSSIBLE USAGES-
*      1. PROVIDE VISIBLE SCREEN ICON OF GARBAGE COLLECTION
*         IN PROGRESS
*      2. INFORM VIRTUAL MEMORY MANAGER TO IGNORE PAGE ACCESS
*         PATTERNS DURING GARBAGE COLLECTION.  SUCH ACCESSES
*         TYPICALLY DESTROY THE PAGE WORKING SET ACCUMULATED
*         BY THE PROGRAM.
*      3. INFORM VIRTUAL MEMORY MANAGER THAT CONTENTS OF MEMORY
*         FREED BY GARBAGE COLLECTION CAN BE DISCARDED.
*
*      (XR)                  NON-ZERO IF BEGINNING GC
*                            =0 IF COMPLETING GC
*      (WA)                  DNAMB=START OF DYNAMIC AREA
*      (WB)                  DNAMP=NEXT AVAILABLE LOCATION
*      (WC)                  DNAME=LAST AVAILABLE LOCATION + 1
*      JSR  SYSGC            CALL TO SYSGC FUNCTION
*      ALL REGISTERS PRESERVED
{{EJC{{{{{1148
*
*      SYSHS -- GIVE ACCESS TO HOST COMPUTER FEATURES
*
{SYSHS{EXP{1,8{{{DEFINE EXTERNAL ENTRY POINT{1152
*
*      PROVIDES MEANS FOR IMPLEMENTING SPECIAL FEATURES
*      ON DIFFERENT HOST COMPUTERS. THE ONLY DEFINED ENTRY IS
*      THAT WHERE ALL ARGUMENTS ARE NULL IN WHICH CASE SYSHS
*      RETURNS AN SCBLK CONTAINING NAME OF COMPUTER,
*      NAME OF OPERATING SYSTEM AND NAME OF SITE SEPARATED BY
*      COLONS. THE SCBLK NEED NOT HAVE A CORRECT FIRST FIELD
*      AS THIS IS SUPPLIED ON COPYING STRING TO DYNAMIC MEMORY.
*      SPITBOL DOES NO ARGUMENT CHECKING BUT DOES PROVIDE A
*      SINGLE ERROR RETURN FOR ARGUMENTS CHECKED AS ERRONEOUS
*      BY OSINT. IT ALSO PROVIDES A SINGLE EXECUTION ERROR
*      RETURN. IF THESE ARE INADEQUATE, USE MAY BE MADE OF THE
*      MINIMAL ERROR SECTION DIRECT AS DESCRIBED IN MINIMAL
*      DOCUMENTATION, SECTION 10.
*      SEVERAL NON-ERROR RETURNS ARE PROVIDED. THE FIRST
*      CORRESPONDS TO THE DEFINED ENTRY OR, FOR IMPLEMENTATION
*      DEFINED ENTRIES, ANY STRING MAY BE RETURNED. THE OTHERS
*      PERMIT RESPECTIVELY,  RETURN A NULL RESULT, RETURN WITH A
*      RESULT TO BE STACKED WHICH IS POINTED AT BY XR, AND A
*      RETURN CAUSING SPITBOL STATEMENT FAILURE. IF A RETURNED
*      RESULT IS IN DYNAMIC MEMORY IT MUST OBEY GARBAGE
*      COLLECTOR RULES. THE ONLY RESULTS COPIED ON RETURN
*      ARE STRINGS RETURNED VIA PPM LOC3 RETURN.
*
*      (WA)                  ARGUMENT 1
*      (XL)                  ARGUMENT 2
*      (XR)                  ARGUMENT 3
*      (WB)                  ARGUMENT 4
*      (WC)                  ARGUMENT 5
*      JSR  SYSHS            CALL TO GET HOST INFORMATION
*      PPM  LOC1             ERRONEOUS ARG
*      PPM  LOC2             EXECUTION ERROR
*      PPM  LOC3             SCBLK PTR IN XL OR 0 IF UNAVAILABLE
*      PPM  LOC4             RETURN A NULL RESULT
*      PPM  LOC5             RETURN RESULT IN XR
*      PPM  LOC6             CAUSE STATEMENT FAILURE
*      PPM  LOC7             RETURN STRING AT XL, LENGTH WA
*      PPM  LOC8             RETURN COPY OF RESULT IN XR
{{EJC{{{{{1191
*
*      SYSID -- RETURN SYSTEM IDENTIFICATION
*
{SYSID{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{1195
*
*      THIS ROUTINE SHOULD RETURN STRINGS TO HEAD THE STANDARD
*      PRINTER OUTPUT. THE FIRST STRING WILL BE APPENDED TO
*      A HEADING LINE OF THE FORM
*           MACRO SPITBOL VERSION V.V
*      SUPPLIED BY SPITBOL ITSELF. V.V ARE DIGITS GIVING THE
*      MAJOR VERSION NUMBER AND GENERALLY AT LEAST A MINOR
*      VERSION NUMBER RELATING TO OSINT SHOULD BE SUPPLIED TO
*      GIVE SAY
*           MACRO SPITBOL VERSION V.V(M.M)
*      THE SECOND STRING SHOULD IDENTIFY AT LEAST THE MACHINE
*      AND OPERATING SYSTEM.  PREFERABLY IT SHOULD INCLUDE
*      THE DATE AND TIME OF THE RUN.
*      OPTIONALLY THE STRINGS MAY INCLUDE SITE NAME OF THE
*      THE IMPLEMENTOR AND/OR MACHINE ON WHICH RUN TAKES PLACE,
*      UNIQUE SITE OR COPY NUMBER AND OTHER INFORMATION AS
*      APPROPRIATE WITHOUT MAKING IT SO LONG AS TO BE A
*      NUISANCE TO USERS.
*      THE FIRST WORDS OF THE SCBLKS POINTED AT NEED NOT BE
*      CORRECTLY SET.
*
*      JSR  SYSID            CALL FOR SYSTEM IDENTIFICATION
*      (XR)                  SCBLK PTR FOR ADDITION TO HEADER
*      (XL)                  SCBLK PTR FOR SECOND HEADER
{{EJC{{{{{1220
*
*      SYSIF -- SWITCH TO NEW INCLUDE FILE
*
{SYSIF{EXP{1,1{{{DEFINE EXTERNAL ENTRY POINT{1225
*
*      SYSIF IS USED FOR INCLUDE FILE PROCESSING, BOTH TO INFORM
*      THE INTERFACE WHEN A NEW INCLUDE FILE IS DESIRED, AND
*      WHEN THE END OF FILE OF AN INCLUDE FILE HAS BEEN REACHED
*      AND IT IS DESIRED TO RETURN TO READING FROM THE PREVIOUS
*      NESTED FILE.
*
*      IT IS THE RESPONSIBILITY OF SYSIF TO REMEMBER THE FILE
*      ACCESS PATH TO THE PRESENT INPUT FILE BEFORE SWITCHING TO
*      THE NEW INCLUDE FILE.
*
*      (XL)                  PTR TO SCBLK OR ZERO
*      (XR)                  PTR TO VACANT SCBLK OF LENGTH CSWIN
*                            (XR NOT USED IF XL IS ZERO)
*      JSR  SYSIF            CALL TO CHANGE FILES
*      PPM  LOC              UNABLE TO OPEN FILE
*      (XR)                  SCBLK WITH FULL PATH NAME OF FILE
*                            (XR NOT USED IF INPUT XL IS ZERO)
*
*      REGISTER XL POINTS TO AN SCBLK CONTAINING THE NAME OF THE
*      INCLUDE FILE TO WHICH THE INTERFACE SHOULD SWITCH.  DATA
*      IS FETCHED FROM THE FILE UPON THE NEXT CALL TO SYSRD.
*
*      SYSIF MAY HAVE THE ABILITY TO SEARCH MULTIPLE LIBRARIES
*      FOR THE INCLUDE FILE NAMED IN (XL).  IT IS THEREFORE
*      REQUIRED THAT THE FULL PATH NAME OF THE FILE WHERE THE
*      FILE WAS FINALLY LOCATED BE RETURNED IN (XR).  IT IS THIS
*      NAME THAT IS RECORDED ALONG WITH THE SOURCE STATEMENTS,
*      AND WILL ACCOMPANY SUBSEQUENT ERROR MESSAGES.
*
*      REGISTER XL IS ZERO TO MARK CONCLUSION OF USE OF AN
*      INCLUDE FILE.
{{EJC{{{{{1258
*
*      SYSIL -- GET INPUT RECORD LENGTH
*
{SYSIL{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{1263
*
*      SYSIL IS USED TO GET THE LENGTH OF THE NEXT INPUT RECORD
*      FROM A FILE PREVIOUSLY INPUT ASSOCIATED WITH A SYSIO
*      CALL. THE LENGTH RETURNED IS USED TO ESTABLISH A BUFFER
*      FOR A SUBSEQUENT SYSIN CALL.  SYSIL ALSO INDICATES TO THE
*      CALLER IF THIS IS A BINARY OR TEXT FILE.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      JSR  SYSIL            CALL TO GET RECORD LENGTH
*      (WA)                  LENGTH OR ZERO IF FILE CLOSED
*      (WC)                  ZERO IF BINARY, NON-ZERO IF TEXT
*
*      NO HARM IS DONE IF THE VALUE RETURNED IS TOO LONG SINCE
*      UNUSED SPACE WILL BE RECLAIMED AFTER THE SYSIN CALL.
*
*      NOTE THAT IT IS THE SYSIL CALL (NOT THE SYSIO CALL) WHICH
*      CAUSES THE FILE TO BE OPENED AS REQUIRED FOR THE FIRST
*      RECORD INPUT FROM THE FILE.
{{EJC{{{{{1282
*
*      SYSIN -- READ INPUT RECORD
*
{SYSIN{EXP{1,3{{{DEFINE EXTERNAL ENTRY POINT{1286
*
*      SYSIN IS USED TO READ A RECORD FROM THE FILE WHICH WAS
*      REFERENCED IN A PRIOR CALL TO SYSIL (I.E. THESE CALLS
*      ALWAYS OCCUR IN PAIRS). THE BUFFER PROVIDED IS AN
*      SCBLK FOR A STRING OF LENGTH SET FROM THE SYSIL CALL.
*      IF THE ACTUAL LENGTH READ IS LESS THAN THIS, THE LENGTH
*      FIELD OF THE SCBLK MUST BE MODIFIED BEFORE RETURNING
*      UNLESS BUFFER IS RIGHT PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE ANY OF THE ALTERNATIVE
*      RETURNS AFTER SCBLK LENGTH HAS BEEN MODIFIED.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  POINTER TO BUFFER (SCBLK PTR)
*      JSR  SYSIN            CALL TO READ RECORD
*      PPM  LOC              ENDFILE OR NO I/P FILE AFTER SYSXI
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      PPM  LOC              RETURN HERE IF RECORD FORMAT ERROR
*      (WA,WB,WC)            DESTROYED
{{EJC{{{{{1305
*
*      SYSIO -- INPUT/OUTPUT FILE ASSOCIATION
*
{SYSIO{EXP{1,2{{{DEFINE EXTERNAL ENTRY POINT{1309
*
*      SEE ALSO SYSFC.
*      SYSIO IS CALLED IN RESPONSE TO A SNOBOL4 INPUT OR OUTPUT
*      FUNCTION CALL EXCEPT WHEN FILE ARG1 AND FILE ARG2
*      ARE BOTH NULL.
*      ITS CALL ALWAYS FOLLOWS IMMEDIATELY AFTER A CALL
*      OF SYSFC. IF SYSFC REQUESTED ALLOCATION
*      OF AN FCBLK, ITS ADDRESS WILL BE IN WA.
*      FOR INPUT FILES, NON-ZERO VALUES OF _R_ SHOULD BE
*      COPIED TO WC FOR USE IN ALLOCATING INPUT BUFFERS. IF _R_
*      IS DEFAULTED OR NOT IMPLEMENTED, WC SHOULD BE ZEROISED.
*      ONCE A FILE HAS BEEN OPENED, SUBSEQUENT INPUT(),OUTPUT()
*      CALLS IN WHICH THE SECOND ARGUMENT IS IDENTICAL WITH THAT
*      IN A PREVIOUS CALL, MERELY ASSOCIATE THE ADDITIONAL
*      VARIABLE NAME (FIRST ARGUMENT) TO THE FILE AND DO NOT
*      RESULT IN RE-OPENING THE FILE.
*      IN SUBSEQUENT ASSOCIATED ACCESSES TO THE FILE A POINTER
*      TO ANY FCBLK ALLOCATED WILL BE MADE AVAILABLE.
*
*      (XL)                  FILE ARG1 SCBLK PTR (2ND ARG)
*      (XR)                  FILE ARG2 SCBLK PTR (3RD ARG)
*      (WA)                  FCBLK PTR (0 IF NONE)
*      (WB)                  0 FOR INPUT, 3 FOR OUTPUT
*      JSR  SYSIO            CALL TO ASSOCIATE FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN IF INPUT/OUTPUT NOT ALLOWED
*      (XL)                  FCBLK POINTER (0 IF NONE)
*      (WC)                  0 (FOR DEFAULT) OR MAX RECORD LNGTH
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED IF THE FILE NAMED EXISTS
*      BUT INPUT/OUTPUT FROM THE FILE IS NOT ALLOWED. FOR
*      EXAMPLE, THE STANDARD OUTPUT FILE MAY BE IN THIS CATEGORY
*      AS REGARDS INPUT ASSOCIATION.
{{EJC{{{{{1344
*
*      SYSLD -- LOAD EXTERNAL FUNCTION
*
{SYSLD{EXP{1,3{{{DEFINE EXTERNAL ENTRY POINT{1348
*
*      SYSLD IS CALLED IN RESPONSE TO THE USE OF THE SNOBOL4
*      LOAD FUNCTION. THE NAMED FUNCTION IS LOADED (WHATEVER
*      THIS MEANS), AND A POINTER IS RETURNED. THE POINTER WILL
*      BE USED ON SUBSEQUENT CALLS TO THE FUNCTION (SEE SYSEX).
*
*      (XR)                  POINTER TO FUNCTION NAME (SCBLK)
*      (XL)                  POINTER TO LIBRARY NAME (SCBLK)
*      JSR  SYSLD            CALL TO LOAD FUNCTION
*      PPM  LOC              RETURN HERE IF FUNC DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      PPM  LOC              RETURN HERE IF INSUFFICIENT MEMORY
*      (XR)                  POINTER TO LOADED CODE
*
*      THE SIGNIFICANCE OF THE POINTER RETURNED IS UP TO THE
*      SYSTEM INTERFACE ROUTINE. THE ONLY RESTRICTION IS THAT
*      IF THE POINTER IS WITHIN DYNAMIC STORAGE, IT MUST BE
*      A PROPER BLOCK POINTER.
{{EJC{{{{{1367
*
*      SYSMM -- GET MORE MEMORY
*
{SYSMM{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{1371
*
*      SYSMM IS CALLED IN AN ATTEMPT TO ALLOCATE MORE DYNAMIC
*      MEMORY. THIS MEMORY MUST BE ALLOCATED CONTIGUOUSLY WITH
*      THE CURRENT DYNAMIC DATA AREA.
*
*      THE AMOUNT ALLOCATED IS UP TO THE SYSTEM TO DECIDE. ANY
*      VALUE IS ACCEPTABLE INCLUDING ZERO IF ALLOCATION IS
*      IMPOSSIBLE.
*
*      JSR  SYSMM            CALL TO GET MORE MEMORY
*      (XR)                  NUMBER OF ADDITIONAL WORDS OBTAINED
{{EJC{{{{{1383
*
*      SYSMX -- SUPPLY MXLEN
*
{SYSMX{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{1387
*
*      BECAUSE OF THE METHOD OF GARBAGE COLLECTION, NO SPITBOL
*      OBJECT IS ALLOWED TO OCCUPY MORE BYTES OF MEMORY THAN
*      THE INTEGER GIVING THE LOWEST ADDRESS OF DYNAMIC
*      (GARBAGE COLLECTABLE) MEMORY. MXLEN IS THE NAME USED TO
*      REFER TO THIS MAXIMUM LENGTH OF AN OBJECT AND FOR MOST
*      USERS OF MOST IMPLEMENTATIONS, PROVIDED DYNAMIC MEMORY
*      STARTS AT AN ADDRESS OF AT LEAST A FEW THOUSAND WORDS,
*      THERE IS NO PROBLEM.
*      IF THE DEFAULT STARTING ADDRESS IS LESS THAN SAY 10000 OR
*      20000, THEN A LOAD TIME OPTION SHOULD BE PROVIDED WHERE A
*      USER CAN REQUEST THAT HE BE ABLE TO CREATE LARGER
*      OBJECTS. THIS ROUTINE INFORMS SPITBOL OF THIS REQUEST IF
*      ANY. THE VALUE RETURNED IS EITHER AN INTEGER
*      REPRESENTING THE DESIRED VALUE OF MXLEN (AND HENCE THE
*      MINIMUM DYNAMIC STORE ADDRESS WHICH MAY RESULT IN
*      NON-USE OF SOME STORE) OR ZERO IF A DEFAULT IS ACCEPTABLE
*      IN WHICH MXLEN IS SET TO THE LOWEST ADDRESS ALLOCATED
*      TO DYNAMIC STORE BEFORE COMPILATION STARTS.
*      IF A NON-ZERO VALUE IS RETURNED, THIS IS USED FOR KEYWORD
*      MAXLNGTH. OTHERWISE THE INITIAL LOW ADDRESS OF DYNAMIC
*      MEMORY IS USED FOR THIS KEYWORD.
*
*      JSR  SYSMX            CALL TO GET MXLEN
*      (WA)                  EITHER MXLEN OR 0 FOR DEFAULT
{{EJC{{{{{1413
*
*      SYSOU -- OUTPUT RECORD
*
{SYSOU{EXP{1,2{{{DEFINE EXTERNAL ENTRY POINT{1417
*
*      SYSOU IS USED TO WRITE A RECORD TO A FILE PREVIOUSLY
*      ASSOCIATED WITH A SYSIO CALL.
*
*      (WA)                  PTR TO FCBLK
*                            OR 0 FOR TERMINAL OR 1 FOR OUTPUT
*      (XR)                  RECORD TO BE WRITTEN (SCBLK)
*      JSR  SYSOU            CALL TO OUTPUT RECORD
*      PPM  LOC              FILE FULL OR NO FILE AFTER SYSXI
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB,WC)            DESTROYED
*
*      NOTE THAT IT IS THE SYSOU CALL (NOT THE SYSIO CALL) WHICH
*      CAUSES THE FILE TO BE OPENED AS REQUIRED FOR THE FIRST
*      RECORD OUTPUT TO THE FILE.
{{EJC{{{{{1439
*
*      SYSPI -- PRINT ON INTERACTIVE CHANNEL
*
{SYSPI{EXP{1,1{{{DEFINE EXTERNAL ENTRY POINT{1443
*
*      IF SPITBOL IS RUN FROM AN ONLINE TERMINAL, OSINT CAN
*      REQUEST THAT MESSAGES SUCH AS COPIES OF COMPILATION
*      ERRORS BE SENT TO THE TERMINAL (SEE SYSPP). IF RELEVANT
*      REPLY WAS MADE BY SYSPP THEN SYSPI IS CALLED TO SEND SUCH
*      MESSAGES TO THE INTERACTIVE CHANNEL.
*      SYSPI IS ALSO USED FOR SENDING OUTPUT TO THE TERMINAL
*      THROUGH THE SPECIAL VARIABLE NAME, TERMINAL.
*
*      (XR)                  PTR TO LINE BUFFER (SCBLK)
*      (WA)                  LINE LENGTH
*      JSR  SYSPI            CALL TO PRINT LINE
*      PPM  LOC              FAILURE RETURN
*      (WA,WB)               DESTROYED
{{EJC{{{{{1459
*
*      SYSPL -- PROVIDE INTERACTIVE CONTROL OF SPITBOL
*
{SYSPL{EXP{1,3{{{DEFINE EXTERNAL ENTRY POINT{1463
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS,
*      SUCH AS INTERRUPTING EXECUTION, BREAKPOINTING, STEPPING,
*      AND EXPRESSION EVALUATION.  THESE LAST THREE OPTIONS ARE
*      NOT PRESENTLY IMPLEMENTED BY THE CODE CALLING SYSPL.
*
*
*      (WA)                  OPCODE AS FOLLOWS-
*                            =0 POLL TO ALLOW OSINT TO INTERRUPT
*                            =1 BREAKPOINT HIT
*                            =2 COMPLETION OF STATEMENT STEPPING
*                            =3 EXPRESSION EVALUATION RESULT
*      (WB)                  STATEMENT NUMBER
*      R_FCB                 O OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSPL            CALL TO SYSPL FUNCTION
*      PPM  LOC              USER INTERRUPTION
*      PPM  LOC              STEP ONE STATEMENT
*      PPM  LOC              EVALUATE EXPRESSION
*      ---                   RESUME EXECUTION
*                            (WA) = NEW POLLING INTERVAL
*
{{EJC{{{{{1486
*
*      SYSPP -- OBTAIN PRINT PARAMETERS
*
{SYSPP{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{1490
*
*      SYSPP IS CALLED ONCE DURING COMPILATION TO OBTAIN
*      PARAMETERS REQUIRED FOR CORRECT PRINTED OUTPUT FORMAT
*      AND TO SELECT OTHER OPTIONS. IT MAY ALSO BE CALLED AGAIN
*      AFTER SYSXI WHEN A LOAD MODULE IS RESUMED. IN THIS
*      CASE THE VALUE RETURNED IN WA MAY BE LESS THAN OR EQUAL
*      TO THAT RETURNED IN INITIAL CALL BUT MAY NOT BE
*      GREATER.
*      THE INFORMATION RETURNED IS -
*      1.   LINE LENGTH IN CHARS FOR STANDARD PRINT FILE
*      2.   NO OF LINES/PAGE. 0 IS PREFERABLE FOR A NON-PAGED
*           DEVICE (E.G. ONLINE TERMINAL) IN WHICH CASE LISTING
*           PAGE THROWS ARE SUPPRESSED AND PAGE HEADERS
*           RESULTING FROM -TITLE,-STITL LINES ARE KEPT SHORT.
*      3.   AN INITIAL -NOLIST OPTION TO SUPPRESS LISTING UNLESS
*           THE PROGRAM CONTAINS AN EXPLICIT -LIST.
*      4.   OPTIONS TO SUPPRESS LISTING OF COMPILATION AND/OR
*           EXECUTION STATS (USEFUL FOR ESTABLISHED PROGRAMS) -
*           COMBINED WITH 3. GIVES POSSIBILITY OF LISTING
*           FILE NEVER BEING OPENED.
*      5.   OPTION TO HAVE COPIES OF ERRORS SENT TO AN
*           INTERACTIVE CHANNEL IN ADDITION TO STANDARD PRINTER.
*      6.   OPTION TO KEEP PAGE HEADERS SHORT (E.G. IF LISTING
*           TO AN ONLINE TERMINAL).
*      7.   AN OPTION TO CHOOSE EXTENDED OR COMPACT LISTING
*           FORMAT. IN THE FORMER A PAGE EJECT AND IN THE LATTER
*           A FEW LINE FEEDS PRECEDE THE PRINTING OF EACH
*           OF-- LISTING, COMPILATION STATISTICS, EXECUTION
*           OUTPUT AND EXECUTION STATISTICS.
*      8.   AN OPTION TO SUPPRESS EXECUTION AS THOUGH A
*           -NOEXECUTE CARD WERE SUPPLIED.
*      9.   AN OPTION TO REQUEST THAT NAME /TERMINAL/  BE PRE-
*           ASSOCIATED TO AN ONLINE TERMINAL VIA SYSPI AND SYSRI
*      10.  AN INTERMEDIATE (STANDARD) LISTING OPTION REQUIRING
*           THAT PAGE EJECTS OCCUR IN SOURCE LISTINGS. REDUNDANT
*           IF EXTENDED OPTION CHOSEN BUT PARTIALLY EXTENDS
*           COMPACT OPTION.
*      11.  OPTION TO SUPPRESS SYSID IDENTIFICATION.
*
*      JSR  SYSPP            CALL TO GET PRINT PARAMETERS
*      (WA)                  PRINT LINE LENGTH IN CHARS
*      (WB)                  NUMBER OF LINES/PAGE
*      (WC)                  BITS VALUE ...MLKJIHGFEDCBA WHERE
*                            A = 1 TO SEND ERROR COPY TO INT.CH.
*                            B = 1 MEANS STD PRINTER IS INT. CH.
*                            C = 1 FOR -NOLIST OPTION
*                            D = 1 TO SUPPRESS COMPILN. STATS
*
*                            E = 1 TO SUPPRESS EXECN. STATS
*                            F = 1/0 FOR EXTNDED/COMPACT LISTING
*                            G = 1 FOR -NOEXECUTE
*                            H = 1 PRE-ASSOCIATE /TERMINAL/
*
*                            I = 1 FOR STANDARD LISTING OPTION.
*                            J = 1 SUPPRESSES LISTING HEADER
*                            K = 1 FOR -PRINT
*                            L = 1 FOR -NOERRORS
*
*                            M = 1 FOR -CASE 1
{{EJC{{{{{1552
*
*      SYSPR -- PRINT LINE ON STANDARD OUTPUT FILE
*
{SYSPR{EXP{1,1{{{DEFINE EXTERNAL ENTRY POINT{1556
*
*      SYSPR IS USED TO PRINT A SINGLE LINE ON THE STANDARD
*      OUTPUT FILE.
*
*      (XR)                  POINTER TO LINE BUFFER (SCBLK)
*      (WA)                  LINE LENGTH
*      JSR  SYSPR            CALL TO PRINT LINE
*      PPM  LOC              TOO MUCH O/P OR NO FILE AFTER SYSXI
*      (WA,WB)               DESTROYED
*
*      THE BUFFER POINTED TO IS THE LENGTH OBTAINED FROM THE
*      SYSPP CALL AND IS FILLED OUT WITH TRAILING BLANKS. THE
*      VALUE IN WA IS THE ACTUAL LINE LENGTH WHICH MAY BE LESS
*      THAN THE MAXIMUM LINE LENGTH POSSIBLE. THERE IS NO SPACE
*      CONTROL ASSOCIATED WITH THE LINE, ALL LINES ARE PRINTED
*      SINGLE SPACED. NOTE THAT NULL LINES (WA=0) ARE POSSIBLE
*      IN WHICH CASE A BLANK LINE IS TO BE PRINTED.
*
*      THE ERROR EXIT IS USED FOR SYSTEMS WHICH LIMIT THE AMOUNT
*      OF PRINTED OUTPUT. IF POSSIBLE, PRINTING SHOULD BE
*      PERMITTED AFTER THIS CONDITION HAS BEEN SIGNALLED ONCE TO
*      ALLOW FOR DUMP AND OTHER DIAGNOSTIC INFORMATION.
*      ASSUMING THIS TO BE POSSIBLE, SPITBOL MAY MAKE MORE SYSPR
*      CALLS. IF THE ERROR RETURN OCCURS ANOTHER TIME, EXECUTION
*      IS TERMINATED BY A CALL OF SYSEJ WITH ENDING CODE 998.
{{EJC{{{{{1582
*
*      SYSRD -- READ RECORD FROM STANDARD INPUT FILE
*
{SYSRD{EXP{1,1{{{DEFINE EXTERNAL ENTRY POINT{1586
*
*      SYSRD IS USED TO READ A RECORD FROM THE STANDARD INPUT
*      FILE. THE BUFFER PROVIDED IS AN SCBLK FOR A STRING THE
*      LENGTH OF WHICH IN CHARACTERS IS GIVEN IN WC, THIS
*      CORRESPONDING TO THE MAXIMUM LENGTH OF STRING WHICH
*      SPITBOL IS PREPARED TO RECEIVE. AT COMPILE TIME IT
*      CORRESPONDS TO XXX IN THE MOST RECENT -INXXX CARD
*      (DEFAULT 72) AND AT EXECUTION TIME TO THE MOST RECENT
*      ,R_R_ (RECORD LENGTH) IN THE THIRD ARG OF AN INPUT()
*      STATEMENT FOR THE STANDARD INPUT FILE (DEFAULT 80).
*      IF FEWER THAN (WC) CHARACTERS ARE READ, THE LENGTH
*      FIELD OF THE SCBLK MUST BE ADJUSTED BEFORE RETURNING
*      UNLESS THE BUFFER IS RIGHT PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE THE ALTERNATIVE RETURN
*      AFTER SUCH AN ADJUSTMENT HAS BEEN MADE.
*      SPITBOL MAY CONTINUE TO MAKE CALLS AFTER AN ENDFILE
*      RETURN SO THIS ROUTINE SHOULD BE PREPARED TO MAKE
*      REPEATED ENDFILE RETURNS.
*
*      (XR)                  POINTER TO BUFFER (SCBLK PTR)
*      (WC)                  LENGTH OF BUFFER IN CHARACTERS
*      JSR  SYSRD            CALL TO READ LINE
*      PPM  LOC              ENDFILE OR NO I/P FILE AFTER SYSXI
*                            OR INPUT FILE NAME CHANGE.  IF
*                            THE FORMER, SCBLK LENGTH IS ZERO.
*                            IF INPUT FILE NAME CHANGE, LENGTH
*                            IS NON-ZERO. CALLER SHOULD RE-ISSUE
*                            SYSRD TO OBTAIN INPUT RECORD.
*      (WA,WB,WC)            DESTROYED
{{EJC{{{{{1618
*
*      SYSRI -- READ RECORD FROM INTERACTIVE CHANNEL
*
{SYSRI{EXP{1,1{{{DEFINE EXTERNAL ENTRY POINT{1622
*
*      READS A RECORD FROM ONLINE TERMINAL FOR SPITBOL VARIABLE,
*      TERMINAL. IF ONLINE TERMINAL IS UNAVAILABLE THEN CODE THE
*      ENDFILE RETURN ONLY.
*      THE BUFFER PROVIDED IS OF LENGTH 258 CHARACTERS. SYSRI
*      SHOULD REPLACE THE COUNT IN THE SECOND WORD OF THE SCBLK
*      BY THE ACTUAL CHARACTER COUNT UNLESS BUFFER IS RIGHT
*      PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE THE ALTERNATIVE
*      RETURN AFTER ADJUSTING THE COUNT.
*      THE END OF FILE RETURN MAY BE USED IF THIS MAKES
*      SENSE ON THE TARGET MACHINE (E.G. IF THERE IS AN
*      EOF CHARACTER.)
*
*      (XR)                  PTR TO 258 CHAR BUFFER (SCBLK PTR)
*      JSR  SYSRI            CALL TO READ LINE FROM TERMINAL
*      PPM  LOC              END OF FILE RETURN
*      (WA,WB,WC)            MAY BE DESTROYED
{{EJC{{{{{1641
*
*      SYSRW -- REWIND FILE
*
{SYSRW{EXP{1,3{{{DEFINE EXTERNAL ENTRY POINT{1645
*
*      SYSRW IS USED TO REWIND A FILE I.E. REPOSITION THE FILE
*      AT THE START BEFORE THE FIRST RECORD. THE FILE SHOULD BE
*      CLOSED AND THE NEXT READ OR WRITE CALL WILL OPEN THE
*      FILE AT THE START.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  REWIND ARG (SCBLK PTR)
*      JSR  SYSRW            CALL TO REWIND FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF REWIND NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
{{EJC{{{{{1658
*
*      SYSST -- SET FILE POINTER
*
{SYSST{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{1663
*
*      SYSST IS CALLED TO CHANGE THE POSITION OF A FILE
*      POINTER. THIS IS ACCOMPLISHED IN A SYSTEM DEPENDENT
*      MANNER, AND THUS THE 2ND AND 3RD ARGUMENTS ARE PASSED
*      UNCONVERTED.
*
*      (WA)                  FCBLK POINTER
*      (WB)                  2ND ARGUMENT
*      (WC)                  3RD ARGUMENT
*      JSR  SYSST            CALL TO SET FILE POINTER
*      PPM  LOC              RETURN HERE IF INVALID 2ND ARG
*      PPM  LOC              RETURN HERE IF INVALID 3RD ARG
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF SET NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*
{{EJC{{{{{1680
*
*      SYSTM -- GET EXECUTION TIME SO FAR
*
{SYSTM{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{1685
*
*      SYSTM IS USED TO OBTAIN THE AMOUNT OF EXECUTION TIME
*      USED SO FAR SINCE SPITBOL WAS GIVEN CONTROL. THE UNITS
*      ARE DESCRIBED AS MILLISECONDS IN THE SPITBOL OUTPUT, BUT
*      THE EXACT MEANING IS SYSTEM DEPENDENT. WHERE APPROPRIATE,
*      THIS VALUE SHOULD RELATE TO PROCESSOR RATHER THAN CLOCK
*      TIMING VALUES.
*      IF THE SYMBOL .CTMD IS DEFINED, THE UNITS ARE DESCRIBED
*      AS DECISECONDS (0.1 SECOND).
*
*      JSR  SYSTM            CALL TO GET TIMER VALUE
*      (IA)                  TIME SO FAR IN MILLISECONDS
*                            (DECISECONDS IF .CTMD DEFINED)
{{EJC{{{{{1699
*
*      SYSTT -- TRACE TOGGLE
*
{SYSTT{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{1703
*
*      CALLED BY SPITBOL FUNCTION TRACE() WITH NO ARGS TO
*      TOGGLE THE SYSTEM TRACE SWITCH.  THIS PERMITS TRACING OF
*      LABELS IN SPITBOL CODE TO BE TURNED ON OR OFF.
*
*      JSR  SYSTT            CALL TO TOGGLE TRACE SWITCH
{{EJC{{{{{1710
*
*      SYSUL -- UNLOAD EXTERNAL FUNCTION
*
{SYSUL{EXP{1,0{{{DEFINE EXTERNAL ENTRY POINT{1714
*
*      SYSUL IS USED TO UNLOAD A FUNCTION PREVIOUSLY
*      LOADED WITH A CALL TO SYSLD.
*
*      (XR)                  PTR TO CONTROL BLOCK (EFBLK)
*      JSR  SYSUL            CALL TO UNLOAD FUNCTION
*
*      THE FUNCTION CANNOT BE CALLED FOLLOWING A SYSUL CALL
*      UNTIL ANOTHER SYSLD CALL IS MADE FOR THE SAME FUNCTION.
*
*      THE EFBLK CONTAINS THE FUNCTION CODE POINTER AND ALSO A
*      POINTER TO THE VRBLK CONTAINING THE FUNCTION NAME (SEE
*      DEFINITIONS AND DATA STRUCTURES SECTION).
{{EJC{{{{{1730
*
*      SYSXI -- EXIT TO PRODUCE LOAD MODULE
*
{SYSXI{EXP{1,2{{{DEFINE EXTERNAL ENTRY POINT{1734
*
*      WHEN SYSXI IS CALLED, XL CONTAINS EITHER A STRING POINTER
*      OR ZERO. IN THE FORMER CASE, THE STRING GIVES THE
*      CHARACTER NAME OF A PROGRAM. THE INTENTION IS THAT
*      SPITBOL EXECUTION SHOULD BE TERMINATED FORTHWITH AND
*      THE NAMED PROGRAM LOADED AND EXECUTED. THIS TYPE OF CHAIN
*      EXECUTION IS VERY SYSTEM DEPENDENT AND IMPLEMENTORS MAY
*      CHOOSE TO OMIT IT OR FIND IT IMPOSSIBLE TO PROVIDE.
*      IF (XL) IS ZERO,IA CONTAINS ONE OF THE FOLLOWING INTEGERS
*
*      -1, -2, -3, -4
*           CREATE IF POSSIBLE A LOAD MODULE CONTAINING ONLY THE
*           IMPURE AREA OF MEMORY WHICH NEEDS TO BE LOADED WITH
*           A COMPATIBLE PURE SEGMENT FOR SUBSEQUENT EXECUTIONS.
*           VERSION NUMBERS TO CHECK COMPATIBILITY SHOULD BE
*           KEPT IN BOTH SEGMENTS AND CHECKED ON LOADING.
*           TO ASSIST WITH THIS CHECK, (XR) ON ENTRY IS A
*           POINTER TO AN SCBLK CONTAINING THE SPITBOL MAJOR
*           VERSION NUMBER V.V (SEE SYSID).  THE FILE THUS
*           CREATED IS CALLED A SAVE FILE.
*
*      0    IF POSSIBLE, RETURN CONTROL TO JOB CONTROL
*           COMMAND LEVEL. THE EFFECT IF AVAILABLE WILL BE
*           SYSTEM DEPENDENT.
*
*      +1, +2, +3, +4
*           CREATE IF POSSIBLE A LOAD MODULE FROM ALL OF
*           MEMORY. IT SHOULD BE POSSIBLE TO LOAD AND EXECUTE
*           THIS MODULE DIRECTLY.
*
*      IN THE CASE OF SAVED LOAD MODULES, THE STATUS OF OPEN
*      FILES IS NOT PRESERVED AND IMPLEMENTORS MAY CHOOSE TO
*      OFFER MEANS OF ATTACHING FILES BEFORE EXECUTION OF LOAD
*      MODULES STARTS OR LEAVE IT TO THE USER TO INCLUDE
*      SUITABLE INPUT(), OUTPUT() CALLS IN HIS PROGRAM.
*      SYSXI SHOULD MAKE A NOTE THAT NO I/O CHANNELS,
*      INCLUDING STANDARD FILES, HAVE FILES ATTACHED SO THAT
*      CALLS OF SYSIN, SYSOU, SYSPR, SYSRD SHOULD FAIL UNLESS
*      NEW ASSOCIATIONS ARE MADE FOR THE LOAD MODULE.
*      AT LEAST IN THE CASE OF THE STANDARD OUTPUT FILE, IT IS
*      RECOMMENDED THAT EITHER THE USER BE REQUIRED TO ATTACH
*      A FILE OR THAT A DEFAULT FILE IS ATTACHED, SINCE THE
*      PROBLEM OF ERROR MESSAGES GENERATED BY THE LOAD MODULE
*      IS OTHERWISE SEVERE. AS A LAST RESORT, IF SPITBOL
*      ATTEMPTS TO WRITE TO THE STANDARD OUTPUT FILE AND GETS A
*      REPLY INDICATING THAT SUCH OUPUT IS UNACCEPTABLE IT STOPS
*      BY USING AN ENTRY TO SYSEJ WITH ENDING CODE 998.
*      AS DESCRIBED BELOW, PASSING OF SOME ARGUMENTS MAKES IT
*      CLEAR THAT LOAD MODULE WILL USE A STANDARD OUTPUT FILE.
*
*      IF USE IS MADE OF FCBLKS FOR I/O ASSOCIATION, SPITBOL
*      BUILDS A CHAIN SO THAT THOSE IN USE MAY BE FOUND IN SYSXI
*      AND SYSEJ. THE NODES ARE 4 WORDS LONG. THIRD WORD
*      CONTAINS LINK TO NEXT NODE OR 0, FOURTH WORD CONTAINS
*      FCBLK POINTER.
{{EJC{{{{{1790
*
*      SYSXI (CONTINUED)
*
*      (XL)                  ZERO OR SCBLK PTR TO FIRST ARGUMENT
*      (XR)                  PTR TO V.V SCBLK
*      (IA)                  SIGNED INTEGER ARGUMENT
*      (WA)                  SCBLK PTR TO SECOND ARGUMENT
*      (WB)                  0 OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSXI            CALL TO EXIT
*      PPM  LOC              REQUESTED ACTION NOT POSSIBLE
*      PPM  LOC              ACTION CAUSED IRRECOVERABLE ERROR
*      (WB,WC,IA,XR,XL,CP)   SHOULD BE PRESERVED OVER CALL
*      (WA)                  0 IN ALL CASES EXCEPT SUCESSFUL
*                            PERFORMANCE OF EXIT(4) OR EXIT(-4),
*                            IN WHICH CASE 1 SHOULD BE RETURNED.
*
*      LOADING AND RUNNING THE LOAD MODULE OR RETURNING FROM
*      JCL COMMAND LEVEL CAUSES EXECUTION TO RESUME AT THE POINT
*      AFTER THE ERROR RETURNS WHICH FOLLOW THE CALL OF SYSXI.
*      THE VALUE PASSED AS EXIT ARGUMENT IS USED TO INDICATE
*      OPTIONS REQUIRED ON RESUMPTION OF LOAD MODULE.
*      +1 OR -1 REQUIRE THAT ON RESUMPTION, SYSID AND SYSPP BE
*      CALLED AND A HEADING PRINTED ON THE STANDARD OUTPUT FILE.
*      +2 OR -2 INDICATE THAT SYSPP WILL BE CALLED BUT NOT SYSID
*      AND NO HEADING WILL BE PUT ON STANDARD OUTPUT FILE.
*      ABOVE OPTIONS HAVE THE OBVIOUS IMPLICATION THAT A
*      STANDARD O/P FILE MUST BE PROVIDED FOR THE LOAD MODULE.
*      +3, +4, -3 OR -4 INDICATE CALLS OF NEITHER SYSID NOR
*      SYSPP AND NO HEADING WILL BE PLACED ON STANDARD OUTPUT
*      FILE.
*      +4 OR -4 INDICATE THAT EXECUTION IS TO CONTINUE AFTER
*      CREATION OF THE SAVE FILE OR LOAD MODULE, ALTHOUGH ALL
*      FILES WILL BE CLOSED BY THE SYSXI ACTION.  THIS PERMITS
*      THE USER TO CHECKPOINT LONG-RUNNING PROGRAMS WHILE
*      CONTINUING EXECUTION.
*
*      NO RETURN FROM SYSXI IS POSSIBLE IF ANOTHER PROGRAM
*      IS LOADED AND ENTERED.
{{EJC{{{{{1830
*
*      INTRODUCE THE INTERNAL PROCEDURES.
*
{ACESS{INP{25,R{1,1{{{1834
{ACOMP{INP{25,N{1,5{{{1835
{ALLOC{INP{25,E{1,0{{{1836
{ALOCS{INP{25,E{1,0{{{1841
{ALOST{INP{25,E{1,0{{{1842
{ARITH{INP{25,N{1,3{{{1850
{ASIGN{INP{25,R{1,1{{{1852
{ASINP{INP{25,R{1,1{{{1853
{BLKLN{INP{25,E{1,0{{{1854
{CDGCG{INP{25,E{1,0{{{1855
{CDGEX{INP{25,R{1,0{{{1856
{CDGNM{INP{25,R{1,0{{{1857
{CDGVL{INP{25,R{1,0{{{1858
{CDWRD{INP{25,E{1,0{{{1859
{CMGEN{INP{25,R{1,0{{{1860
{CMPIL{INP{25,E{1,0{{{1861
{CNCRD{INP{25,E{1,0{{{1862
{COPYB{INP{25,N{1,1{{{1863
{DFFNC{INP{25,E{1,0{{{1864
{DTACH{INP{25,E{1,0{{{1865
{DTYPE{INP{25,E{1,0{{{1866
{DUMPR{INP{25,E{1,0{{{1867
{ERMSG{INP{25,E{1,0{{{1872
{ERTEX{INP{25,E{1,0{{{1873
{EVALI{INP{25,R{1,4{{{1874
{EVALP{INP{25,R{1,1{{{1875
{EVALS{INP{25,R{1,3{{{1876
{EVALX{INP{25,R{1,1{{{1877
{EXBLD{INP{25,E{1,0{{{1878
{EXPAN{INP{25,E{1,0{{{1879
{EXPAP{INP{25,E{1,1{{{1880
{EXPDM{INP{25,N{1,0{{{1881
{EXPOP{INP{25,N{1,0{{{1882
{FILNM{INP{25,E{1,0{{{1884
{FLSTG{INP{25,E{1,0{{{1887
{GBCOL{INP{25,E{1,0{{{1889
{GBCPF{INP{25,E{1,0{{{1890
{GTARR{INP{25,E{1,2{{{1891
{{EJC{{{{{1892
{GTCOD{INP{25,E{1,1{{{1893
{GTEXP{INP{25,E{1,1{{{1894
{GTINT{INP{25,E{1,1{{{1895
{GTNUM{INP{25,E{1,1{{{1896
{GTNVR{INP{25,E{1,1{{{1897
{GTPAT{INP{25,E{1,1{{{1898
{GTREA{INP{25,E{1,1{{{1901
{GTSMI{INP{25,N{1,2{{{1903
{GTSTG{INP{25,N{1,1{{{1908
{GTVAR{INP{25,E{1,1{{{1909
{HASHS{INP{25,E{1,0{{{1910
{ICBLD{INP{25,E{1,0{{{1911
{IDENT{INP{25,E{1,1{{{1912
{INOUT{INP{25,E{1,0{{{1913
{INSTA{INP{25,E{1,0{{{1918
{IOFCB{INP{25,N{1,3{{{1919
{IOPPF{INP{25,N{1,0{{{1920
{IOPUT{INP{25,N{1,7{{{1921
{KTREX{INP{25,R{1,0{{{1922
{KWNAM{INP{25,N{1,0{{{1923
{LCOMP{INP{25,N{1,5{{{1924
{LISTR{INP{25,E{1,0{{{1925
{LISTT{INP{25,E{1,0{{{1926
{NEWFN{INP{25,E{1,0{{{1928
{NEXTS{INP{25,E{1,0{{{1930
{PATIN{INP{25,N{1,2{{{1931
{PATST{INP{25,N{1,1{{{1932
{PBILD{INP{25,E{1,0{{{1933
{PCONC{INP{25,E{1,0{{{1934
{PCOPY{INP{25,N{1,0{{{1935
{PRFLR{INP{25,E{1,0{{{1938
{PRFLU{INP{25,E{1,0{{{1939
{PRPAR{INP{25,E{1,0{{{1941
{PRTCH{INP{25,E{1,0{{{1942
{PRTIC{INP{25,E{1,0{{{1943
{PRTIS{INP{25,E{1,0{{{1944
{PRTIN{INP{25,E{1,0{{{1945
{PRTMI{INP{25,E{1,0{{{1946
{PRTMM{INP{25,E{1,0{{{1947
{PRTMX{INP{25,E{1,0{{{1948
{PRTNL{INP{25,R{1,0{{{1949
{PRTNM{INP{25,R{1,0{{{1950
{PRTNV{INP{25,E{1,0{{{1951
{PRTPG{INP{25,E{1,0{{{1952
{PRTPS{INP{25,E{1,0{{{1953
{PRTSN{INP{25,E{1,0{{{1954
{PRTST{INP{25,R{1,0{{{1955
{{EJC{{{{{1956
{PRTTR{INP{25,E{1,0{{{1957
{PRTVL{INP{25,R{1,0{{{1958
{PRTVN{INP{25,E{1,0{{{1959
{RCBLD{INP{25,E{1,0{{{1962
{READR{INP{25,E{1,0{{{1964
{RELAJ{INP{25,E{1,0{{{1966
{RELCR{INP{25,E{1,0{{{1967
{RELDN{INP{25,E{1,0{{{1968
{RELOC{INP{25,E{1,0{{{1969
{RELST{INP{25,E{1,0{{{1970
{RELWS{INP{25,E{1,0{{{1971
{RSTRT{INP{25,E{1,0{{{1973
{SBSTR{INP{25,E{1,0{{{1977
{SCANE{INP{25,E{1,0{{{1978
{SCNGF{INP{25,E{1,0{{{1979
{SETVR{INP{25,E{1,0{{{1980
{SORTA{INP{25,N{1,1{{{1983
{SORTC{INP{25,E{1,1{{{1984
{SORTF{INP{25,E{1,0{{{1985
{SORTH{INP{25,N{1,0{{{1986
{START{INP{25,E{1,0{{{1988
{STGCC{INP{25,E{1,0{{{1989
{TFIND{INP{25,E{1,1{{{1990
{TMAKE{INP{25,E{1,0{{{1991
{TRACE{INP{25,N{1,2{{{1992
{TRBLD{INP{25,E{1,0{{{1993
{TRIMR{INP{25,E{1,0{{{1994
{TRXEQ{INP{25,R{1,0{{{1995
{VMAKE{INP{25,E{1,1{{{1996
{XSCAN{INP{25,E{1,0{{{1997
{XSCNI{INP{25,N{1,2{{{1998
*
*      INTRODUCE THE INTERNAL ROUTINES
*
{ARREF{INR{{{{{2002
{CFUNC{INR{{{{{2003
{EXFAL{INR{{{{{2004
{EXINT{INR{{{{{2005
{EXITS{INR{{{{{2006
{EXIXR{INR{{{{{2007
{EXNAM{INR{{{{{2008
{EXNUL{INR{{{{{2009
{EXREA{INR{{{{{2012
{EXSID{INR{{{{{2014
{EXVNM{INR{{{{{2015
{FAILP{INR{{{{{2016
{FLPOP{INR{{{{{2017
{INDIR{INR{{{{{2018
{MATCH{INR{{{{{2019
{RETRN{INR{{{{{2020
{STCOV{INR{{{{{2021
{STMGO{INR{{{{{2022
{STOPR{INR{{{{{2023
{SUCCP{INR{{{{{2024
{SYSAB{INR{{{{{2025
{SYSTU{INR{{{{{2026
{{TTL{27,S P I T B O L -- DEFINITIONS AND DATA STRUCTURES{{{{2027
*      THIS SECTION CONTAINS ALL SYMBOL DEFINITIONS AND ALSO
*      PICTURES OF ALL DATA STRUCTURES USED IN THE SYSTEM.
*
{{SEC{{{{START OF DEFINITIONS SECTION{2031
*
*      DEFINITIONS OF MACHINE PARAMETERS
*
*      THE MINIMAL TRANSLATOR SHOULD SUPPLY APPROPRIATE VALUES
*      FOR THE PARTICULAR TARGET MACHINE FOR ALL THE
*      EQU  *
*      DEFINITIONS GIVEN AT THE START OF THIS SECTION.
*      NOTE THAT EVEN IF CONDITIONAL ASSEMBLY IS USED TO OMIT
*      SOME FEATURE (E.G. REAL ARITHMETIC) A FULL SET OF CFP_-
*      VALUES MUST BE SUPPLIED. USE DUMMY VALUES IF GENUINE
*      ONES ARE NOT NEEDED.
*
{CFP_A{EQU{24,256{{{NUMBER OF CHARACTERS IN ALPHABET{2044
*
{CFP_B{EQU{24,4{{{BYTES/WORD ADDRESSING FACTOR{2046
*
{CFP_C{EQU{24,4{{{NUMBER OF CHARACTERS PER WORD{2048
*
{CFP_F{EQU{24,8{{{OFFSET IN BYTES TO CHARS IN{2050
*                            SCBLK. SEE SCBLK FORMAT.
*
{CFP_I{EQU{24,1{{{NUMBER OF WORDS IN INTEGER CONSTANT{2053
*
{CFP_M{EQU{24,2147483647{{{MAX POSITIVE INTEGER IN ONE WORD{2055
*
{CFP_N{EQU{24,32{{{NUMBER OF BITS IN ONE WORD{2057
*
*      THE FOLLOWING DEFINITIONS REQUIRE THE SUPPLY OF EITHER
*      A SINGLE PARAMETER IF REAL ARITHMETIC IS OMITTED OR
*      THREE PARAMETERS IF REAL ARITHMETIC IS INCLUDED.
*
*
{CFP_R{EQU{24,2{{{NUMBER OF WORDS IN REAL CONSTANT{2067
*
{CFP_S{EQU{24,9{{{NUMBER OF SIG DIGS FOR REAL OUTPUT{2069
*
{CFP_X{EQU{24,3{{{MAX DIGITS IN REAL EXPONENT{2071
*
{MXDGS{EQU{24,CFP_S+CFP_X{{{MAX DIGITS IN REAL NUMBER{2082
*
*
*      MAX SPACE FOR REAL (FOR +0.E+) NEEDS FIVE MORE PLACES
*
{NSTMX{EQU{24,MXDGS+5{{{MAX SPACE FOR REAL{2087
*
*      THE FOLLOWING DEFINITION FOR CFP_U SUPPLIES A REALISTIC
*      UPPER BOUND ON THE SIZE OF THE ALPHABET.  CFP_U IS USED
*      TO SAVE SPACE IN THE SCANE BSW-IFF-ESW TABLE AND TO EASE
*      TRANSLATION STORAGE REQUIREMENTS.
*
{CFP_U{EQU{24,128{{{REALISTIC UPPER BOUND ON ALPHABET{2097
{{EJC{{{{{2099
*
*      ENVIRONMENT PARAMETERS
*
*      THE SPITBOL PROGRAM IS ESSENTIALLY INDEPENDENT OF
*      THE DEFINITIONS OF THESE PARAMETERS. HOWEVER, THE
*      EFFICIENCY OF THE SYSTEM MAY BE AFFECTED. CONSEQUENTLY,
*      THESE PARAMETERS MAY REQUIRE TUNING FOR A GIVEN VERSION
*      THE VALUES GIVEN IN COMMENTS HAVE BEEN SUCCESSFULLY USED.
*
*      E_SRS IS THE NUMBER OF WORDS TO RESERVE AT THE END OF
*      STORAGE FOR END OF RUN PROCESSING. IT SHOULD BE
*      SET AS SMALL AS POSSIBLE WITHOUT CAUSING MEMORY OVERFLOW
*      IN CRITICAL SITUATIONS (E.G. MEMORY OVERFLOW TERMINATION)
*      AND SHOULD THUS RESERVE SUFFICIENT SPACE AT LEAST FOR
*      AN SCBLK CONTAINING SAY 30 CHARACTERS.
*
{E_SRS{EQU{24,100{{{30 WORDS{2116
*
*      E_STS IS THE NUMBER OF WORDS GRABBED IN A CHUNK WHEN
*      STORAGE IS ALLOCATED IN THE STATIC REGION. THE MINIMUM
*      PERMITTED VALUE IS 256/CFP_B. LARGER VALUES WILL LEAD
*      TO INCREASED EFFICIENCY AT THE COST OF WASTING MEMORY.
*
{E_STS{EQU{24,1000{{{500 WORDS{2123
*
*      E_CBS IS THE SIZE OF CODE BLOCK ALLOCATED INITIALLY AND
*      THE EXPANSION INCREMENT IF OVERFLOW OCCURS. IF THIS VALUE
*      IS TOO SMALL OR TOO LARGE, EXCESSIVE GARBAGE COLLECTIONS
*      WILL OCCUR DURING COMPILATION AND MEMORY MAY BE LOST
*      IN THE CASE OF A TOO LARGE VALUE.
*
{E_CBS{EQU{24,500{{{500 WORDS{2131
*
*      E_HNB IS THE NUMBER OF BUCKET HEADERS IN THE VARIABLE
*      HASH TABLE. IT SHOULD ALWAYS BE ODD. LARGER VALUES WILL
*      SPEED UP COMPILATION AND INDIRECT REFERENCES AT THE
*      EXPENSE OF ADDITIONAL STORAGE FOR THE HASH TABLE ITSELF.
*
{E_HNB{EQU{24,257{{{127 BUCKET HEADERS{2138
*
*      E_HNW IS THE MAXIMUM NUMBER OF WORDS OF A STRING
*      NAME WHICH PARTICIPATE IN THE STRING HASH ALGORITHM.
*      LARGER VALUES GIVE A BETTER HASH AT THE EXPENSE OF TAKING
*      LONGER TO COMPUTE THE HASH. THERE IS SOME OPTIMAL VALUE.
*
{E_HNW{EQU{24,6{{{6 WORDS{2145
*
*      E_FSP.  IF THE AMOUNT OF FREE SPACE LEFT AFTER A GARBAGE
*      COLLECTION IS SMALL COMPARED TO THE TOTAL AMOUNT OF SPACE
*      IN USE GARBAGE COLLECTOR THRASHING IS LIKELY TO OCCUR AS
*      THIS SPACE IS USED UP.  E_FSP IS A MEASURE OF THE
*      MINIMUM PERCENTAGE OF DYNAMIC MEMORY LEFT AS FREE SPACE
*      BEFORE THE SYSTEM ROUTINE SYSMM IS CALLED TO TRY TO
*      OBTAIN MORE MEMORY.
*
{E_FSP{EQU{24,15{{{15 PERCENT{2155
*
*      E_SED.  IF THE AMOUNT OF FREE SPACE LEFT IN THE SEDIMENT
*      AFTER A GARBAGE COLLECTION IS A SIGNIFICANT FRACTION OF
*      THE NEW SEDIMENT SIZE, THE SEDIMENT IS MARKED FOR
*      COLLECTION ON THE NEXT CALL TO THE GARBAGE COLLECTOR.
*
{E_SED{EQU{24,25{{{25 PERCENT{2163
{{EJC{{{{{2165
*
*      DEFINITIONS OF CODES FOR LETTERS
*
{CH_LA{EQU{24,65{{{LETTER A{2169
{CH_LB{EQU{24,66{{{LETTER B{2170
{CH_LC{EQU{24,67{{{LETTER C{2171
{CH_LD{EQU{24,68{{{LETTER D{2172
{CH_LE{EQU{24,69{{{LETTER E{2173
{CH_LF{EQU{24,70{{{LETTER F{2174
{CH_LG{EQU{24,71{{{LETTER G{2175
{CH_LH{EQU{24,72{{{LETTER H{2176
{CH_LI{EQU{24,73{{{LETTER I{2177
{CH_LJ{EQU{24,74{{{LETTER J{2178
{CH_LK{EQU{24,75{{{LETTER K{2179
{CH_LL{EQU{24,76{{{LETTER L{2180
{CH_LM{EQU{24,77{{{LETTER M{2181
{CH_LN{EQU{24,78{{{LETTER N{2182
{CH_LO{EQU{24,79{{{LETTER O{2183
{CH_LP{EQU{24,80{{{LETTER P{2184
{CH_LQ{EQU{24,81{{{LETTER Q{2185
{CH_LR{EQU{24,82{{{LETTER R{2186
{CH_LS{EQU{24,83{{{LETTER S{2187
{CH_LT{EQU{24,84{{{LETTER T{2188
{CH_LU{EQU{24,85{{{LETTER U{2189
{CH_LV{EQU{24,86{{{LETTER V{2190
{CH_LW{EQU{24,87{{{LETTER W{2191
{CH_LX{EQU{24,88{{{LETTER X{2192
{CH_LY{EQU{24,89{{{LETTER Y{2193
{CH_L_{EQU{24,90{{{LETTER Z{2194
*
*      DEFINITIONS OF CODES FOR DIGITS
*
{CH_D0{EQU{24,48{{{DIGIT 0{2198
{CH_D1{EQU{24,49{{{DIGIT 1{2199
{CH_D2{EQU{24,50{{{DIGIT 2{2200
{CH_D3{EQU{24,51{{{DIGIT 3{2201
{CH_D4{EQU{24,52{{{DIGIT 4{2202
{CH_D5{EQU{24,53{{{DIGIT 5{2203
{CH_D6{EQU{24,54{{{DIGIT 6{2204
{CH_D7{EQU{24,55{{{DIGIT 7{2205
{CH_D8{EQU{24,56{{{DIGIT 8{2206
{CH_D9{EQU{24,57{{{DIGIT 9{2207
{{EJC{{{{{2208
*
*      DEFINITIONS OF CODES FOR SPECIAL CHARACTERS
*
*      THE NAMES OF THESE CHARACTERS ARE RELATED TO THEIR
*      ORIGINAL REPRESENTATION IN THE EBCDIC SET CORRESPONDING
*      TO THE DESCRIPTION IN STANDARD SNOBOL4 MANUALS AND TEXTS.
*
{CH_AM{EQU{24,38{{{KEYWORD OPERATOR (AMPERSAND){2216
{CH_AS{EQU{24,42{{{MULTIPLICATION SYMBOL (ASTERISK){2217
{CH_AT{EQU{24,64{{{CURSOR POSITION OPERATOR (AT){2218
{CH_BB{EQU{24,60{{{LEFT ARRAY BRACKET (LESS THAN){2219
{CH_BL{EQU{24,32{{{BLANK{2220
{CH_BR{EQU{24,124{{{ALTERNATION OPERATOR (VERTICAL BAR){2221
{CH_CL{EQU{24,58{{{GOTO SYMBOL (COLON){2222
{CH_CM{EQU{24,44{{{COMMA{2223
{CH_DL{EQU{24,36{{{INDIRECTION OPERATOR (DOLLAR){2224
{CH_DT{EQU{24,46{{{NAME OPERATOR (DOT){2225
{CH_DQ{EQU{24,34{{{DOUBLE QUOTE{2226
{CH_EQ{EQU{24,61{{{EQUAL SIGN{2227
{CH_EX{EQU{24,33{{{EXPONENTIATION OPERATOR (EXCLM){2228
{CH_MN{EQU{24,45{{{MINUS SIGN / HYPHEN{2229
{CH_NM{EQU{24,35{{{NUMBER SIGN{2230
{CH_NT{EQU{24,126{{{NEGATION OPERATOR (NOT){2231
{CH_PC{EQU{24,37{{{PERCENT{2232
{CH_PL{EQU{24,43{{{PLUS SIGN{2233
{CH_PP{EQU{24,40{{{LEFT PARENTHESIS{2234
{CH_RB{EQU{24,62{{{RIGHT ARRAY BRACKET (GRTR THAN){2235
{CH_RP{EQU{24,41{{{RIGHT PARENTHESIS{2236
{CH_QU{EQU{24,63{{{INTERROGATION OPERATOR (QUESTION){2237
{CH_SL{EQU{24,47{{{SLASH{2238
{CH_SM{EQU{24,59{{{SEMICOLON{2239
{CH_SQ{EQU{24,39{{{SINGLE QUOTE{2240
{CH_UN{EQU{24,95{{{SPECIAL IDENTIFIER CHAR (UNDERLINE){2241
{CH_OB{EQU{24,91{{{OPENING BRACKET{2242
{CH_CB{EQU{24,93{{{CLOSING BRACKET{2243
{{EJC{{{{{2244
*
*      REMAINING CHARS ARE OPTIONAL ADDITIONS TO THE STANDARDS.
*
*      TAB CHARACTERS - SYNTACTICALLY EQUIVALENT TO BLANK
*
{CH_HT{EQU{24,9{{{HORIZONTAL TAB{2251
*
*      UP ARROW SAME AS EXCLAMATION MARK FOR EXPONENTIATION
*
{CH_EY{EQU{24,94{{{UP ARROW{2260
*
*      LOWER CASE OR SHIFTED CASE ALPHABETIC CHARS
*
{CH__A{EQU{24,97{{{SHIFTED A{2266
{CH__B{EQU{24,98{{{SHIFTED B{2267
{CH__C{EQU{24,99{{{SHIFTED C{2268
{CH__D{EQU{24,100{{{SHIFTED D{2269
{CH__E{EQU{24,101{{{SHIFTED E{2270
{CH__F{EQU{24,102{{{SHIFTED F{2271
{CH__G{EQU{24,103{{{SHIFTED G{2272
{CH__H{EQU{24,104{{{SHIFTED H{2273
{CH__I{EQU{24,105{{{SHIFTED I{2274
{CH__J{EQU{24,106{{{SHIFTED J{2275
{CH__K{EQU{24,107{{{SHIFTED K{2276
{CH__L{EQU{24,108{{{SHIFTED L{2277
{CH__M{EQU{24,109{{{SHIFTED M{2278
{CH__N{EQU{24,110{{{SHIFTED N{2279
{CH__O{EQU{24,111{{{SHIFTED O{2280
{CH__P{EQU{24,112{{{SHIFTED P{2281
{CH__Q{EQU{24,113{{{SHIFTED Q{2282
{CH__R{EQU{24,114{{{SHIFTED R{2283
{CH__S{EQU{24,115{{{SHIFTED S{2284
{CH__T{EQU{24,116{{{SHIFTED T{2285
{CH__U{EQU{24,117{{{SHIFTED U{2286
{CH__V{EQU{24,118{{{SHIFTED V{2287
{CH__W{EQU{24,119{{{SHIFTED W{2288
{CH__X{EQU{24,120{{{SHIFTED X{2289
{CH__Y{EQU{24,121{{{SHIFTED Y{2290
{CH___{EQU{24,122{{{SHIFTED Z{2291
*      IF A DELIMITER OTHER THAN CH_CM MUST BE USED IN
*      THE THIRD ARGUMENT OF INPUT(),OUTPUT() THEN .CIOD SHOULD
*      BE DEFINED AND A PARAMETER SUPPLIED FOR IODEL.
*
{IODEL{EQU{24,32{{{{2298
{{EJC{{{{{2302
*
*      DATA BLOCK FORMATS AND DEFINITIONS
*
*      THE FOLLOWING SECTIONS DESCRIBE THE DETAILED FORMAT OF
*      ALL POSSIBLE DATA BLOCKS IN STATIC AND DYNAMIC MEMORY.
*
*      EVERY BLOCK HAS A NAME OF THE FORM XXBLK WHERE XX IS A
*      UNIQUE TWO CHARACTER IDENTIFIER. THE FIRST WORD OF EVERY
*      BLOCK MUST CONTAIN A POINTER TO A PROGRAM LOCATION IN THE
*      INTERPRETOR WHICH IS IMMEDIATELY PRECEDED BY AN ADDRESS
*      CONSTANT CONTAINING THE VALUE BL_XX WHERE XX IS THE BLOCK
*      IDENTIFIER. THIS PROVIDES A UNIFORM MECHANISM FOR
*      DISTINGUISHING BETWEEN THE VARIOUS BLOCK TYPES.
*
*      IN SOME CASES, THE CONTENTS OF THE FIRST WORD IS CONSTANT
*      FOR A GIVEN BLOCK TYPE AND MERELY SERVES AS A POINTER
*      TO THE IDENTIFYING ADDRESS CONSTANT. HOWEVER, IN OTHER
*      CASES THERE ARE SEVERAL POSSIBILITIES FOR THE FIRST
*      WORD IN WHICH CASE EACH OF THE SEVERAL PROGRAM ENTRY
*      POINTS MUST BE PRECEDED BY THE APPROPRIATE CONSTANT.
*
*      IN EACH BLOCK, SOME OF THE FIELDS ARE RELOCATABLE. THIS
*      MEANS THAT THEY MAY CONTAIN A POINTER TO ANOTHER BLOCK
*      IN THE DYNAMIC AREA. (TO BE MORE PRECISE, IF THEY CONTAIN
*      A POINTER WITHIN THE DYNAMIC AREA, THEN IT IS A POINTER
*      TO A BLOCK). SUCH FIELDS MUST BE MODIFIED BY THE GARBAGE
*      COLLECTOR (PROCEDURE GBCOL) WHENEVER BLOCKS ARE COMPACTED
*      IN THE DYNAMIC REGION. THE GARBAGE COLLECTOR (ACTUALLY
*      PROCEDURE GBCPF) REQUIRES THAT ALL SUCH RELOCATABLE
*      FIELDS IN A BLOCK MUST BE CONTIGUOUS.
{{EJC{{{{{2333
*
*      THE DESCRIPTION FORMAT USES THE FOLLOWING SCHEME.
*
*      1)   BLOCK TITLE AND TWO CHARACTER IDENTIFIER
*
*      2)   DESCRIPTION OF BASIC USE OF BLOCK AND INDICATION
*           OF CIRCUMSTANCES UNDER WHICH IT IS CONSTRUCTED.
*
*      3)   PICTURE OF THE BLOCK FORMAT. IN THESE PICTURES LOW
*           MEMORY ADDRESSES ARE AT THE TOP OF THE PAGE. FIXED
*           LENGTH FIELDS ARE SURROUNDED BY I (LETTER I). FIELDS
*           WHICH ARE FIXED LENGTH BUT WHOSE LENGTH IS DEPENDENT
*           ON A CONFIGURATION PARAMETER ARE SURROUNDED BY *
*           (ASTERISK). VARIABLE LENGTH FIELDS ARE SURROUNDED
*           BY / (SLASH).
*
*      4)   DEFINITION OF SYMBOLIC OFFSETS TO FIELDS IN
*           BLOCK AND OF THE SIZE OF THE BLOCK IF FIXED LENGTH
*           OR OF THE SIZE OF THE FIXED LENGTH FIELDS IF THE
*           BLOCK IS VARIABLE LENGTH.
*           NOTE THAT SOME ROUTINES SUCH AS GBCPF ASSUME
*           CERTAIN OFFSETS ARE EQUAL. THE DEFINITIONS
*           GIVEN HERE ENFORCE THIS.  MAKE CHANGES TO
*           THEM ONLY WITH DUE CARE.
*
*      DEFINITIONS OF COMMON OFFSETS
*
{OFFS1{EQU{24,1{{{{2361
{OFFS2{EQU{24,2{{{{2362
{OFFS3{EQU{24,3{{{{2363
*
*      5)   DETAILED COMMENTS ON THE SIGNIFICANCE AND FORMATS
*           OF THE VARIOUS FIELDS.
*
*      THE ORDER IS ALPHABETICAL BY IDENTIFICATION CODE.
{{EJC{{{{{2369
*
*      DEFINITIONS OF BLOCK CODES
*
*      THIS TABLE PROVIDES A UNIQUE IDENTIFICATION CODE FOR
*      EACH SEPARATE BLOCK TYPE. THE FIRST WORD OF A BLOCK IN
*      THE DYNAMIC AREA ALWAYS CONTAINS THE ADDRESS OF A PROGRAM
*      ENTRY POINT. THE BLOCK CODE IS USED AS THE ENTRY POINT ID
*      THE ORDER OF THESE CODES DICTATES THE ORDER OF THE TABLE
*      USED BY THE DATATYPE FUNCTION (SCNMT IN THE CONSTANT SEC)
*
*      BLOCK CODES FOR ACCESSIBLE DATATYPES
*
*      NOTE THAT REAL AND BUFFER TYPES ARE ALWAYS INCLUDED, EVEN
*      IF THEY ARE CONDITIONALLY EXCLUDED ELSEWHERE.  THIS MAIN-
*      TAINS BLOCK TYPE CODES ACROSS ALL VERSIONS OF SPITBOL,
*      PROVIDING CONSISTANCY FOR EXTERNAL FUNCTIONS.  BUT NOTE
*      THAT THE BCBLK IS OUT OF ALPHABETIC ORDER, PLACED AT THE
*      END OF THE LIST SO AS NOT TO CHANGE THE BLOCK TYPE
*      ORDERING IN USE IN EXISTING EXTERNAL FUNCTIONS.
*
{BL_AR{EQU{24,0{{{ARBLK     ARRAY{2390
{BL_CD{EQU{24,BL_AR+1{{{CDBLK     CODE{2391
{BL_EX{EQU{24,BL_CD+1{{{EXBLK     EXPRESSION{2392
{BL_IC{EQU{24,BL_EX+1{{{ICBLK     INTEGER{2393
{BL_NM{EQU{24,BL_IC+1{{{NMBLK     NAME{2394
{BL_P0{EQU{24,BL_NM+1{{{P0BLK     PATTERN{2395
{BL_P1{EQU{24,BL_P0+1{{{P1BLK     PATTERN{2396
{BL_P2{EQU{24,BL_P1+1{{{P2BLK     PATTERN{2397
{BL_RC{EQU{24,BL_P2+1{{{RCBLK     REAL{2398
{BL_SC{EQU{24,BL_RC+1{{{SCBLK     STRING{2399
{BL_SE{EQU{24,BL_SC+1{{{SEBLK     EXPRESSION{2400
{BL_TB{EQU{24,BL_SE+1{{{TBBLK     TABLE{2401
{BL_VC{EQU{24,BL_TB+1{{{VCBLK     ARRAY{2402
{BL_XN{EQU{24,BL_VC+1{{{XNBLK     EXTERNAL{2403
{BL_XR{EQU{24,BL_XN+1{{{XRBLK     EXTERNAL{2404
{BL_BC{EQU{24,BL_XR+1{{{BCBLK     BUFFER{2405
{BL_PD{EQU{24,BL_BC+1{{{PDBLK     PROGRAM DEFINED DATATYPE{2406
*
{BL__D{EQU{24,BL_PD+1{{{NUMBER OF BLOCK CODES FOR DATA{2408
*
*      OTHER BLOCK CODES
*
{BL_TR{EQU{24,BL_PD+1{{{TRBLK{2412
{BL_BF{EQU{24,BL_TR+1{{{BFBLK{2413
{BL_CC{EQU{24,BL_BF+1{{{CCBLK{2414
{BL_CM{EQU{24,BL_CC+1{{{CMBLK{2415
{BL_CT{EQU{24,BL_CM+1{{{CTBLK{2416
{BL_DF{EQU{24,BL_CT+1{{{DFBLK{2417
{BL_EF{EQU{24,BL_DF+1{{{EFBLK{2418
{BL_EV{EQU{24,BL_EF+1{{{EVBLK{2419
{BL_FF{EQU{24,BL_EV+1{{{FFBLK{2420
{BL_KV{EQU{24,BL_FF+1{{{KVBLK{2421
{BL_PF{EQU{24,BL_KV+1{{{PFBLK{2422
{BL_TE{EQU{24,BL_PF+1{{{TEBLK{2423
*
{BL__I{EQU{24,0{{{DEFAULT IDENTIFICATION CODE{2425
{BL__T{EQU{24,BL_TR+1{{{CODE FOR DATA OR TRACE BLOCK{2426
{BL___{EQU{24,BL_TE+1{{{NUMBER OF BLOCK CODES{2427
{{EJC{{{{{2428
*
*      FIELD REFERENCES
*
*      REFERENCES TO THE FIELDS OF DATA BLOCKS ARE SYMBOLIC
*      (I.E. USE THE SYMBOLIC OFFSETS) WITH THE FOLLOWING
*      EXCEPTIONS.
*
*      1)   REFERENCES TO THE FIRST WORD ARE USUALLY NOT
*           SYMBOLIC SINCE THEY USE THE (X) OPERAND FORMAT.
*
*      2)   THE CODE WHICH CONSTRUCTS A BLOCK IS OFTEN NOT
*           SYMBOLIC AND SHOULD BE CHANGED IF THE CORRESPONDING
*           BLOCK FORMAT IS MODIFIED.
*
*      3)   THE PLC AND PSC INSTRUCTIONS IMPLY AN OFFSET
*           CORRESPONDING TO THE DEFINITION OF CFP_F.
*
*      4)   THERE ARE NON-SYMBOLIC REFERENCES (EASILY CHANGED)
*           IN THE GARBAGE COLLECTOR (PROCEDURES GBCPF, BLKLN).
*
*      5)   THE FIELDS IDVAL, FARGS APPEAR IN SEVERAL BLOCKS
*           AND ANY CHANGES MUST BE MADE IN PARALLEL TO ALL
*           BLOCKS CONTAINING THE FIELDS. THE ACTUAL REFERENCES
*           TO THESE FIELDS ARE SYMBOLIC WITH THE ABOVE
*           LISTED EXCEPTIONS.
*
*      6)   SEVERAL SPOTS IN THE CODE ASSUME THAT THE
*           DEFINITIONS OF THE FIELDS VRVAL, TEVAL, TRNXT ARE
*           THE SAME (THESE ARE SECTIONS OF CODE WHICH SEARCH
*           OUT ALONG A TRBLK CHAIN FROM A VARIABLE).
*
*      7)   REFERENCES TO THE FIELDS OF AN ARRAY BLOCK IN THE
*           ARRAY REFERENCE ROUTINE ARREF ARE NON-SYMBOLIC.
*
*      APART FROM THE EXCEPTIONS LISTED, REFERENCES ARE SYMBOLIC
*      AS FAR AS POSSIBLE AND MODIFYING THE ORDER OR NUMBER
*      OF FIELDS WILL NOT REQUIRE CHANGES.
{{EJC{{{{{2466
*
*      COMMON FIELDS FOR FUNCTION BLOCKS
*
*      BLOCKS WHICH REPRESENT CALLABLE FUNCTIONS HAVE TWO
*      COMMON FIELDS AT THE START OF THE BLOCK AS FOLLOWS.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           /                                    /
*           /       REST OF FUNCTION BLOCK       /
*           /                                    /
*           +------------------------------------+
*
{FCODE{EQU{24,0{{{POINTER TO CODE FOR FUNCTION{2483
{FARGS{EQU{24,1{{{NUMBER OF ARGUMENTS{2484
*
*      FCODE IS A POINTER TO THE LOCATION IN THE INTERPRETOR
*      PROGRAM WHICH PROCESSES THIS TYPE OF FUNCTION CALL.
*
*      FARGS IS THE EXPECTED NUMBER OF ARGUMENTS. THE ACTUAL
*      NUMBER OF ARGUMENTS IS ADJUSTED TO THIS AMOUNT BY
*      DELETING EXTRA ARGUMENTS OR SUPPLYING TRAILING NULLS
*      FOR MISSING ONES BEFORE TRANSFERRING THOUGH FCODE.
*      A VALUE OF 999 MAY BE USED IN THIS FIELD TO INDICATE A
*      VARIABLE NUMBER OF ARGUMENTS (SEE SVBLK FIELD SVNAR).
*
*      THE BLOCK TYPES WHICH FOLLOW THIS SCHEME ARE.
*
*      FFBLK                 FIELD FUNCTION
*      DFBLK                 DATATYPE FUNCTION
*      PFBLK                 PROGRAM DEFINED FUNCTION
*      EFBLK                 EXTERNAL LOADED FUNCTION
{{EJC{{{{{2502
*
*      IDENTIFICATION FIELD
*
*
*      ID   FIELD
*
*      CERTAIN PROGRAM ACCESSIBLE OBJECTS (THOSE WHICH CONTAIN
*      OTHER DATA VALUES AND CAN BE COPIED) ARE GIVEN A UNIQUE
*      IDENTIFICATION NUMBER (SEE EXSID). THIS ID VALUE IS AN
*      ADDRESS INTEGER VALUE WHICH IS ALWAYS STORED IN WORD TWO.
*
{IDVAL{EQU{24,1{{{ID VALUE FIELD{2514
*
*      THE BLOCKS CONTAINING AN IDVAL FIELD ARE.
*
*      ARBLK                 ARRAY
*      PDBLK                 PROGRAM DEFINED DATATYPE
*      TBBLK                 TABLE
*      VCBLK                 VECTOR BLOCK (ARRAY)
*
*      NOTE THAT A ZERO IDVAL MEANS THAT THE BLOCK IS ONLY
*      HALF BUILT AND SHOULD NOT BE DUMPED (SEE DUMPR).
{{EJC{{{{{2529
*
*      ARRAY BLOCK (ARBLK)
*
*      AN ARRAY BLOCK REPRESENTS AN ARRAY VALUE OTHER THAN ONE
*      WITH ONE DIMENSION WHOSE LOWER BOUND IS ONE (SEE VCBLK).
*      AN ARBLK IS BUILT WITH A CALL TO THE FUNCTIONS CONVERT
*      (S_CNV) OR ARRAY (S_ARR).
*
*           +------------------------------------+
*           I                ARTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                ARLEN               I
*           +------------------------------------+
*           I                AROFS               I
*           +------------------------------------+
*           I                ARNDM               I
*           +------------------------------------+
*           *                ARLBD               *
*           +------------------------------------+
*           *                ARDIM               *
*           +------------------------------------+
*           *                                    *
*           * ABOVE 2 FLDS REPEATED FOR EACH DIM *
*           *                                    *
*           +------------------------------------+
*           I                ARPRO               I
*           +------------------------------------+
*           /                                    /
*           /                ARVLS               /
*           /                                    /
*           +------------------------------------+
{{EJC{{{{{2563
*
*      ARRAY BLOCK (CONTINUED)
*
{ARTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_ART{2567
{ARLEN{EQU{24,IDVAL+1{{{LENGTH OF ARBLK IN BYTES{2568
{AROFS{EQU{24,ARLEN+1{{{OFFSET IN ARBLK TO ARPRO FIELD{2569
{ARNDM{EQU{24,AROFS+1{{{NUMBER OF DIMENSIONS{2570
{ARLBD{EQU{24,ARNDM+1{{{LOW BOUND (FIRST SUBSCRIPT){2571
{ARDIM{EQU{24,ARLBD+CFP_I{{{DIMENSION (FIRST SUBSCRIPT){2572
{ARLB2{EQU{24,ARDIM+CFP_I{{{LOW BOUND (SECOND SUBSCRIPT){2573
{ARDM2{EQU{24,ARLB2+CFP_I{{{DIMENSION (SECOND SUBSCRIPT){2574
{ARPRO{EQU{24,ARDIM+CFP_I{{{ARRAY PROTOTYPE (ONE DIMENSION){2575
{ARVLS{EQU{24,ARPRO+1{{{START OF VALUES (ONE DIMENSION){2576
{ARPR2{EQU{24,ARDM2+CFP_I{{{ARRAY PROTOTYPE (TWO DIMENSIONS){2577
{ARVL2{EQU{24,ARPR2+1{{{START OF VALUES (TWO DIMENSIONS){2578
{ARSI_{EQU{24,ARLBD{{{NUMBER OF STANDARD FIELDS IN BLOCK{2579
{ARDMS{EQU{24,ARLB2-ARLBD{{{SIZE OF INFO FOR ONE SET OF BOUNDS{2580
*
*      THE BOUNDS AND DIMENSION FIELDS ARE SIGNED INTEGER
*      VALUES AND EACH OCCUPY CFP_I WORDS IN THE ARBLK.
*
*      THE LENGTH OF AN ARBLK IN BYTES MAY NOT EXCEED MXLEN.
*      THIS IS REQUIRED TO KEEP NAME OFFSETS GARBAGE COLLECTABLE
*
*      THE ACTUAL VALUES ARE ARRANGED IN ROW-WISE ORDER AND
*      CAN CONTAIN A DATA POINTER OR A POINTER TO A TRBLK.
{{EJC{{{{{2666
*
*      CODE CONSTRUCTION BLOCK (CCBLK)
*
*      AT ANY ONE MOMENT THERE IS AT MOST ONE CCBLK INTO
*      WHICH THE COMPILER IS CURRENTLY STORING CODE (CDWRD).
*
*           +------------------------------------+
*           I                CCTYP               I
*           +------------------------------------+
*           I                CCLEN               I
*           +------------------------------------+
*           I                CCSLN               I
*           +------------------------------------+
*           I                CCUSE               I
*           +------------------------------------+
*           /                                    /
*           /                CCCOD               /
*           /                                    /
*           +------------------------------------+
*
{CCTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_CCT{2689
{CCLEN{EQU{24,CCTYP+1{{{LENGTH OF CCBLK IN BYTES{2690
{CCSLN{EQU{24,CCLEN+1{{{SOURCE LINE NUMBER{2692
{CCUSE{EQU{24,CCSLN+1{{{OFFSET PAST LAST USED WORD (BYTES){2693
{CCCOD{EQU{24,CCUSE+1{{{START OF GENERATED CODE IN BLOCK{2697
*
*      THE REASON THAT THE CCBLK IS A SEPARATE BLOCK TYPE FROM
*      THE USUAL CDBLK IS THAT THE GARBAGE COLLECTOR MUST
*      ONLY PROCESS THOSE FIELDS WHICH HAVE BEEN SET (SEE GBCPF)
{{EJC{{{{{2702
*
*      CODE BLOCK (CDBLK)
*
*      A CODE BLOCK IS BUILT FOR EACH STATEMENT COMPILED DURING
*      THE INITIAL COMPILATION OR BY SUBSEQUENT CALLS TO CODE.
*
*           +------------------------------------+
*           I                CDJMP               I
*           +------------------------------------+
*           I                CDSTM               I
*           +------------------------------------+
*           I                CDSLN               I
*           +------------------------------------+
*           I                CDLEN               I
*           +------------------------------------+
*           I                CDFAL               I
*           +------------------------------------+
*           /                                    /
*           /                CDCOD               /
*           /                                    /
*           +------------------------------------+
*
{CDJMP{EQU{24,0{{{PTR TO ROUTINE TO EXECUTE STATEMENT{2727
{CDSTM{EQU{24,CDJMP+1{{{STATEMENT NUMBER{2728
{CDSLN{EQU{24,CDSTM+1{{{SOURCE LINE NUMBER{2730
{CDLEN{EQU{24,CDSLN+1{{{LENGTH OF CDBLK IN BYTES{2731
{CDFAL{EQU{24,CDLEN+1{{{FAILURE EXIT (SEE BELOW){2732
{CDCOD{EQU{24,CDFAL+1{{{EXECUTABLE PSEUDO-CODE{2737
{CDSI_{EQU{24,CDCOD{{{NUMBER OF STANDARD FIELDS IN CDBLK{2738
*
*      CDSTM IS THE STATEMENT NUMBER OF THE CURRENT STATEMENT.
*
*      CDJMP, CDFAL ARE SET AS FOLLOWS.
*
*      1)   IF THE FAILURE EXIT IS THE NEXT STATEMENT
*
*           CDJMP = B_CDS
*           CDFAL = PTR TO CDBLK FOR NEXT STATEMENT
*
*      2)   IF THE FAILURE EXIT IS A SIMPLE LABEL NAME
*
*           CDJMP = B_CDS
*           CDFAL IS A PTR TO THE VRTRA FIELD OF THE VRBLK
*
*      3)   IF THERE IS NO FAILURE EXIT (-NOFAIL MODE)
*
*           CDJMP = B_CDS
*           CDFAL = O_UNF
*
*      4)   IF THE FAILURE EXIT IS COMPLEX OR DIRECT
*
*           CDJMP = B_CDC
*           CDFAL IS THE OFFSET TO THE O_GOF WORD
{{EJC{{{{{2763
*
*      CODE BLOCK (CONTINUED)
*
*      CDCOD IS THE START OF THE ACTUAL CODE. FIRST WE DESCRIBE
*      THE CODE GENERATED FOR AN EXPRESSION. IN AN EXPRESSION,
*      ELEMENTS ARE FETCHED BY NAME OR BY VALUE. FOR EXAMPLE,
*      THE BINARY EQUAL OPERATOR FETCHES ITS LEFT ARGUMENT
*      BY NAME AND ITS RIGHT ARGUMENT BY VALUE. THESE TWO
*      CASES GENERATE QUITE DIFFERENT CODE AND ARE DESCRIBED
*      SEPARATELY. FIRST WE CONSIDER THE CODE BY VALUE CASE.
*
*      GENERATION OF CODE BY VALUE FOR EXPRESSIONS ELEMENTS.
*
*      EXPRESSION            POINTER TO EXBLK OR SEBLK
*
*      INTEGER CONSTANT      POINTER TO ICBLK
*
*      NULL CONSTANT         POINTER TO NULLS
*
*      PATTERN               (RESULTING FROM PREEVALUATION)
*                            =O_LPT
*                            POINTER TO P0BLK,P1BLK OR P2BLK
*
*      REAL CONSTANT         POINTER TO RCBLK
*
*      STRING CONSTANT       POINTER TO SCBLK
*
*      VARIABLE              POINTER TO VRGET FIELD OF VRBLK
*
*      ADDITION              VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O_ADD
*
*      AFFIRMATION           VALUE CODE FOR OPERAND
*                            =O_AFF
*
*      ALTERNATION           VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O_ALT
*
*      ARRAY REFERENCE       (CASE OF ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR SUBSCRIPT OPERAND
*                            =O_AOV
*
*                            (CASE OF MORE THAN ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR FIRST SUBSCRIPT
*                            VALUE CODE FOR SECOND SUBSCRIPT
*                            ...
*                            VALUE CODE FOR LAST SUBSCRIPT
*                            =O_AMV
*                            NUMBER OF SUBSCRIPTS
{{EJC{{{{{2817
*
*      CODE BLOCK (CONTINUED)
*
*      ASSIGNMENT            (TO NATURAL VARIABLE)
*                            VALUE CODE FOR RIGHT OPERAND
*                            POINTER TO VRSTO FIELD OF VRBLK
*
*                            (TO ANY OTHER VARIABLE)
*                            NAME CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O_ASS
*
*      COMPILE ERROR         =O_CER
*
*
*      COMPLEMENTATION       VALUE CODE FOR OPERAND
*                            =O_COM
*
*      CONCATENATION         (CASE OF PRED FUNC LEFT OPERAND)
*                            VALUE CODE FOR LEFT OPERAND
*                            =O_POP
*                            VALUE CODE FOR RIGHT OPERAND
*
*                            (ALL OTHER CASES)
*                            VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O_CNC
*
*      CURSOR ASSIGNMENT     NAME CODE FOR OPERAND
*                            =O_CAS
*
*      DIVISION              VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O_DVD
*
*      EXPONENTIATION        VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O_EXP
*
*      FUNCTION CALL         (CASE OF CALL TO SYSTEM FUNCTION)
*                            VALUE CODE FOR FIRST ARGUMENT
*                            VALUE CODE FOR SECOND ARGUMENT
*                            ...
*                            VALUE CODE FOR LAST ARGUMENT
*                            POINTER TO SVFNC FIELD OF SVBLK
*
{{EJC{{{{{2864
*
*      CODE BLOCK (CONTINUED)
*
*      FUNCTION CALL         (CASE OF NON-SYSTEM FUNCTION 1 ARG)
*                            VALUE CODE FOR ARGUMENT
*                            =O_FNS
*                            POINTER TO VRBLK FOR FUNCTION
*
*                            (NON-SYSTEM FUNCTION, GT 1 ARG)
*                            VALUE CODE FOR FIRST ARGUMENT
*                            VALUE CODE FOR SECOND ARGUMENT
*                            ...
*                            VALUE CODE FOR LAST ARGUMENT
*                            =O_FNC
*                            NUMBER OF ARGUMENTS
*                            POINTER TO VRBLK FOR FUNCTION
*
*      IMMEDIATE ASSIGNMENT  VALUE CODE FOR LEFT OPERAND
*                            NAME CODE FOR RIGHT OPERAND
*                            =O_IMA
*
*      INDIRECTION           VALUE CODE FOR OPERAND
*                            =O_INV
*
*      INTERROGATION         VALUE CODE FOR OPERAND
*                            =O_INT
*
*      KEYWORD REFERENCE     NAME CODE FOR OPERAND
*                            =O_KWV
*
*      MULTIPLICATION        VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O_MLT
*
*      NAME REFERENCE        (NATURAL VARIABLE CASE)
*                            POINTER TO NMBLK FOR NAME
*
*                            (ALL OTHER CASES)
*                            NAME CODE FOR OPERAND
*                            =O_NAM
*
*      NEGATION              =O_NTA
*                            CDBLK OFFSET OF O_NTC WORD
*                            VALUE CODE FOR OPERAND
*                            =O_NTB
*                            =O_NTC
{{EJC{{{{{2911
*
*      CODE BLOCK (CONTINUED)
*
*      PATTERN ASSIGNMENT    VALUE CODE FOR LEFT OPERAND
*                            NAME CODE FOR RIGHT OPERAND
*                            =O_PAS
*
*      PATTERN MATCH         VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O_PMV
*
*      PATTERN REPLACEMENT   NAME CODE FOR SUBJECT
*                            VALUE CODE FOR PATTERN
*                            =O_PMN
*                            VALUE CODE FOR REPLACEMENT
*                            =O_RPL
*
*      SELECTION             (FOR FIRST ALTERNATIVE)
*                            =O_SLA
*                            CDBLK OFFSET TO NEXT O_SLC WORD
*                            VALUE CODE FOR FIRST ALTERNATIVE
*                            =O_SLB
*                            CDBLK OFFSET PAST ALTERNATIVES
*
*                            (FOR SUBSEQUENT ALTERNATIVES)
*                            =O_SLC
*                            CDBLK OFFSET TO NEXT O_SLC,O_SLD
*                            VALUE CODE FOR ALTERNATIVE
*                            =O_SLB
*                            OFFSET IN CDBLK PAST ALTERNATIVES
*
*                            (FOR LAST ALTERNATIVE)
*                            =O_SLD
*                            VALUE CODE FOR LAST ALTERNATIVE
*
*      SUBTRACTION           VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O_SUB
{{EJC{{{{{2950
*
*      CODE BLOCK (CONTINUED)
*
*      GENERATION OF CODE BY NAME FOR EXPRESSION ELEMENTS.
*
*      VARIABLE              =O_LVN
*                            POINTER TO VRBLK
*
*      EXPRESSION            (CASE OF *NATURAL VARIABLE)
*                            =O_LVN
*                            POINTER TO VRBLK
*
*                            (ALL OTHER CASES)
*                            =O_LEX
*                            POINTER TO EXBLK
*
*
*      ARRAY REFERENCE       (CASE OF ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR SUBSCRIPT OPERAND
*                            =O_AON
*
*                            (CASE OF MORE THAN ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR FIRST SUBSCRIPT
*                            VALUE CODE FOR SECOND SUBSCRIPT
*                            ...
*                            VALUE CODE FOR LAST SUBSCRIPT
*                            =O_AMN
*                            NUMBER OF SUBSCRIPTS
*
*      COMPILE ERROR         =O_CER
*
*      FUNCTION CALL         (SAME CODE AS FOR VALUE CALL)
*                            =O_FNE
*
*      INDIRECTION           VALUE CODE FOR OPERAND
*                            =O_INN
*
*      KEYWORD REFERENCE     NAME CODE FOR OPERAND
*                            =O_KWN
*
*      ANY OTHER OPERAND IS AN ERROR IN A NAME POSITION
*
*      NOTE THAT IN THIS DESCRIPTION, =O_XXX REFERS TO THE
*      GENERATION OF A WORD CONTAINING THE ADDRESS OF ANOTHER
*      WORD WHICH CONTAINS THE ENTRY POINT ADDRESS O_XXX.
{{EJC{{{{{2998
*
*      CODE BLOCK (CONTINUED)
*
*      NOW WE CONSIDER THE OVERALL STRUCTURE OF THE CODE BLOCK
*      FOR A STATEMENT WITH POSSIBLE GOTO FIELDS.
*
*      FIRST COMES THE CODE FOR THE STATEMENT BODY.
*      THE STATEMENT BODY IS AN EXPRESSION TO BE EVALUATED
*      BY VALUE ALTHOUGH THE VALUE IS NOT ACTUALLY REQUIRED.
*      NORMAL VALUE CODE IS GENERATED FOR THE BODY OF THE
*      STATEMENT EXCEPT IN THE CASE OF A PATTERN MATCH BY
*      VALUE, IN WHICH CASE THE FOLLOWING IS GENERATED.
*
*                            VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O_PMS
*
*      NEXT WE HAVE THE CODE FOR THE SUCCESS GOTO. THERE ARE
*      SEVERAL CASES AS FOLLOWS.
*
*      1)   NO SUCCESS GOTO  PTR TO CDBLK FOR NEXT STATEMENT
*
*      2)   SIMPLE LABEL     PTR TO VRTRA FIELD OF VRBLK
*
*      3)   COMPLEX GOTO     (CODE BY NAME FOR GOTO OPERAND)
*                            =O_GOC
*
*      4)   DIRECT GOTO      (CODE BY VALUE FOR GOTO OPERAND)
*                            =O_GOD
*
*      FOLLOWING THIS WE GENERATE CODE FOR THE FAILURE GOTO IF
*      IT IS DIRECT OR IF IT IS COMPLEX, SIMPLE FAILURE GOTOS
*      HAVING BEEN HANDLED BY AN APPROPRIATE SETTING OF THE
*      CDFAL FIELD OF THE CDBLK. THE GENERATED CODE IS ONE
*      OF THE FOLLOWING.
*
*      1)   COMPLEX FGOTO    =O_FIF
*                            =O_GOF
*                            NAME CODE FOR GOTO OPERAND
*                            =O_GOC
*
*      2)   DIRECT FGOTO     =O_FIF
*                            =O_GOF
*                            VALUE CODE FOR GOTO OPERAND
*                            =O_GOD
*
*      AN OPTIMIZATION OCCURS IF THE SUCCESS AND FAILURE GOTOS
*      ARE IDENTICAL AND EITHER COMPLEX OR DIRECT. IN THIS CASE,
*      NO CODE IS GENERATED FOR THE SUCCESS GOTO AND CONTROL
*      IS ALLOWED TO FALL INTO THE FAILURE GOTO ON SUCCESS.
{{EJC{{{{{3049
*
*      COMPILER BLOCK (CMBLK)
*
*      A COMPILER BLOCK (CMBLK) IS BUILT BY EXPAN TO REPRESENT
*      ONE NODE OF A TREE STRUCTURED EXPRESSION REPRESENTATION.
*
*           +------------------------------------+
*           I                CMIDN               I
*           +------------------------------------+
*           I                CMLEN               I
*           +------------------------------------+
*           I                CMTYP               I
*           +------------------------------------+
*           I                CMOPN               I
*           +------------------------------------+
*           /           CMVLS OR CMROP           /
*           /                                    /
*           /                CMLOP               /
*           /                                    /
*           +------------------------------------+
*
{CMIDN{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_CMT{3071
{CMLEN{EQU{24,CMIDN+1{{{LENGTH OF CMBLK IN BYTES{3072
{CMTYP{EQU{24,CMLEN+1{{{TYPE (C_XXX, SEE LIST BELOW){3073
{CMOPN{EQU{24,CMTYP+1{{{OPERAND POINTER (SEE BELOW){3074
{CMVLS{EQU{24,CMOPN+1{{{OPERAND VALUE POINTERS (SEE BELOW){3075
{CMROP{EQU{24,CMVLS{{{RIGHT (ONLY) OPERATOR OPERAND{3076
{CMLOP{EQU{24,CMVLS+1{{{LEFT OPERATOR OPERAND{3077
{CMSI_{EQU{24,CMVLS{{{NUMBER OF STANDARD FIELDS IN CMBLK{3078
{CMUS_{EQU{24,CMSI_+1{{{SIZE OF UNARY OPERATOR CMBLK{3079
{CMBS_{EQU{24,CMSI_+2{{{SIZE OF BINARY OPERATOR CMBLK{3080
{CMAR1{EQU{24,CMVLS+1{{{ARRAY SUBSCRIPT POINTERS{3081
*
*      THE CMOPN AND CMVLS FIELDS ARE SET AS FOLLOWS
*
*      ARRAY REFERENCE       CMOPN = PTR TO ARRAY OPERAND
*                            CMVLS = PTRS TO SUBSCRIPT OPERANDS
*
*      FUNCTION CALL         CMOPN = PTR TO VRBLK FOR FUNCTION
*                            CMVLS = PTRS TO ARGUMENT OPERANDS
*
*      SELECTION             CMOPN = ZERO
*                            CMVLS = PTRS TO ALTERNATE OPERANDS
*
*      UNARY OPERATOR        CMOPN = PTR TO OPERATOR DVBLK
*                            CMROP = PTR TO OPERAND
*
*      BINARY OPERATOR       CMOPN = PTR TO OPERATOR DVBLK
*                            CMROP = PTR TO RIGHT OPERAND
*                            CMLOP = PTR TO LEFT OPERAND
{{EJC{{{{{3100
*
*      CMTYP IS SET TO INDICATE THE TYPE OF EXPRESSION ELEMENT
*      AS SHOWN BY THE FOLLOWING TABLE OF DEFINITIONS.
*
{C_ARR{EQU{24,0{{{ARRAY REFERENCE{3105
{C_FNC{EQU{24,C_ARR+1{{{FUNCTION CALL{3106
{C_DEF{EQU{24,C_FNC+1{{{DEFERRED EXPRESSION (UNARY *){3107
{C_IND{EQU{24,C_DEF+1{{{INDIRECTION (UNARY _){3108
{C_KEY{EQU{24,C_IND+1{{{KEYWORD REFERENCE (UNARY AMPERSAND){3109
{C_UBO{EQU{24,C_KEY+1{{{UNDEFINED BINARY OPERATOR{3110
{C_UUO{EQU{24,C_UBO+1{{{UNDEFINED UNARY OPERATOR{3111
{C_UO_{EQU{24,C_UUO+1{{{TEST VALUE (=C_UUO+1=C_UBO+2){3112
{C__NM{EQU{24,C_UUO+1{{{NUMBER OF CODES FOR NAME OPERANDS{3113
*
*      THE REMAINING TYPES INDICATE EXPRESSION ELEMENTS WHICH
*      CAN ONLY BE EVALUATED BY VALUE (NOT BY NAME).
*
{C_BVL{EQU{24,C_UUO+1{{{BINARY OP WITH VALUE OPERANDS{3118
{C_UVL{EQU{24,C_BVL+1{{{UNARY OPERATOR WITH VALUE OPERAND{3119
{C_ALT{EQU{24,C_UVL+1{{{ALTERNATION (BINARY BAR){3120
{C_CNC{EQU{24,C_ALT+1{{{CONCATENATION{3121
{C_CNP{EQU{24,C_CNC+1{{{CONCATENATION, NOT PATTERN MATCH{3122
{C_UNM{EQU{24,C_CNP+1{{{UNARY OP WITH NAME OPERAND{3123
{C_BVN{EQU{24,C_UNM+1{{{BINARY OP (OPERANDS BY VALUE, NAME){3124
{C_ASS{EQU{24,C_BVN+1{{{ASSIGNMENT{3125
{C_INT{EQU{24,C_ASS+1{{{INTERROGATION{3126
{C_NEG{EQU{24,C_INT+1{{{NEGATION (UNARY NOT){3127
{C_SEL{EQU{24,C_NEG+1{{{SELECTION{3128
{C_PMT{EQU{24,C_SEL+1{{{PATTERN MATCH{3129
*
{C_PR_{EQU{24,C_BVN{{{LAST PREEVALUABLE CODE{3131
{C__NV{EQU{24,C_PMT+1{{{NUMBER OF DIFFERENT CMBLK TYPES{3132
{{EJC{{{{{3133
*
*      CHARACTER TABLE BLOCK (CTBLK)
*
*      A CHARACTER TABLE BLOCK IS USED TO HOLD LOGICAL CHARACTER
*      TABLES FOR USE WITH ANY,NOTANY,SPAN,BREAK,BREAKX
*      PATTERNS. EACH CHARACTER TABLE CAN BE USED TO STORE
*      CFP_N DISTINCT TABLES AS BIT COLUMNS. A BIT COLUMN
*      ALLOCATED FOR EACH ARGUMENT OF MORE THAN ONE CHARACTER
*      IN LENGTH TO ONE OF THE ABOVE LISTED PATTERN PRIMITIVES.
*
*           +------------------------------------+
*           I                CTTYP               I
*           +------------------------------------+
*           *                                    *
*           *                                    *
*           *                CTCHS               *
*           *                                    *
*           *                                    *
*           +------------------------------------+
*
{CTTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_CTT{3154
{CTCHS{EQU{24,CTTYP+1{{{START OF CHARACTER TABLE WORDS{3155
{CTSI_{EQU{24,CTCHS+CFP_A{{{NUMBER OF WORDS IN CTBLK{3156
*
*      CTCHS IS CFP_A WORDS LONG AND CONSISTS OF A ONE WORD
*      BIT STRING VALUE FOR EACH POSSIBLE CHARACTER IN THE
*      INTERNAL ALPHABET. EACH OF THE CFP_N POSSIBLE BITS IN
*      A BITSTRING IS USED TO FORM A COLUMN OF BIT INDICATORS.
*      A BIT IS SET ON IF THE CHARACTER IS IN THE TABLE AND OFF
*      IF THE CHARACTER IS NOT PRESENT.
{{EJC{{{{{3164
*
*      DATATYPE FUNCTION BLOCK (DFBLK)
*
*      A DATATYPE FUNCTION IS USED TO CONTROL THE CONSTRUCTION
*      OF A PROGRAM DEFINED DATATYPE OBJECT. A CALL TO THE
*      SYSTEM FUNCTION DATA BUILDS A DFBLK FOR THE DATATYPE NAME
*
*      NOTE THAT THESE BLOCKS ARE BUILT IN STATIC BECAUSE PDBLK
*      LENGTH IS GOT FROM DFLEN FIELD.  IF DFBLK WAS IN DYNAMIC
*      STORE THIS WOULD CAUSE TROUBLE DURING PASS TWO OF GARBAGE
*      COLLECTION.  SCBLK REFERRED TO BY DFNAM FIELD IS ALSO PUT
*      IN STATIC SO THAT THERE ARE NO RELOC. FIELDS. THIS CUTS
*      GARBAGE COLLECTION TASK APPRECIABLY FOR PDBLKS WHICH ARE
*      LIKELY TO BE PRESENT IN LARGE NUMBERS.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                DFLEN               I
*           +------------------------------------+
*           I                DFPDL               I
*           +------------------------------------+
*           I                DFNAM               I
*           +------------------------------------+
*           /                                    /
*           /                DFFLD               /
*           /                                    /
*           +------------------------------------+
*
{DFLEN{EQU{24,FARGS+1{{{LENGTH OF DFBLK IN BYTES{3196
{DFPDL{EQU{24,DFLEN+1{{{LENGTH OF CORRESPONDING PDBLK{3197
{DFNAM{EQU{24,DFPDL+1{{{POINTER TO SCBLK FOR DATATYPE NAME{3198
{DFFLD{EQU{24,DFNAM+1{{{START OF VRBLK PTRS FOR FIELD NAMES{3199
{DFFLB{EQU{24,DFFLD-1{{{OFFSET BEHIND DFFLD FOR FIELD FUNC{3200
{DFSI_{EQU{24,DFFLD{{{NUMBER OF STANDARD FIELDS IN DFBLK{3201
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B_DFC
*
*      FARGS (THE NUMBER OF ARGUMENTS) IS THE NUMBER OF FIELDS.
{{EJC{{{{{3206
*
*      DOPE VECTOR BLOCK (DVBLK)
*
*      A DOPE VECTOR IS ASSEMBLED FOR EACH POSSIBLE OPERATOR IN
*      THE SNOBOL4 LANGUAGE AS PART OF THE CONSTANT SECTION.
*
*           +------------------------------------+
*           I                DVOPN               I
*           +------------------------------------+
*           I                DVTYP               I
*           +------------------------------------+
*           I                DVLPR               I
*           +------------------------------------+
*           I                DVRPR               I
*           +------------------------------------+
*
{DVOPN{EQU{24,0{{{ENTRY ADDRESS (PTR TO O_XXX){3223
{DVTYP{EQU{24,DVOPN+1{{{TYPE CODE (C_XXX, SEE CMBLK){3224
{DVLPR{EQU{24,DVTYP+1{{{LEFT PRECEDENCE (LLXXX, SEE BELOW){3225
{DVRPR{EQU{24,DVLPR+1{{{RIGHT PRECEDENCE (RRXXX, SEE BELOW){3226
{DVUS_{EQU{24,DVLPR+1{{{SIZE OF UNARY OPERATOR DV{3227
{DVBS_{EQU{24,DVRPR+1{{{SIZE OF BINARY OPERATOR DV{3228
{DVUBS{EQU{24,DVUS_+DVBS_{{{SIZE OF UNOP + BINOP (SEE SCANE){3229
*
*      THE CONTENTS OF THE DVTYP FIELD IS COPIED INTO THE CMTYP
*      FIELD OF THE CMBLK FOR THE OPERATOR IF IT IS USED.
*
*      THE CMOPN FIELD OF AN OPERATOR CMBLK POINTS TO THE DVBLK
*      ITSELF, PROVIDING THE REQUIRED ENTRY ADDRESS POINTER PTR.
*
*      FOR NORMALLY UNDEFINED OPERATORS, THE DVOPN (AND CMOPN)
*      FIELDS CONTAIN A WORD OFFSET FROM R_UBA OF THE FUNCTION
*      BLOCK POINTER FOR THE OPERATOR (INSTEAD OF O_XXX PTR).
*      FOR CERTAIN SPECIAL OPERATORS, THE DVOPN FIELD IS NOT
*      REQUIRED AT ALL AND IS ASSEMBLED AS ZERO.
*
*      THE LEFT PRECEDENCE IS USED IN COMPARING AN OPERATOR TO
*      THE LEFT OF SOME OTHER OPERATOR. IT THEREFORE GOVERNS THE
*      PRECEDENCE OF THE OPERATOR TOWARDS ITS RIGHT OPERAND.
*
*      THE RIGHT PRECEDENCE IS USED IN COMPARING AN OPERATOR TO
*      THE RIGHT OF SOME OTHER OPERATOR. IT THEREFORE GOVERNS
*      THE PRECEDENCE OF THE OPERATOR TOWARDS ITS LEFT OPERAND.
*
*      HIGHER PRECEDENCE VALUES CORRESPOND TO A TIGHTER BINDING
*      CAPABILITY. THUS WE HAVE THE LEFT PRECEDENCE LOWER
*      (HIGHER) THAN THE RIGHT PRECEDENCE FOR RIGHT (LEFT)
*      ASSOCIATIVE BINARY OPERATORS.
*
*      THE LEFT PRECEDENCE OF UNARY OPERATORS IS SET TO AN
*      ARBITRARY HIGH VALUE. THE RIGHT VALUE IS NOT REQUIRED AND
*      CONSEQUENTLY THE DVRPR FIELD IS OMITTED FOR UNARY OPS.
{{EJC{{{{{3259
*
*      TABLE OF OPERATOR PRECEDENCE VALUES
*
{RRASS{EQU{24,10{{{RIGHT     EQUAL{3263
{LLASS{EQU{24,00{{{LEFT      EQUAL{3264
{RRPMT{EQU{24,20{{{RIGHT     QUESTION MARK{3265
{LLPMT{EQU{24,30{{{LEFT      QUESTION MARK{3266
{RRAMP{EQU{24,40{{{RIGHT     AMPERSAND{3267
{LLAMP{EQU{24,50{{{LEFT      AMPERSAND{3268
{RRALT{EQU{24,70{{{RIGHT     VERTICAL BAR{3269
{LLALT{EQU{24,60{{{LEFT      VERTICAL BAR{3270
{RRCNC{EQU{24,90{{{RIGHT     BLANK{3271
{LLCNC{EQU{24,80{{{LEFT      BLANK{3272
{RRATS{EQU{24,110{{{RIGHT     AT{3273
{LLATS{EQU{24,100{{{LEFT      AT{3274
{RRPLM{EQU{24,120{{{RIGHT     PLUS, MINUS{3275
{LLPLM{EQU{24,130{{{LEFT      PLUS, MINUS{3276
{RRNUM{EQU{24,140{{{RIGHT     NUMBER{3277
{LLNUM{EQU{24,150{{{LEFT      NUMBER{3278
{RRDVD{EQU{24,160{{{RIGHT     SLASH{3279
{LLDVD{EQU{24,170{{{LEFT      SLASH{3280
{RRMLT{EQU{24,180{{{RIGHT     ASTERISK{3281
{LLMLT{EQU{24,190{{{LEFT      ASTERISK{3282
{RRPCT{EQU{24,200{{{RIGHT     PERCENT{3283
{LLPCT{EQU{24,210{{{LEFT      PERCENT{3284
{RREXP{EQU{24,230{{{RIGHT     EXCLAMATION{3285
{LLEXP{EQU{24,220{{{LEFT      EXCLAMATION{3286
{RRDLD{EQU{24,240{{{RIGHT     DOLLAR, DOT{3287
{LLDLD{EQU{24,250{{{LEFT      DOLLAR, DOT{3288
{RRNOT{EQU{24,270{{{RIGHT     NOT{3289
{LLNOT{EQU{24,260{{{LEFT      NOT{3290
{LLUNO{EQU{24,999{{{LEFT      ALL UNARY OPERATORS{3291
*
*      PRECEDENCES ARE THE SAME AS IN BTL SNOBOL4 WITH THE
*      FOLLOWING EXCEPTIONS.
*
*      1)   BINARY QUESTION MARK IS LOWERED AND MADE LEFT ASSOC-
*           IATIVE TO REFLECT ITS NEW USE FOR PATTERN MATCHING.
*
*      2)   ALTERNATION AND CONCATENATION ARE MADE RIGHT
*           ASSOCIATIVE FOR GREATER EFFICIENCY IN PATTERN
*           CONSTRUCTION AND MATCHING RESPECTIVELY. THIS CHANGE
*           IS TRANSPARENT TO THE SNOBOL4 PROGRAMMER.
*
*      3)   THE EQUAL SIGN HAS BEEN ADDED AS A LOW PRECEDENCE
*           OPERATOR WHICH IS RIGHT ASSOCIATIVE TO REFLECT ITS
*           MORE GENERAL USAGE IN THIS VERSION OF SNOBOL4.
{{EJC{{{{{3307
*
*      EXTERNAL FUNCTION BLOCK (EFBLK)
*
*      AN EXTERNAL FUNCTION BLOCK IS USED TO CONTROL THE CALLING
*      OF AN EXTERNAL FUNCTION. IT IS BUILT BY A CALL TO LOAD.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                EFLEN               I
*           +------------------------------------+
*           I                EFUSE               I
*           +------------------------------------+
*           I                EFCOD               I
*           +------------------------------------+
*           I                EFVAR               I
*           +------------------------------------+
*           I                EFRSL               I
*           +------------------------------------+
*           /                                    /
*           /                EFTAR               /
*           /                                    /
*           +------------------------------------+
*
{EFLEN{EQU{24,FARGS+1{{{LENGTH OF EFBLK IN BYTES{3334
{EFUSE{EQU{24,EFLEN+1{{{USE COUNT (FOR OPSYN){3335
{EFCOD{EQU{24,EFUSE+1{{{PTR TO CODE (FROM SYSLD){3336
{EFVAR{EQU{24,EFCOD+1{{{PTR TO ASSOCIATED VRBLK{3337
{EFRSL{EQU{24,EFVAR+1{{{RESULT TYPE (SEE BELOW){3338
{EFTAR{EQU{24,EFRSL+1{{{ARGUMENT TYPES (SEE BELOW){3339
{EFSI_{EQU{24,EFTAR{{{NUMBER OF STANDARD FIELDS IN EFBLK{3340
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B_EFC.
*
*      EFUSE IS USED TO KEEP TRACK OF MULTIPLE USE WHEN OPSYN
*      IS EMPLOYED. THE FUNCTION IS AUTOMATICALLY UNLOADED
*      WHEN THERE ARE NO MORE REFERENCES TO THE FUNCTION.
*
*      EFRSL AND EFTAR ARE TYPE CODES AS FOLLOWS.
*
*           0                TYPE IS UNCONVERTED
*           1                TYPE IS STRING
*           2                TYPE IS INTEGER
*           3                TYPE IS REAL
*           4                TYPE IS FILE
{{EJC{{{{{3363
*
*      EXPRESSION VARIABLE BLOCK (EVBLK)
*
*      IN THIS VERSION OF SPITBOL, AN EXPRESSION CAN BE USED IN
*      ANY POSITION WHICH WOULD NORMALLY EXPECT A NAME (FOR
*      EXAMPLE ON THE LEFT SIDE OF EQUALS OR AS THE RIGHT
*      ARGUMENT OF BINARY DOT). THIS CORRESPONDS TO THE CREATION
*      OF A PSEUDO-VARIABLE WHICH IS REPRESENTED BY A POINTER TO
*      AN EXPRESSION VARIABLE BLOCK AS FOLLOWS.
*
*           +------------------------------------+
*           I                EVTYP               I
*           +------------------------------------+
*           I                EVEXP               I
*           +------------------------------------+
*           I                EVVAR               I
*           +------------------------------------+
*
{EVTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_EVT{3382
{EVEXP{EQU{24,EVTYP+1{{{POINTER TO EXBLK FOR EXPRESSION{3383
{EVVAR{EQU{24,EVEXP+1{{{POINTER TO TRBEV DUMMY TRBLK{3384
{EVSI_{EQU{24,EVVAR+1{{{SIZE OF EVBLK{3385
*
*      THE NAME OF AN EXPRESSION VARIABLE IS REPRESENTED BY A
*      BASE POINTER TO THE EVBLK AND AN OFFSET OF EVVAR. THIS
*      VALUE APPEARS TO BE TRAPPED BY THE DUMMY TRBEV BLOCK.
*
*      NOTE THAT THERE IS NO NEED TO ALLOW FOR THE CASE OF AN
*      EXPRESSION VARIABLE WHICH REFERENCES AN SEBLK SINCE A
*      VARIABLE WHICH IS OF THE FORM *VAR IS EQUIVALENT TO VAR.
{{EJC{{{{{3394
*
*      EXPRESSION BLOCK (EXBLK)
*
*      AN EXPRESSION BLOCK IS BUILT FOR EACH EXPRESSION
*      REFERENCED IN A PROGRAM OR CREATED BY EVAL OR CONVERT
*      DURING EXECUTION OF A PROGRAM.
*
*           +------------------------------------+
*           I                EXTYP               I
*           +------------------------------------+
*           I                EXSTM               I
*           +------------------------------------+
*           I                EXSLN               I
*           +------------------------------------+
*           I                EXLEN               I
*           +------------------------------------+
*           I                EXFLC               I
*           +------------------------------------+
*           /                                    /
*           /                EXCOD               /
*           /                                    /
*           +------------------------------------+
*
{EXTYP{EQU{24,0{{{PTR TO ROUTINE B_EXL TO LOAD EXPR{3420
{EXSTM{EQU{24,CDSTM{{{STORES STMNT NO. DURING EVALUATION{3421
{EXSLN{EQU{24,EXSTM+1{{{STORES LINE NO. DURING EVALUATION{3423
{EXLEN{EQU{24,EXSLN+1{{{LENGTH OF EXBLK IN BYTES{3424
{EXFLC{EQU{24,EXLEN+1{{{FAILURE CODE (=O_FEX){3428
{EXCOD{EQU{24,EXFLC+1{{{PSEUDO-CODE FOR EXPRESSION{3429
{EXSI_{EQU{24,EXCOD{{{NUMBER OF STANDARD FIELDS IN EXBLK{3430
*
*      THERE ARE TWO CASES FOR EXCOD DEPENDING ON WHETHER THE
*      EXPRESSION CAN BE EVALUATED BY NAME (SEE DESCRIPTION
*      OF CDBLK FOR DETAILS OF CODE FOR EXPRESSIONS).
*
*      IF THE EXPRESSION CAN BE EVALUATED BY NAME WE HAVE.
*
*                            (CODE FOR EXPR BY NAME)
*                            =O_RNM
*
*      IF THE EXPRESSION CAN ONLY BE EVALUATED BY VALUE.
*
*                            (CODE FOR EXPR BY VALUE)
*                            =O_RVL
{{EJC{{{{{3445
*
*      FIELD FUNCTION BLOCK (FFBLK)
*
*      A FIELD FUNCTION BLOCK IS USED TO CONTROL THE SELECTION
*      OF A FIELD FROM A PROGRAM DEFINED DATATYPE BLOCK.
*      A CALL TO DATA CREATES AN FFBLK FOR EACH FIELD.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                FFDFP               I
*           +------------------------------------+
*           I                FFNXT               I
*           +------------------------------------+
*           I                FFOFS               I
*           +------------------------------------+
*
{FFDFP{EQU{24,FARGS+1{{{POINTER TO ASSOCIATED DFBLK{3465
{FFNXT{EQU{24,FFDFP+1{{{PTR TO NEXT FFBLK ON CHAIN OR ZERO{3466
{FFOFS{EQU{24,FFNXT+1{{{OFFSET (BYTES) TO FIELD IN PDBLK{3467
{FFSI_{EQU{24,FFOFS+1{{{SIZE OF FFBLK IN WORDS{3468
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B_FFC.
*
*      FARGS ALWAYS CONTAINS ONE.
*
*      FFDFP IS USED TO VERIFY THAT THE CORRECT PROGRAM DEFINED
*      DATATYPE IS BEING ACCESSED BY THIS CALL.
*      FFDFP IS NON-RELOC. BECAUSE DFBLK IS IN STATIC
*
*      FFOFS IS USED TO SELECT THE APPROPRIATE FIELD. NOTE THAT
*      IT IS AN ACTUAL OFFSET (NOT A FIELD NUMBER)
*
*      FFNXT IS USED TO POINT TO THE NEXT FFBLK OF THE SAME NAME
*      IN THE CASE WHERE THERE ARE SEVERAL FIELDS OF THE SAME
*      NAME FOR DIFFERENT DATATYPES. ZERO MARKS THE END OF CHAIN
{{EJC{{{{{3484
*
*      INTEGER CONSTANT BLOCK (ICBLK)
*
*      AN ICBLK IS CREATED FOR EVERY INTEGER REFERENCED OR
*      CREATED BY A PROGRAM. NOTE HOWEVER THAT CERTAIN INTERNAL
*      INTEGER VALUES ARE STORED AS ADDRESSES (E.G. THE LENGTH
*      FIELD IN A STRING CONSTANT BLOCK)
*
*           +------------------------------------+
*           I                ICGET               I
*           +------------------------------------+
*           *                ICVAL               *
*           +------------------------------------+
*
{ICGET{EQU{24,0{{{PTR TO ROUTINE B_ICL TO LOAD INT{3499
{ICVAL{EQU{24,ICGET+1{{{INTEGER VALUE{3500
{ICSI_{EQU{24,ICVAL+CFP_I{{{SIZE OF ICBLK{3501
*
*      THE LENGTH OF THE ICVAL FIELD IS CFP_I.
{{EJC{{{{{3504
*
*      KEYWORD VARIABLE BLOCK (KVBLK)
*
*      A KVBLK IS USED TO REPRESENT A KEYWORD PSEUDO-VARIABLE.
*      A KVBLK IS BUILT FOR EACH KEYWORD REFERENCE (KWNAM).
*
*           +------------------------------------+
*           I                KVTYP               I
*           +------------------------------------+
*           I                KVVAR               I
*           +------------------------------------+
*           I                KVNUM               I
*           +------------------------------------+
*
{KVTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_KVT{3519
{KVVAR{EQU{24,KVTYP+1{{{POINTER TO DUMMY BLOCK TRBKV{3520
{KVNUM{EQU{24,KVVAR+1{{{KEYWORD NUMBER{3521
{KVSI_{EQU{24,KVNUM+1{{{SIZE OF KVBLK{3522
*
*      THE NAME OF A KEYWORD VARIABLE IS REPRESENTED BY A
*      BASE POINTER TO THE KVBLK AND AN OFFSET OF KVVAR. THE
*      VALUE APPEARS TO BE TRAPPED BY THE POINTER TO TRBKV.
{{EJC{{{{{3527
*
*      NAME BLOCK (NMBLK)
*
*      A NAME BLOCK IS USED WHEREVER A NAME MUST BE STORED AS
*      A VALUE FOLLOWING USE OF THE UNARY DOT OPERATOR.
*
*           +------------------------------------+
*           I                NMTYP               I
*           +------------------------------------+
*           I                NMBAS               I
*           +------------------------------------+
*           I                NMOFS               I
*           +------------------------------------+
*
{NMTYP{EQU{24,0{{{PTR TO ROUTINE B_NML TO LOAD NAME{3542
{NMBAS{EQU{24,NMTYP+1{{{BASE POINTER FOR VARIABLE{3543
{NMOFS{EQU{24,NMBAS+1{{{OFFSET FOR VARIABLE{3544
{NMSI_{EQU{24,NMOFS+1{{{SIZE OF NMBLK{3545
*
*      THE ACTUAL FIELD REPRESENTING THE CONTENTS OF THE NAME
*      IS FOUND NMOFS BYTES PAST THE ADDRESS IN NMBAS.
*
*      THE NAME IS SPLIT INTO BASE AND OFFSET FORM TO AVOID
*      CREATION OF A POINTER INTO THE MIDDLE OF A BLOCK WHICH
*      COULD NOT BE HANDLED PROPERLY BY THE GARBAGE COLLECTOR.
*
*      A NAME MAY BE BUILT FOR ANY VARIABLE (SEE SECTION ON
*      REPRESENTATIONS OF VARIABLES) THIS INCLUDES THE
*      CASES OF PSEUDO-VARIABLES.
{{EJC{{{{{3557
*
*      PATTERN BLOCK, NO PARAMETERS (P0BLK)
*
*      A P0BLK IS USED TO REPRESENT PATTERN NODES WHICH DO
*      NOT REQUIRE THE USE OF ANY PARAMETER VALUES.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*
{PCODE{EQU{24,0{{{PTR TO MATCH ROUTINE (P_XXX){3570
{PTHEN{EQU{24,PCODE+1{{{POINTER TO SUBSEQUENT NODE{3571
{PASI_{EQU{24,PTHEN+1{{{SIZE OF P0BLK{3572
*
*      PTHEN POINTS TO THE PATTERN BLOCK FOR THE SUBSEQUENT
*      NODE TO BE MATCHED. THIS IS A POINTER TO THE PATTERN
*      BLOCK NDNTH IF THERE IS NO SUBSEQUENT (END OF PATTERN)
*
*      PCODE IS A POINTER TO THE MATCH ROUTINE FOR THE NODE.
{{EJC{{{{{3579
*
*      PATTERN BLOCK (ONE PARAMETER)
*
*      A P1BLK IS USED TO REPRESENT PATTERN NODES WHICH
*      REQUIRE ONE PARAMETER VALUE.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*
{PARM1{EQU{24,PTHEN+1{{{FIRST PARAMETER VALUE{3594
{PBSI_{EQU{24,PARM1+1{{{SIZE OF P1BLK IN WORDS{3595
*
*      SEE P0BLK FOR DEFINITIONS OF PCODE, PTHEN
*
*      PARM1 CONTAINS A PARAMETER VALUE USED IN MATCHING THE
*      NODE. FOR EXAMPLE, IN A LEN PATTERN, IT IS THE INTEGER
*      ARGUMENT TO LEN. THE DETAILS OF THE USE OF THE PARAMETER
*      FIELD ARE INCLUDED IN THE DESCRIPTION OF THE INDIVIDUAL
*      MATCH ROUTINES. PARM1 IS ALWAYS AN ADDRESS POINTER WHICH
*      IS PROCESSED BY THE GARBAGE COLLECTOR.
{{EJC{{{{{3605
*
*      PATTERN BLOCK (TWO PARAMETERS)
*
*      A P2BLK IS USED TO REPRESENT PATTERN NODES WHICH
*      REQUIRE TWO PARAMETER VALUES.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*           I                PARM2               I
*           +------------------------------------+
*
{PARM2{EQU{24,PARM1+1{{{SECOND PARAMETER VALUE{3622
{PCSI_{EQU{24,PARM2+1{{{SIZE OF P2BLK IN WORDS{3623
*
*      SEE P1BLK FOR DEFINITIONS OF PCODE, PTHEN, PARM1
*
*      PARM2 IS A PARAMETER WHICH PERFORMS THE SAME SORT OF
*      FUNCTION AS PARM1 (SEE DESCRIPTION OF P1BLK).
*
*      PARM2 IS A NON-RELOCATABLE FIELD AND IS NOT
*      PROCESSED BY THE GARBAGE COLLECTOR. ACCORDINGLY, IT MAY
*      NOT CONTAIN A POINTER TO A BLOCK IN DYNAMIC MEMORY.
{{EJC{{{{{3633
*
*      PROGRAM-DEFINED DATATYPE BLOCK
*
*      A PDBLK REPRESENTS THE DATA ITEM FORMED BY A CALL TO A
*      DATATYPE FUNCTION AS DEFINED BY THE SYSTEM FUNCTION DATA.
*
*           +------------------------------------+
*           I                PDTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                PDDFP               I
*           +------------------------------------+
*           /                                    /
*           /                PDFLD               /
*           /                                    /
*           +------------------------------------+
*
{PDTYP{EQU{24,0{{{PTR TO DUMMY ROUTINE B_PDT{3652
{PDDFP{EQU{24,IDVAL+1{{{PTR TO ASSOCIATED DFBLK{3653
{PDFLD{EQU{24,PDDFP+1{{{START OF FIELD VALUE POINTERS{3654
{PDFOF{EQU{24,DFFLD-PDFLD{{{DIFFERENCE IN OFFSET TO FIELD PTRS{3655
{PDSI_{EQU{24,PDFLD{{{SIZE OF STANDARD FIELDS IN PDBLK{3656
{PDDFS{EQU{24,DFSI_-PDSI_{{{DIFFERENCE IN DFBLK, PDBLK SIZES{3657
*
*      THE PDDFP POINTER MAY BE USED TO DETERMINE THE DATATYPE
*      AND THE NAMES OF THE FIELDS IF REQUIRED. THE DFBLK ALSO
*      CONTAINS THE LENGTH OF THE PDBLK IN BYTES (FIELD DFPDL).
*      PDDFP IS NON-RELOC. BECAUSE DFBLK IS IN STATIC
*
*      PDFLD VALUES ARE STORED IN ORDER FROM LEFT TO RIGHT.
*      THEY CONTAIN VALUES OR POINTERS TO TRBLK CHAINS.
{{EJC{{{{{3666
*
*      PROGRAM DEFINED FUNCTION BLOCK (PFBLK)
*
*      A PFBLK IS CREATED FOR EACH CALL TO THE DEFINE FUNCTION
*      AND A POINTER TO THE PFBLK PLACED IN THE PROPER VRBLK.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                PFLEN               I
*           +------------------------------------+
*           I                PFVBL               I
*           +------------------------------------+
*           I                PFNLO               I
*           +------------------------------------+
*           I                PFCOD               I
*           +------------------------------------+
*           I                PFCTR               I
*           +------------------------------------+
*           I                PFRTR               I
*           +------------------------------------+
*           /                                    /
*           /                PFARG               /
*           /                                    /
*           +------------------------------------+
*
{PFLEN{EQU{24,FARGS+1{{{LENGTH OF PFBLK IN BYTES{3695
{PFVBL{EQU{24,PFLEN+1{{{POINTER TO VRBLK FOR FUNCTION NAME{3696
{PFNLO{EQU{24,PFVBL+1{{{NUMBER OF LOCALS{3697
{PFCOD{EQU{24,PFNLO+1{{{PTR TO VRBLK FOR ENTRY LABEL{3698
{PFCTR{EQU{24,PFCOD+1{{{TRBLK PTR IF CALL TRACED ELSE 0{3699
{PFRTR{EQU{24,PFCTR+1{{{TRBLK PTR IF RETURN TRACED ELSE 0{3700
{PFARG{EQU{24,PFRTR+1{{{VRBLK PTRS FOR ARGUMENTS AND LOCALS{3701
{PFAGB{EQU{24,PFARG-1{{{OFFSET BEHIND PFARG FOR ARG, LOCAL{3702
{PFSI_{EQU{24,PFARG{{{NUMBER OF STANDARD FIELDS IN PFBLK{3703
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B_PFC.
*
*      PFARG IS STORED IN THE FOLLOWING ORDER.
*
*           ARGUMENTS (LEFT TO RIGHT)
*           LOCALS (LEFT TO RIGHT)
{{EJC{{{{{3713
*
*      REAL CONSTANT BLOCK (RCBLK)
*
*      AN RCBLK IS CREATED FOR EVERY REAL REFERENCED OR
*      CREATED BY A PROGRAM.
*
*           +------------------------------------+
*           I                RCGET               I
*           +------------------------------------+
*           *                RCVAL               *
*           +------------------------------------+
*
{RCGET{EQU{24,0{{{PTR TO ROUTINE B_RCL TO LOAD REAL{3726
{RCVAL{EQU{24,RCGET+1{{{REAL VALUE{3727
{RCSI_{EQU{24,RCVAL+CFP_R{{{SIZE OF RCBLK{3728
*
*      THE LENGTH OF THE RCVAL FIELD IS CFP_R.
{{EJC{{{{{3732
*
*      STRING CONSTANT BLOCK (SCBLK)
*
*      AN SCBLK IS BUILT FOR EVERY STRING REFERENCED OR CREATED
*      BY A PROGRAM.
*
*           +------------------------------------+
*           I                SCGET               I
*           +------------------------------------+
*           I                SCLEN               I
*           +------------------------------------+
*           /                                    /
*           /                SCHAR               /
*           /                                    /
*           +------------------------------------+
*
{SCGET{EQU{24,0{{{PTR TO ROUTINE B_SCL TO LOAD STRING{3749
{SCLEN{EQU{24,SCGET+1{{{LENGTH OF STRING IN CHARACTERS{3750
{SCHAR{EQU{24,SCLEN+1{{{CHARACTERS OF STRING{3751
{SCSI_{EQU{24,SCHAR{{{SIZE OF STANDARD FIELDS IN SCBLK{3752
*
*      THE CHARACTERS OF THE STRING ARE STORED LEFT JUSTIFIED.
*      THE FINAL WORD IS PADDED ON THE RIGHT WITH ZEROS.
*      (I.E. THE CHARACTER WHOSE INTERNAL CODE IS ZERO).
*
*      THE VALUE OF SCLEN MAY NOT EXCEED MXLEN. THIS ENSURES
*      THAT CHARACTER OFFSETS (E.G. THE PATTERN MATCH CURSOR)
*      CAN BE CORRECTLY PROCESSED BY THE GARBAGE COLLECTOR.
*
*      NOTE THAT THE OFFSET TO THE CHARACTERS OF THE STRING
*      IS GIVEN IN BYTES BY CFP_F AND THAT THIS VALUE IS
*      AUTOMATICALLY ALLOWED FOR IN PLC, PSC.
*      NOTE THAT FOR A SPITBOL SCBLK, THE VALUE OF CFP_F
*      IS GIVEN BY CFP_B*SCHAR.
{{EJC{{{{{3767
*
*      SIMPLE EXPRESSION BLOCK (SEBLK)
*
*      AN SEBLK IS USED TO REPRESENT AN EXPRESSION OF THE FORM
*      *(NATURAL VARIABLE). ALL OTHER EXPRESSIONS ARE EXBLKS.
*
*           +------------------------------------+
*           I                SETYP               I
*           +------------------------------------+
*           I                SEVAR               I
*           +------------------------------------+
*
{SETYP{EQU{24,0{{{PTR TO ROUTINE B_SEL TO LOAD EXPR{3780
{SEVAR{EQU{24,SETYP+1{{{PTR TO VRBLK FOR VARIABLE{3781
{SESI_{EQU{24,SEVAR+1{{{LENGTH OF SEBLK IN WORDS{3782
{{EJC{{{{{3783
*
*      STANDARD VARIABLE BLOCK (SVBLK)
*
*      AN SVBLK IS ASSEMBLED IN THE CONSTANT SECTION FOR EACH
*      VARIABLE WHICH SATISFIES ONE OF THE FOLLOWING CONDITIONS.
*
*      1)   IT IS THE NAME OF A SYSTEM FUNCTION
*      2)   IT HAS AN INITIAL VALUE
*      3)   IT HAS A KEYWORD ASSOCIATION
*      4)   IT HAS A STANDARD I/O ASSOCIATION
*      6)   IT HAS A STANDARD LABEL ASSOCIATION
*
*      IF VRBLKS ARE CONSTRUCTED FOR ANY OF THESE VARIABLES,
*      THEN THE VRSVP FIELD POINTS TO THE SVBLK (SEE VRBLK)
*
*           +------------------------------------+
*           I                SVBIT               I
*           +------------------------------------+
*           I                SVLEN               I
*           +------------------------------------+
*           /                SVCHS               /
*           +------------------------------------+
*           I                SVKNM               I
*           +------------------------------------+
*           I                SVFNC               I
*           +------------------------------------+
*           I                SVNAR               I
*           +------------------------------------+
*           I                SVLBL               I
*           +------------------------------------+
*           I                SVVAL               I
*           +------------------------------------+
{{EJC{{{{{3816
*
*      STANDARD VARIABLE BLOCK (CONTINUED)
*
{SVBIT{EQU{24,0{{{BIT STRING INDICATING ATTRIBUTES{3820
{SVLEN{EQU{24,1{{{(=SCLEN) LENGTH OF NAME IN CHARS{3821
{SVCHS{EQU{24,2{{{(=SCHAR) CHARACTERS OF NAME{3822
{SVSI_{EQU{24,2{{{NUMBER OF STANDARD FIELDS IN SVBLK{3823
{SVPRE{EQU{24,1{{{SET IF PREEVALUATION PERMITTED{3824
{SVFFC{EQU{24,SVPRE+SVPRE{{{SET ON IF FAST CALL PERMITTED{3825
{SVCKW{EQU{24,SVFFC+SVFFC{{{SET ON IF KEYWORD VALUE CONSTANT{3826
{SVPRD{EQU{24,SVCKW+SVCKW{{{SET ON IF PREDICATE FUNCTION{3827
{SVNBT{EQU{24,4{{{NUMBER OF BITS TO RIGHT OF SVKNM{3828
{SVKNM{EQU{24,SVPRD+SVPRD{{{SET ON IF KEYWORD ASSOCIATION{3829
{SVFNC{EQU{24,SVKNM+SVKNM{{{SET ON IF SYSTEM FUNCTION{3830
{SVNAR{EQU{24,SVFNC+SVFNC{{{SET ON IF SYSTEM FUNCTION{3831
{SVLBL{EQU{24,SVNAR+SVNAR{{{SET ON IF SYSTEM LABEL{3832
{SVVAL{EQU{24,SVLBL+SVLBL{{{SET ON IF PREDEFINED VALUE{3833
*
*      NOTE THAT THE LAST FIVE BITS CORRESPOND IN ORDER
*      TO THE FIELDS WHICH ARE PRESENT (SEE PROCEDURE GTNVR).
*
*      THE FOLLOWING DEFINITIONS ARE USED IN THE SVBLK TABLE
*
{SVFNF{EQU{24,SVFNC+SVNAR{{{FUNCTION WITH NO FAST CALL{3840
{SVFNN{EQU{24,SVFNF+SVFFC{{{FUNCTION WITH FAST CALL, NO PREEVAL{3841
{SVFNP{EQU{24,SVFNN+SVPRE{{{FUNCTION ALLOWING PREEVALUATION{3842
{SVFPR{EQU{24,SVFNN+SVPRD{{{PREDICATE FUNCTION{3843
{SVFNK{EQU{24,SVFNN+SVKNM{{{NO PREEVAL FUNC + KEYWORD{3844
{SVKWV{EQU{24,SVKNM+SVVAL{{{KEYWORD + VALUE{3845
{SVKWC{EQU{24,SVCKW+SVKNM{{{KEYWORD WITH CONSTANT VALUE{3846
{SVKVC{EQU{24,SVKWV+SVCKW{{{CONSTANT KEYWORD + VALUE{3847
{SVKVL{EQU{24,SVKVC+SVLBL{{{CONSTANT KEYWORD + VALUE + LABEL{3848
{SVFPK{EQU{24,SVFNP+SVKVC{{{PREEVAL FCN + CONST KEYWD + VAL{3849
*
*      THE SVPRE BIT ALLOWS THE COMPILER TO PREEVALUATE A CALL
*      TO THE ASSOCIATED SYSTEM FUNCTION IF ALL THE ARGUMENTS
*      ARE THEMSELVES CONSTANTS. FUNCTIONS IN THIS CATEGORY
*      MUST HAVE NO SIDE EFFECTS AND MUST NEVER CAUSE FAILURE.
*      THE CALL MAY GENERATE AN ERROR CONDITION.
*
*      THE SVFFC BIT ALLOWS THE COMPILER TO GENERATE THE SPECIAL
*      FAST CALL AFTER ADJUSTING THE NUMBER OF ARGUMENTS. ONLY
*      THE ITEM AND APPLY FUNCTIONS FALL OUTSIDE THIS CATEGORY.
*
*      THE SVCKW BIT IS SET IF THE ASSOCIATED KEYWORD VALUE IS
*      A CONSTANT, THUS ALLOWING PREEVALUATION FOR A VALUE CALL.
*
*      THE SVPRD BIT IS SET ON FOR ALL PREDICATE FUNCTIONS TO
*      ENABLE THE SPECIAL CONCATENATION CODE OPTIMIZATION.
{{EJC{{{{{3866
*
*      SVBLK (CONTINUED)
*
*      SVKNM                 KEYWORD NUMBER
*
*           SVKNM IS PRESENT ONLY FOR A STANDARD KEYWORD ASSOC.
*           IT CONTAINS A KEYWORD NUMBER AS DEFINED BY THE
*           KEYWORD NUMBER TABLE GIVEN LATER ON.
*
*      SVFNC                 SYSTEM FUNCTION POINTER
*
*           SVFNC IS PRESENT ONLY FOR A SYSTEM FUNCTION ASSOC.
*           IT IS A POINTER TO THE ACTUAL CODE FOR THE SYSTEM
*           FUNCTION. THE GENERATED CODE FOR A FAST CALL IS A
*           POINTER TO THE SVFNC FIELD OF THE SVBLK FOR THE
*           FUNCTION. THE VRFNC FIELD OF THE VRBLK POINTS TO
*           THIS SAME FIELD, IN WHICH CASE, IT SERVES AS THE
*           FCODE FIELD FOR THE FUNCTION CALL.
*
*      SVNAR                 NUMBER OF FUNCTION ARGUMENTS
*
*           SVNAR IS PRESENT ONLY FOR A SYSTEM FUNCTION ASSOC.
*           IT IS THE NUMBER OF ARGUMENTS REQUIRED FOR A CALL
*           TO THE SYSTEM FUNCTION. THE COMPILER USES THIS
*           VALUE TO ADJUST THE NUMBER OF ARGUMENTS IN A FAST
*           CALL AND IN THE CASE OF A FUNCTION CALLED THROUGH
*           THE VRFNC FIELD OF THE VRBLK, THE SVNAR FIELD
*           SERVES AS THE FARGS FIELD FOR O_FNC. A SPECIAL
*           CASE OCCURS IF THIS VALUE IS SET TO 999. THIS IS
*           USED TO INDICATE THAT THE FUNCTION HAS A VARIABLE
*           NUMBER OF ARGUMENTS AND CAUSES O_FNC TO PASS CONTROL
*           WITHOUT ADJUSTING THE ARGUMENT COUNT. THE ONLY
*           PREDEFINED FUNCTIONS USING THIS ARE APPLY AND ITEM.
*
*      SVLBL                 SYSTEM LABEL POINTER
*
*           SVLBL IS PRESENT ONLY FOR A STANDARD LABEL ASSOC.
*           IT IS A POINTER TO A SYSTEM LABEL ROUTINE (L_XXX).
*           THE VRLBL FIELD OF THE CORRESPONDING VRBLK POINTS TO
*           THE SVLBL FIELD OF THE SVBLK.
*
*      SVVAL                 SYSTEM VALUE POINTER
*
*           SVVAL IS PRESENT ONLY FOR A STANDARD VALUE.
*           IT IS A POINTER TO THE PATTERN NODE (NDXXX) WHICH
*           IS THE STANDARD INITIAL VALUE OF THE VARIABLE.
*           THIS VALUE IS COPIED TO THE VRVAL FIELD OF THE VRBLK
{{EJC{{{{{3914
*
*      SVBLK (CONTINUED)
*
*      KEYWORD NUMBER TABLE
*
*      THE FOLLOWING TABLE GIVES SYMBOLIC NAMES FOR KEYWORD
*      NUMBERS. THESE VALUES ARE STORED IN THE SVKNM FIELD OF
*      SVBLKS AND IN THE KVNUM FIELD OF KVBLKS. SEE ALSO
*      PROCEDURES ASIGN, ACESS AND KWNAM.
*
*      UNPROTECTED KEYWORDS WITH ONE WORD INTEGER VALUES
*
{K_ABE{EQU{24,0{{{ABEND{3927
{K_ANC{EQU{24,K_ABE+CFP_B{{{ANCHOR{3928
{K_CAS{EQU{24,K_ANC+CFP_B{{{CASE{3930
{K_COD{EQU{24,K_CAS+CFP_B{{{CODE{3931
{K_COM{EQU{24,K_COD+CFP_B{{{COMPARE{3936
{K_DMP{EQU{24,K_COM+CFP_B{{{DUMP{3937
{K_ERL{EQU{24,K_DMP+CFP_B{{{ERRLIMIT{3941
{K_ERT{EQU{24,K_ERL+CFP_B{{{ERRTYPE{3942
{K_FTR{EQU{24,K_ERT+CFP_B{{{FTRACE{3943
{K_FLS{EQU{24,K_FTR+CFP_B{{{FULLSCAN{3944
{K_INP{EQU{24,K_FLS+CFP_B{{{INPUT{3945
{K_MXL{EQU{24,K_INP+CFP_B{{{MAXLENGTH{3946
{K_OUP{EQU{24,K_MXL+CFP_B{{{OUTPUT{3947
{K_PFL{EQU{24,K_OUP+CFP_B{{{PROFILE{3951
{K_TRA{EQU{24,K_PFL+CFP_B{{{TRACE{3952
{K_TRM{EQU{24,K_TRA+CFP_B{{{TRIM{3954
*
*      PROTECTED KEYWORDS WITH ONE WORD INTEGER VALUES
*
{K_FNC{EQU{24,K_TRM+CFP_B{{{FNCLEVEL{3958
{K_LST{EQU{24,K_FNC+CFP_B{{{LASTNO{3959
{K_LLN{EQU{24,K_LST+CFP_B{{{LASTLINE{3961
{K_LIN{EQU{24,K_LLN+CFP_B{{{LINE{3962
{K_STN{EQU{24,K_LIN+CFP_B{{{STNO{3963
*
*      KEYWORDS WITH CONSTANT PATTERN VALUES
*
{K_ABO{EQU{24,K_STN+CFP_B{{{ABORT{3970
{K_ARB{EQU{24,K_ABO+PASI_{{{ARB{3971
{K_BAL{EQU{24,K_ARB+PASI_{{{BAL{3972
{K_FAL{EQU{24,K_BAL+PASI_{{{FAIL{3973
{K_FEN{EQU{24,K_FAL+PASI_{{{FENCE{3974
{K_REM{EQU{24,K_FEN+PASI_{{{REM{3975
{K_SUC{EQU{24,K_REM+PASI_{{{SUCCEED{3976
{{EJC{{{{{3977
*
*      KEYWORD NUMBER TABLE (CONTINUED)
*
*      SPECIAL KEYWORDS
*
{K_ALP{EQU{24,K_SUC+1{{{ALPHABET{3983
{K_RTN{EQU{24,K_ALP+1{{{RTNTYPE{3984
{K_STC{EQU{24,K_RTN+1{{{STCOUNT{3985
{K_ETX{EQU{24,K_STC+1{{{ERRTEXT{3986
{K_FIL{EQU{24,K_ETX+1{{{FILE{3988
{K_LFL{EQU{24,K_FIL+1{{{LASTFILE{3989
{K_STL{EQU{24,K_LFL+1{{{STLIMIT{3990
{K_LCS{EQU{24,K_STL+1{{{LCASE{3995
{K_UCS{EQU{24,K_LCS+1{{{UCASE{3996
*
*      RELATIVE OFFSETS OF SPECIAL KEYWORDS
*
{K__AL{EQU{24,K_ALP-K_ALP{{{ALPHABET{4001
{K__RT{EQU{24,K_RTN-K_ALP{{{RTNTYPE{4002
{K__SC{EQU{24,K_STC-K_ALP{{{STCOUNT{4003
{K__ET{EQU{24,K_ETX-K_ALP{{{ERRTEXT{4004
{K__FL{EQU{24,K_FIL-K_ALP{{{FILE{4006
{K__LF{EQU{24,K_LFL-K_ALP{{{LASTFILE{4007
{K__SL{EQU{24,K_STL-K_ALP{{{STLIMIT{4009
{K__LC{EQU{24,K_LCS-K_ALP{{{LCASE{4011
{K__UC{EQU{24,K_UCS-K_ALP{{{UCASE{4012
{K__N_{EQU{24,K__UC+1{{{NUMBER OF SPECIAL CASES{4013
*
*      SYMBOLS USED IN ASIGN AND ACESS PROCEDURES
*
{K_P__{EQU{24,K_FNC{{{FIRST PROTECTED KEYWORD{4020
{K_V__{EQU{24,K_ABO{{{FIRST KEYWORD WITH CONSTANT VALUE{4021
{K_S__{EQU{24,K_ALP{{{FIRST KEYWORD WITH SPECIAL ACESS{4022
{{EJC{{{{{4023
*
*      FORMAT OF A TABLE BLOCK (TBBLK)
*
*      A TABLE BLOCK IS USED TO REPRESENT A TABLE VALUE.
*      IT IS BUILT BY A CALL TO THE TABLE OR CONVERT FUNCTIONS.
*
*           +------------------------------------+
*           I                TBTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                TBLEN               I
*           +------------------------------------+
*           I                TBINV               I
*           +------------------------------------+
*           /                                    /
*           /                TBBUK               /
*           /                                    /
*           +------------------------------------+
*
{TBTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_TBT{4044
{TBLEN{EQU{24,OFFS2{{{LENGTH OF TBBLK IN BYTES{4045
{TBINV{EQU{24,OFFS3{{{DEFAULT INITIAL LOOKUP VALUE{4046
{TBBUK{EQU{24,TBINV+1{{{START OF HASH BUCKET POINTERS{4047
{TBSI_{EQU{24,TBBUK{{{SIZE OF STANDARD FIELDS IN TBBLK{4048
{TBNBK{EQU{24,11{{{DEFAULT NO. OF BUCKETS{4049
*
*      THE TABLE BLOCK IS A HASH TABLE WHICH POINTS TO CHAINS
*      OF TABLE ELEMENT BLOCKS REPRESENTING THE ELEMENTS
*      IN THE TABLE WHICH HASH INTO THE SAME BUCKET.
*
*      TBBUK ENTRIES EITHER POINT TO THE FIRST TEBLK ON THE
*      CHAIN OR THEY POINT TO THE TBBLK ITSELF TO INDICATE THE
*      END OF THE CHAIN.
{{EJC{{{{{4058
*
*      TABLE ELEMENT BLOCK (TEBLK)
*
*      A TABLE ELEMENT IS USED TO REPRESENT A SINGLE ENTRY IN
*      A TABLE (SEE DESCRIPTION OF TBBLK FORMAT FOR HASH TABLE)
*
*           +------------------------------------+
*           I                TETYP               I
*           +------------------------------------+
*           I                TESUB               I
*           +------------------------------------+
*           I                TEVAL               I
*           +------------------------------------+
*           I                TENXT               I
*           +------------------------------------+
*
{TETYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_TET{4075
{TESUB{EQU{24,TETYP+1{{{SUBSCRIPT VALUE{4076
{TEVAL{EQU{24,TESUB+1{{{(=VRVAL) TABLE ELEMENT VALUE{4077
{TENXT{EQU{24,TEVAL+1{{{LINK TO NEXT TEBLK{4078
*      SEE S_CNV WHERE RELATION IS ASSUMED WITH TENXT AND TBBUK
{TESI_{EQU{24,TENXT+1{{{SIZE OF TEBLK IN WORDS{4080
*
*      TENXT POINTS TO THE NEXT TEBLK ON THE HASH CHAIN FROM THE
*      TBBUK CHAIN FOR THIS HASH INDEX. AT THE END OF THE CHAIN,
*      TENXT POINTS BACK TO THE START OF THE TBBLK.
*
*      TEVAL CONTAINS A DATA POINTER OR A TRBLK POINTER.
*
*      TESUB CONTAINS A DATA POINTER.
{{EJC{{{{{4089
*
*      TRAP BLOCK (TRBLK)
*
*      A TRAP BLOCK IS USED TO REPRESENT A TRACE OR INPUT OR
*      OUTPUT ASSOCIATION IN RESPONSE TO A CALL TO THE TRACE
*      INPUT OR OUTPUT SYSTEM FUNCTIONS. SEE BELOW FOR DETAILS
*
*           +------------------------------------+
*           I                TRIDN               I
*           +------------------------------------+
*           I                TRTYP               I
*           +------------------------------------+
*           I  TRVAL OR TRLBL OR TRNXT OR TRKVR  I
*           +------------------------------------+
*           I       TRTAG OR TRTER OR TRTRF      I
*           +------------------------------------+
*           I            TRFNC OR TRFPT          I
*           +------------------------------------+
*
{TRIDN{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_TRT{4109
{TRTYP{EQU{24,TRIDN+1{{{TRAP TYPE CODE{4110
{TRVAL{EQU{24,TRTYP+1{{{VALUE OF TRAPPED VARIABLE (=VRVAL){4111
{TRNXT{EQU{24,TRVAL{{{PTR TO NEXT TRBLK ON TRBLK CHAIN{4112
{TRLBL{EQU{24,TRVAL{{{PTR TO ACTUAL LABEL (TRACED LABEL){4113
{TRKVR{EQU{24,TRVAL{{{VRBLK POINTER FOR KEYWORD TRACE{4114
{TRTAG{EQU{24,TRVAL+1{{{TRACE TAG{4115
{TRTER{EQU{24,TRTAG{{{PTR TO TERMINAL VRBLK OR NULL{4116
{TRTRF{EQU{24,TRTAG{{{PTR TO TRBLK HOLDING FCBLK PTR{4117
{TRFNC{EQU{24,TRTAG+1{{{TRACE FUNCTION VRBLK (ZERO IF NONE){4118
{TRFPT{EQU{24,TRFNC{{{FCBLK PTR FOR SYSIO{4119
{TRSI_{EQU{24,TRFNC+1{{{NUMBER OF WORDS IN TRBLK{4120
*
{TRTIN{EQU{24,0{{{TRACE TYPE FOR INPUT ASSOCIATION{4122
{TRTAC{EQU{24,TRTIN+1{{{TRACE TYPE FOR ACCESS TRACE{4123
{TRTVL{EQU{24,TRTAC+1{{{TRACE TYPE FOR VALUE TRACE{4124
{TRTOU{EQU{24,TRTVL+1{{{TRACE TYPE FOR OUTPUT ASSOCIATION{4125
{TRTFC{EQU{24,TRTOU+1{{{TRACE TYPE FOR FCBLK IDENTIFICATION{4126
{{EJC{{{{{4127
*
*      TRAP BLOCK (CONTINUED)
*
*      VARIABLE INPUT ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B_VRA AND =B_VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTIN
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTER IS A POINTER TO SVBLK IF ASSOCIATION IS
*           FOR INPUT, TERMINAL, ELSE IT IS NULL.
*           TRTRF POINTS TO THE TRAP BLOCK WHICH IN TURN POINTS
*           TO AN FCBLK USED FOR I/O ASSOCIATION.
*           TRFPT IS THE FCBLK PTR RETURNED BY SYSIO.
*
*      VARIABLE ACCESS TRACE ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B_VRA AND =B_VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTAC
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      VARIABLE VALUE TRACE ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B_VRA AND =B_VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTVL
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
{{EJC{{{{{4169
*      TRAP BLOCK (CONTINUED)
*
*      VARIABLE OUTPUT ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B_VRA AND =B_VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTOU
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTER IS A POINTER TO SVBLK IF ASSOCIATION IS
*           FOR OUTPUT, TERMINAL, ELSE IT IS NULL.
*           TRTRF POINTS TO THE TRAP BLOCK WHICH IN TURN POINTS
*           TO AN FCBLK USED FOR I/O ASSOCIATION.
*           TRFPT IS THE FCBLK PTR RETURNED BY SYSIO.
*
*      FUNCTION CALL TRACE
*
*           THE PFCTR FIELD OF THE CORRESPONDING PFBLK IS SET
*           TO POINT TO A TRBLK.
*
*           TRTYP IS SET TO TRTIN
*           TRNXT IS ZERO
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      FUNCTION RETURN TRACE
*
*           THE PFRTR FIELD OF THE CORRESPONDING PFBLK IS SET
*           TO POINT TO A TRBLK
*
*           TRTYP IS SET TO TRTIN
*           TRNXT IS ZERO
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      LABEL TRACE
*
*           THE VRLBL OF THE VRBLK FOR THE LABEL IS
*           CHANGED TO POINT TO A TRBLK AND THE VRTRA FIELD IS
*           SET TO B_VRT TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTIN
*           TRLBL POINTS TO THE ACTUAL LABEL (CDBLK) VALUE
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
{{EJC{{{{{4217
*
*      TRAP BLOCK (CONTINUED)
*
*      KEYWORD TRACE
*
*           KEYWORDS WHICH CAN BE TRACED POSSESS A UNIQUE
*           LOCATION WHICH IS ZERO IF THERE IS NO TRACE AND
*           POINTS TO A TRBLK IF THERE IS A TRACE. THE LOCATIONS
*           ARE AS FOLLOWS.
*
*           R_ERT            ERRTYPE
*           R_FNC            FNCLEVEL
*           R_STC            STCOUNT
*
*           THE FORMAT OF THE TRBLK IS AS FOLLOWS.
*
*           TRTYP IS SET TO TRTIN
*           TRKVR IS A POINTER TO THE VRBLK FOR THE KEYWORD
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      INPUT/OUTPUT FILE ARG1 TRAP BLOCK
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE OF
*           A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B_VRA AND =B_VRV. THIS TRAP BLOCK IS USED
*           TO HOLD A POINTER TO THE FCBLK WHICH AN
*           IMPLEMENTATION MAY REQUEST TO HOLD INFORMATION
*           ABOUT A FILE.
*
*           TRTYP IS SET TO TRTFC
*           TRNEXT POINTS TO NEXT TRBLK OR TRVAL IS VARIABLE VAL
*           TRFNM IS 0
*           TRFPT IS THE FCBLK POINTER.
*
*      NOTE THAT WHEN MULTIPLE TRAPS ARE SET ON A VARIABLE
*      THE ORDER IS IN ASCENDING VALUE OF TRTYP FIELD.
*
*      INPUT ASSOCIATION (IF PRESENT)
*      ACCESS TRACE (IF PRESENT)
*      VALUE TRACE (IF PRESENT)
*      OUTPUT ASSOCIATION (IF PRESENT)
*
*      THE ACTUAL VALUE OF THE VARIABLE IS STORED IN THE TRVAL
*      FIELD OF THE LAST TRBLK ON THE CHAIN.
*
*      THIS IMPLEMENTATION DOES NOT PERMIT TRACE OR I/O
*      ASSOCIATIONS TO ANY OF THE PSEUDO-VARIABLES.
{{EJC{{{{{4267
*
*      VECTOR BLOCK (VCBLK)
*
*      A VCBLK IS USED TO REPRESENT AN ARRAY VALUE WHICH HAS
*      ONE DIMENSION WHOSE LOWER BOUND IS ONE. ALL OTHER ARRAYS
*      ARE REPRESENTED BY ARBLKS. A VCBLK IS CREATED BY THE
*      SYSTEM FUNCTION ARRAY (S_ARR) WHEN PASSED AN INTEGER ARG.
*
*           +------------------------------------+
*           I                VCTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                VCLEN               I
*           +------------------------------------+
*           I                VCVLS               I
*           +------------------------------------+
*
{VCTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_VCT{4286
{VCLEN{EQU{24,OFFS2{{{LENGTH OF VCBLK IN BYTES{4287
{VCVLS{EQU{24,OFFS3{{{START OF VECTOR VALUES{4288
{VCSI_{EQU{24,VCVLS{{{SIZE OF STANDARD FIELDS IN VCBLK{4289
{VCVLB{EQU{24,VCVLS-1{{{OFFSET ONE WORD BEHIND VCVLS{4290
{VCTBD{EQU{24,TBSI_-VCSI_{{{DIFFERENCE IN SIZES - SEE PRTVL{4291
*
*      VCVLS ARE EITHER DATA POINTERS OR TRBLK POINTERS
*
*      THE DIMENSION CAN BE DEDUCED FROM VCLEN.
{{EJC{{{{{4296
*
*      VARIABLE BLOCK (VRBLK)
*
*      A VARIABLE BLOCK IS BUILT IN THE STATIC MEMORY AREA
*      FOR EVERY VARIABLE REFERENCED OR CREATED BY A PROGRAM.
*      THE ORDER OF FIELDS IS ASSUMED IN THE MODEL VRBLK STNVR.
*
*      NOTE THAT SINCE THESE BLOCKS ONLY OCCUR IN THE STATIC
*      REGION, IT IS PERMISSIBLE TO POINT TO ANY WORD IN
*      THE BLOCK AND THIS IS USED TO PROVIDE THREE DISTINCT
*      ACCESS POINTS FROM THE GENERATED CODE AS FOLLOWS.
*
*      1)   POINT TO VRGET (FIRST WORD OF VRBLK) TO LOAD THE
*           VALUE OF THE VARIABLE ONTO THE MAIN STACK.
*
*      2)   POINT TO VRSTO (SECOND WORD OF VRBLK) TO STORE THE
*           TOP STACK ELEMENT AS THE VALUE OF THE VARIABLE.
*
*      3)   POINT TO VRTRA (FOURTH WORD OF VRBLK) TO JUMP TO
*           THE LABEL ASSOCIATED WITH THE VARIABLE NAME.
*
*           +------------------------------------+
*           I                VRGET               I
*           +------------------------------------+
*           I                VRSTO               I
*           +------------------------------------+
*           I                VRVAL               I
*           +------------------------------------+
*           I                VRTRA               I
*           +------------------------------------+
*           I                VRLBL               I
*           +------------------------------------+
*           I                VRFNC               I
*           +------------------------------------+
*           I                VRNXT               I
*           +------------------------------------+
*           I                VRLEN               I
*           +------------------------------------+
*           /                                    /
*           /            VRCHS = VRSVP           /
*           /                                    /
*           +------------------------------------+
{{EJC{{{{{4339
*
*      VARIABLE BLOCK (CONTINUED)
*
{VRGET{EQU{24,0{{{POINTER TO ROUTINE TO LOAD VALUE{4343
{VRSTO{EQU{24,VRGET+1{{{POINTER TO ROUTINE TO STORE VALUE{4344
{VRVAL{EQU{24,VRSTO+1{{{VARIABLE VALUE{4345
{VRVLO{EQU{24,VRVAL-VRSTO{{{OFFSET TO VALUE FROM STORE FIELD{4346
{VRTRA{EQU{24,VRVAL+1{{{POINTER TO ROUTINE TO JUMP TO LABEL{4347
{VRLBL{EQU{24,VRTRA+1{{{POINTER TO CODE FOR LABEL{4348
{VRLBO{EQU{24,VRLBL-VRTRA{{{OFFSET TO LABEL FROM TRANSFER FIELD{4349
{VRFNC{EQU{24,VRLBL+1{{{POINTER TO FUNCTION BLOCK{4350
{VRNXT{EQU{24,VRFNC+1{{{POINTER TO NEXT VRBLK ON HASH CHAIN{4351
{VRLEN{EQU{24,VRNXT+1{{{LENGTH OF NAME (OR ZERO){4352
{VRCHS{EQU{24,VRLEN+1{{{CHARACTERS OF NAME (VRLEN GT 0){4353
{VRSVP{EQU{24,VRLEN+1{{{PTR TO SVBLK (VRLEN EQ 0){4354
{VRSI_{EQU{24,VRCHS+1{{{NUMBER OF STANDARD FIELDS IN VRBLK{4355
{VRSOF{EQU{24,VRLEN-SCLEN{{{OFFSET TO DUMMY SCBLK FOR NAME{4356
{VRSVO{EQU{24,VRSVP-VRSOF{{{PSEUDO-OFFSET TO VRSVP FIELD{4357
*
*      VRGET = B_VRL IF NOT INPUT ASSOCIATED OR ACCESS TRACED
*      VRGET = B_VRA IF INPUT ASSOCIATED OR ACCESS TRACED
*
*      VRSTO = B_VRS IF NOT OUTPUT ASSOCIATED OR VALUE TRACED
*      VRSTO = B_VRV IF OUTPUT ASSOCIATED OR VALUE TRACED
*      VRSTO = B_VRE IF VALUE IS PROTECTED PATTERN VALUE
*
*      VRVAL POINTS TO THE APPROPRIATE VALUE UNLESS THE
*      VARIABLE IS I/O/TRACE ASSOCIATED IN WHICH CASE, VRVAL
*      POINTS TO AN APPROPRIATE TRBLK (TRAP BLOCK) CHAIN.
*
*      VRTRA = B_VRG IF THE LABEL IS NOT TRACED
*      VRTRA = B_VRT IF THE LABEL IS TRACED
*
*      VRLBL POINTS TO A CDBLK IF THERE IS A LABEL
*      VRLBL POINTS TO THE SVBLK SVLBL FIELD FOR A SYSTEM LABEL
*      VRLBL POINTS TO STNDL FOR AN UNDEFINED LABEL
*      VRLBL POINTS TO A TRBLK IF THE LABEL IS TRACED
*
*      VRFNC POINTS TO A FFBLK FOR A FIELD FUNCTION
*      VRFNC POINTS TO A DFBLK FOR A DATATYPE FUNCTION
*      VRFNC POINTS TO A PFBLK FOR A PROGRAM DEFINED FUNCTION
*      VRFNC POINTS TO A EFBLK FOR AN EXTERNAL LOADED FUNCTION
*      VRFNC POINTS TO SVFNC (SVBLK) FOR A SYSTEM FUNCTION
*      VRFNC POINTS TO STNDF IF THE FUNCTION IS UNDEFINED
*
*      VRNXT POINTS TO THE NEXT VRBLK ON THIS CHAIN UNLESS
*      THIS IS THE END OF THE CHAIN IN WHICH CASE IT IS ZERO.
*
*      VRLEN IS THE NAME LENGTH FOR A NON-SYSTEM VARIABLE.
*      VRLEN IS ZERO FOR A SYSTEM VARIABLE.
*
*      VRCHS IS THE NAME (LJRZ) IF VRLEN IS NON-ZERO.
*      VRSVP IS A PTR TO THE SVBLK IF VRLEN IS ZERO.
{{EJC{{{{{4393
*
*      FORMAT OF A NON-RELOCATABLE EXTERNAL BLOCK (XNBLK)
*
*      AN XNBLK IS A BLOCK REPRESENTING AN UNKNOWN (EXTERNAL)
*      DATA VALUE. THE BLOCK CONTAINS NO POINTERS TO OTHER
*      RELOCATABLE BLOCKS. AN XNBLK IS USED BY EXTERNAL FUNCTION
*      PROCESSING OR POSSIBLY FOR SYSTEM I/O ROUTINES ETC.
*      THE MACRO-SYSTEM ITSELF DOES NOT USE XNBLKS.
*      THIS TYPE OF BLOCK MAY BE USED AS A FILE CONTROL BLOCK.
*      SEE SYSFC,SYSIN,SYSOU,S_INP,S_OUP FOR DETAILS.
*
*           +------------------------------------+
*           I                XNTYP               I
*           +------------------------------------+
*           I                XNLEN               I
*           +------------------------------------+
*           /                                    /
*           /                XNDTA               /
*           /                                    /
*           +------------------------------------+
*
{XNTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_XNT{4415
{XNLEN{EQU{24,XNTYP+1{{{LENGTH OF XNBLK IN BYTES{4416
{XNDTA{EQU{24,XNLEN+1{{{DATA WORDS{4417
{XNSI_{EQU{24,XNDTA{{{SIZE OF STANDARD FIELDS IN XNBLK{4418
*
*      NOTE THAT THE TERM NON-RELOCATABLE REFERS TO THE CONTENTS
*      AND NOT THE BLOCK ITSELF. AN XNBLK CAN BE MOVED AROUND IF
*      IT IS BUILT IN THE DYNAMIC MEMORY AREA.
{{EJC{{{{{4423
*
*      RELOCATABLE EXTERNAL BLOCK (XRBLK)
*
*      AN XRBLK IS A BLOCK REPRESENTING AN UNKNOWN (EXTERNAL)
*      DATA VALUE. THE DATA AREA IN THIS BLOCK CONSISTS ONLY
*      OF ADDRESS VALUES AND ANY ADDRESSES POINTING INTO THE
*      DYNAMIC MEMORY AREA MUST POINT TO THE START OF OTHER
*      DATA BLOCKS. SEE ALSO DESCRIPTION OF XNBLK.
*      THIS TYPE OF BLOCK MAY BE USED AS A FILE CONTROL BLOCK.
*      SEE SYSFC,SYSIN,SYSOU,S_INP,S_OUP FOR DETAILS.
*
*           +------------------------------------+
*           I                XRTYP               I
*           +------------------------------------+
*           I                XRLEN               I
*           +------------------------------------+
*           /                                    /
*           /                XRPTR               /
*           /                                    /
*           +------------------------------------+
*
{XRTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B_XRT{4445
{XRLEN{EQU{24,XRTYP+1{{{LENGTH OF XRBLK IN BYTES{4446
{XRPTR{EQU{24,XRLEN+1{{{START OF ADDRESS POINTERS{4447
{XRSI_{EQU{24,XRPTR{{{SIZE OF STANDARD FIELDS IN XRBLK{4448
{{EJC{{{{{4449
*
*      S_CNV (CONVERT) FUNCTION SWITCH CONSTANTS.  THE VALUES
*      ARE TIED TO THE ORDER OF THE ENTRIES IN THE SVCTB TABLE
*      AND HENCE TO THE BRANCH TABLE IN S_CNV.
*
{CNVST{EQU{24,8{{{MAX STANDARD TYPE CODE FOR CONVERT{4455
{CNVRT{EQU{24,CNVST+1{{{CONVERT CODE FOR REALS{4459
{CNVBT{EQU{24,CNVRT{{{NO BUFFERS - SAME AS REAL CODE{4462
{CNVTT{EQU{24,CNVBT+1{{{BSW CODE FOR CONVERT{4466
*
*      INPUT IMAGE LENGTH
*
{INILN{EQU{24,1024{{{DEFAULT IMAGE LENGTH FOR COMPILER{4470
{INILS{EQU{24,1024{{{IMAGE LENGTH IF -SEQU IN EFFECT{4471
*
{IONMB{EQU{24,2{{{NAME BASE USED FOR IOCHN IN SYSIO{4473
{IONMO{EQU{24,4{{{NAME OFFSET USED FOR IOCHN IN SYSIO{4474
*
*      MINIMUM VALUE FOR KEYWORD MAXLNGTH
*      SHOULD BE LARGER THAN INILN
*
{MNLEN{EQU{24,1024{{{MIN VALUE ALLOWED KEYWORD MAXLNGTH{4479
{MXERN{EQU{24,329{{{ERR NUM INADEQUATE STARTUP MEMORY{4480
*
*      IN GENERAL, MEANINGFUL MNEMONICS SHOULD BE USED FOR
*      OFFSETS. HOWEVER FOR SMALL INTEGERS USED OFTEN IN
*      LITERALS THE FOLLOWING GENERAL DEFINITIONS ARE PROVIDED.
*
{NUM01{EQU{24,1{{{{4486
{NUM02{EQU{24,2{{{{4487
{NUM03{EQU{24,3{{{{4488
{NUM04{EQU{24,4{{{{4489
{NUM05{EQU{24,5{{{{4490
{NUM06{EQU{24,6{{{{4491
{NUM07{EQU{24,7{{{{4492
{NUM08{EQU{24,8{{{{4493
{NUM09{EQU{24,9{{{{4494
{NUM10{EQU{24,10{{{{4495
{NUM25{EQU{24,25{{{{4496
{NM320{EQU{24,320{{{{4497
{NM321{EQU{24,321{{{{4498
{NINI8{EQU{24,998{{{{4499
{NINI9{EQU{24,999{{{{4500
{THSND{EQU{24,1000{{{{4501
{{EJC{{{{{4502
*
*      NUMBERS OF UNDEFINED SPITBOL OPERATORS
*
{OPBUN{EQU{24,5{{{NO. OF BINARY UNDEFINED OPS{4506
{OPUUN{EQU{24,6{{{NO OF UNARY UNDEFINED OPS{4507
*
*      OFFSETS USED IN PRTSN, PRTMI AND ACESS
*
{PRSNF{EQU{24,13{{{OFFSET USED IN PRTSN{4511
{PRTMF{EQU{24,21{{{OFFSET TO COL 21 (PRTMI){4512
{RILEN{EQU{24,1024{{{BUFFER LENGTH FOR SYSRI{4513
*
*      CODES FOR STAGES OF PROCESSING
*
{STGIC{EQU{24,0{{{INITIAL COMPILE{4517
{STGXC{EQU{24,STGIC+1{{{EXECUTION COMPILE (CODE){4518
{STGEV{EQU{24,STGXC+1{{{EXPRESSION EVAL DURING EXECUTION{4519
{STGXT{EQU{24,STGEV+1{{{EXECUTION TIME{4520
{STGCE{EQU{24,STGXT+1{{{INITIAL COMPILE AFTER END LINE{4521
{STGXE{EQU{24,STGCE+1{{{EXEC. COMPILE AFTER END LINE{4522
{STGND{EQU{24,STGCE-STGIC{{{DIFFERENCE IN STAGE AFTER END{4523
{STGEE{EQU{24,STGXE+1{{{EVAL EVALUATING EXPRESSION{4524
{STGNO{EQU{24,STGEE+1{{{NUMBER OF CODES{4525
{{EJC{{{{{4526
*
*
*      STATEMENT NUMBER PAD COUNT FOR LISTR
*
{STNPD{EQU{24,8{{{STATEMENT NO. PAD COUNT{4535
*
*      SYNTAX TYPE CODES
*
*      THESE CODES ARE RETURNED FROM THE SCANE PROCEDURE.
*
*      THEY ARE SPACED 3 APART FOR THE BENEFIT OF EXPAN.
*
{T_UOP{EQU{24,0{{{UNARY OPERATOR{4547
{T_LPR{EQU{24,T_UOP+3{{{LEFT PAREN{4548
{T_LBR{EQU{24,T_LPR+3{{{LEFT BRACKET{4549
{T_CMA{EQU{24,T_LBR+3{{{COMMA{4550
{T_FNC{EQU{24,T_CMA+3{{{FUNCTION CALL{4551
{T_VAR{EQU{24,T_FNC+3{{{VARIABLE{4552
{T_CON{EQU{24,T_VAR+3{{{CONSTANT{4553
{T_BOP{EQU{24,T_CON+3{{{BINARY OPERATOR{4554
{T_RPR{EQU{24,T_BOP+3{{{RIGHT PAREN{4555
{T_RBR{EQU{24,T_RPR+3{{{RIGHT BRACKET{4556
{T_COL{EQU{24,T_RBR+3{{{COLON{4557
{T_SMC{EQU{24,T_COL+3{{{SEMI-COLON{4558
*
*      THE FOLLOWING DEFINITIONS ARE USED ONLY IN THE GOTO FIELD
*
{T_FGO{EQU{24,T_SMC+1{{{FAILURE GOTO{4562
{T_SGO{EQU{24,T_FGO+1{{{SUCCESS GOTO{4563
*
*      THE ABOVE CODES ARE GROUPED SO THAT CODES FOR ELEMENTS
*      WHICH CAN LEGITIMATELY IMMEDIATELY PRECEDE A UNARY
*      OPERATOR COME FIRST TO FACILITATE OPERATOR SYNTAX CHECK.
*
{T_UOK{EQU{24,T_FNC{{{LAST CODE OK BEFORE UNARY OPERATOR{4569
{{EJC{{{{{4570
*
*      DEFINITIONS OF VALUES FOR EXPAN JUMP TABLE
*
{T_UO0{EQU{24,T_UOP+0{{{UNARY OPERATOR, STATE ZERO{4574
{T_UO1{EQU{24,T_UOP+1{{{UNARY OPERATOR, STATE ONE{4575
{T_UO2{EQU{24,T_UOP+2{{{UNARY OPERATOR, STATE TWO{4576
{T_LP0{EQU{24,T_LPR+0{{{LEFT PAREN, STATE ZERO{4577
{T_LP1{EQU{24,T_LPR+1{{{LEFT PAREN, STATE ONE{4578
{T_LP2{EQU{24,T_LPR+2{{{LEFT PAREN, STATE TWO{4579
{T_LB0{EQU{24,T_LBR+0{{{LEFT BRACKET, STATE ZERO{4580
{T_LB1{EQU{24,T_LBR+1{{{LEFT BRACKET, STATE ONE{4581
{T_LB2{EQU{24,T_LBR+2{{{LEFT BRACKET, STATE TWO{4582
{T_CM0{EQU{24,T_CMA+0{{{COMMA, STATE ZERO{4583
{T_CM1{EQU{24,T_CMA+1{{{COMMA, STATE ONE{4584
{T_CM2{EQU{24,T_CMA+2{{{COMMA, STATE TWO{4585
{T_FN0{EQU{24,T_FNC+0{{{FUNCTION CALL, STATE ZERO{4586
{T_FN1{EQU{24,T_FNC+1{{{FUNCTION CALL, STATE ONE{4587
{T_FN2{EQU{24,T_FNC+2{{{FUNCTION CALL, STATE TWO{4588
{T_VA0{EQU{24,T_VAR+0{{{VARIABLE, STATE ZERO{4589
{T_VA1{EQU{24,T_VAR+1{{{VARIABLE, STATE ONE{4590
{T_VA2{EQU{24,T_VAR+2{{{VARIABLE, STATE TWO{4591
{T_CO0{EQU{24,T_CON+0{{{CONSTANT, STATE ZERO{4592
{T_CO1{EQU{24,T_CON+1{{{CONSTANT, STATE ONE{4593
{T_CO2{EQU{24,T_CON+2{{{CONSTANT, STATE TWO{4594
{T_BO0{EQU{24,T_BOP+0{{{BINARY OPERATOR, STATE ZERO{4595
{T_BO1{EQU{24,T_BOP+1{{{BINARY OPERATOR, STATE ONE{4596
{T_BO2{EQU{24,T_BOP+2{{{BINARY OPERATOR, STATE TWO{4597
{T_RP0{EQU{24,T_RPR+0{{{RIGHT PAREN, STATE ZERO{4598
{T_RP1{EQU{24,T_RPR+1{{{RIGHT PAREN, STATE ONE{4599
{T_RP2{EQU{24,T_RPR+2{{{RIGHT PAREN, STATE TWO{4600
{T_RB0{EQU{24,T_RBR+0{{{RIGHT BRACKET, STATE ZERO{4601
{T_RB1{EQU{24,T_RBR+1{{{RIGHT BRACKET, STATE ONE{4602
{T_RB2{EQU{24,T_RBR+2{{{RIGHT BRACKET, STATE TWO{4603
{T_CL0{EQU{24,T_COL+0{{{COLON, STATE ZERO{4604
{T_CL1{EQU{24,T_COL+1{{{COLON, STATE ONE{4605
{T_CL2{EQU{24,T_COL+2{{{COLON, STATE TWO{4606
{T_SM0{EQU{24,T_SMC+0{{{SEMICOLON, STATE ZERO{4607
{T_SM1{EQU{24,T_SMC+1{{{SEMICOLON, STATE ONE{4608
{T_SM2{EQU{24,T_SMC+2{{{SEMICOLON, STATE TWO{4609
*
{T_NES{EQU{24,T_SM2+1{{{NUMBER OF ENTRIES IN BRANCH TABLE{4611
{{EJC{{{{{4612
*
*       DEFINITION OF OFFSETS USED IN CONTROL CARD PROCESSING
*
{CC_CA{EQU{24,0{{{-CASE{4617
{CC_DO{EQU{24,CC_CA+1{{{-DOUBLE{4618
{CC_CO{EQU{24,CC_DO+1{{{-COMPARE{4623
{CC_DU{EQU{24,CC_CO+1{{{-DUMP{4624
{CC_CP{EQU{24,CC_DU+1{{{-COPY{4629
{CC_EJ{EQU{24,CC_CP+1{{{-EJECT{4630
{CC_ER{EQU{24,CC_EJ+1{{{-ERRORS{4634
{CC_EX{EQU{24,CC_ER+1{{{-EXECUTE{4635
{CC_FA{EQU{24,CC_EX+1{{{-FAIL{4636
{CC_IN{EQU{24,CC_FA+1{{{-INCLUDE{4638
{CC_LN{EQU{24,CC_IN+1{{{-LINE{4640
{CC_LI{EQU{24,CC_LN+1{{{-LIST{4641
{CC_NR{EQU{24,CC_LI+1{{{-NOERRORS{4653
{CC_NX{EQU{24,CC_NR+1{{{-NOEXECUTE{4654
{CC_NF{EQU{24,CC_NX+1{{{-NOFAIL{4655
{CC_NL{EQU{24,CC_NF+1{{{-NOLIST{4656
{CC_NO{EQU{24,CC_NL+1{{{-NOOPT{4657
{CC_NP{EQU{24,CC_NO+1{{{-NOPRINT{4658
{CC_OP{EQU{24,CC_NP+1{{{-OPTIMISE{4659
{CC_PR{EQU{24,CC_OP+1{{{-PRINT{4660
{CC_SI{EQU{24,CC_PR+1{{{-SINGLE{4661
{CC_SP{EQU{24,CC_SI+1{{{-SPACE{4662
{CC_ST{EQU{24,CC_SP+1{{{-STITL{4663
{CC_TI{EQU{24,CC_ST+1{{{-TITLE{4664
{CC_TR{EQU{24,CC_TI+1{{{-TRACE{4665
{CC_NC{EQU{24,CC_TR+1{{{NUMBER OF CONTROL CARDS{4666
{CCNOC{EQU{24,4{{{NO. OF CHARS INCLUDED IN MATCH{4667
{CCOFS{EQU{24,7{{{OFFSET TO START OF TITLE/SUBTITLE{4668
{CCINM{EQU{24,9{{{MAX DEPTH OF INCLUDE FILE NESTING{4670
{{EJC{{{{{4672
*
*      DEFINITIONS OF STACK OFFSETS USED IN CMPIL PROCEDURE
*
*      SEE DESCRIPTION AT START OF CMPIL PROCEDURE FOR DETAILS
*      OF USE OF THESE LOCATIONS ON THE STACK.
*
{CMSTM{EQU{24,0{{{TREE FOR STATEMENT BODY{4679
{CMSGO{EQU{24,CMSTM+1{{{TREE FOR SUCCESS GOTO{4680
{CMFGO{EQU{24,CMSGO+1{{{TREE FOR FAIL GOTO{4681
{CMCGO{EQU{24,CMFGO+1{{{CONDITIONAL GOTO FLAG{4682
{CMPCD{EQU{24,CMCGO+1{{{PREVIOUS CDBLK POINTER{4683
{CMFFP{EQU{24,CMPCD+1{{{FAILURE FILL IN FLAG FOR PREVIOUS{4684
{CMFFC{EQU{24,CMFFP+1{{{FAILURE FILL IN FLAG FOR CURRENT{4685
{CMSOP{EQU{24,CMFFC+1{{{SUCCESS FILL IN OFFSET FOR PREVIOUS{4686
{CMSOC{EQU{24,CMSOP+1{{{SUCCESS FILL IN OFFSET FOR CURRENT{4687
{CMLBL{EQU{24,CMSOC+1{{{PTR TO VRBLK FOR CURRENT LABEL{4688
{CMTRA{EQU{24,CMLBL+1{{{PTR TO ENTRY CDBLK{4689
*
{CMNEN{EQU{24,CMTRA+1{{{COUNT OF STACK ENTRIES FOR CMPIL{4691
*
*      A FEW CONSTANTS USED BY THE PROFILER
{PFPD1{EQU{24,8{{{PAD POSITIONS ...{4696
{PFPD2{EQU{24,20{{{... FOR PROFILE ...{4697
{PFPD3{EQU{24,32{{{... PRINTOUT{4698
{PF_I2{EQU{24,CFP_I+CFP_I{{{SIZE OF TABLE ENTRY (2 INTS){4699
{{EJC{{{{{4702
*
*      DEFINITION OF LIMITS AND ADJUSTMENTS THAT ARE BUILT BY
*      RELCR FOR USE BY THE ROUTINES THAT RELOCATE POINTERS
*      AFTER A SAVE FILE IS RELOADED.  SEE RELOC ETC. FOR USAGE.
*
*      A BLOCK OF INFORMATION IS BUILT THAT IS USED IN
*      RELOCATING POINTERS.  THERE ARE RNSI_ INSTANCES
*      OF A RSSI_ WORD STRUCTURE.  EACH INSTANCE CORRESPONDS
*      TO ONE OF THE REGIONS THAT A POINTER MIGHT POINT INTO.
*
*      EACH STRUCTURE TAKES THE FORM:
*
*           +------------------------------------+
*           I    ADDRESS PAST END OF SECTION     I
*           +------------------------------------+
*           I  ADJUSTMENT FROM OLD TO NEW ADRS   I
*           +------------------------------------+
*           I    ADDRESS OF START OF SECTION     I
*           +------------------------------------+
*
*      THE INSTANCES ARE ORDERED THUSLY:
*
*           +------------------------------------+
*           I           DYNAMIC STORAGE          I
*           +------------------------------------+
*           I           STATIC STORAGE           I
*           +------------------------------------+
*           I       WORKING SECTION GLOBALS      I
*           +------------------------------------+
*           I          CONSTANT SECTION          I
*           +------------------------------------+
*           I            CODE SECTION            I
*           +------------------------------------+
*
*      SYMBOLIC NAMES FOR THESE LOCATIONS AS OFFSETS FROM
*      THE FIRST ENTRY ARE PROVIDED HERE.
*
*      DEFINITIONS WITHIN A SECTION
*
{RLEND{EQU{24,0{{{END{4742
{RLADJ{EQU{24,RLEND+1{{{ADJUSTMENT{4743
{RLSTR{EQU{24,RLADJ+1{{{START{4744
{RSSI_{EQU{24,RLSTR+1{{{SIZE OF SECTION{4745
{RNSI_{EQU{24,5{{{NUMBER OF STRUCTURES{4746
*
*      OVERALL DEFINITIONS OF ALL STRUCTURES
*
{RLDYE{EQU{24,0{{{DYNAMIC REGION END{4750
{RLDYA{EQU{24,RLDYE+1{{{DYNAMIC REGION ADJUSTMENT{4751
{RLDYS{EQU{24,RLDYA+1{{{DYNAMIC REGION START{4752
{RLSTE{EQU{24,RLDYS+1{{{STATIC REGION END{4753
{RLSTA{EQU{24,RLSTE+1{{{STATIC REGION ADJUSTMENT{4754
{RLSTS{EQU{24,RLSTA+1{{{STATIC REGION START{4755
{RLWKE{EQU{24,RLSTS+1{{{WORKING SECTION GLOBALS END{4756
{RLWKA{EQU{24,RLWKE+1{{{WORKING SECTION GLOBALS ADJUSTMENT{4757
{RLWKS{EQU{24,RLWKA+1{{{WORKING SECTION GLOBALS START{4758
{RLCNE{EQU{24,RLWKS+1{{{CONSTANTS SECTION END{4759
{RLCNA{EQU{24,RLCNE+1{{{CONSTANTS SECTION ADJUSTMENT{4760
{RLCNS{EQU{24,RLCNA+1{{{CONSTANTS SECTION START{4761
{RLCDE{EQU{24,RLCNS+1{{{CODE SECTION END{4762
{RLCDA{EQU{24,RLCDE+1{{{CODE SECTION ADJUSTMENT{4763
{RLCDS{EQU{24,RLCDA+1{{{CODE SECTION START{4764
{RLSI_{EQU{24,RLCDS+1{{{NUMBER OF FIELDS IN STRUCTURE{4765
*
{{TTL{27,S P I T B O L -- CONSTANT SECTION{{{{4768
*
*      THIS SECTION CONSISTS ENTIRELY OF ASSEMBLED CONSTANTS.
*
*      ALL LABEL NAMES ARE FIVE LETTERS. THE ORDER IS
*      APPROXIMATELY ALPHABETICAL, BUT IN SOME CASES (ALWAYS
*      DOCUMENTED), CONSTANTS MUST BE PLACED IN SOME SPECIAL
*      ORDER WHICH MUST NOT BE DISTURBED.
*
*      IT MUST ALSO BE REMEMBERED THAT THERE IS A REQUIREMENT
*      FOR NO FORWARD REFERENCES WHICH ALSO DISTURBS THE
*      ALPHABETICAL ORDER IN SOME CASES.
*
{{SEC{{{{START OF CONSTANT SECTION{4781
*
*      START OF CONSTANT SECTION
*
{C_AAA{DAC{1,0{{{FIRST LOCATION OF CONSTANT SECTION{4785
*
*      FREE STORE PERCENTAGE (USED BY ALLOC)
*
{ALFSP{DAC{2,E_FSP{{{FREE STORE PERCENTAGE{4789
*
*      BIT CONSTANTS FOR GENERAL USE
*
{BITS0{DBC{1,0{{{ALL ZERO BITS{4793
{BITS1{DBC{1,1{{{ONE BIT IN LOW ORDER POSITION{4794
{BITS2{DBC{1,2{{{BIT IN POSITION 2{4795
{BITS3{DBC{1,4{{{BIT IN POSITION 3{4796
{BITS4{DBC{1,8{{{BIT IN POSITION 4{4797
{BITS5{DBC{1,16{{{BIT IN POSITION 5{4798
{BITS6{DBC{1,32{{{BIT IN POSITION 6{4799
{BITS7{DBC{1,64{{{BIT IN POSITION 7{4800
{BITS8{DBC{1,128{{{BIT IN POSITION 8{4801
{BITS9{DBC{1,256{{{BIT IN POSITION 9{4802
{BIT10{DBC{1,512{{{BIT IN POSITION 10{4803
{BIT11{DBC{1,1024{{{BIT IN POSITION 11{4804
{BIT12{DBC{1,2048{{{BIT IN POSITION 12{4805
{BITSM{DBC{2,CFP_M{{{MASK FOR MAX INTEGER{4806
*
*      BIT CONSTANTS FOR SVBLK (SVBIT FIELD) TESTS
*
{BTFNC{DBC{2,SVFNC{{{BIT TO TEST FOR FUNCTION{4810
{BTKNM{DBC{2,SVKNM{{{BIT TO TEST FOR KEYWORD NUMBER{4811
{BTLBL{DBC{2,SVLBL{{{BIT TO TEST FOR LABEL{4812
{BTFFC{DBC{2,SVFFC{{{BIT TO TEST FOR FAST CALL{4813
{BTCKW{DBC{2,SVCKW{{{BIT TO TEST FOR CONSTANT KEYWORD{4814
{BTKWV{DBC{2,SVKWV{{{BITS TO TEST FOR KEWORD WITH VALUE{4815
{BTPRD{DBC{2,SVPRD{{{BIT TO TEST FOR PREDICATE FUNCTION{4816
{BTPRE{DBC{2,SVPRE{{{BIT TO TEST FOR PREEVALUATION{4817
{BTVAL{DBC{2,SVVAL{{{BIT TO TEST FOR VALUE{4818
{{EJC{{{{{4819
*
*      LIST OF NAMES USED FOR CONTROL CARD PROCESSING
*
{CCNMS{DTC{27,/CASE/{{{{4824
{{DTC{27,/DOUB/{{{{4825
{{DTC{27,/COMP/{{{{4830
{{DTC{27,/DUMP/{{{{4832
{{DTC{27,/COPY/{{{{4834
{{DTC{27,/EJEC/{{{{4836
{{DTC{27,/ERRO/{{{{4837
{{DTC{27,/EXEC/{{{{4838
{{DTC{27,/FAIL/{{{{4839
{{DTC{27,/INCL/{{{{4841
{{DTC{27,/LINE/{{{{4844
{{DTC{27,/LIST/{{{{4846
{{DTC{27,/NOER/{{{{4847
{{DTC{27,/NOEX/{{{{4848
{{DTC{27,/NOFA/{{{{4849
{{DTC{27,/NOLI/{{{{4850
{{DTC{27,/NOOP/{{{{4851
{{DTC{27,/NOPR/{{{{4852
{{DTC{27,/OPTI/{{{{4853
{{DTC{27,/PRIN/{{{{4854
{{DTC{27,/SING/{{{{4855
{{DTC{27,/SPAC/{{{{4856
{{DTC{27,/STIT/{{{{4857
{{DTC{27,/TITL/{{{{4858
{{DTC{27,/TRAC/{{{{4859
*
*      HEADER MESSAGES FOR DUMPR PROCEDURE (SCBLK FORMAT)
*
{DMHDK{DAC{6,B_SCL{{{DUMP OF KEYWORD VALUES{4863
{{DAC{1,22{{{{4864
{{DTC{27,/Dump of Keyword Values/{{{{4865
*
{DMHDV{DAC{6,B_SCL{{{DUMP OF NATURAL VARIABLES{4867
{{DAC{1,25{{{{4868
{{DTC{27,/Dump of Natural Variables/{{{{4869
{{EJC{{{{{4870
*
*      MESSAGE TEXT FOR COMPILATION STATISTICS
*
{ENCM1{DAC{6,B_SCL{{{{4874
{{DAC{1,19{{{{4876
{{DTC{27,/Memory used (bytes)/{{{{4877
*
{ENCM2{DAC{6,B_SCL{{{{4879
{{DAC{1,19{{{{4880
{{DTC{27,/Memory left (bytes)/{{{{4881
*
{ENCM3{DAC{6,B_SCL{{{{4891
{{DAC{1,11{{{{4892
{{DTC{27,/Comp errors/{{{{4893
*
{ENCM4{DAC{6,B_SCL{{{{4895
{{DAC{1,20{{{{4900
{{DTC{27,/Comp time (millisec)/{{{{4901
*
{ENCM5{DAC{6,B_SCL{{{EXECUTION SUPPRESSED{4904
{{DAC{1,20{{{{4905
{{DTC{27,/Execution suppressed/{{{{4906
*
*      STRING CONSTANT FOR ABNORMAL END
*
{ENDAB{DAC{6,B_SCL{{{{4910
{{DAC{1,12{{{{4911
{{DTC{27,/Abnormal End/{{{{4912
{{EJC{{{{{4913
*
*      MEMORY OVERFLOW DURING INITIALISATION
*
{ENDMO{DAC{6,B_SCL{{{{4917
{ENDML{DAC{1,15{{{{4918
{{DTC{27,/Memory Overflow/{{{{4919
*
*      STRING CONSTANT FOR MESSAGE ISSUED BY L_END
*
{ENDMS{DAC{6,B_SCL{{{{4923
{{DAC{1,10{{{{4924
{{DTC{27,/Normal end/{{{{4925
*
*      FAIL MESSAGE FOR STACK FAIL SECTION
*
{ENDSO{DAC{6,B_SCL{{{STACK OVERFLOW IN GARBAGE COLLECTOR{4929
{{DAC{1,36{{{{4930
{{DTC{27,/Stack overflow in garbage collection/{{{{4931
*
*      STRING CONSTANT FOR TIME UP
*
{ENDTU{DAC{6,B_SCL{{{{4935
{{DAC{1,15{{{{4936
{{DTC{27,/Error - Time Up/{{{{4937
{{EJC{{{{{4938
*
*      STRING CONSTANT FOR ERROR MESSAGE (ERROR SECTION)
*
{ERMMS{DAC{6,B_SCL{{{ERROR{4942
{{DAC{1,5{{{{4943
{{DTC{27,/Error/{{{{4944
*
{ERMNS{DAC{6,B_SCL{{{STRING / -- /{4946
{{DAC{1,4{{{{4947
{{DTC{27,/ -- /{{{{4948
*
*      STRING CONSTANT FOR PAGE NUMBERING
*
{LSTMS{DAC{6,B_SCL{{{PAGE{4952
{{DAC{1,5{{{{4953
{{DTC{27,/Page /{{{{4954
*
*      LISTING HEADER MESSAGE
*
{HEADR{DAC{6,B_SCL{{{{4958
{{DAC{1,27{{{{4959
{{DTC{27,/Macro SPITBOL Version 13.01/{{{{4960
*
{HEADV{DAC{6,B_SCL{{{FOR EXIT() VERSION NO. CHECK{4962
{{DAC{1,5{{{{4963
{{DTC{27,/13.01/{{{{4964
*      FREE STORE PERCENTAGE (USED BY GBCOL)
*
{GBSDP{DAC{2,E_SED{{{SEDIMENT PERCENTAGE{4968
*
*      INTEGER CONSTANTS FOR GENERAL USE
*      ICBLD OPTIMISATION USES THE FIRST THREE.
*
{INT_R{DAC{6,B_ICL{{{{4974
{INTV0{DIC{16,+0{{{0{4975
{INTON{DAC{6,B_ICL{{{{4976
{INTV1{DIC{16,+1{{{1{4977
{INTTW{DAC{6,B_ICL{{{{4978
{INTV2{DIC{16,+2{{{2{4979
{INTVT{DIC{16,+10{{{10{4980
{INTVH{DIC{16,+100{{{100{4981
{INTTH{DIC{16,+1000{{{1000{4982
*
*      TABLE USED IN ICBLD OPTIMISATION
*
{INTAB{DAC{4,INT_R{{{POINTER TO 0{4986
{{DAC{4,INTON{{{POINTER TO 1{4987
{{DAC{4,INTTW{{{POINTER TO 2{4988
{{EJC{{{{{4989
*
*      SPECIAL PATTERN NODES. THE FOLLOWING PATTERN NODES
*      CONSIST SIMPLY OF A PCODE POINTER, SEE MATCH ROUTINES
*      (P_XXX) FOR FULL DETAILS OF THEIR USE AND FORMAT).
*
{NDABB{DAC{6,P_ABB{{{ARBNO{4995
{NDABD{DAC{6,P_ABD{{{ARBNO{4996
{NDARC{DAC{6,P_ARC{{{ARB{4997
{NDEXB{DAC{6,P_EXB{{{EXPRESSION{4998
{NDFNB{DAC{6,P_FNB{{{FENCE(){4999
{NDFND{DAC{6,P_FND{{{FENCE(){5000
{NDEXC{DAC{6,P_EXC{{{EXPRESSION{5001
{NDIMB{DAC{6,P_IMB{{{IMMEDIATE ASSIGNMENT{5002
{NDIMD{DAC{6,P_IMD{{{IMMEDIATE ASSIGNMENT{5003
{NDNTH{DAC{6,P_NTH{{{PATTERN END (NULL PATTERN){5004
{NDPAB{DAC{6,P_PAB{{{PATTERN ASSIGNMENT{5005
{NDPAD{DAC{6,P_PAD{{{PATTERN ASSIGNMENT{5006
{NDUNA{DAC{6,P_UNA{{{ANCHOR POINT MOVEMENT{5007
*
*      KEYWORD CONSTANT PATTERN NODES. THE FOLLOWING NODES ARE
*      USED AS THE VALUES OF PATTERN KEYWORDS AND THE INITIAL
*      VALUES OF THE CORRESPONDING NATURAL VARIABLES. ALL
*      NODES ARE IN P0BLK FORMAT AND THE ORDER IS TIED TO THE
*      DEFINITIONS OF CORRESPONDING K_XXX SYMBOLS.
*
{NDABO{DAC{6,P_ABO{{{ABORT{5015
{{DAC{4,NDNTH{{{{5016
{NDARB{DAC{6,P_ARB{{{ARB{5017
{{DAC{4,NDNTH{{{{5018
{NDBAL{DAC{6,P_BAL{{{BAL{5019
{{DAC{4,NDNTH{{{{5020
{NDFAL{DAC{6,P_FAL{{{FAIL{5021
{{DAC{4,NDNTH{{{{5022
{NDFEN{DAC{6,P_FEN{{{FENCE{5023
{{DAC{4,NDNTH{{{{5024
{NDREM{DAC{6,P_REM{{{REM{5025
{{DAC{4,NDNTH{{{{5026
{NDSUC{DAC{6,P_SUC{{{SUCCEED{5027
{{DAC{4,NDNTH{{{{5028
*
*      NULL STRING. ALL NULL VALUES POINT TO THIS STRING. THE
*      SVCHS FIELD CONTAINS A BLANK TO PROVIDE FOR EASY DEFAULT
*      PROCESSING IN TRACE, STOPTR, LPAD AND RPAD.
*      NULLW CONTAINS 10 BLANKS WHICH ENSURES AN ALL BLANK WORD
*      BUT FOR VERY EXCEPTIONAL MACHINES.
*
{NULLS{DAC{6,B_SCL{{{NULL STRING VALUE{5036
{{DAC{1,0{{{SCLEN = 0{5037
{NULLW{DTC{27,/          /{{{{5038
*
*
*      CONSTANT STRINGS FOR LCASE AND UCASE KEYWORDS
*
{LCASE{DAC{6,B_SCL{{{{5044
{{DAC{1,26{{{{5045
{{DTC{27,/abcdefghijklmnopqrstuvwxyz/{{{{5046
*
{UCASE{DAC{6,B_SCL{{{{5048
{{DAC{1,26{{{{5049
{{DTC{27,/ABCDEFGHIJKLMNOPQRSTUVWXYZ/{{{{5050
{{EJC{{{{{5052
*
*      OPERATOR DOPE VECTORS (SEE DVBLK FORMAT)
*
{OPDVC{DAC{6,O_CNC{{{CONCATENATION{5056
{{DAC{2,C_CNC{{{{5057
{{DAC{2,LLCNC{{{{5058
{{DAC{2,RRCNC{{{{5059
*
*      OPDVS IS USED WHEN SCANNING BELOW THE TOP LEVEL TO
*      INSURE THAT THE CONCATENATION WILL NOT BE LATER
*      MISTAKEN FOR PATTERN MATCHING
*
{OPDVP{DAC{6,O_CNC{{{CONCATENATION - NOT PATTERN MATCH{5065
{{DAC{2,C_CNP{{{{5066
{{DAC{2,LLCNC{{{{5067
{{DAC{2,RRCNC{{{{5068
*
*      NOTE THAT THE ORDER OF THE REMAINING ENTRIES IS TIED TO
*      THE ORDER OF THE CODING IN THE SCANE PROCEDURE.
*
{OPDVS{DAC{6,O_ASS{{{ASSIGNMENT{5073
{{DAC{2,C_ASS{{{{5074
{{DAC{2,LLASS{{{{5075
{{DAC{2,RRASS{{{{5076
*
{{DAC{1,6{{{UNARY EQUAL{5078
{{DAC{2,C_UUO{{{{5079
{{DAC{2,LLUNO{{{{5080
*
{{DAC{6,O_PMV{{{PATTERN MATCH{5082
{{DAC{2,C_PMT{{{{5083
{{DAC{2,LLPMT{{{{5084
{{DAC{2,RRPMT{{{{5085
*
{{DAC{6,O_INT{{{INTERROGATION{5087
{{DAC{2,C_UVL{{{{5088
{{DAC{2,LLUNO{{{{5089
*
{{DAC{1,1{{{BINARY AMPERSAND{5091
{{DAC{2,C_UBO{{{{5092
{{DAC{2,LLAMP{{{{5093
{{DAC{2,RRAMP{{{{5094
*
{{DAC{6,O_KWV{{{KEYWORD REFERENCE{5096
{{DAC{2,C_KEY{{{{5097
{{DAC{2,LLUNO{{{{5098
*
{{DAC{6,O_ALT{{{ALTERNATION{5100
{{DAC{2,C_ALT{{{{5101
{{DAC{2,LLALT{{{{5102
{{DAC{2,RRALT{{{{5103
{{EJC{{{{{5104
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{1,5{{{UNARY VERTICAL BAR{5108
{{DAC{2,C_UUO{{{{5109
{{DAC{2,LLUNO{{{{5110
*
{{DAC{1,0{{{BINARY AT{5112
{{DAC{2,C_UBO{{{{5113
{{DAC{2,LLATS{{{{5114
{{DAC{2,RRATS{{{{5115
*
{{DAC{6,O_CAS{{{CURSOR ASSIGNMENT{5117
{{DAC{2,C_UNM{{{{5118
{{DAC{2,LLUNO{{{{5119
*
{{DAC{1,2{{{BINARY NUMBER SIGN{5121
{{DAC{2,C_UBO{{{{5122
{{DAC{2,LLNUM{{{{5123
{{DAC{2,RRNUM{{{{5124
*
{{DAC{1,7{{{UNARY NUMBER SIGN{5126
{{DAC{2,C_UUO{{{{5127
{{DAC{2,LLUNO{{{{5128
*
{{DAC{6,O_DVD{{{DIVISION{5130
{{DAC{2,C_BVL{{{{5131
{{DAC{2,LLDVD{{{{5132
{{DAC{2,RRDVD{{{{5133
*
{{DAC{1,9{{{UNARY SLASH{5135
{{DAC{2,C_UUO{{{{5136
{{DAC{2,LLUNO{{{{5137
*
{{DAC{6,O_MLT{{{MULTIPLICATION{5139
{{DAC{2,C_BVL{{{{5140
{{DAC{2,LLMLT{{{{5141
{{DAC{2,RRMLT{{{{5142
{{EJC{{{{{5143
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{1,0{{{DEFERRED EXPRESSION{5147
{{DAC{2,C_DEF{{{{5148
{{DAC{2,LLUNO{{{{5149
*
{{DAC{1,3{{{BINARY PERCENT{5151
{{DAC{2,C_UBO{{{{5152
{{DAC{2,LLPCT{{{{5153
{{DAC{2,RRPCT{{{{5154
*
{{DAC{1,8{{{UNARY PERCENT{5156
{{DAC{2,C_UUO{{{{5157
{{DAC{2,LLUNO{{{{5158
*
{{DAC{6,O_EXP{{{EXPONENTIATION{5160
{{DAC{2,C_BVL{{{{5161
{{DAC{2,LLEXP{{{{5162
{{DAC{2,RREXP{{{{5163
*
{{DAC{1,10{{{UNARY EXCLAMATION{5165
{{DAC{2,C_UUO{{{{5166
{{DAC{2,LLUNO{{{{5167
*
{{DAC{6,O_IMA{{{IMMEDIATE ASSIGNMENT{5169
{{DAC{2,C_BVN{{{{5170
{{DAC{2,LLDLD{{{{5171
{{DAC{2,RRDLD{{{{5172
*
{{DAC{6,O_INV{{{INDIRECTION{5174
{{DAC{2,C_IND{{{{5175
{{DAC{2,LLUNO{{{{5176
*
{{DAC{1,4{{{BINARY NOT{5178
{{DAC{2,C_UBO{{{{5179
{{DAC{2,LLNOT{{{{5180
{{DAC{2,RRNOT{{{{5181
*
{{DAC{1,0{{{NEGATION{5183
{{DAC{2,C_NEG{{{{5184
{{DAC{2,LLUNO{{{{5185
{{EJC{{{{{5186
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{6,O_SUB{{{SUBTRACTION{5190
{{DAC{2,C_BVL{{{{5191
{{DAC{2,LLPLM{{{{5192
{{DAC{2,RRPLM{{{{5193
*
{{DAC{6,O_COM{{{COMPLEMENTATION{5195
{{DAC{2,C_UVL{{{{5196
{{DAC{2,LLUNO{{{{5197
*
{{DAC{6,O_ADD{{{ADDITION{5199
{{DAC{2,C_BVL{{{{5200
{{DAC{2,LLPLM{{{{5201
{{DAC{2,RRPLM{{{{5202
*
{{DAC{6,O_AFF{{{AFFIRMATION{5204
{{DAC{2,C_UVL{{{{5205
{{DAC{2,LLUNO{{{{5206
*
{{DAC{6,O_PAS{{{PATTERN ASSIGNMENT{5208
{{DAC{2,C_BVN{{{{5209
{{DAC{2,LLDLD{{{{5210
{{DAC{2,RRDLD{{{{5211
*
{{DAC{6,O_NAM{{{NAME REFERENCE{5213
{{DAC{2,C_UNM{{{{5214
{{DAC{2,LLUNO{{{{5215
*
*      SPECIAL DVS FOR GOTO OPERATORS (SEE PROCEDURE SCNGF)
*
{OPDVD{DAC{6,O_GOD{{{DIRECT GOTO{5219
{{DAC{2,C_UVL{{{{5220
{{DAC{2,LLUNO{{{{5221
*
{OPDVN{DAC{6,O_GOC{{{COMPLEX NORMAL GOTO{5223
{{DAC{2,C_UNM{{{{5224
{{DAC{2,LLUNO{{{{5225
{{EJC{{{{{5226
*
*      OPERATOR ENTRY ADDRESS POINTERS, USED IN CODE
*
{OAMN_{DAC{6,O_AMN{{{ARRAY REF (MULTI-SUBS BY VALUE){5230
{OAMV_{DAC{6,O_AMV{{{ARRAY REF (MULTI-SUBS BY VALUE){5231
{OAON_{DAC{6,O_AON{{{ARRAY REF (ONE SUB BY NAME){5232
{OAOV_{DAC{6,O_AOV{{{ARRAY REF (ONE SUB BY VALUE){5233
{OCER_{DAC{6,O_CER{{{COMPILATION ERROR{5234
{OFEX_{DAC{6,O_FEX{{{FAILURE IN EXPRESSION EVALUATION{5235
{OFIF_{DAC{6,O_FIF{{{FAILURE DURING GOTO EVALUATION{5236
{OFNC_{DAC{6,O_FNC{{{FUNCTION CALL (MORE THAN ONE ARG){5237
{OFNE_{DAC{6,O_FNE{{{FUNCTION NAME ERROR{5238
{OFNS_{DAC{6,O_FNS{{{FUNCTION CALL (SINGLE ARGUMENT){5239
{OGOF_{DAC{6,O_GOF{{{SET GOTO FAILURE TRAP{5240
{OINN_{DAC{6,O_INN{{{INDIRECTION BY NAME{5241
{OKWN_{DAC{6,O_KWN{{{KEYWORD REFERENCE BY NAME{5242
{OLEX_{DAC{6,O_LEX{{{LOAD EXPRESSION BY NAME{5243
{OLPT_{DAC{6,O_LPT{{{LOAD PATTERN{5244
{OLVN_{DAC{6,O_LVN{{{LOAD VARIABLE NAME{5245
{ONTA_{DAC{6,O_NTA{{{NEGATION, FIRST ENTRY{5246
{ONTB_{DAC{6,O_NTB{{{NEGATION, SECOND ENTRY{5247
{ONTC_{DAC{6,O_NTC{{{NEGATION, THIRD ENTRY{5248
{OPMN_{DAC{6,O_PMN{{{PATTERN MATCH BY NAME{5249
{OPMS_{DAC{6,O_PMS{{{PATTERN MATCH (STATEMENT){5250
{OPOP_{DAC{6,O_POP{{{POP TOP STACK ITEM{5251
{ORNM_{DAC{6,O_RNM{{{RETURN NAME FROM EXPRESSION{5252
{ORPL_{DAC{6,O_RPL{{{PATTERN REPLACEMENT{5253
{ORVL_{DAC{6,O_RVL{{{RETURN VALUE FROM EXPRESSION{5254
{OSLA_{DAC{6,O_SLA{{{SELECTION, FIRST ENTRY{5255
{OSLB_{DAC{6,O_SLB{{{SELECTION, SECOND ENTRY{5256
{OSLC_{DAC{6,O_SLC{{{SELECTION, THIRD ENTRY{5257
{OSLD_{DAC{6,O_SLD{{{SELECTION, FOURTH ENTRY{5258
{OSTP_{DAC{6,O_STP{{{STOP EXECUTION{5259
{OUNF_{DAC{6,O_UNF{{{UNEXPECTED FAILURE{5260
{{EJC{{{{{5261
*
*      TABLE OF NAMES OF UNDEFINED BINARY OPERATORS FOR OPSYN
*
{OPSNB{DAC{2,CH_AT{{{AT{5265
{{DAC{2,CH_AM{{{AMPERSAND{5266
{{DAC{2,CH_NM{{{NUMBER{5267
{{DAC{2,CH_PC{{{PERCENT{5268
{{DAC{2,CH_NT{{{NOT{5269
*
*      TABLE OF NAMES OF UNDEFINED UNARY OPERATORS FOR OPSYN
*
{OPNSU{DAC{2,CH_BR{{{VERTICAL BAR{5273
{{DAC{2,CH_EQ{{{EQUAL{5274
{{DAC{2,CH_NM{{{NUMBER{5275
{{DAC{2,CH_PC{{{PERCENT{5276
{{DAC{2,CH_SL{{{SLASH{5277
{{DAC{2,CH_EX{{{EXCLAMATION{5278
*
*      ADDRESS CONST CONTAINING PROFILE TABLE ENTRY SIZE
*
{PFI2A{DAC{2,PF_I2{{{{5284
*
*      PROFILER MESSAGE STRINGS
*
{PFMS1{DAC{6,B_SCL{{{{5288
{{DAC{1,15{{{{5289
{{DTC{27,/Program Profile/{{{{5290
{PFMS2{DAC{6,B_SCL{{{{5291
{{DAC{1,42{{{{5292
{{DTC{27,/STMT    Number Of     -- Execution Time --/{{{{5293
{PFMS3{DAC{6,B_SCL{{{{5294
{{DAC{1,47{{{{5295
{{DTC{27,/Number  Executions  Total(MSec) per Excn(MCSec)/{{{{5296
*
*
*      REAL CONSTANTS FOR GENERAL USE. NOTE THAT THE CONSTANTS
*      STARTING AT REAV1 FORM A POWERS OF TEN TABLE (USED IN
*      GTNUM AND GTSTG)
*
{REAV0{DRC{17,+0.0{{{0.0{5306
{REAP1{DRC{17,+0.1{{{0.1{5309
{REAP5{DRC{17,+0.5{{{0.5{5310
{REAV1{DRC{17,+1.0{{{10**0{5312
{REAVT{DRC{17,+1.0E+1{{{10**1{5313
{{DRC{17,+1.0E+2{{{10**2{5314
{{DRC{17,+1.0E+3{{{10**3{5315
{{DRC{17,+1.0E+4{{{10**4{5316
{{DRC{17,+1.0E+5{{{10**5{5317
{{DRC{17,+1.0E+6{{{10**6{5318
{{DRC{17,+1.0E+7{{{10**7{5319
{{DRC{17,+1.0E+8{{{10**8{5320
{{DRC{17,+1.0E+9{{{10**9{5321
{REATT{DRC{17,+1.0E+10{{{10**10{5322
{{EJC{{{{{5324
*
*      STRING CONSTANTS (SCBLK FORMAT) FOR DTYPE PROCEDURE
*
{SCARR{DAC{6,B_SCL{{{ARRAY{5328
{{DAC{1,5{{{{5329
{{DTC{27,/ARRAY/{{{{5330
*
{SCCOD{DAC{6,B_SCL{{{CODE{5339
{{DAC{1,4{{{{5340
{{DTC{27,/CODE/{{{{5341
*
{SCEXP{DAC{6,B_SCL{{{EXPRESSION{5343
{{DAC{1,10{{{{5344
{{DTC{27,/EXPRESSION/{{{{5345
*
{SCEXT{DAC{6,B_SCL{{{EXTERNAL{5347
{{DAC{1,8{{{{5348
{{DTC{27,/EXTERNAL/{{{{5349
*
{SCINT{DAC{6,B_SCL{{{INTEGER{5351
{{DAC{1,7{{{{5352
{{DTC{27,/INTEGER/{{{{5353
*
{SCNAM{DAC{6,B_SCL{{{NAME{5355
{{DAC{1,4{{{{5356
{{DTC{27,/NAME/{{{{5357
*
{SCNUM{DAC{6,B_SCL{{{NUMERIC{5359
{{DAC{1,7{{{{5360
{{DTC{27,/NUMERIC/{{{{5361
*
{SCPAT{DAC{6,B_SCL{{{PATTERN{5363
{{DAC{1,7{{{{5364
{{DTC{27,/PATTERN/{{{{5365
*
{SCREA{DAC{6,B_SCL{{{REAL{5369
{{DAC{1,4{{{{5370
{{DTC{27,/REAL/{{{{5371
*
{SCSTR{DAC{6,B_SCL{{{STRING{5374
{{DAC{1,6{{{{5375
{{DTC{27,/STRING/{{{{5376
*
{SCTAB{DAC{6,B_SCL{{{TABLE{5378
{{DAC{1,5{{{{5379
{{DTC{27,/TABLE/{{{{5380
{SCFIL{DAC{6,B_SCL{{{FILE (FOR EXTENDED LOAD ARGUMENTS){5382
{{DAC{1,4{{{{5383
{{DTC{27,/FILE/{{{{5384
{{EJC{{{{{5386
*
*      STRING CONSTANTS (SCBLK FORMAT) FOR KVRTN (SEE RETRN)
*
{SCFRT{DAC{6,B_SCL{{{FRETURN{5390
{{DAC{1,7{{{{5391
{{DTC{27,/FRETURN/{{{{5392
*
{SCNRT{DAC{6,B_SCL{{{NRETURN{5394
{{DAC{1,7{{{{5395
{{DTC{27,/NRETURN/{{{{5396
*
{SCRTN{DAC{6,B_SCL{{{RETURN{5398
{{DAC{1,6{{{{5399
{{DTC{27,/RETURN/{{{{5400
*
*      DATATYPE NAME TABLE FOR DTYPE PROCEDURE. THE ORDER OF
*      THESE ENTRIES IS TIED TO THE B_XXX DEFINITIONS FOR BLOCKS
*
*      NOTE THAT SLOTS FOR BUFFER AND REAL DATA TYPES ARE FILLED
*      EVEN IF THESE DATA TYPES ARE CONDITIONALIZED OUT OF THE
*      IMPLEMENTATION.  THIS IS DONE SO THAT THE BLOCK NUMBERING
*      AT BL_AR ETC. REMAINS CONSTANT IN ALL VERSIONS.
*
{SCNMT{DAC{4,SCARR{{{ARBLK     ARRAY{5410
{{DAC{4,SCCOD{{{CDBLK     CODE{5411
{{DAC{4,SCEXP{{{EXBLK     EXPRESSION{5412
{{DAC{4,SCINT{{{ICBLK     INTEGER{5413
{{DAC{4,SCNAM{{{NMBLK     NAME{5414
{{DAC{4,SCPAT{{{P0BLK     PATTERN{5415
{{DAC{4,SCPAT{{{P1BLK     PATTERN{5416
{{DAC{4,SCPAT{{{P2BLK     PATTERN{5417
{{DAC{4,SCREA{{{RCBLK     REAL{5422
{{DAC{4,SCSTR{{{SCBLK     STRING{5424
{{DAC{4,SCEXP{{{SEBLK     EXPRESSION{5425
{{DAC{4,SCTAB{{{TBBLK     TABLE{5426
{{DAC{4,SCARR{{{VCBLK     ARRAY{5427
{{DAC{4,SCEXT{{{XNBLK     EXTERNAL{5428
{{DAC{4,SCEXT{{{XRBLK     EXTERNAL{5429
{{DAC{4,NULLS{{{BFBLK     NO BUFFER IN THIS VERSION{5431
*
*      STRING CONSTANT FOR REAL ZERO
*
{SCRE0{DAC{6,B_SCL{{{{5440
{{DAC{1,2{{{{5441
{{DTC{27,/0./{{{{5442
{{EJC{{{{{5444
*
*      USED TO RE-INITIALISE KVSTL
*
{STLIM{DIC{16,+2147483647{{{DEFAULT STATEMENT LIMIT{5452
*
*      DUMMY FUNCTION BLOCK USED FOR UNDEFINED FUNCTIONS
*
{STNDF{DAC{6,O_FUN{{{PTR TO UNDEFINED FUNCTION ERR CALL{5460
{{DAC{1,0{{{DUMMY FARGS COUNT FOR CALL CIRCUIT{5461
*
*      DUMMY CODE BLOCK USED FOR UNDEFINED LABELS
*
{STNDL{DAC{6,L_UND{{{CODE PTR POINTS TO UNDEFINED LBL{5465
*
*      DUMMY OPERATOR BLOCK USED FOR UNDEFINED OPERATORS
*
{STNDO{DAC{6,O_OUN{{{PTR TO UNDEFINED OPERATOR ERR CALL{5469
{{DAC{1,0{{{DUMMY FARGS COUNT FOR CALL CIRCUIT{5470
*
*      STANDARD VARIABLE BLOCK. THIS BLOCK IS USED TO INITIALIZE
*      THE FIRST SEVEN FIELDS OF A NEWLY CONSTRUCTED VRBLK.
*      ITS FORMAT IS TIED TO THE VRBLK DEFINITIONS (SEE GTNVR).
*
{STNVR{DAC{6,B_VRL{{{VRGET{5476
{{DAC{6,B_VRS{{{VRSTO{5477
{{DAC{4,NULLS{{{VRVAL{5478
{{DAC{6,B_VRG{{{VRTRA{5479
{{DAC{4,STNDL{{{VRLBL{5480
{{DAC{4,STNDF{{{VRFNC{5481
{{DAC{1,0{{{VRNXT{5482
{{EJC{{{{{5483
*
*      MESSAGES USED IN END OF RUN PROCESSING (STOPR)
*
{STPM1{DAC{6,B_SCL{{{IN STATEMENT{5487
{{DAC{1,12{{{{5488
{{DTC{27,/In statement/{{{{5489
*
{STPM2{DAC{6,B_SCL{{{{5491
{{DAC{1,14{{{{5492
{{DTC{27,/Stmts executed/{{{{5493
*
{STPM3{DAC{6,B_SCL{{{{5495
{{DAC{1,19{{{{5500
{{DTC{27,/Run time (millisec)/{{{{5501
*
{STPM4{DAC{6,B_SCL{{{{5504
{{DAC{1,12{{{{5505
{{DTC{27,_MCSec / Stmt_{{{{5506
*
{STPM5{DAC{6,B_SCL{{{{5508
{{DAC{1,13{{{{5509
{{DTC{27,/Regenerations/{{{{5510
*
{STPM6{DAC{6,B_SCL{{{IN LINE{5513
{{DAC{1,7{{{{5514
{{DTC{27,/In line/{{{{5515
*
{STPM7{DAC{6,B_SCL{{{IN FILE{5519
{{DAC{1,7{{{{5520
{{DTC{27,/In file/{{{{5521
*
*      CHARS FOR /TU/ ENDING CODE
*
{STRTU{DTC{27,/TU/{{{{5526
*
*      TABLE USED BY CONVERT FUNCTION TO CHECK DATATYPE NAME
*      THE ENTRIES ARE ORDERED TO CORRESPOND TO BRANCH TABLE
*      IN S_CNV
*
{SVCTB{DAC{4,SCSTR{{{STRING{5532
{{DAC{4,SCINT{{{INTEGER{5533
{{DAC{4,SCNAM{{{NAME{5534
{{DAC{4,SCPAT{{{PATTERN{5535
{{DAC{4,SCARR{{{ARRAY{5536
{{DAC{4,SCTAB{{{TABLE{5537
{{DAC{4,SCEXP{{{EXPRESSION{5538
{{DAC{4,SCCOD{{{CODE{5539
{{DAC{4,SCNUM{{{NUMERIC{5540
{{DAC{4,SCREA{{{REAL{5543
{{DAC{1,0{{{ZERO MARKS END OF LIST{5549
{{EJC{{{{{5550
*
*      MESSAGES (SCBLK FORMAT) USED BY TRACE PROCEDURES
*
*
{TMASB{DAC{6,B_SCL{{{ASTERISKS FOR TRACE STATEMENT NO{5555
{{DAC{1,13{{{{5556
{{DTC{27,/************ /{{{{5557
*
{TMBEB{DAC{6,B_SCL{{{BLANK-EQUAL-BLANK{5560
{{DAC{1,3{{{{5561
{{DTC{27,/ = /{{{{5562
*
*      DUMMY TRBLK FOR EXPRESSION VARIABLE
*
{TRBEV{DAC{6,B_TRT{{{DUMMY TRBLK{5566
*
*      DUMMY TRBLK FOR KEYWORD VARIABLE
*
{TRBKV{DAC{6,B_TRT{{{DUMMY TRBLK{5570
*
*      DUMMY CODE BLOCK TO RETURN CONTROL TO TRXEQ PROCEDURE
*
{TRXDR{DAC{6,O_TXR{{{BLOCK POINTS TO RETURN ROUTINE{5574
{TRXDC{DAC{4,TRXDR{{{POINTER TO BLOCK{5575
{{EJC{{{{{5576
*
*      STANDARD VARIABLE BLOCKS
*
*      SEE SVBLK FORMAT FOR FULL DETAILS OF THE FORMAT. THE
*      VRBLKS ARE ORDERED BY LENGTH AND WITHIN EACH LENGTH THE
*      ORDER IS ALPHABETICAL BY NAME OF THE VARIABLE.
*
{V_EQF{DBC{2,SVFPR{{{EQ{5584
{{DAC{1,2{{{{5585
{{DTC{27,/EQ/{{{{5586
{{DAC{6,S_EQF{{{{5587
{{DAC{1,2{{{{5588
*
{V_GEF{DBC{2,SVFPR{{{GE{5590
{{DAC{1,2{{{{5591
{{DTC{27,/GE/{{{{5592
{{DAC{6,S_GEF{{{{5593
{{DAC{1,2{{{{5594
*
{V_GTF{DBC{2,SVFPR{{{GT{5596
{{DAC{1,2{{{{5597
{{DTC{27,/GT/{{{{5598
{{DAC{6,S_GTF{{{{5599
{{DAC{1,2{{{{5600
*
{V_LEF{DBC{2,SVFPR{{{LE{5602
{{DAC{1,2{{{{5603
{{DTC{27,/LE/{{{{5604
{{DAC{6,S_LEF{{{{5605
{{DAC{1,2{{{{5606
*
{V_LNF{DBC{2,SVFNP{{{LN{5609
{{DAC{1,2{{{{5610
{{DTC{27,/LN/{{{{5611
{{DAC{6,S_LNF{{{{5612
{{DAC{1,1{{{{5613
*
{V_LTF{DBC{2,SVFPR{{{LT{5616
{{DAC{1,2{{{{5617
{{DTC{27,/LT/{{{{5618
{{DAC{6,S_LTF{{{{5619
{{DAC{1,2{{{{5620
*
{V_NEF{DBC{2,SVFPR{{{NE{5622
{{DAC{1,2{{{{5623
{{DTC{27,/NE/{{{{5624
{{DAC{6,S_NEF{{{{5625
{{DAC{1,2{{{{5626
*
{V_ANY{DBC{2,SVFNP{{{ANY{5652
{{DAC{1,3{{{{5653
{{DTC{27,/ANY/{{{{5654
{{DAC{6,S_ANY{{{{5655
{{DAC{1,1{{{{5656
*
{V_ARB{DBC{2,SVKVC{{{ARB{5658
{{DAC{1,3{{{{5659
{{DTC{27,/ARB/{{{{5660
{{DAC{2,K_ARB{{{{5661
{{DAC{4,NDARB{{{{5662
{{EJC{{{{{5663
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V_ARG{DBC{2,SVFNN{{{ARG{5667
{{DAC{1,3{{{{5668
{{DTC{27,/ARG/{{{{5669
{{DAC{6,S_ARG{{{{5670
{{DAC{1,2{{{{5671
*
{V_BAL{DBC{2,SVKVC{{{BAL{5673
{{DAC{1,3{{{{5674
{{DTC{27,/BAL/{{{{5675
{{DAC{2,K_BAL{{{{5676
{{DAC{4,NDBAL{{{{5677
*
{V_COS{DBC{2,SVFNP{{{COS{5680
{{DAC{1,3{{{{5681
{{DTC{27,/COS/{{{{5682
{{DAC{6,S_COS{{{{5683
{{DAC{1,1{{{{5684
*
{V_END{DBC{2,SVLBL{{{END{5687
{{DAC{1,3{{{{5688
{{DTC{27,/END/{{{{5689
{{DAC{6,L_END{{{{5690
*
{V_EXP{DBC{2,SVFNP{{{EXP{5693
{{DAC{1,3{{{{5694
{{DTC{27,/EXP/{{{{5695
{{DAC{6,S_EXP{{{{5696
{{DAC{1,1{{{{5697
*
{V_LEN{DBC{2,SVFNP{{{LEN{5700
{{DAC{1,3{{{{5701
{{DTC{27,/LEN/{{{{5702
{{DAC{6,S_LEN{{{{5703
{{DAC{1,1{{{{5704
*
{V_LEQ{DBC{2,SVFPR{{{LEQ{5706
{{DAC{1,3{{{{5707
{{DTC{27,/LEQ/{{{{5708
{{DAC{6,S_LEQ{{{{5709
{{DAC{1,2{{{{5710
*
{V_LGE{DBC{2,SVFPR{{{LGE{5712
{{DAC{1,3{{{{5713
{{DTC{27,/LGE/{{{{5714
{{DAC{6,S_LGE{{{{5715
{{DAC{1,2{{{{5716
*
{V_LGT{DBC{2,SVFPR{{{LGT{5718
{{DAC{1,3{{{{5719
{{DTC{27,/LGT/{{{{5720
{{DAC{6,S_LGT{{{{5721
{{DAC{1,2{{{{5722
*
{V_LLE{DBC{2,SVFPR{{{LLE{5724
{{DAC{1,3{{{{5725
{{DTC{27,/LLE/{{{{5726
{{DAC{6,S_LLE{{{{5727
{{DAC{1,2{{{{5728
{{EJC{{{{{5729
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V_LLT{DBC{2,SVFPR{{{LLT{5733
{{DAC{1,3{{{{5734
{{DTC{27,/LLT/{{{{5735
{{DAC{6,S_LLT{{{{5736
{{DAC{1,2{{{{5737
*
{V_LNE{DBC{2,SVFPR{{{LNE{5739
{{DAC{1,3{{{{5740
{{DTC{27,/LNE/{{{{5741
{{DAC{6,S_LNE{{{{5742
{{DAC{1,2{{{{5743
*
{V_POS{DBC{2,SVFNP{{{POS{5745
{{DAC{1,3{{{{5746
{{DTC{27,/POS/{{{{5747
{{DAC{6,S_POS{{{{5748
{{DAC{1,1{{{{5749
*
{V_REM{DBC{2,SVKVC{{{REM{5751
{{DAC{1,3{{{{5752
{{DTC{27,/REM/{{{{5753
{{DAC{2,K_REM{{{{5754
{{DAC{4,NDREM{{{{5755
*
{V_SET{DBC{2,SVFNN{{{SET{5758
{{DAC{1,3{{{{5759
{{DTC{27,/SET/{{{{5760
{{DAC{6,S_SET{{{{5761
{{DAC{1,3{{{{5762
*
{V_SIN{DBC{2,SVFNP{{{SIN{5766
{{DAC{1,3{{{{5767
{{DTC{27,/SIN/{{{{5768
{{DAC{6,S_SIN{{{{5769
{{DAC{1,1{{{{5770
*
{V_TAB{DBC{2,SVFNP{{{TAB{5773
{{DAC{1,3{{{{5774
{{DTC{27,/TAB/{{{{5775
{{DAC{6,S_TAB{{{{5776
{{DAC{1,1{{{{5777
*
{V_TAN{DBC{2,SVFNP{{{TAN{5780
{{DAC{1,3{{{{5781
{{DTC{27,/TAN/{{{{5782
{{DAC{6,S_TAN{{{{5783
{{DAC{1,1{{{{5784
*
{V_ATN{DBC{2,SVFNP{{{ATAN{5796
{{DAC{1,4{{{{5797
{{DTC{27,/ATAN/{{{{5798
{{DAC{6,S_ATN{{{{5799
{{DAC{1,1{{{{5800
*
{V_CAS{DBC{2,SVKNM{{{CASE{5804
{{DAC{1,4{{{{5805
{{DTC{27,/CASE/{{{{5806
{{DAC{2,K_CAS{{{{5807
*
{V_CHR{DBC{2,SVFNP{{{CHAR{5810
{{DAC{1,4{{{{5811
{{DTC{27,/CHAR/{{{{5812
{{DAC{6,S_CHR{{{{5813
{{DAC{1,1{{{{5814
*
*
{V_CHP{DBC{2,SVFNP{{{CHOP{5818
{{DAC{1,4{{{{5819
{{DTC{27,/CHOP/{{{{5820
{{DAC{6,S_CHP{{{{5821
{{DAC{1,1{{{{5822
{V_COD{DBC{2,SVFNK{{{CODE{5824
{{DAC{1,4{{{{5825
{{DTC{27,/CODE/{{{{5826
{{DAC{2,K_COD{{{{5827
{{DAC{6,S_COD{{{{5828
{{DAC{1,1{{{{5829
*
{V_COP{DBC{2,SVFNN{{{COPY{5831
{{DAC{1,4{{{{5832
{{DTC{27,/COPY/{{{{5833
{{DAC{6,S_COP{{{{5834
{{DAC{1,1{{{{5835
{{EJC{{{{{5836
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V_DAT{DBC{2,SVFNN{{{DATA{5840
{{DAC{1,4{{{{5841
{{DTC{27,/DATA/{{{{5842
{{DAC{6,S_DAT{{{{5843
{{DAC{1,1{{{{5844
*
{V_DTE{DBC{2,SVFNN{{{DATE{5846
{{DAC{1,4{{{{5847
{{DTC{27,/DATE/{{{{5848
{{DAC{6,S_DTE{{{{5849
{{DAC{1,1{{{{5850
*
{V_DMP{DBC{2,SVFNK{{{DUMP{5852
{{DAC{1,4{{{{5853
{{DTC{27,/DUMP/{{{{5854
{{DAC{2,K_DMP{{{{5855
{{DAC{6,S_DMP{{{{5856
{{DAC{1,1{{{{5857
*
{V_DUP{DBC{2,SVFNN{{{DUPL{5859
{{DAC{1,4{{{{5860
{{DTC{27,/DUPL/{{{{5861
{{DAC{6,S_DUP{{{{5862
{{DAC{1,2{{{{5863
*
{V_EVL{DBC{2,SVFNN{{{EVAL{5865
{{DAC{1,4{{{{5866
{{DTC{27,/EVAL/{{{{5867
{{DAC{6,S_EVL{{{{5868
{{DAC{1,1{{{{5869
*
{V_EXT{DBC{2,SVFNN{{{EXIT{5873
{{DAC{1,4{{{{5874
{{DTC{27,/EXIT/{{{{5875
{{DAC{6,S_EXT{{{{5876
{{DAC{1,2{{{{5877
*
{V_FAL{DBC{2,SVKVC{{{FAIL{5880
{{DAC{1,4{{{{5881
{{DTC{27,/FAIL/{{{{5882
{{DAC{2,K_FAL{{{{5883
{{DAC{4,NDFAL{{{{5884
*
{V_FIL{DBC{2,SVKNM{{{FILE{5887
{{DAC{1,4{{{{5888
{{DTC{27,/FILE/{{{{5889
{{DAC{2,K_FIL{{{{5890
*
{V_HST{DBC{2,SVFNN{{{HOST{5893
{{DAC{1,4{{{{5894
{{DTC{27,/HOST/{{{{5895
{{DAC{6,S_HST{{{{5896
{{DAC{1,5{{{{5897
{{EJC{{{{{5898
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V_ITM{DBC{2,SVFNF{{{ITEM{5902
{{DAC{1,4{{{{5903
{{DTC{27,/ITEM/{{{{5904
{{DAC{6,S_ITM{{{{5905
{{DAC{1,999{{{{5906
*
{V_LIN{DBC{2,SVKNM{{{LINE{5909
{{DAC{1,4{{{{5910
{{DTC{27,/LINE/{{{{5911
{{DAC{2,K_LIN{{{{5912
*
{V_LOD{DBC{2,SVFNN{{{LOAD{5917
{{DAC{1,4{{{{5918
{{DTC{27,/LOAD/{{{{5919
{{DAC{6,S_LOD{{{{5920
{{DAC{1,2{{{{5921
*
{V_LPD{DBC{2,SVFNP{{{LPAD{5924
{{DAC{1,4{{{{5925
{{DTC{27,/LPAD/{{{{5926
{{DAC{6,S_LPD{{{{5927
{{DAC{1,3{{{{5928
*
{V_RPD{DBC{2,SVFNP{{{RPAD{5930
{{DAC{1,4{{{{5931
{{DTC{27,/RPAD/{{{{5932
{{DAC{6,S_RPD{{{{5933
{{DAC{1,3{{{{5934
*
{V_RPS{DBC{2,SVFNP{{{RPOS{5936
{{DAC{1,4{{{{5937
{{DTC{27,/RPOS/{{{{5938
{{DAC{6,S_RPS{{{{5939
{{DAC{1,1{{{{5940
*
{V_RTB{DBC{2,SVFNP{{{RTAB{5942
{{DAC{1,4{{{{5943
{{DTC{27,/RTAB/{{{{5944
{{DAC{6,S_RTB{{{{5945
{{DAC{1,1{{{{5946
*
{V_SI_{DBC{2,SVFNP{{{SIZE{5948
{{DAC{1,4{{{{5949
{{DTC{27,/SIZE/{{{{5950
{{DAC{6,S_SI_{{{{5951
{{DAC{1,1{{{{5952
*
*
{V_SRT{DBC{2,SVFNN{{{SORT{5957
{{DAC{1,4{{{{5958
{{DTC{27,/SORT/{{{{5959
{{DAC{6,S_SRT{{{{5960
{{DAC{1,2{{{{5961
{V_SPN{DBC{2,SVFNP{{{SPAN{5963
{{DAC{1,4{{{{5964
{{DTC{27,/SPAN/{{{{5965
{{DAC{6,S_SPN{{{{5966
{{DAC{1,1{{{{5967
{{EJC{{{{{5968
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
*
{V_SQR{DBC{2,SVFNP{{{SQRT{5974
{{DAC{1,4{{{{5975
{{DTC{27,/SQRT/{{{{5976
{{DAC{6,S_SQR{{{{5977
{{DAC{1,1{{{{5978
{V_STN{DBC{2,SVKNM{{{STNO{5980
{{DAC{1,4{{{{5981
{{DTC{27,/STNO/{{{{5982
{{DAC{2,K_STN{{{{5983
*
{V_TIM{DBC{2,SVFNN{{{TIME{5985
{{DAC{1,4{{{{5986
{{DTC{27,/TIME/{{{{5987
{{DAC{6,S_TIM{{{{5988
{{DAC{1,0{{{{5989
*
{V_TRM{DBC{2,SVFNK{{{TRIM{5991
{{DAC{1,4{{{{5992
{{DTC{27,/TRIM/{{{{5993
{{DAC{2,K_TRM{{{{5994
{{DAC{6,S_TRM{{{{5995
{{DAC{1,1{{{{5996
*
{V_ABE{DBC{2,SVKNM{{{ABEND{5998
{{DAC{1,5{{{{5999
{{DTC{27,/ABEND/{{{{6000
{{DAC{2,K_ABE{{{{6001
*
{V_ABO{DBC{2,SVKVL{{{ABORT{6003
{{DAC{1,5{{{{6004
{{DTC{27,/ABORT/{{{{6005
{{DAC{2,K_ABO{{{{6006
{{DAC{6,L_ABO{{{{6007
{{DAC{4,NDABO{{{{6008
*
{V_APP{DBC{2,SVFNF{{{APPLY{6010
{{DAC{1,5{{{{6011
{{DTC{27,/APPLY/{{{{6012
{{DAC{6,S_APP{{{{6013
{{DAC{1,999{{{{6014
*
{V_ABN{DBC{2,SVFNP{{{ARBNO{6016
{{DAC{1,5{{{{6017
{{DTC{27,/ARBNO/{{{{6018
{{DAC{6,S_ABN{{{{6019
{{DAC{1,1{{{{6020
*
{V_ARR{DBC{2,SVFNN{{{ARRAY{6022
{{DAC{1,5{{{{6023
{{DTC{27,/ARRAY/{{{{6024
{{DAC{6,S_ARR{{{{6025
{{DAC{1,2{{{{6026
{{EJC{{{{{6027
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V_BRK{DBC{2,SVFNP{{{BREAK{6031
{{DAC{1,5{{{{6032
{{DTC{27,/BREAK/{{{{6033
{{DAC{6,S_BRK{{{{6034
{{DAC{1,1{{{{6035
*
{V_CLR{DBC{2,SVFNN{{{CLEAR{6037
{{DAC{1,5{{{{6038
{{DTC{27,/CLEAR/{{{{6039
{{DAC{6,S_CLR{{{{6040
{{DAC{1,1{{{{6041
*
{V_EJC{DBC{2,SVFNN{{{EJECT{6051
{{DAC{1,5{{{{6052
{{DTC{27,/EJECT/{{{{6053
{{DAC{6,S_EJC{{{{6054
{{DAC{1,1{{{{6055
*
{V_FEN{DBC{2,SVFPK{{{FENCE{6057
{{DAC{1,5{{{{6058
{{DTC{27,/FENCE/{{{{6059
{{DAC{2,K_FEN{{{{6060
{{DAC{6,S_FNC{{{{6061
{{DAC{1,1{{{{6062
{{DAC{4,NDFEN{{{{6063
*
{V_FLD{DBC{2,SVFNN{{{FIELD{6065
{{DAC{1,5{{{{6066
{{DTC{27,/FIELD/{{{{6067
{{DAC{6,S_FLD{{{{6068
{{DAC{1,2{{{{6069
*
{V_IDN{DBC{2,SVFPR{{{IDENT{6071
{{DAC{1,5{{{{6072
{{DTC{27,/IDENT/{{{{6073
{{DAC{6,S_IDN{{{{6074
{{DAC{1,2{{{{6075
*
{V_INP{DBC{2,SVFNK{{{INPUT{6077
{{DAC{1,5{{{{6078
{{DTC{27,/INPUT/{{{{6079
{{DAC{2,K_INP{{{{6080
{{DAC{6,S_INP{{{{6081
{{DAC{1,3{{{{6082
*
{V_LCS{DBC{2,SVKWC{{{LCASE{6085
{{DAC{1,5{{{{6086
{{DTC{27,/LCASE/{{{{6087
{{DAC{2,K_LCS{{{{6088
*
{V_LOC{DBC{2,SVFNN{{{LOCAL{6091
{{DAC{1,5{{{{6092
{{DTC{27,/LOCAL/{{{{6093
{{DAC{6,S_LOC{{{{6094
{{DAC{1,2{{{{6095
{{EJC{{{{{6096
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V_OPS{DBC{2,SVFNN{{{OPSYN{6100
{{DAC{1,5{{{{6101
{{DTC{27,/OPSYN/{{{{6102
{{DAC{6,S_OPS{{{{6103
{{DAC{1,3{{{{6104
*
{V_RMD{DBC{2,SVFNP{{{REMDR{6106
{{DAC{1,5{{{{6107
{{DTC{27,/REMDR/{{{{6108
{{DAC{6,S_RMD{{{{6109
{{DAC{1,2{{{{6110
*
{V_RSR{DBC{2,SVFNN{{{RSORT{6114
{{DAC{1,5{{{{6115
{{DTC{27,/RSORT/{{{{6116
{{DAC{6,S_RSR{{{{6117
{{DAC{1,2{{{{6118
*
{V_TBL{DBC{2,SVFNN{{{TABLE{6121
{{DAC{1,5{{{{6122
{{DTC{27,/TABLE/{{{{6123
{{DAC{6,S_TBL{{{{6124
{{DAC{1,3{{{{6125
*
{V_TRA{DBC{2,SVFNK{{{TRACE{6127
{{DAC{1,5{{{{6128
{{DTC{27,/TRACE/{{{{6129
{{DAC{2,K_TRA{{{{6130
{{DAC{6,S_TRA{{{{6131
{{DAC{1,4{{{{6132
*
{V_UCS{DBC{2,SVKWC{{{UCASE{6135
{{DAC{1,5{{{{6136
{{DTC{27,/UCASE/{{{{6137
{{DAC{2,K_UCS{{{{6138
*
{V_ANC{DBC{2,SVKNM{{{ANCHOR{6141
{{DAC{1,6{{{{6142
{{DTC{27,/ANCHOR/{{{{6143
{{DAC{2,K_ANC{{{{6144
*
{V_BKX{DBC{2,SVFNP{{{BREAKX{6155
{{DAC{1,6{{{{6156
{{DTC{27,/BREAKX/{{{{6157
{{DAC{6,S_BKX{{{{6158
{{DAC{1,1{{{{6159
*
*
{V_DEF{DBC{2,SVFNN{{{DEFINE{6170
{{DAC{1,6{{{{6171
{{DTC{27,/DEFINE/{{{{6172
{{DAC{6,S_DEF{{{{6173
{{DAC{1,2{{{{6174
*
{V_DET{DBC{2,SVFNN{{{DETACH{6176
{{DAC{1,6{{{{6177
{{DTC{27,/DETACH/{{{{6178
{{DAC{6,S_DET{{{{6179
{{DAC{1,1{{{{6180
{{EJC{{{{{6181
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V_DIF{DBC{2,SVFPR{{{DIFFER{6185
{{DAC{1,6{{{{6186
{{DTC{27,/DIFFER/{{{{6187
{{DAC{6,S_DIF{{{{6188
{{DAC{1,2{{{{6189
*
{V_FTR{DBC{2,SVKNM{{{FTRACE{6191
{{DAC{1,6{{{{6192
{{DTC{27,/FTRACE/{{{{6193
{{DAC{2,K_FTR{{{{6194
*
{V_LST{DBC{2,SVKNM{{{LASTNO{6205
{{DAC{1,6{{{{6206
{{DTC{27,/LASTNO/{{{{6207
{{DAC{2,K_LST{{{{6208
*
{V_NAY{DBC{2,SVFNP{{{NOTANY{6210
{{DAC{1,6{{{{6211
{{DTC{27,/NOTANY/{{{{6212
{{DAC{6,S_NAY{{{{6213
{{DAC{1,1{{{{6214
*
{V_OUP{DBC{2,SVFNK{{{OUTPUT{6216
{{DAC{1,6{{{{6217
{{DTC{27,/OUTPUT/{{{{6218
{{DAC{2,K_OUP{{{{6219
{{DAC{6,S_OUP{{{{6220
{{DAC{1,3{{{{6221
*
{V_RET{DBC{2,SVLBL{{{RETURN{6223
{{DAC{1,6{{{{6224
{{DTC{27,/RETURN/{{{{6225
{{DAC{6,L_RTN{{{{6226
*
{V_REW{DBC{2,SVFNN{{{REWIND{6228
{{DAC{1,6{{{{6229
{{DTC{27,/REWIND/{{{{6230
{{DAC{6,S_REW{{{{6231
{{DAC{1,1{{{{6232
*
{V_STT{DBC{2,SVFNN{{{STOPTR{6234
{{DAC{1,6{{{{6235
{{DTC{27,/STOPTR/{{{{6236
{{DAC{6,S_STT{{{{6237
{{DAC{1,2{{{{6238
{{EJC{{{{{6239
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V_SUB{DBC{2,SVFNN{{{SUBSTR{6243
{{DAC{1,6{{{{6244
{{DTC{27,/SUBSTR/{{{{6245
{{DAC{6,S_SUB{{{{6246
{{DAC{1,3{{{{6247
*
{V_UNL{DBC{2,SVFNN{{{UNLOAD{6249
{{DAC{1,6{{{{6250
{{DTC{27,/UNLOAD/{{{{6251
{{DAC{6,S_UNL{{{{6252
{{DAC{1,1{{{{6253
*
{V_COL{DBC{2,SVFNN{{{COLLECT{6255
{{DAC{1,7{{{{6256
{{DTC{27,/COLLECT/{{{{6257
{{DAC{6,S_COL{{{{6258
{{DAC{1,1{{{{6259
*
{V_COM{DBC{2,SVKNM{{{COMPARE{6262
{{DAC{1,7{{{{6263
{{DTC{27,/COMPARE/{{{{6264
{{DAC{2,K_COM{{{{6265
*
{V_CNV{DBC{2,SVFNN{{{CONVERT{6268
{{DAC{1,7{{{{6269
{{DTC{27,/CONVERT/{{{{6270
{{DAC{6,S_CNV{{{{6271
{{DAC{1,2{{{{6272
*
{V_ENF{DBC{2,SVFNN{{{ENDFILE{6274
{{DAC{1,7{{{{6275
{{DTC{27,/ENDFILE/{{{{6276
{{DAC{6,S_ENF{{{{6277
{{DAC{1,1{{{{6278
*
{V_ETX{DBC{2,SVKNM{{{ERRTEXT{6280
{{DAC{1,7{{{{6281
{{DTC{27,/ERRTEXT/{{{{6282
{{DAC{2,K_ETX{{{{6283
*
{V_ERT{DBC{2,SVKNM{{{ERRTYPE{6285
{{DAC{1,7{{{{6286
{{DTC{27,/ERRTYPE/{{{{6287
{{DAC{2,K_ERT{{{{6288
*
{V_FRT{DBC{2,SVLBL{{{FRETURN{6290
{{DAC{1,7{{{{6291
{{DTC{27,/FRETURN/{{{{6292
{{DAC{6,L_FRT{{{{6293
*
{V_INT{DBC{2,SVFPR{{{INTEGER{6295
{{DAC{1,7{{{{6296
{{DTC{27,/INTEGER/{{{{6297
{{DAC{6,S_INT{{{{6298
{{DAC{1,1{{{{6299
*
{V_NRT{DBC{2,SVLBL{{{NRETURN{6301
{{DAC{1,7{{{{6302
{{DTC{27,/NRETURN/{{{{6303
{{DAC{6,L_NRT{{{{6304
{{EJC{{{{{6305
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
*
{V_PFL{DBC{2,SVKNM{{{PROFILE{6312
{{DAC{1,7{{{{6313
{{DTC{27,/PROFILE/{{{{6314
{{DAC{2,K_PFL{{{{6315
*
{V_RPL{DBC{2,SVFNP{{{REPLACE{6318
{{DAC{1,7{{{{6319
{{DTC{27,/REPLACE/{{{{6320
{{DAC{6,S_RPL{{{{6321
{{DAC{1,3{{{{6322
*
{V_RVS{DBC{2,SVFNP{{{REVERSE{6324
{{DAC{1,7{{{{6325
{{DTC{27,/REVERSE/{{{{6326
{{DAC{6,S_RVS{{{{6327
{{DAC{1,1{{{{6328
*
{V_RTN{DBC{2,SVKNM{{{RTNTYPE{6330
{{DAC{1,7{{{{6331
{{DTC{27,/RTNTYPE/{{{{6332
{{DAC{2,K_RTN{{{{6333
*
{V_STX{DBC{2,SVFNN{{{SETEXIT{6335
{{DAC{1,7{{{{6336
{{DTC{27,/SETEXIT/{{{{6337
{{DAC{6,S_STX{{{{6338
{{DAC{1,1{{{{6339
*
{V_STC{DBC{2,SVKNM{{{STCOUNT{6341
{{DAC{1,7{{{{6342
{{DTC{27,/STCOUNT/{{{{6343
{{DAC{2,K_STC{{{{6344
*
{V_STL{DBC{2,SVKNM{{{STLIMIT{6346
{{DAC{1,7{{{{6347
{{DTC{27,/STLIMIT/{{{{6348
{{DAC{2,K_STL{{{{6349
*
{V_SUC{DBC{2,SVKVC{{{SUCCEED{6351
{{DAC{1,7{{{{6352
{{DTC{27,/SUCCEED/{{{{6353
{{DAC{2,K_SUC{{{{6354
{{DAC{4,NDSUC{{{{6355
*
{V_ALP{DBC{2,SVKWC{{{ALPHABET{6357
{{DAC{1,8{{{{6358
{{DTC{27,/ALPHABET/{{{{6359
{{DAC{2,K_ALP{{{{6360
*
{V_CNT{DBC{2,SVLBL{{{CONTINUE{6362
{{DAC{1,8{{{{6363
{{DTC{27,/CONTINUE/{{{{6364
{{DAC{6,L_CNT{{{{6365
{{EJC{{{{{6366
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V_DTP{DBC{2,SVFNP{{{DATATYPE{6370
{{DAC{1,8{{{{6371
{{DTC{27,/DATATYPE/{{{{6372
{{DAC{6,S_DTP{{{{6373
{{DAC{1,1{{{{6374
*
{V_ERL{DBC{2,SVKNM{{{ERRLIMIT{6376
{{DAC{1,8{{{{6377
{{DTC{27,/ERRLIMIT/{{{{6378
{{DAC{2,K_ERL{{{{6379
*
{V_FNC{DBC{2,SVKNM{{{FNCLEVEL{6381
{{DAC{1,8{{{{6382
{{DTC{27,/FNCLEVEL/{{{{6383
{{DAC{2,K_FNC{{{{6384
*
{V_FLS{DBC{2,SVKNM{{{FULLSCAN{6386
{{DAC{1,8{{{{6387
{{DTC{27,/FULLSCAN/{{{{6388
{{DAC{2,K_FLS{{{{6389
*
{V_LFL{DBC{2,SVKNM{{{LASTFILE{6392
{{DAC{1,8{{{{6393
{{DTC{27,/LASTFILE/{{{{6394
{{DAC{2,K_LFL{{{{6395
*
{V_LLN{DBC{2,SVKNM{{{LASTLINE{6399
{{DAC{1,8{{{{6400
{{DTC{27,/LASTLINE/{{{{6401
{{DAC{2,K_LLN{{{{6402
*
{V_MXL{DBC{2,SVKNM{{{MAXLNGTH{6405
{{DAC{1,8{{{{6406
{{DTC{27,/MAXLNGTH/{{{{6407
{{DAC{2,K_MXL{{{{6408
*
{V_TER{DBC{1,0{{{TERMINAL{6410
{{DAC{1,8{{{{6411
{{DTC{27,/TERMINAL/{{{{6412
{{DAC{1,0{{{{6413
*
{V_BSP{DBC{2,SVFNN{{{BACKSPACE{6416
{{DAC{1,9{{{{6417
{{DTC{27,/BACKSPACE/{{{{6418
{{DAC{6,S_BSP{{{{6419
{{DAC{1,1{{{{6420
*
{V_PRO{DBC{2,SVFNN{{{PROTOTYPE{6423
{{DAC{1,9{{{{6424
{{DTC{27,/PROTOTYPE/{{{{6425
{{DAC{6,S_PRO{{{{6426
{{DAC{1,1{{{{6427
*
{V_SCN{DBC{2,SVLBL{{{SCONTINUE{6429
{{DAC{1,9{{{{6430
{{DTC{27,/SCONTINUE/{{{{6431
{{DAC{6,L_SCN{{{{6432
*
{{DBC{1,0{{{DUMMY ENTRY TO END LIST{6434
{{DAC{1,10{{{LENGTH GT 9 (SCONTINUE){6435
{{EJC{{{{{6436
*
*      LIST OF SVBLK POINTERS FOR KEYWORDS TO BE DUMPED. THE
*      LIST IS IN THE ORDER WHICH APPEARS ON THE DUMP OUTPUT.
*
{VDMKW{DAC{4,V_ANC{{{ANCHOR{6441
{{DAC{4,V_CAS{{{CCASE{6443
{{DAC{4,V_COD{{{CODE{6445
{{DAC{1,1{{{COMPARE NOT PRINTED{6450
{{DAC{4,V_DMP{{{DUMP{6453
{{DAC{4,V_ERL{{{ERRLIMIT{6454
{{DAC{4,V_ETX{{{ERRTEXT{6455
{{DAC{4,V_ERT{{{ERRTYPE{6456
{{DAC{4,V_FIL{{{FILE{6458
{{DAC{4,V_FNC{{{FNCLEVEL{6460
{{DAC{4,V_FTR{{{FTRACE{6461
{{DAC{4,V_FLS{{{FULLSCAN{6462
{{DAC{4,V_INP{{{INPUT{6463
{{DAC{4,V_LFL{{{LASTFILE{6465
{{DAC{4,V_LLN{{{LASTLINE{6468
{{DAC{4,V_LST{{{LASTNO{6470
{{DAC{4,V_LIN{{{LINE{6472
{{DAC{4,V_MXL{{{MAXLENGTH{6474
{{DAC{4,V_OUP{{{OUTPUT{6475
{{DAC{4,V_PFL{{{PROFILE{6478
{{DAC{4,V_RTN{{{RTNTYPE{6480
{{DAC{4,V_STC{{{STCOUNT{6481
{{DAC{4,V_STL{{{STLIMIT{6482
{{DAC{4,V_STN{{{STNO{6483
{{DAC{4,V_TRA{{{TRACE{6484
{{DAC{4,V_TRM{{{TRIM{6485
{{DAC{1,0{{{END OF LIST{6486
*
*      TABLE USED BY GTNVR TO SEARCH SVBLK LISTS
*
{VSRCH{DAC{1,0{{{DUMMY ENTRY TO GET PROPER INDEXING{6490
{{DAC{4,V_EQF{{{START OF 1 CHAR VARIABLES (NONE){6491
{{DAC{4,V_EQF{{{START OF 2 CHAR VARIABLES{6492
{{DAC{4,V_ANY{{{START OF 3 CHAR VARIABLES{6493
{{DAC{4,V_ATN{{{START OF 4 CHAR VARIABLES{6495
{{DAC{4,V_ABE{{{START OF 5 CHAR VARIABLES{6503
{{DAC{4,V_ANC{{{START OF 6 CHAR VARIABLES{6504
{{DAC{4,V_COL{{{START OF 7 CHAR VARIABLES{6505
{{DAC{4,V_ALP{{{START OF 8 CHAR VARIABLES{6506
{{DAC{4,V_BSP{{{START OF 9 CHAR VARIABLES{6508
*
*      LAST LOCATION IN CONSTANT SECTION
*
{C_YYY{DAC{1,0{{{LAST LOCATION IN CONSTANT SECTION{6515
{{TTL{27,S P I T B O L -- WORKING STORAGE SECTION{{{{6516
*
*      THE WORKING STORAGE SECTION CONTAINS AREAS WHICH ARE
*      CHANGED DURING EXECUTION OF THE PROGRAM. THE VALUE
*      ASSEMBLED IS THE INITIAL VALUE BEFORE EXECUTION STARTS.
*
*      ALL THESE AREAS ARE FIXED LENGTH AREAS. VARIABLE LENGTH
*      DATA IS STORED IN THE STATIC OR DYNAMIC REGIONS OF THE
*      ALLOCATED DATA AREAS.
*
*      THE VALUES IN THIS AREA ARE DESCRIBED EITHER AS WORK
*      AREAS OR AS GLOBAL VALUES. A WORK AREA IS USED IN AN
*      EPHEMERAL MANNER AND THE VALUE IS NOT SAVED FROM ONE
*      ENTRY INTO A ROUTINE TO ANOTHER. A GLOBAL VALUE IS A
*      LESS TEMPORARY LOCATION WHOSE VALUE IS SAVED FROM ONE
*      CALL TO ANOTHER.
*
*      W_AAA MARKS THE START OF THE WORKING SECTION WHILST
*      W_YYY MARKS ITS END.  G_AAA MARKS THE DIVISION BETWEEN
*      TEMPORARY AND GLOBAL VALUES.
*
*      GLOBAL VALUES ARE FURTHER SUBDIVIDED TO FACILITATE
*      PROCESSING BY THE GARBAGE COLLECTOR. R_AAA THROUGH
*      R_YYY ARE GLOBAL VALUES THAT MAY POINT INTO DYNAMIC
*      STORAGE AND HENCE MUST BE RELOCATED AFTER EACH GARBAGE
*      COLLECTION.  THEY ALSO SERVE AS ROOT POINTERS TO ALL
*      ALLOCATED DATA THAT MUST BE PRESERVED.  POINTERS BETWEEN
*      A_AAA AND R_AAA MAY POINT INTO CODE, STATIC STORAGE,
*      OR MARK THE LIMITS OF DYNAMIC MEMORY.  THESE POINTERS
*      MUST BE ADJUSTED WHEN THE WORKING SECTION IS SAVED TO A
*      FILE AND SUBSEQUENTLY RELOADED AT A DIFFERENT ADDRESS.
*
*      A GENERAL PART OF THE APPROACH IN THIS PROGRAM IS NOT
*      TO OVERLAP WORK AREAS BETWEEN PROCEDURES EVEN THOUGH A
*      SMALL AMOUNT OF SPACE COULD BE SAVED. SUCH OVERLAP IS
*      CONSIDERED A SOURCE OF PROGRAM ERRORS AND DECREASES THE
*      INFORMATION LEFT BEHIND AFTER A SYSTEM CRASH OF ANY KIND.
*
*      THE NAMES OF THESE LOCATIONS ARE LABELS WITH FIVE LETTER
*      (A-Y,_) NAMES. AS FAR AS POSSIBLE THE ORDER IS KEPT
*      ALPHABETICAL BY THESE NAMES BUT IN SOME CASES THERE
*      ARE SLIGHT DEPARTURES CAUSED BY OTHER ORDER REQUIREMENTS.
*
*      UNLESS OTHERWISE DOCUMENTED, THE ORDER OF WORK AREAS
*      DOES NOT AFFECT THE EXECUTION OF THE SPITBOL PROGRAM.
*
{{SEC{{{{START OF WORKING STORAGE SECTION{6562
{{EJC{{{{{6563
*
*      THIS AREA IS NOT CLEARED BY INITIAL CODE
*
{CMLAB{DAC{6,B_SCL{{{STRING USED TO CHECK LABEL LEGALITY{6567
{{DAC{1,2{{{{6568
{{DTC{27,/  /{{{{6569
*
*      LABEL TO MARK START OF WORK AREA
*
{W_AAA{DAC{1,0{{{{6573
*
*      WORK AREAS FOR ACESS PROCEDURE
*
{ACTRM{DAC{1,0{{{TRIM INDICATOR{6577
*
*      WORK AREAS FOR ALLOC PROCEDURE
*
{ALDYN{DAC{1,0{{{AMOUNT OF DYNAMIC STORE{6581
{ALLIA{DIC{16,+0{{{DUMP IA{6582
{ALLSV{DAC{1,0{{{SAVE WB IN ALLOC{6583
*
*      WORK AREAS FOR ALOST PROCEDURE
*
{ALSTA{DAC{1,0{{{SAVE WA IN ALOST{6587
*
*      WORK AREAS FOR ARRAY FUNCTION (S_ARR)
*
{ARCDM{DAC{1,0{{{COUNT DIMENSIONS{6591
{ARNEL{DIC{16,+0{{{COUNT ELEMENTS{6592
{ARPTR{DAC{1,0{{{OFFSET PTR INTO ARBLK{6593
{ARSVL{DIC{16,+0{{{SAVE INTEGER LOW BOUND{6594
{{EJC{{{{{6595
*
*      WORK AREAS FOR ARREF ROUTINE
*
{ARFSI{DIC{16,+0{{{SAVE CURRENT EVOLVING SUBSCRIPT{6599
{ARFXS{DAC{1,0{{{SAVE BASE STACK POINTER{6600
*
*      WORK AREAS FOR B_EFC BLOCK ROUTINE
*
{BEFOF{DAC{1,0{{{SAVE OFFSET PTR INTO EFBLK{6604
*
*      WORK AREAS FOR B_PFC BLOCK ROUTINE
*
{BPFPF{DAC{1,0{{{SAVE PFBLK POINTER{6608
{BPFSV{DAC{1,0{{{SAVE OLD FUNCTION VALUE{6609
{BPFXT{DAC{1,0{{{POINTER TO STACKED ARGUMENTS{6610
*
*      WORK AREA FOR COLLECT FUNCTION (S_COL)
*
{CLSVI{DIC{16,+0{{{SAVE INTEGER ARGUMENT{6614
*
*      WORK AREAS VALUE FOR CNCRD
*
{CNSCC{DAC{1,0{{{POINTER TO CONTROL CARD STRING{6618
{CNSWC{DAC{1,0{{{WORD COUNT{6619
{CNR_T{DAC{1,0{{{POINTER TO R_TTL OR R_STL{6620
*
*      WORK AREAS FOR CONVERT FUNCTION (S_CNV)
*
{CNVTP{DAC{1,0{{{SAVE PTR INTO SCVTB{6624
*
*      WORK AREAS FOR DATA FUNCTION (S_DAT)
*
{DATDV{DAC{1,0{{{SAVE VRBLK PTR FOR DATATYPE NAME{6628
{DATXS{DAC{1,0{{{SAVE INITIAL STACK POINTER{6629
*
*      WORK AREAS FOR DEFINE FUNCTION (S_DEF)
*
{DEFLB{DAC{1,0{{{SAVE VRBLK PTR FOR LABEL{6633
{DEFNA{DAC{1,0{{{COUNT FUNCTION ARGUMENTS{6634
{DEFVR{DAC{1,0{{{SAVE VRBLK PTR FOR FUNCTION NAME{6635
{DEFXS{DAC{1,0{{{SAVE INITIAL STACK POINTER{6636
*
*      WORK AREAS FOR DUMPR PROCEDURE
*
{DMARG{DAC{1,0{{{DUMP ARGUMENT{6640
{DMPSA{DAC{1,0{{{PRESERVE WA OVER PRTVL CALL{6641
{DMPSB{DAC{1,0{{{PRESERVE WB OVER SYSCM CALL{6643
{DMPSV{DAC{1,0{{{GENERAL SCRATCH SAVE{6645
{DMVCH{DAC{1,0{{{CHAIN POINTER FOR VARIABLE BLOCKS{6646
{DMPCH{DAC{1,0{{{SAVE SORTED VRBLK CHAIN POINTER{6647
{DMPKB{DAC{1,0{{{DUMMY KVBLK FOR USE IN DUMPR{6648
{DMPKT{DAC{1,0{{{KVVAR TRBLK PTR (MUST FOLLOW DMPKB){6649
{DMPKN{DAC{1,0{{{KEYWORD NUMBER (MUST FOLLOW DMPKT){6650
*
*      WORK AREA FOR DTACH
*
{DTCNB{DAC{1,0{{{NAME BASE{6654
{DTCNM{DAC{1,0{{{NAME PTR{6655
*
*      WORK AREAS FOR DUPL FUNCTION (S_DUP)
*
{DUPSI{DIC{16,+0{{{STORE INTEGER STRING LENGTH{6659
*
*      WORK AREA FOR ENDFILE (S_ENF)
*
{ENFCH{DAC{1,0{{{FOR IOCHN CHAIN HEAD{6663
{{EJC{{{{{6664
*
*      WORK AREAS FOR ERTEX
*
{ERTWA{DAC{1,0{{{SAVE WA{6668
{ERTWB{DAC{1,0{{{SAVE WB{6669
*
*      WORK AREAS FOR EVALI
*
{EVLIN{DAC{1,0{{{DUMMY PATTERN BLOCK PCODE{6673
{EVLIS{DAC{1,0{{{THEN NODE (MUST FOLLOW EVLIN){6674
{EVLIV{DAC{1,0{{{VALUE OF PARM1 (MUST FOLLOW EVLIS){6675
{EVLIO{DAC{1,0{{{PTR TO ORIGINAL NODE{6676
{EVLIF{DAC{1,0{{{FLAG FOR SIMPLE/COMPLEX ARGUMENT{6677
*
*      WORK AREA FOR EXPAN
*
{EXPSV{DAC{1,0{{{SAVE OP DOPE VECTOR POINTER{6681
*
*      WORK AREAS FOR GBCOL PROCEDURE
*
{GBCFL{DAC{1,0{{{GARBAGE COLLECTOR ACTIVE FLAG{6685
{GBCLM{DAC{1,0{{{POINTER TO LAST MOVE BLOCK (PASS 3){6686
{GBCNM{DAC{1,0{{{DUMMY FIRST MOVE BLOCK{6687
{GBCNS{DAC{1,0{{{REST OF DUMMY BLOCK (FOLLOWS GBCNM){6688
{GBCIA{DIC{16,+0{{{DUMP IA{6694
{GBCSD{DAC{1,0{{{FIRST ADDRESS BEYOND SEDIMENT{6695
{GBCSF{DAC{1,0{{{FREE SPACE WITHIN SEDIMENT{6696
{GBSVA{DAC{1,0{{{SAVE WA{6698
{GBSVB{DAC{1,0{{{SAVE WB{6699
{GBSVC{DAC{1,0{{{SAVE WC{6700
*
*      WORK AREAS FOR GTNVR PROCEDURE
*
{GNVHE{DAC{1,0{{{PTR TO END OF HASH CHAIN{6704
{GNVNW{DAC{1,0{{{NUMBER OF WORDS IN STRING NAME{6705
{GNVSA{DAC{1,0{{{SAVE WA{6706
{GNVSB{DAC{1,0{{{SAVE WB{6707
{GNVSP{DAC{1,0{{{POINTER INTO VSRCH TABLE{6708
{GNVST{DAC{1,0{{{POINTER TO CHARS OF STRING{6709
*
*      WORK AREAS FOR GTARR
*
{GTAWA{DAC{1,0{{{SAVE WA{6713
*
*      WORK AREAS FOR GTINT
*
{GTINA{DAC{1,0{{{SAVE WA{6717
{GTINB{DAC{1,0{{{SAVE WB{6718
{{EJC{{{{{6719
*
*      WORK AREAS FOR GTNUM PROCEDURE
*
{GTNNF{DAC{1,0{{{ZERO/NONZERO FOR RESULT +/-{6723
{GTNSI{DIC{16,+0{{{GENERAL INTEGER SAVE{6724
{GTNDF{DAC{1,0{{{0/1 FOR DEC POINT SO FAR NO/YES{6727
{GTNES{DAC{1,0{{{ZERO/NONZERO EXPONENT +/-{6728
{GTNEX{DIC{16,+0{{{REAL EXPONENT{6729
{GTNSC{DAC{1,0{{{SCALE (PLACES AFTER POINT){6730
{GTNSR{DRC{17,+0.0{{{GENERAL REAL SAVE{6731
{GTNRD{DAC{1,0{{{FLAG FOR OK REAL NUMBER{6732
*
*      WORK AREAS FOR GTPAT PROCEDURE
*
{GTPSB{DAC{1,0{{{SAVE WB{6737
*
*      WORK AREAS FOR GTSTG PROCEDURE
*
{GTSSF{DAC{1,0{{{0/1 FOR RESULT +/-{6741
{GTSVC{DAC{1,0{{{SAVE WC{6742
{GTSVB{DAC{1,0{{{SAVE WB{6743
{GTSES{DAC{1,0{{{CHAR + OR - FOR EXPONENT +/-{6748
{GTSRS{DRC{17,+0.0{{{GENERAL REAL SAVE{6749
*
*      WORK AREAS FOR GTVAR PROCEDURE
*
{GTVRC{DAC{1,0{{{SAVE WC{6755
*
*      WORK AREAS FOR IOPUT
*
{IOPTT{DAC{1,0{{{TYPE OF ASSOCIATION{6770
*
*      WORK AREAS FOR LOAD FUNCTION
*
{LODFN{DAC{1,0{{{POINTER TO VRBLK FOR FUNC NAME{6776
{LODNA{DAC{1,0{{{COUNT NUMBER OF ARGUMENTS{6777
*
*      WORK AREA FOR PROFILER
*
{PFSVW{DAC{1,0{{{TO SAVE A W-REG{6784
*
*      WORK AREAS FOR PRTNM PROCEDURE
*
{PRNSI{DIC{16,+0{{{SCRATCH INTEGER LOC{6789
*
*      WORK AREAS FOR PRTSN PROCEDURE
*
{PRSNA{DAC{1,0{{{SAVE WA{6793
*
*      WORK AREAS FOR PRTST PROCEDURE
*
{PRSVA{DAC{1,0{{{SAVE WA{6797
{PRSVB{DAC{1,0{{{SAVE WB{6798
{PRSVC{DAC{1,0{{{SAVE CHAR COUNTER{6799
*
*      WORK AREA FOR PRTNL
*
{PRTSA{DAC{1,0{{{SAVE WA{6803
{PRTSB{DAC{1,0{{{SAVE WB{6804
*
*      WORK AREA FOR PRTVL
*
{PRVSI{DAC{1,0{{{SAVE IDVAL{6808
*
*      WORK AREAS FOR PATTERN MATCH ROUTINES
*
{PSAVE{DAC{1,0{{{TEMPORARY SAVE FOR CURRENT NODE PTR{6812
{PSAVC{DAC{1,0{{{SAVE CURSOR IN P_SPN, P_STR{6813
*
*      WORK AREA FOR RELAJ ROUTINE
*
{RLALS{DAC{1,0{{{PTR TO LIST OF BOUNDS AND ADJUSTS{6818
*
*      WORK AREA FOR RELDN ROUTINE
*
{RLDCD{DAC{1,0{{{SAVE CODE ADJUSTMENT{6822
{RLDST{DAC{1,0{{{SAVE STATIC ADJUSTMENT{6823
{RLDLS{DAC{1,0{{{SAVE LIST POINTER{6824
*
*      WORK AREAS FOR RETRN ROUTINE
*
{RTNBP{DAC{1,0{{{TO SAVE A BLOCK POINTER{6829
{RTNFV{DAC{1,0{{{NEW FUNCTION VALUE (RESULT){6830
{RTNSV{DAC{1,0{{{OLD FUNCTION VALUE (SAVED VALUE){6831
*
*      WORK AREAS FOR SUBSTR FUNCTION (S_SUB)
*
{SBSSV{DAC{1,0{{{SAVE THIRD ARGUMENT{6835
*
*      WORK AREAS FOR SCAN PROCEDURE
*
{SCNSA{DAC{1,0{{{SAVE WA{6839
{SCNSB{DAC{1,0{{{SAVE WB{6840
{SCNSC{DAC{1,0{{{SAVE WC{6841
{SCNOF{DAC{1,0{{{SAVE OFFSET{6842
{{EJC{{{{{6845
*
*      WORK AREA USED BY SORTA, SORTC, SORTF, SORTH
*
{SRTDF{DAC{1,0{{{DATATYPE FIELD NAME{6849
{SRTFD{DAC{1,0{{{FOUND DFBLK ADDRESS{6850
{SRTFF{DAC{1,0{{{FOUND FIELD NAME{6851
{SRTFO{DAC{1,0{{{OFFSET TO FIELD NAME{6852
{SRTNR{DAC{1,0{{{NUMBER OF ROWS{6853
{SRTOF{DAC{1,0{{{OFFSET WITHIN ROW TO SORT KEY{6854
{SRTRT{DAC{1,0{{{ROOT OFFSET{6855
{SRTS1{DAC{1,0{{{SAVE OFFSET 1{6856
{SRTS2{DAC{1,0{{{SAVE OFFSET 2{6857
{SRTSC{DAC{1,0{{{SAVE WC{6858
{SRTSF{DAC{1,0{{{SORT ARRAY FIRST ROW OFFSET{6859
{SRTSN{DAC{1,0{{{SAVE N{6860
{SRTSO{DAC{1,0{{{OFFSET TO A(0){6861
{SRTSR{DAC{1,0{{{0, NON-ZERO FOR SORT, RSORT{6862
{SRTST{DAC{1,0{{{STRIDE FROM ONE ROW TO NEXT{6863
{SRTWC{DAC{1,0{{{DUMP WC{6864
*
*      WORK AREAS FOR STOPR ROUTINE
*
{STPSI{DIC{16,+0{{{SAVE VALUE OF STCOUNT{6869
{STPTI{DIC{16,+0{{{SAVE TIME ELAPSED{6870
*
*      WORK AREAS FOR TFIND PROCEDURE
*
{TFNSI{DIC{16,+0{{{NUMBER OF HEADERS{6874
*
*      WORK AREAS FOR XSCAN PROCEDURE
*
{XSCRT{DAC{1,0{{{SAVE RETURN CODE{6878
{XSCWB{DAC{1,0{{{SAVE REGISTER WB{6879
*
*      START OF GLOBAL VALUES IN WORKING SECTION
*
{G_AAA{DAC{1,0{{{{6883
*
*      GLOBAL VALUE FOR ALLOC PROCEDURE
*
{ALFSF{DIC{16,+0{{{FACTOR IN FREE STORE PCNTAGE CHECK{6887
*
*      GLOBAL VALUES FOR CMPIL PROCEDURE
*
{CMERC{DAC{1,0{{{COUNT OF INITIAL COMPILE ERRORS{6891
{CMPLN{DAC{1,0{{{LINE NUMBER OF FIRST LINE OF STMT{6892
{CMPXS{DAC{1,0{{{SAVE STACK PTR IN CASE OF ERRORS{6893
{CMPSN{DAC{1,1{{{NUMBER OF NEXT STATEMENT TO COMPILE{6894
*
*      GLOBAL VALUES FOR CNCRD
*
{CNSIL{DAC{1,0{{{SAVE SCNIL DURING INCLUDE PROCESS.{6899
{CNIND{DAC{1,0{{{CURRENT INCLUDE FILE NEST LEVEL{6900
{CNSPT{DAC{1,0{{{SAVE SCNPT DURING INCLUDE PROCESS.{6901
{CNTTL{DAC{1,0{{{FLAG FOR -TITLE, -STITL{6903
*
*      GLOBAL FLAG FOR SUPPRESSION OF COMPILATION STATISTICS.
*
{CPSTS{DAC{1,0{{{SUPPRESS COMP. STATS IF NON ZERO{6907
*
*      GLOBAL VALUES FOR CONTROL CARD SWITCHES
*
{CSWDB{DAC{1,0{{{0/1 FOR -SINGLE/-DOUBLE{6911
{CSWER{DAC{1,0{{{0/1 FOR -ERRORS/-NOERRORS{6912
{CSWEX{DAC{1,0{{{0/1 FOR -EXECUTE/-NOEXECUTE{6913
{CSWFL{DAC{1,1{{{0/1 FOR -NOFAIL/-FAIL{6914
{CSWIN{DAC{2,INILN{{{XXX FOR -INXXX{6915
{CSWLS{DAC{1,1{{{0/1 FOR -NOLIST/-LIST{6916
{CSWNO{DAC{1,0{{{0/1 FOR -OPTIMISE/-NOOPT{6917
{CSWPR{DAC{1,0{{{0/1 FOR -NOPRINT/-PRINT{6918
*
*      GLOBAL LOCATION USED BY PATST PROCEDURE
*
{CTMSK{DBC{1,0{{{LAST BIT POSITION USED IN R_CTP{6922
{CURID{DAC{1,0{{{CURRENT ID VALUE{6923
{{EJC{{{{{6924
*
*      GLOBAL VALUE FOR CDWRD PROCEDURE
*
{CWCOF{DAC{1,0{{{NEXT WORD OFFSET IN CURRENT CCBLK{6928
*
*      GLOBAL LOCATIONS FOR DYNAMIC STORAGE POINTERS
*
{DNAMS{DAC{1,0{{{SIZE OF SEDIMENT IN BAUS{6933
*
*      GLOBAL AREA FOR ERROR PROCESSING.
*
{ERICH{DAC{1,0{{{COPY ERROR REPORTS TO INT.CHAN IF 1{6938
{ERLST{DAC{1,0{{{FOR LISTR WHEN ERRORS GO TO INT.CH.{6939
{ERRFT{DAC{1,0{{{FATAL ERROR FLAG{6940
{ERRSP{DAC{1,0{{{ERROR SUPPRESSION FLAG{6941
*
*      GLOBAL FLAG FOR SUPPRESSION OF EXECUTION STATS
*
{EXSTS{DAC{1,0{{{SUPPRESS EXEC STATS IF SET{6945
*
*      GLOBAL VALUES FOR EXFAL AND RETURN
*
{FLPRT{DAC{1,0{{{LOCATION OF FAIL OFFSET FOR RETURN{6949
{FLPTR{DAC{1,0{{{LOCATION OF FAILURE OFFSET ON STACK{6950
*
*      GLOBAL LOCATION TO COUNT GARBAGE COLLECTIONS (GBCOL)
*
{GBSED{DIC{16,+0{{{FACTOR IN SEDIMENT PCNTAGE CHECK{6955
{GBCNT{DAC{1,0{{{COUNT OF GARBAGE COLLECTIONS{6957
*
*      GLOBAL VALUE FOR GTCOD AND GTEXP
*
{GTCEF{DAC{1,0{{{SAVE FAIL PTR IN CASE OF ERROR{6961
*
*      GLOBAL LOCATIONS FOR GTSTG PROCEDURE
*
{GTSRN{DRC{17,+0.0{{{ROUNDING FACTOR 0.5*10**-CFP_S{6969
{GTSSC{DRC{17,+0.0{{{SCALING VALUE 10**CFP_S{6970
{GTSWK{DAC{1,0{{{PTR TO WORK AREA FOR GTSTG{6973
*
*      GLOBAL FLAG FOR HEADER PRINTING
*
{HEADP{DAC{1,0{{{HEADER PRINTED FLAG{6977
*
*      GLOBAL VALUES FOR VARIABLE HASH TABLE
*
{HSHNB{DIC{16,+0{{{NUMBER OF HASH BUCKETS{6981
*
*      GLOBAL AREAS FOR INIT
*
{INITR{DAC{1,0{{{SAVE TERMINAL FLAG{6985
{{EJC{{{{{6986
*
*      GLOBAL VALUES FOR KEYWORD VALUES WHICH ARE STORED AS ONE
*      WORD INTEGERS. THESE VALUES MUST BE ASSEMBLED IN THE
*      FOLLOWING ORDER (AS DICTATED BY K_XXX DEFINITION VALUES).
*
{KVABE{DAC{1,0{{{ABEND{6992
{KVANC{DAC{1,0{{{ANCHOR{6993
{KVCAS{DAC{1,0{{{CASE{6995
{KVCOD{DAC{1,0{{{CODE{6997
{KVCOM{DAC{1,0{{{COMPARE{6999
{KVDMP{DAC{1,0{{{DUMP{7001
{KVERL{DAC{1,0{{{ERRLIMIT{7002
{KVERT{DAC{1,0{{{ERRTYPE{7003
{KVFTR{DAC{1,0{{{FTRACE{7004
{KVFLS{DAC{1,1{{{FULLSCAN{7005
{KVINP{DAC{1,1{{{INPUT{7006
{KVMXL{DAC{1,5000{{{MAXLENGTH{7007
{KVOUP{DAC{1,1{{{OUTPUT{7008
{KVPFL{DAC{1,0{{{PROFILE{7011
{KVTRA{DAC{1,0{{{TRACE{7013
{KVTRM{DAC{1,0{{{TRIM{7014
{KVFNC{DAC{1,0{{{FNCLEVEL{7015
{KVLST{DAC{1,0{{{LASTNO{7016
{KVLLN{DAC{1,0{{{LASTLINE{7018
{KVLIN{DAC{1,0{{{LINE{7019
{KVSTN{DAC{1,0{{{STNO{7021
*
*      GLOBAL VALUES FOR OTHER KEYWORDS
*
{KVALP{DAC{1,0{{{ALPHABET{7025
{KVRTN{DAC{4,NULLS{{{RTNTYPE (SCBLK POINTER){7026
{KVSTL{DIC{16,+2147483647{{{STLIMIT{7032
{KVSTC{DIC{16,+2147483647{{{STCOUNT (COUNTS DOWN FROM STLIMIT){7033
*
*      GLOBAL VALUES FOR LISTR PROCEDURE
*
{LSTID{DAC{1,0{{{INCLUDE DEPTH OF CURRENT IMAGE{7043
{LSTLC{DAC{1,0{{{COUNT LINES ON SOURCE LIST PAGE{7045
{LSTNP{DAC{1,0{{{MAX NUMBER OF LINES ON PAGE{7046
{LSTPF{DAC{1,1{{{SET NONZERO IF CURRENT IMAGE LISTED{7047
{LSTPG{DAC{1,0{{{CURRENT SOURCE LIST PAGE NUMBER{7048
{LSTPO{DAC{1,0{{{OFFSET TO   PAGE NNN   MESSAGE{7049
{LSTSN{DAC{1,0{{{REMEMBER LAST STMNUM LISTED{7050
*
*      GLOBAL MAXIMUM SIZE OF SPITBOL OBJECTS
*
{MXLEN{DAC{1,0{{{INITIALISED BY SYSMX CALL{7054
*
*      GLOBAL EXECUTION CONTROL VARIABLE
*
{NOXEQ{DAC{1,0{{{SET NON-ZERO TO INHIBIT EXECUTION{7058
*
*      GLOBAL PROFILER VALUES LOCATIONS
*
{PFDMP{DAC{1,0{{{SET NON-0 IF &PROFILE SET NON-0{7064
{PFFNC{DAC{1,0{{{SET NON-0 IF FUNCT JUST ENTERED{7065
{PFSTM{DIC{16,+0{{{TO STORE STARTING TIME OF STMT{7066
{PFETM{DIC{16,+0{{{TO STORE ENDING TIME OF STMT{7067
{PFNTE{DAC{1,0{{{NR OF TABLE ENTRIES{7068
{PFSTE{DIC{16,+0{{{GETS INT REP OF TABLE ENTRY SIZE{7069
*
{{EJC{{{{{7072
*
*      GLOBAL VALUES USED IN PATTERN MATCH ROUTINES
*
{PMDFL{DAC{1,0{{{PATTERN ASSIGNMENT FLAG{7076
{PMHBS{DAC{1,0{{{HISTORY STACK BASE POINTER{7077
{PMSSL{DAC{1,0{{{LENGTH OF SUBJECT STRING IN CHARS{7078
*
*      GLOBAL VALUES FOR INTERFACE POLLING (SYSPL)
*
{POLCS{DAC{1,1{{{POLL INTERVAL START VALUE{7083
{POLCT{DAC{1,1{{{POLL INTERVAL COUNTER{7084
*
*      GLOBAL FLAGS USED FOR STANDARD FILE LISTING OPTIONS
*
{PRICH{DAC{1,0{{{PRINTER ON INTERACTIVE CHANNEL{7089
{PRSTD{DAC{1,0{{{TESTED BY PRTPG{7090
{PRSTO{DAC{1,0{{{STANDARD LISTING OPTION FLAG{7091
*
*      GLOBAL VALUES FOR PRINT PROCEDURES
*
{PRBUF{DAC{1,0{{{PTR TO PRINT BFR IN STATIC{7095
{PRECL{DAC{1,0{{{EXTENDED/COMPACT LISTING FLAG{7096
{PRLEN{DAC{1,0{{{LENGTH OF PRINT BUFFER IN CHARS{7097
{PRLNW{DAC{1,0{{{LENGTH OF PRINT BUFFER IN WORDS{7098
{PROFS{DAC{1,0{{{OFFSET TO NEXT LOCATION IN PRBUF{7099
{PRTEF{DAC{1,0{{{ENDFILE FLAG{7100
{{EJC{{{{{7101
*
*      GLOBAL AREA FOR READR
*
{RDCLN{DAC{1,0{{{CURRENT STATEMENT LINE NUMBER{7105
{RDNLN{DAC{1,0{{{NEXT STATEMENT LINE NUMBER{7106
*
*      GLOBAL AMOUNT OF MEMORY RESERVED FOR END OF EXECUTION
*
{RSMEM{DAC{1,0{{{RESERVE MEMORY{7110
*
*      GLOBAL AREA FOR STMGO COUNTERS
*
{STMCS{DAC{1,1{{{COUNTER STARTUP VALUE{7114
{STMCT{DAC{1,1{{{COUNTER ACTIVE VALUE{7115
*
*      ADJUSTABLE GLOBAL VALUES
*
*      ALL THE POINTERS IN THIS SECTION CAN POINT TO THE
*      DYNAMIC OR THE STATIC REGION.
*      WHEN A SAVE FILE IS RELOADED, THESE POINTERS MUST
*      BE ADJUSTED IF STATIC OR DYNAMIC MEMORY IS NOW
*      AT A DIFFERENT ADDRESS.  SEE ROUTINE RELOC FOR
*      ADDITIONAL INFORMATION.
*
*      SOME VALUES CANNOT BE MOVE HERE BECAUSE OF ADJACENCY
*      CONSTRAINTS.  THEY ARE HANDLED SPECIALLY BY RELOC ET AL.
*      THESE VALUES ARE KVRTN,
*
*      VALUES GTSWK, KVALP, AND PRBUF ARE REINITIALIZED BY
*      PROCEDURE INSTA, AND DO NOT NEED TO APPEAR HERE.
*
*      VALUES FLPRT, FLPTR, GTCEF, AND STBAS POINT INTO THE
*      STACK AND ARE EXPLICITLY ADJUSTED BY OSINT'S RESTART
*      PROCEDURE.
*
{A_AAA{DAC{1,0{{{START OF ADJUSTABLE VALUES{7137
{CMPSS{DAC{1,0{{{SAVE SUBROUTINE STACK PTR{7138
{DNAMB{DAC{1,0{{{START OF DYNAMIC AREA{7139
{DNAMP{DAC{1,0{{{NEXT AVAILABLE LOC IN DYNAMIC AREA{7140
{DNAME{DAC{1,0{{{END OF AVAILABLE DYNAMIC AREA{7141
{HSHTB{DAC{1,0{{{POINTER TO START OF VRBLK HASH TABL{7142
{HSHTE{DAC{1,0{{{POINTER PAST END OF VRBLK HASH TABL{7143
{INISS{DAC{1,0{{{SAVE SUBROUTINE STACK PTR{7144
{PFTBL{DAC{1,0{{{GETS ADRS OF (IMAG) TABLE BASE{7145
{PRNMV{DAC{1,0{{{VRBLK PTR FROM LAST NAME SEARCH{7146
{STATB{DAC{1,0{{{START OF STATIC AREA{7147
{STATE{DAC{1,0{{{END OF STATIC AREA{7148
{STXVR{DAC{4,NULLS{{{VRBLK POINTER OR NULL{7149
*
*      RELOCATABLE GLOBAL VALUES
*
*      ALL THE POINTERS IN THIS SECTION CAN POINT TO BLOCKS IN
*      THE DYNAMIC STORAGE AREA AND MUST BE RELOCATED BY THE
*      GARBAGE COLLECTOR. THEY ARE IDENTIFIED BY R_XXX NAMES.
*
{R_AAA{DAC{1,0{{{START OF RELOCATABLE VALUES{7158
{R_ARF{DAC{1,0{{{ARRAY BLOCK POINTER FOR ARREF{7159
{R_CCB{DAC{1,0{{{PTR TO CCBLK BEING BUILT (CDWRD){7160
{R_CIM{DAC{1,0{{{PTR TO CURRENT COMPILER INPUT STR{7161
{R_CMP{DAC{1,0{{{COPY OF R_CIM USED IN CMPIL{7162
{R_CNI{DAC{1,0{{{PTR TO NEXT COMPILER INPUT STRING{7163
{R_CNT{DAC{1,0{{{CDBLK POINTER FOR SETEXIT CONTINUE{7164
{R_COD{DAC{1,0{{{POINTER TO CURRENT CDBLK OR EXBLK{7165
{R_CTP{DAC{1,0{{{PTR TO CURRENT CTBLK FOR PATST{7166
{R_CTS{DAC{1,0{{{PTR TO LAST STRING SCANNED BY PATST{7167
{R_ERT{DAC{1,0{{{TRBLK POINTER FOR ERRTYPE TRACE{7168
{R_ETX{DAC{4,NULLS{{{POINTER TO ERRTEXT STRING{7169
{R_EXS{DAC{1,0{{{= SAVE XL IN EXPDM{7170
{R_FCB{DAC{1,0{{{FCBLK CHAIN HEAD{7171
{R_FNC{DAC{1,0{{{TRBLK POINTER FOR FNCLEVEL TRACE{7172
{R_GTC{DAC{1,0{{{KEEP CODE PTR FOR GTCOD,GTEXP{7173
{R_ICI{DAC{1,0{{{SAVED R_CIM DURING INCLUDE PROCESS.{7175
{R_IFA{DAC{1,0{{{ARRAY OF FILE NAMES BY INCL. DEPTH{7177
{R_IFL{DAC{1,0{{{ARRAY OF LINE NUMS BY INCLUDE DEPTH{7178
{R_IFN{DAC{1,0{{{LAST INCLUDE FILE NAME{7180
{R_INC{DAC{1,0{{{TABLE OF INCLUDE FILE NAMES SEEN{7181
{R_IO1{DAC{1,0{{{FILE ARG1 FOR IOPUT{7183
{R_IO2{DAC{1,0{{{FILE ARG2 FOR IOPUT{7184
{R_IOF{DAC{1,0{{{FCBLK PTR OR 0{7185
{R_ION{DAC{1,0{{{NAME BASE PTR{7186
{R_IOP{DAC{1,0{{{PREDECESSOR BLOCK PTR FOR IOPUT{7187
{R_IOT{DAC{1,0{{{TRBLK PTR FOR IOPUT{7188
{R_PMS{DAC{1,0{{{SUBJECT STRING PTR IN PATTERN MATCH{7193
{R_RA2{DAC{1,0{{{REPLACE SECOND ARGUMENT LAST TIME{7194
{R_RA3{DAC{1,0{{{REPLACE THIRD ARGUMENT LAST TIME{7195
{R_RPT{DAC{1,0{{{PTR TO CTBLK REPLACE TABLE LAST USD{7196
{R_SCP{DAC{1,0{{{SAVE POINTER FROM LAST SCANE CALL{7197
{R_SFC{DAC{4,NULLS{{{CURRENT SOURCE FILE NAME{7199
{R_SFN{DAC{1,0{{{PTR TO SOURCE FILE NAME TABLE{7200
{R_SXL{DAC{1,0{{{PRESERVE XL IN SORTC{7202
{R_SXR{DAC{1,0{{{PRESERVE XR IN SORTA/SORTC{7203
{R_STC{DAC{1,0{{{TRBLK POINTER FOR STCOUNT TRACE{7204
{R_STL{DAC{1,0{{{SOURCE LISTING SUB-TITLE{7205
{R_SXC{DAC{1,0{{{CODE (CDBLK) PTR FOR SETEXIT TRAP{7206
{R_TTL{DAC{4,NULLS{{{SOURCE LISTING TITLE{7207
{R_XSC{DAC{1,0{{{STRING POINTER FOR XSCAN{7208
{{EJC{{{{{7209
*
*      THE REMAINING POINTERS IN THIS LIST ARE USED TO POINT
*      TO FUNCTION BLOCKS FOR NORMALLY UNDEFINED OPERATORS.
*
{R_UBA{DAC{4,STNDO{{{BINARY AT{7214
{R_UBM{DAC{4,STNDO{{{BINARY AMPERSAND{7215
{R_UBN{DAC{4,STNDO{{{BINARY NUMBER SIGN{7216
{R_UBP{DAC{4,STNDO{{{BINARY PERCENT{7217
{R_UBT{DAC{4,STNDO{{{BINARY NOT{7218
{R_UUB{DAC{4,STNDO{{{UNARY VERTICAL BAR{7219
{R_UUE{DAC{4,STNDO{{{UNARY EQUAL{7220
{R_UUN{DAC{4,STNDO{{{UNARY NUMBER SIGN{7221
{R_UUP{DAC{4,STNDO{{{UNARY PERCENT{7222
{R_UUS{DAC{4,STNDO{{{UNARY SLASH{7223
{R_UUX{DAC{4,STNDO{{{UNARY EXCLAMATION{7224
{R_YYY{DAC{1,0{{{LAST RELOCATABLE LOCATION{7225
*
*      GLOBAL LOCATIONS USED IN SCAN PROCEDURE
*
{SCNBL{DAC{1,0{{{SET NON-ZERO IF SCANNED PAST BLANKS{7229
{SCNCC{DAC{1,0{{{NON-ZERO TO SCAN CONTROL CARD NAME{7230
{SCNGO{DAC{1,0{{{SET NON-ZERO TO SCAN GOTO FIELD{7231
{SCNIL{DAC{1,0{{{LENGTH OF CURRENT INPUT IMAGE{7232
{SCNPT{DAC{1,0{{{POINTER TO NEXT LOCATION IN R_CIM{7233
{SCNRS{DAC{1,0{{{SET NON-ZERO TO SIGNAL RESCAN{7234
{SCNSE{DAC{1,0{{{START OF CURRENT ELEMENT{7235
{SCNTP{DAC{1,0{{{SAVE SYNTAX TYPE FROM LAST CALL{7236
*
*      GLOBAL VALUE FOR INDICATING STAGE (SEE ERROR SECTION)
*
{STAGE{DAC{1,0{{{INITIAL VALUE = INITIAL COMPILE{7240
{{EJC{{{{{7241
*
*      GLOBAL STACK POINTER
*
{STBAS{DAC{1,0{{{POINTER PAST STACK BASE{7245
*
*      GLOBAL VALUES FOR SETEXIT FUNCTION (S_STX)
*
{STXOC{DAC{1,0{{{CODE POINTER OFFSET{7249
{STXOF{DAC{1,0{{{FAILURE OFFSET{7250
*
*      GLOBAL VALUE FOR TIME KEEPING
*
{TIMSX{DIC{16,+0{{{TIME AT START OF EXECUTION{7254
{TIMUP{DAC{1,0{{{SET WHEN TIME UP OCCURS{7255
*
*      GLOBAL VALUES FOR XSCAN AND XSCNI PROCEDURES
*
{XSOFS{DAC{1,0{{{OFFSET TO CURRENT LOCATION IN R_XSC{7259
*
*      LABEL TO MARK END OF WORKING SECTION
*
{W_YYY{DAC{1,0{{{{7263
{{TTL{27,S P I T B O L -- MINIMAL CODE{{{{7264
{{SEC{{{{START OF PROGRAM SECTION{7265
{S_AAA{ENT{2,BL__I{{{MARK START OF CODE{7266
{{TTL{27,S P I T B O L -- RELOCATION{{{{7268
*
*      RELOCATION
*      THE FOLLOWING SECTION PROVIDES SERVICES TO OSINT TO
*      RELOCATE PORTIONS OF THE WORKSPACE.  IT IS USED WHEN
*      A SAVED MEMORY IMAGE MUST BE RESTARTED AT A DIFFERENT
*      LOCATION.
*
*      RELAJ -- RELOCATE A LIST OF POINTERS
*
*      (WA)                  PTR PAST LAST POINTER OF LIST
*      (WB)                  PTR TO FIRST POINTER OF LIST
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELAJ            CALL TO PROCESS LIST OF POINTERS
*      (WB)                  DESTROYED
*
{RELAJ{PRC{25,E{1,0{{ENTRY POINT{7284
{{MOV{11,-(XS){7,XR{{SAVE XR{7285
{{MOV{11,-(XS){8,WA{{SAVE WA{7286
{{MOV{3,RLALS{7,XL{{SAVE PTR TO LIST OF BOUNDS{7287
{{MOV{7,XR{8,WB{{PTR TO FIRST POINTER TO PROCESS{7288
*
*      MERGE HERE TO CHECK IF DONE
*
{RLAJ0{MOV{7,XL{3,RLALS{{RESTORE XL{7292
{{BNE{7,XR{9,(XS){6,RLAJ1{PROCEED IF MORE TO DO{7293
{{MOV{8,WA{10,(XS)+{{RESTORE WA{7294
{{MOV{7,XR{10,(XS)+{{RESTORE XR{7295
{{EXI{{{{RETURN TO CALLER{7296
*
*      MERGE HERE TO PROCESS NEXT POINTER ON LIST
*
{RLAJ1{MOV{8,WA{9,(XR){{LOAD NEXT POINTER ON LIST{7300
{{LCT{8,WB{18,=RNSI_{{NUMBER OF SECTIONS OF ADJUSTERS{7301
*
*      MERGE HERE TO PROCESS NEXT SECTION OF STACK LIST
*
{RLAJ2{BGT{8,WA{13,RLEND(XL){6,RLAJ3{OK IF PAST END OF SECTION{7305
{{BLT{8,WA{13,RLSTR(XL){6,RLAJ3{OR IF BEFORE START OF SECTION{7306
{{ADD{8,WA{13,RLADJ(XL){{WITHIN SECTION, ADD ADJUSTMENT{7307
{{MOV{9,(XR){8,WA{{RETURN UPDATED PTR TO MEMORY{7308
{{BRN{6,RLAJ4{{{DONE WITH THIS POINTER{7309
*
*      HERE IF NOT WITHIN SECTION
*
{RLAJ3{ADD{7,XL{19,*RSSI_{{ADVANCE TO NEXT SECTION{7313
{{BCT{8,WB{6,RLAJ2{{JUMP IF MORE TO GO{7314
*
*      HERE WHEN FINISHED PROCESSING ONE POINTER
*
{RLAJ4{ICA{7,XR{{{INCREMENT TO NEXT PTR ON LIST{7318
{{BRN{6,RLAJ0{{{JUMP TO CHECK  FOR COMPLETION{7319
{{ENP{{{{END PROCEDURE RELAJ{7320
{{EJC{{{{{7321
*
*      RELCR -- CREATE RELOCATION INFO AFTER SAVE FILE RELOAD
*
*      (WA)                  ORIGINAL S_AAA CODE SECTION ADR
*      (WB)                  ORIGINAL C_AAA CONSTANT SECTION ADR
*      (WC)                  ORIGINAL G_AAA WORKING SECTION ADR
*      (XR)                  PTR TO START OF STATIC REGION
*      (CP)                  PTR TO START OF DYNAMIC REGION
*      (XL)                  PTR TO AREA TO RECEIVE INFORMATION
*      JSR  RELCR            CREATE RELOCATION INFORMATION
*      (WA,WB,WC,XR)         DESTROYED
*
*      A BLOCK OF INFORMATION IS BUILT AT (XL) THAT IS USED
*      IN RELOCATING POINTERS.  THERE ARE RNSI_ INSTANCES
*      OF A RSSI_ WORD STRUCTURE.  EACH INSTANCE CORRESPONDS
*      TO ONE OF THE REGIONS THAT A POINTER MIGHT POINT INTO.
*      THE LAYOUT OF THIS STRUCTURE IS SHOWN IN THE DEFINITIONS
*      SECTION, TOGETHER WITH SYMBOLIC DEFINITIONS OF THE
*      ENTRIES AS OFFSETS FROM XL.
*
{RELCR{PRC{25,E{1,0{{ENTRY POINT{7342
{{ADD{7,XL{19,*RLSI_{{POINT PAST BUILD AREA{7343
{{MOV{11,-(XL){8,WA{{SAVE ORIGINAL CODE ADDRESS{7344
{{MOV{8,WA{22,=S_AAA{{COMPUTE ADJUSTMENT{7345
{{SUB{8,WA{9,(XL){{AS NEW S_AAA MINUS ORIGINAL S_AAA{7346
{{MOV{11,-(XL){8,WA{{SAVE CODE ADJUSTMENT{7347
{{MOV{8,WA{22,=S_YYY{{END OF TARGET CODE SECTION{7348
{{SUB{8,WA{22,=S_AAA{{LENGTH OF CODE SECTION{7349
{{ADD{8,WA{13,NUM01(XL){{PLUS ORIGINAL START ADDRESS{7350
{{MOV{11,-(XL){8,WA{{END OF ORIGINAL CODE SECTION{7351
{{MOV{11,-(XL){8,WB{{SAVE CONSTANT SECTION ADDRESS{7352
{{MOV{8,WB{21,=C_AAA{{START OF CONSTANTS SECTION{7353
{{MOV{8,WA{21,=C_YYY{{END OF CONSTANTS SECTION{7354
{{SUB{8,WA{8,WB{{LENGTH OF CONSTANTS SECTION{7355
{{SUB{8,WB{9,(XL){{NEW C_AAA MINUS ORIGINAL C_AAA{7356
{{MOV{11,-(XL){8,WB{{SAVE CONSTANT ADJUSTMENT{7357
{{ADD{8,WA{13,NUM01(XL){{LENGTH PLUS ORIGINAL START ADR{7358
{{MOV{11,-(XL){8,WA{{SAVE AS END OF ORIGINAL CONSTANTS{7359
{{MOV{11,-(XL){8,WC{{SAVE WORKING GLOBALS ADDRESS{7360
{{MOV{8,WC{20,=G_AAA{{START OF WORKING GLOBALS SECTION{7361
{{MOV{8,WA{20,=W_YYY{{END OF WORKING SECTION{7362
{{SUB{8,WA{8,WC{{LENGTH OF WORKING GLOBALS{7363
{{SUB{8,WC{9,(XL){{NEW G_AAA MINUS ORIGINAL G_AAA{7364
{{MOV{11,-(XL){8,WC{{SAVE WORKING GLOBALS ADJUSTMENT{7365
{{ADD{8,WA{13,NUM01(XL){{LENGTH PLUS ORIGINAL START ADR{7366
{{MOV{11,-(XL){8,WA{{SAVE AS END OF WORKING GLOBALS{7367
{{MOV{8,WB{3,STATB{{OLD START OF STATIC REGION{7368
{{MOV{11,-(XL){8,WB{{SAVE{7369
{{SUB{7,XR{8,WB{{COMPUTE ADJUSTMENT{7370
{{MOV{11,-(XL){7,XR{{SAVE NEW STATB MINUS OLD STATB{7371
{{MOV{11,-(XL){3,STATE{{OLD END OF STATIC REGION{7372
{{MOV{8,WB{3,DNAMB{{OLD START OF DYNAMIC REGION{7373
{{MOV{11,-(XL){8,WB{{SAVE{7374
{{SCP{8,WA{{{NEW START OF DYNAMIC{7375
{{SUB{8,WA{8,WB{{COMPUTE ADJUSTMENT{7376
{{MOV{11,-(XL){8,WA{{SAVE NEW DNAMB MINUS OLD DNAMB{7377
{{MOV{8,WC{3,DNAMP{{OLD END OF DYNAMIC REGION IN USE{7378
{{MOV{11,-(XL){8,WC{{SAVE AS END OF OLD DYNAMIC REGION{7379
{{EXI{{{{{7380
{{ENP{{{{{7381
{{EJC{{{{{7382
*
*      RELDN -- RELOCATE POINTERS IN THE DYNAMIC REGION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      (XR)                  PTR TO FIRST LOCATION TO PROCESS
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*      JSR  RELDN            CALL TO PROCESS BLOCKS IN DYNAMIC
*      (WA,WB,WC,XR)         DESTROYED
*
*      PROCESSES ALL BLOCKS IN THE DYNAMIC REGION.  WITHIN A
*      BLOCK, POINTERS TO THE CODE SECTION, CONSTANT SECTION,
*      WORKING GLOBALS SECTION, STATIC REGION, AND DYNAMIC
*      REGION ARE RELOCATED AS NEEDED.
*
{RELDN{PRC{25,E{1,0{{ENTRY POINT{7397
{{MOV{3,RLDCD{13,RLCDA(XL){{SAVE CODE ADJUSTMENT{7398
{{MOV{3,RLDST{13,RLSTA(XL){{SAVE STATIC ADJUSTMENT{7399
{{MOV{3,RLDLS{7,XL{{SAVE LIST POINTER{7400
*
*      MERGE HERE TO PROCESS THE NEXT BLOCK IN DYNAMIC
*
{RLD01{ADD{9,(XR){3,RLDCD{{ADJUST BLOCK TYPE WORD{7404
{{MOV{7,XL{9,(XR){{LOAD BLOCK TYPE WORD{7405
{{LEI{7,XL{{{LOAD ENTRY POINT ID (BL_XX){7406
*
*      BLOCK TYPE SWITCH. NOTE THAT BLOCKS WITH NO RELOCATABLE
*      FIELDS JUST RETURN TO RLD05 TO CONTINUE TO NEXT BLOCK.
*
*      NOTE THAT DFBLKS DO NOT APPEAR IN DYNAMIC, ONLY IN STATIC.
*      CCBLKS AND CMBLKS ARE NOT LIVE WHEN A SAVE FILE IS
*      CREATED, AND CAN BE SKIPPED.
*
*      FURTHER NOTE:  STATIC BLOCKS OTHER THAN VRBLKS DISCOVERED
*      WHILE SCANNING DYNAMIC MUST BE ADJUSTED AT THIS TIME.
*      SEE PROCESSING OF FFBLK FOR EXAMPLE.
*
{{EJC{{{{{7419
*
*      RELDN (CONTINUED)
*
{{BSW{7,XL{2,BL___{{SWITCH ON BLOCK TYPE{7423
{{IFF{2,BL_AR{6,RLD03{{ARBLK{7460
{{IFF{2,BL_CD{6,RLD07{{CDBLK{7460
{{IFF{2,BL_EX{6,RLD10{{EXBLK{7460
{{IFF{2,BL_IC{6,RLD05{{ICBLK{7460
{{IFF{2,BL_NM{6,RLD13{{NMBLK{7460
{{IFF{2,BL_P0{6,RLD13{{P0BLK{7460
{{IFF{2,BL_P1{6,RLD14{{P1BLK{7460
{{IFF{2,BL_P2{6,RLD14{{P2BLK{7460
{{IFF{2,BL_RC{6,RLD05{{RCBLK{7460
{{IFF{2,BL_SC{6,RLD05{{SCBLK{7460
{{IFF{2,BL_SE{6,RLD13{{SEBLK{7460
{{IFF{2,BL_TB{6,RLD17{{TBBLK{7460
{{IFF{2,BL_VC{6,RLD17{{VCBLK{7460
{{IFF{2,BL_XN{6,RLD05{{XNBLK{7460
{{IFF{2,BL_XR{6,RLD20{{XRBLK{7460
{{IFF{2,BL_BC{6,RLD05{{BCBLK - DUMMY TO FILL OUT IFFS{7460
{{IFF{2,BL_PD{6,RLD15{{PDBLK{7460
{{IFF{2,BL_TR{6,RLD19{{TRBLK{7460
{{IFF{2,BL_BF{6,RLD05{{BFBLK{7460
{{IFF{2,BL_CC{6,RLD05{{CCBLK{7460
{{IFF{2,BL_CM{6,RLD05{{CMBLK{7460
{{IFF{2,BL_CT{6,RLD05{{CTBLK{7460
{{IFF{2,BL_DF{6,RLD05{{DFBLK{7460
{{IFF{2,BL_EF{6,RLD08{{EFBLK{7460
{{IFF{2,BL_EV{6,RLD09{{EVBLK{7460
{{IFF{2,BL_FF{6,RLD11{{FFBLK{7460
{{IFF{2,BL_KV{6,RLD13{{KVBLK{7460
{{IFF{2,BL_PF{6,RLD16{{PFBLK{7460
{{IFF{2,BL_TE{6,RLD18{{TEBLK{7460
{{ESW{{{{END OF JUMP TABLE{7460
*
*      ARBLK
*
{RLD03{MOV{8,WA{13,ARLEN(XR){{LOAD LENGTH{7464
{{MOV{8,WB{13,AROFS(XR){{SET OFFSET TO 1ST RELOC FLD (ARPRO){7465
*
*      MERGE HERE TO PROCESS POINTERS IN A BLOCK
*
*      (XR)                  PTR TO CURRENT BLOCK
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*      (WA)                  LENGTH (RELOC FLDS + FLDS AT START)
*      (WB)                  OFFSET TO FIRST RELOC FIELD
*
{RLD04{ADD{8,WA{7,XR{{POINT PAST LAST RELOC FIELD{7474
{{ADD{8,WB{7,XR{{POINT TO FIRST RELOC FIELD{7475
{{MOV{7,XL{3,RLDLS{{POINT TO LIST OF BOUNDS{7476
{{JSR{6,RELAJ{{{ADJUST POINTERS{7477
{{EJC{{{{{7478
*
*      RELDN (CONTINUED)
*
*
*      MERGE HERE TO ADVANCE TO NEXT BLOCK
*
*      (XR)                  PTR TO CURRENT BLOCK
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*
{RLD05{MOV{8,WA{9,(XR){{BLOCK TYPE WORD{7488
{{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{7489
{{ADD{7,XR{8,WA{{POINT TO NEXT BLOCK{7490
{{BLT{7,XR{8,WC{6,RLD01{CONTINUE IF MORE TO PROCESS{7491
{{MOV{7,XL{3,RLDLS{{RESTORE XL{7492
{{EXI{{{{RETURN TO CALLER IF DONE{7493
*
*      CDBLK
*
{RLD07{MOV{8,WA{13,CDLEN(XR){{LOAD LENGTH{7506
{{MOV{8,WB{19,*CDFAL{{SET OFFSET{7507
{{BNE{9,(XR){22,=B_CDC{6,RLD04{JUMP BACK IF NOT COMPLEX GOTO{7508
{{MOV{8,WB{19,*CDCOD{{DO NOT PROCESS CDFAL WORD{7509
{{BRN{6,RLD04{{{JUMP BACK{7510
*
*      EFBLK
*
*      IF THE EFCOD WORD POINTS TO AN XNBLK, THE XNBLK TYPE
*      WORD WILL NOT BE ADJUSTED.  SINCE THIS IS IMPLEMENTATION
*      DEPENDENT, WE WILL NOT WORRY ABOUT IT.
*
{RLD08{MOV{8,WA{19,*EFRSL{{SET LENGTH{7518
{{MOV{8,WB{19,*EFCOD{{AND OFFSET{7519
{{BRN{6,RLD04{{{ALL SET{7520
*
*      EVBLK
*
{RLD09{MOV{8,WA{19,*OFFS3{{POINT PAST THIRD FIELD{7524
{{MOV{8,WB{19,*EVEXP{{SET OFFSET{7525
{{BRN{6,RLD04{{{ALL SET{7526
*
*      EXBLK
*
{RLD10{MOV{8,WA{13,EXLEN(XR){{LOAD LENGTH{7530
{{MOV{8,WB{19,*EXFLC{{SET OFFSET{7531
{{BRN{6,RLD04{{{JUMP BACK{7532
{{EJC{{{{{7533
*
*      RELDN (CONTINUED)
*
*
*      FFBLK
*
*      THIS BLOCK CONTAINS A PTR TO A DFBLK IN THE STATIC RGN.
*      BECAUSE THERE ARE MULTIPLE FFBLKS POINTING TO THE SAME
*      DFBLK (ONE FOR EACH FIELD NAME), WE ONLY PROCESS THE
*      DFBLK WHEN WE ENCOUNTER THE FFBLK FOR THE FIRST FIELD.
*      THE DFBLK IN TURN CONTAINS A POINTER TO AN SCBLK WITHIN
*      STATIC.
*
{RLD11{BNE{13,FFOFS(XR){19,*PDFLD{6,RLD12{SKIP DFBLK IF NOT FIRST FIELD{7547
{{MOV{11,-(XS){7,XR{{SAVE XR{7548
{{MOV{7,XR{13,FFDFP(XR){{LOAD OLD PTR TO DFBLK{7549
{{ADD{7,XR{3,RLDST{{CURRENT LOCATION OF DFBLK{7550
{{ADD{9,(XR){3,RLDCD{{ADJUST DFBLK TYPE WORD{7551
{{MOV{8,WA{13,DFLEN(XR){{LENGTH OF DFBLK{7552
{{MOV{8,WB{19,*DFNAM{{OFFSET TO DFNAM FIELD{7553
{{ADD{8,WA{7,XR{{POINT PAST LAST RELOC FIELD{7554
{{ADD{8,WB{7,XR{{POINT TO FIRST RELOC FIELD{7555
{{MOV{7,XL{3,RLDLS{{POINT TO LIST OF BOUNDS{7556
{{JSR{6,RELAJ{{{ADJUST POINTERS{7557
{{MOV{7,XR{13,DFNAM(XR){{POINTER TO STATIC SCBLK{7558
{{ADD{9,(XR){3,RLDCD{{ADJUST SCBLK TYPE WORD{7559
{{MOV{7,XR{10,(XS)+{{RESTORE FFBLK POINTER{7560
*
*      FFBLK (CONTINUED)
*
*      MERGE HERE TO SET UP FOR ADJUSTMENT OF PTRS IN FFBLK
*
{RLD12{MOV{8,WA{19,*FFOFS{{SET LENGTH{7566
{{MOV{8,WB{19,*FFDFP{{SET OFFSET{7567
{{BRN{6,RLD04{{{ALL SET{7568
*
*      KVBLK, NMBLK, P0BLK, SEBLK
*
{RLD13{MOV{8,WA{19,*OFFS2{{POINT PAST SECOND FIELD{7572
{{MOV{8,WB{19,*OFFS1{{OFFSET IS ONE (ONLY RELOC FLD IS 2){7573
{{BRN{6,RLD04{{{ALL SET{7574
*
*      P1BLK, P2BLK
*
*      IN P2BLKS, PARM2 CONTAINS EITHER A BIT MASK OR THE
*      NAME OFFSET OF A VARIABLE.  IT NEVER REQUIRES RELOCATION.
*
{RLD14{MOV{8,WA{19,*PARM2{{LENGTH (PARM2 IS NON-RELOCATABLE){7581
{{MOV{8,WB{19,*PTHEN{{SET OFFSET{7582
{{BRN{6,RLD04{{{ALL SET{7583
*
*      PDBLK
*
*      NOTE THAT THE DFBLK POINTED TO BY THIS PDBLK WAS
*      PROCESSED WHEN THE FFBLK WAS ENCOUNTERED.  BECAUSE
*      THE DATA FUNCTION WILL BE CALLED BEFORE ANY RECORDS ARE
*      DEFINED, THE FFBLK IS ENCOUNTERED BEFORE ANY
*      CORRESPONDING PDBLK.
*
{RLD15{MOV{7,XL{13,PDDFP(XR){{LOAD PTR TO DFBLK{7593
{{ADD{7,XL{3,RLDST{{ADJUST FOR STATIC RELOCATION{7594
{{MOV{8,WA{13,DFPDL(XL){{GET PDBLK LENGTH{7595
{{MOV{8,WB{19,*PDDFP{{SET OFFSET{7596
{{BRN{6,RLD04{{{ALL SET{7597
{{EJC{{{{{7598
*
*      RELDN (CONTINUED)
*
*
*      PFBLK
*
{RLD16{ADD{13,PFVBL(XR){3,RLDST{{ADJUST NON-CONTIGUOUS FIELD{7605
{{MOV{8,WA{13,PFLEN(XR){{GET PFBLK LENGTH{7606
{{MOV{8,WB{19,*PFCOD{{OFFSET TO FIRST RELOC{7607
{{BRN{6,RLD04{{{ALL SET{7608
*
*      TBBLK, VCBLK
*
{RLD17{MOV{8,WA{13,OFFS2(XR){{LOAD LENGTH{7612
{{MOV{8,WB{19,*OFFS3{{SET OFFSET{7613
{{BRN{6,RLD04{{{JUMP BACK{7614
*
*      TEBLK
*
{RLD18{MOV{8,WA{19,*TESI_{{SET LENGTH{7618
{{MOV{8,WB{19,*TESUB{{AND OFFSET{7619
{{BRN{6,RLD04{{{ALL SET{7620
*
*      TRBLK
*
{RLD19{MOV{8,WA{19,*TRSI_{{SET LENGTH{7624
{{MOV{8,WB{19,*TRVAL{{AND OFFSET{7625
{{BRN{6,RLD04{{{ALL SET{7626
*
*      XRBLK
*
{RLD20{MOV{8,WA{13,XRLEN(XR){{LOAD LENGTH{7630
{{MOV{8,WB{19,*XRPTR{{SET OFFSET{7631
{{BRN{6,RLD04{{{JUMP BACK{7632
{{ENP{{{{END PROCEDURE RELDN{7633
{{EJC{{{{{7634
*
*      RELOC -- RELOCATE STORAGE AFTER SAVE FILE RELOAD
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELOC            RELOCATE ALL POINTERS
*      (WA,WB,WC,XR)         DESTROYED
*
*      THE LIST OF BOUNDARIES AND ADJUSTMENTS POINTED TO BY
*      REGISTER XL IS CREATED BY A CALL TO RELCR, WHICH SHOULD
*      BE CONSULTED FOR INFORMATION ON ITS STRUCTURE.
*
{RELOC{PRC{25,E{1,0{{ENTRY POINT{7646
{{MOV{7,XR{13,RLDYS(XL){{OLD START OF DYNAMIC{7647
{{MOV{8,WC{13,RLDYE(XL){{OLD END OF DYNAMIC{7648
{{ADD{7,XR{13,RLDYA(XL){{CREATE NEW START OF DYNAMIC{7649
{{ADD{8,WC{13,RLDYA(XL){{CREATE NEW END OF DYNAMIC{7650
{{JSR{6,RELDN{{{RELOCATE POINTERS IN DYNAMIC{7651
{{JSR{6,RELWS{{{RELOCATE POINTERS IN WORKING SECT{7652
{{JSR{6,RELST{{{RELOCATE POINTERS IN STATIC{7653
{{EXI{{{{RETURN TO CALLER{7654
{{ENP{{{{END PROCEDURE RELOC{7655
{{EJC{{{{{7656
*
*      RELST -- RELOCATE POINTERS IN THE STATIC REGION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELST            CALL TO PROCESS BLOCKS IN STATIC
*      (WA,WB,WC,XR)         DESTROYED
*
*      ONLY VRBLKS ON THE HASH CHAIN AND ANY PROFILE BLOCK ARE
*      PROCESSED.  OTHER STATIC BLOCKS (DFBLKS) ARE PROCESSED
*      DURING PROCESSING OF DYNAMIC BLOCKS.
*
*      GLOBAL WORK LOCATIONS WILL BE PROCESSED AT THIS POINT,
*      SO POINTERS THERE CAN BE RELIED UPON.
*
{RELST{PRC{25,E{1,0{{ENTRY POINT{7671
{{MOV{7,XR{3,PFTBL{{PROFILE TABLE{7672
{{BZE{7,XR{6,RLS01{{BRANCH IF NO TABLE ALLOCATED{7673
{{ADD{9,(XR){13,RLCDA(XL){{ADJUST BLOCK TYPE WORD{7674
*
*      HERE AFTER DEALING WITH PROFILER
*
{RLS01{MOV{8,WC{3,HSHTB{{POINT TO START OF HASH TABLE{7678
{{MOV{8,WB{8,WC{{POINT TO FIRST HASH BUCKET{7679
{{MOV{8,WA{3,HSHTE{{POINT BEYOND HASH TABLE{7680
{{JSR{6,RELAJ{{{ADJUST BUCKET POINTERS{7681
*
*      LOOP THROUGH SLOTS IN HASH TABLE
*
{RLS02{BEQ{8,WC{3,HSHTE{6,RLS05{DONE IF NONE LEFT{7685
{{MOV{7,XR{8,WC{{ELSE COPY SLOT POINTER{7686
{{ICA{8,WC{{{BUMP SLOT POINTER{7687
{{SUB{7,XR{19,*VRNXT{{SET OFFSET TO MERGE INTO LOOP{7688
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
{RLS03{MOV{7,XR{13,VRNXT(XR){{POINT TO NEXT VRBLK ON CHAIN{7692
{{BZE{7,XR{6,RLS02{{JUMP FOR NEXT BUCKET IF CHAIN END{7693
{{MOV{8,WA{19,*VRLEN{{OFFSET OF FIRST LOC PAST PTR FIELDS{7694
{{MOV{8,WB{19,*VRGET{{OFFSET OF FIRST LOCATION IN VRBLK{7695
{{BNZ{13,VRLEN(XR){6,RLS04{{JUMP IF NOT SYSTEM VARIABLE{7696
{{MOV{8,WA{19,*VRSI_{{OFFSET TO INCLUDE VRSVP FIELD{7697
*
*      MERGE HERE TO PROCESS FIELDS OF VRBLK
*
{RLS04{ADD{8,WA{7,XR{{CREATE END PTR{7701
{{ADD{8,WB{7,XR{{CREATE START PTR{7702
{{JSR{6,RELAJ{{{ADJUST POINTERS IN VRBLK{7703
{{BRN{6,RLS03{{{CHECK FOR ANOTHER VRBLK ON CHAIN{7704
*
*      HERE WHEN ALL VRBLKS PROCESSED
*
{RLS05{EXI{{{{RETURN TO CALLER{7708
{{ENP{{{{END PROCEDURE RELST{7709
{{EJC{{{{{7710
*
*      RELWS -- RELOCATE POINTERS IN THE WORKING SECTION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELWS            CALL TO PROCESS WORKING SECTION
*      (WA,WB,WC,XR)         DESTROYED
*
*      POINTERS BETWEEN A_AAA AND R_YYY ARE EXAMINED AND
*      ADJUSTED IF NECESSARY.  THE POINTER KVRTN IS ALSO
*      ADJUSTED ALTHOUGH IT LIES OUTSIDE THIS RANGE.
*      DNAME IS EXPLICITLY ADJUSTED BECAUSE THE LIMITS
*      ON DYNAMIC REGION IN STACK ARE TO THE AREA ACTIVELY
*      IN USE (BETWEEN DNAMB AND DNAMP), AND DNAME IS OUTSIDE
*      THIS RANGE.
*
{RELWS{PRC{25,E{1,0{{ENTRY POINT{7726
{{MOV{8,WB{20,=A_AAA{{POINT TO START OF ADJUSTABLES{7727
{{MOV{8,WA{20,=R_YYY{{POINT TO END OF ADJUSTABLES{7728
{{JSR{6,RELAJ{{{RELOCATE ADJUSTABLE POINTERS{7729
{{ADD{3,DNAME{13,RLDYA(XL){{ADJUST PTR MISSED BY RELAJ{7730
{{MOV{8,WB{20,=KVRTN{{CASE OF KVRTN{7731
{{MOV{8,WA{8,WB{{HANDLED SPECIALLY{7732
{{ICA{8,WA{{{ONE VALUE TO ADJUST{7733
{{JSR{6,RELAJ{{{ADJUST KVRTN{7734
{{EXI{{{{RETURN TO CALLER{7735
{{ENP{{{{END PROCEDURE RELWS{7736
{{TTL{27,S P I T B O L -- INITIALIZATION{{{{7738
*
*      INITIALISATION
*      THE FOLLOWING SECTION RECEIVES CONTROL FROM THE SYSTEM
*      AT THE START OF A RUN WITH THE REGISTERS SET AS FOLLOWS.
*
*      (WA)                  INITIAL STACK POINTER
*      (XR)                  POINTS TO FIRST WORD OF DATA AREA
*      (XL)                  POINTS TO LAST WORD OF DATA AREA
*
{START{PRC{25,E{1,0{{ENTRY POINT{7748
*Z-
{{MOV{7,XS{8,WA{{DISCARD RETURN{7750
{{JSR{6,SYSTM{{{INITIALISE TIMER{7751
{{STI{3,TIMSX{{{STORE TIME{7753
{{MOV{3,STATB{7,XR{{START ADDRESS OF STATIC{7754
{{MOV{3,RSMEM{19,*E_SRS{{RESERVE MEMORY{7806
{{MOV{3,STBAS{7,XS{{STORE STACK BASE{7807
{{SSS{3,INISS{{{SAVE S-R STACK PTR{7808
*
*      NOW CONVERT FREE STORE PERCENTAGE TO A SUITABLE FACTOR
*      FOR EASY TESTING IN ALLOC ROUTINE.
*
{{LDI{4,INTVH{{{GET 100{7813
{{DVI{4,ALFSP{{{FORM 100 / ALFSP{7814
{{STI{3,ALFSF{{{STORE THE FACTOR{7815
*
*      NOW CONVERT FREE SEDIMENT PERCENTAGE TO A SUITABLE FACTOR
*      FOR EASY TESTING IN GBCOL ROUTINE.
*
{{LDI{4,INTVH{{{GET 100{7821
{{DVI{4,GBSDP{{{FORM 100 / GBSDP{7822
{{STI{3,GBSED{{{STORE THE FACTOR{7823
*
*      INITIALIZE VALUES FOR REAL CONVERSION ROUTINE
*
{{LCT{8,WB{18,=CFP_S{{LOAD COUNTER FOR SIGNIFICANT DIGITS{7832
{{LDR{4,REAV1{{{LOAD 1.0{7833
*
*      LOOP TO COMPUTE 10**(MAX NUMBER SIGNIFICANT DIGITS)
*
{INI03{MLR{4,REAVT{{{* 10.0{7837
{{BCT{8,WB{6,INI03{{LOOP TILL DONE{7838
{{STR{3,GTSSC{{{STORE 10**(MAX SIG DIGITS){7839
{{LDR{4,REAP5{{{LOAD 0.5{7840
{{DVR{3,GTSSC{{{COMPUTE 0.5*10**(MAX SIG DIGITS){7841
{{STR{3,GTSRN{{{STORE AS ROUNDING BIAS{7842
{{ZER{8,WC{{{SET TO READ PARAMETERS{7845
{{JSR{6,PRPAR{{{READ THEM{7846
{{EJC{{{{{7847
*
*      NOW COMPUTE STARTING ADDRESS FOR DYNAMIC STORE AND IF
*      NECESSARY REQUEST MORE MEMORY.
*
{{SUB{7,XL{19,*E_SRS{{ALLOW FOR RESERVE MEMORY{7852
{{MOV{8,WA{3,PRLEN{{GET PRINT BUFFER LENGTH{7853
{{ADD{8,WA{18,=CFP_A{{ADD NO. OF CHARS IN ALPHABET{7854
{{ADD{8,WA{18,=NSTMX{{ADD CHARS FOR GTSTG BFR{7855
{{CTB{8,WA{1,8{{CONVERT TO BYTES, ALLOWING A MARGIN{7856
{{MOV{7,XR{3,STATB{{POINT TO STATIC BASE{7857
{{ADD{7,XR{8,WA{{INCREMENT FOR ABOVE BUFFERS{7858
{{ADD{7,XR{19,*E_HNB{{INCREMENT FOR HASH TABLE{7859
{{ADD{7,XR{19,*E_STS{{BUMP FOR INITIAL STATIC BLOCK{7860
{{JSR{6,SYSMX{{{GET MXLEN{7861
{{MOV{3,KVMXL{8,WA{{PROVISIONALLY STORE AS MAXLNGTH{7862
{{MOV{3,MXLEN{8,WA{{AND AS MXLEN{7863
{{BGT{7,XR{8,WA{6,INI06{SKIP IF STATIC HI EXCEEDS MXLEN{7864
{{CTB{8,WA{1,1{{ROUND UP AND MAKE BIGGER THAN MXLEN{7865
{{MOV{7,XR{8,WA{{USE IT INSTEAD{7866
*
*      HERE TO STORE VALUES WHICH MARK INITIAL DIVISION
*      OF DATA AREA INTO STATIC AND DYNAMIC
*
{INI06{MOV{3,DNAMB{7,XR{{DYNAMIC BASE ADRS{7871
{{MOV{3,DNAMP{7,XR{{DYNAMIC PTR{7872
{{BNZ{8,WA{6,INI07{{SKIP IF NON-ZERO MXLEN{7873
{{DCA{7,XR{{{POINT A WORD IN FRONT{7874
{{MOV{3,KVMXL{7,XR{{USE AS MAXLNGTH{7875
{{MOV{3,MXLEN{7,XR{{AND AS MXLEN{7876
{{EJC{{{{{7877
*
*      LOOP HERE IF NECESSARY TILL ENOUGH MEMORY OBTAINED
*      SO THAT DNAME IS ABOVE DNAMB
*
{INI07{MOV{3,DNAME{7,XL{{STORE DYNAMIC END ADDRESS{7882
{{BLT{3,DNAMB{7,XL{6,INI09{SKIP IF HIGH ENOUGH{7883
{{JSR{6,SYSMM{{{REQUEST MORE MEMORY{7884
{{WTB{7,XR{{{GET AS BAUS (SGD05){7885
{{ADD{7,XL{7,XR{{BUMP BY AMOUNT OBTAINED{7886
{{BNZ{7,XR{6,INI07{{TRY AGAIN{7887
{{MOV{8,WA{18,=MXERN{{INSUFFICIENT MEMORY FOR MAXLENGTH{7889
{{ZER{8,WB{{{NO COLUMN NUMBER INFO{7890
{{ZER{8,WC{{{NO LINE NUMBER INFO{7891
{{MOV{7,XR{18,=STGIC{{INITIAL COMPILE STAGE{7892
{{MOV{7,XL{21,=NULLS{{NO FILE NAME{7894
{{JSR{6,SYSEA{{{ADVISE OF ERROR{7896
{{PPM{6,INI08{{{CANT USE ERROR LOGIC YET{7897
{{BRN{6,INI08{{{FORCE TERMINATION{7898
*
*      INSERT TEXT FOR ERROR 329 IN ERROR MESSAGE TABLE
*
{{ERB{1,329{26,Requested MAXLNGTH too large{{{7902
{INI08{MOV{7,XR{21,=ENDMO{{POINT TO FAILURE MESSAGE{7904
{{MOV{8,WA{4,ENDML{{MESSAGE LENGTH{7905
{{JSR{6,SYSPR{{{PRINT IT (PRTST NOT YET USABLE){7906
{{PPM{{{{SHOULD NOT FAIL{7907
{{ZER{7,XL{{{NO FCB CHAIN YET{7908
{{MOV{8,WB{18,=NUM10{{SET SPECIAL CODE VALUE{7909
{{JSR{6,SYSEJ{{{PACK UP (STOPR NOT YET USABLE){7910
*
*      INITIALISE STRUCTURES AT START OF STATIC REGION
*
{INI09{MOV{7,XR{3,STATB{{POINT TO STATIC AGAIN{7914
{{JSR{6,INSTA{{{INITIALIZE STATIC{7915
*
*      INITIALIZE NUMBER OF HASH HEADERS
*
{{MOV{8,WA{18,=E_HNB{{GET NUMBER OF HASH HEADERS{7919
{{MTI{8,WA{{{CONVERT TO INTEGER{7920
{{STI{3,HSHNB{{{STORE FOR USE BY GTNVR PROCEDURE{7921
{{LCT{8,WA{8,WA{{COUNTER FOR CLEARING HASH TABLE{7922
{{MOV{3,HSHTB{7,XR{{POINTER TO HASH TABLE{7923
*
*      LOOP TO CLEAR HASH TABLE
*
{INI11{ZER{10,(XR)+{{{BLANK A WORD{7927
{{BCT{8,WA{6,INI11{{LOOP{7928
{{MOV{3,HSHTE{7,XR{{END OF HASH TABLE ADRS IS KEPT{7929
{{MOV{3,STATE{7,XR{{STORE STATIC END ADDRESS{7930
*
*      INIT TABLE TO MAP STATEMENT NUMBERS TO SOURCE FILE NAMES
*
{{MOV{8,WC{18,=NUM01{{TABLE WILL HAVE ONLY ONE BUCKET{7935
{{MOV{7,XL{21,=NULLS{{DEFAULT TABLE VALUE{7936
{{MOV{3,R_SFC{7,XL{{CURRENT SOURCE FILE NAME{7937
{{JSR{6,TMAKE{{{CREATE TABLE{7938
{{MOV{3,R_SFN{7,XR{{SAVE PTR TO TABLE{7939
*
*      INITIALIZE TABLE TO DETECT DUPLICATE INCLUDE FILE NAMES
*
{{MOV{8,WC{18,=NUM01{{TABLE WILL HAVE ONLY ONE BUCKET{7945
{{MOV{7,XL{21,=NULLS{{DEFAULT TABLE VALUE{7946
{{JSR{6,TMAKE{{{CREATE TABLE{7947
{{MOV{3,R_INC{7,XR{{SAVE PTR TO TABLE{7948
*
*      INITIALIZE ARRAY TO HOLD NAMES OF NESTED INCLUDE FILES
*
{{MOV{8,WA{18,=CCINM{{MAXIMUM NESTING LEVEL{7953
{{MOV{7,XL{21,=NULLS{{NULL STRING DEFAULT VALUE{7954
{{JSR{6,VMAKE{{{CREATE ARRAY{7955
{{PPM{{{{{7956
{{MOV{3,R_IFA{7,XR{{SAVE PTR TO ARRAY{7957
*
*      INIT ARRAY TO HOLD LINE NUMBERS OF NESTED INCLUDE FILES
*
{{MOV{8,WA{18,=CCINM{{MAXIMUM NESTING LEVEL{7961
{{MOV{7,XL{21,=INTON{{INTEGER ONE DEFAULT VALUE{7962
{{JSR{6,VMAKE{{{CREATE ARRAY{7963
{{PPM{{{{{7964
{{MOV{3,R_IFL{7,XR{{SAVE PTR TO ARRAY{7965
*Z+
*
*      INITIALIZE VARIABLE BLOCKS FOR INPUT AND OUTPUT
*
{{MOV{7,XL{21,=V_INP{{POINT TO STRING /INPUT/{7972
{{MOV{8,WB{18,=TRTIN{{TRBLK TYPE FOR INPUT{7973
{{JSR{6,INOUT{{{PERFORM INPUT ASSOCIATION{7974
{{MOV{7,XL{21,=V_OUP{{POINT TO STRING /OUTPUT/{7975
{{MOV{8,WB{18,=TRTOU{{TRBLK TYPE FOR OUTPUT{7976
{{JSR{6,INOUT{{{PERFORM OUTPUT ASSOCIATION{7977
{{MOV{8,WC{3,INITR{{TERMINAL FLAG{7978
{{BZE{8,WC{6,INI13{{SKIP IF NO TERMINAL{7979
{{JSR{6,PRPAR{{{ASSOCIATE TERMINAL{7980
{{EJC{{{{{7981
*
*      CHECK FOR EXPIRY DATE
*
{INI13{JSR{6,SYSDC{{{CALL DATE CHECK{7985
{{MOV{3,FLPTR{7,XS{{IN CASE STACK OVERFLOWS IN COMPILER{7986
*
*      NOW COMPILE SOURCE INPUT CODE
*
{{JSR{6,CMPIL{{{CALL COMPILER{7990
{{MOV{3,R_COD{7,XR{{SET PTR TO FIRST CODE BLOCK{7991
{{MOV{3,R_TTL{21,=NULLS{{FORGET TITLE{7992
{{MOV{3,R_STL{21,=NULLS{{FORGET SUB-TITLE{7993
{{ZER{3,R_CIM{{{FORGET COMPILER INPUT IMAGE{7994
{{ZER{3,R_CCB{{{FORGET INTERIM CODE BLOCK{7995
{{ZER{3,CNIND{{{IN CASE END OCCURRED WITH INCLUDE{7997
{{ZER{3,LSTID{{{LISTING INCLUDE DEPTH{7998
{{ZER{7,XL{{{CLEAR DUD VALUE{8000
{{ZER{8,WB{{{DONT SHIFT DYNAMIC STORE UP{8001
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{8003
{{JSR{6,GBCOL{{{CLEAR GARBAGE LEFT FROM COMPILE{8004
{{MOV{3,DNAMS{7,XR{{RECORD NEW SEDIMENT SIZE{8005
{{BNZ{3,CPSTS{6,INIX0{{SKIP IF NO LISTING OF COMP STATS{8009
{{JSR{6,PRTPG{{{EJECT PAGE{8010
*
*      PRINT COMPILE STATISTICS
*
{{JSR{6,PRTMM{{{PRINT MEMORY USAGE{8014
{{MTI{3,CMERC{{{GET COUNT OF ERRORS AS INTEGER{8015
{{MOV{7,XR{21,=ENCM3{{POINT TO /COMPILE ERRORS/{8016
{{JSR{6,PRTMI{{{PRINT IT{8017
{{MTI{3,GBCNT{{{GARBAGE COLLECTION COUNT{8018
{{SBI{4,INTV1{{{ADJUST FOR UNAVOIDABLE COLLECT{8019
{{MOV{7,XR{21,=STPM5{{POINT TO /STORAGE REGENERATIONS/{8020
{{JSR{6,PRTMI{{{PRINT GBCOL COUNT{8021
{{JSR{6,SYSTM{{{GET TIME{8022
{{SBI{3,TIMSX{{{GET COMPILATION TIME{8023
{{MOV{7,XR{21,=ENCM4{{POINT TO COMPILATION TIME (MSEC)/{8024
{{JSR{6,PRTMI{{{PRINT MESSAGE{8025
{{ADD{3,LSTLC{18,=NUM05{{BUMP LINE COUNT{8026
{{BZE{3,HEADP{6,INIX0{{NO EJECT IF NOTHING PRINTED{8028
{{JSR{6,PRTPG{{{EJECT PRINTER{8029
{{EJC{{{{{8031
*
*      PREPARE NOW TO START EXECUTION
*
*      SET DEFAULT INPUT RECORD LENGTH
*
{INIX0{BGT{3,CSWIN{18,=INILN{6,INIX1{SKIP IF NOT DEFAULT -IN72 USED{8037
{{MOV{3,CSWIN{18,=INILS{{ELSE USE DEFAULT RECORD LENGTH{8038
*
*      RESET TIMER
*
{INIX1{JSR{6,SYSTM{{{GET TIME AGAIN{8042
{{STI{3,TIMSX{{{STORE FOR END RUN PROCESSING{8043
{{ZER{3,GBCNT{{{INITIALISE COLLECT COUNT{8044
{{JSR{6,SYSBX{{{CALL BEFORE STARTING EXECUTION{8045
{{ADD{3,NOXEQ{3,CSWEX{{ADD -NOEXECUTE FLAG{8046
{{BNZ{3,NOXEQ{6,INIX2{{JUMP IF EXECUTION SUPPRESSED{8047
*
*      MERGE WHEN LISTING FILE SET FOR EXECUTION.  ALSO
*      MERGE HERE WHEN RESTARTING A SAVE FILE OR LOAD MODULE.
*
{INIY0{MNZ{3,HEADP{{{MARK HEADERS OUT REGARDLESS{8057
{{ZER{11,-(XS){{{SET FAILURE LOCATION ON STACK{8058
{{MOV{3,FLPTR{7,XS{{SAVE PTR TO FAILURE OFFSET WORD{8059
{{MOV{7,XR{3,R_COD{{LOAD PTR TO ENTRY CODE BLOCK{8060
{{MOV{3,STAGE{18,=STGXT{{SET STAGE FOR EXECUTE TIME{8061
{{MOV{3,POLCS{18,=NUM01{{RESET INTERFACE POLLING INTERVAL{8063
{{MOV{3,POLCT{18,=NUM01{{RESET INTERFACE POLLING INTERVAL{8064
{{MOV{3,PFNTE{3,CMPSN{{COPY STMTS COMPILED COUNT IN CASE{8068
{{MOV{3,PFDMP{3,KVPFL{{START PROFILING IF &PROFILE SET{8069
{{JSR{6,SYSTM{{{TIME YET AGAIN{8070
{{STI{3,PFSTM{{{{8071
{{JSR{6,STGCC{{{COMPUTE STMGO COUNTDOWN COUNTERS{8073
{{BRI{9,(XR){{{START XEQ WITH FIRST STATEMENT{8074
*
*      HERE IF EXECUTION IS SUPPRESSED
*
{INIX2{ZER{8,WA{{{SET ABEND VALUE TO ZERO{8079
{{MOV{8,WB{18,=NINI9{{SET SPECIAL CODE VALUE{8087
{{ZER{7,XL{{{NO FCB CHAIN{8088
{{JSR{6,SYSEJ{{{END OF JOB, EXIT TO SYSTEM{8089
{{ENP{{{{END PROCEDURE START{8090
*
*      HERE FROM OSINT TO RESTART A SAVE FILE OR LOAD MODULE.
*
{RSTRT{PRC{25,E{1,0{{ENTRY POINT{8094
{{MOV{7,XS{3,STBAS{{DISCARD RETURN{8095
{{ZER{7,XL{{{CLEAR XL{8096
{{BRN{6,INIY0{{{RESUME EXECUTION{8097
{{ENP{{{{END PROCEDURE RSTRT{8098
{{TTL{27,S P I T B O L -- SNOBOL4 OPERATOR ROUTINES{{{{8100
*
*      THIS SECTION INCLUDES ALL ROUTINES WHICH CAN BE ACCESSED
*      DIRECTLY FROM THE GENERATED CODE EXCEPT SYSTEM FUNCTIONS.
*
*      ALL ROUTINES IN THIS SECTION START WITH A LABEL OF THE
*      FORM O_XXX WHERE XXX IS THREE LETTERS. THE GENERATED CODE
*      CONTAINS A POINTER TO THE APPROPRIATE ENTRY LABEL.
*
*      SINCE THE GENERAL FORM OF THE GENERATED CODE CONSISTS OF
*      POINTERS TO BLOCKS WHOSE FIRST WORD IS THE ADDRESS OF THE
*      ACTUAL ENTRY POINT LABEL (O_XXX).
*
*      THESE ROUTINES ARE IN ALPHABETICAL ORDER BY THEIR
*      ENTRY LABEL NAMES (I.E. BY THE XXX OF THE O_XXX NAME)
*
*      THESE ROUTINES RECEIVE CONTROL AS FOLLOWS
*
*      (CP)                  POINTER TO NEXT CODE WORD
*      (XS)                  CURRENT STACK POINTER
{{EJC{{{{{8120
*
*      BINARY PLUS (ADDITION)
*
{O_ADD{ENT{{{{ENTRY POINT{8124
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{8125
{{ERR{1,001{26,Addition left operand is not numeric{{{8126
{{ERR{1,002{26,Addition right operand is not numeric{{{8127
{{PPM{6,OADD1{{{JUMP IF REAL OPERANDS{8130
*
*      HERE TO ADD TWO INTEGERS
*
{{ADI{13,ICVAL(XL){{{ADD RIGHT OPERAND TO LEFT{8135
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{8136
{{ERB{1,003{26,Addition caused integer overflow{{{8137
*
*      HERE TO ADD TWO REALS
*
{OADD1{ADR{13,RCVAL(XL){{{ADD RIGHT OPERAND TO LEFT{8143
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{8144
{{ERB{1,261{26,Addition caused real overflow{{{8145
{{EJC{{{{{8147
*
*      UNARY PLUS (AFFIRMATION)
*
{O_AFF{ENT{{{{ENTRY POINT{8151
{{MOV{7,XR{10,(XS)+{{LOAD OPERAND{8152
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{8153
{{ERR{1,004{26,Affirmation operand is not numeric{{{8154
{{MOV{11,-(XS){7,XR{{RESULT IF CONVERTED TO NUMERIC{8155
{{LCW{7,XR{{{GET NEXT CODE WORD{8156
{{BRI{9,(XR){{{EXECUTE IT{8157
{{EJC{{{{{8158
*
*      BINARY BAR (ALTERNATION)
*
{O_ALT{ENT{{{{ENTRY POINT{8162
{{MOV{7,XR{10,(XS)+{{LOAD RIGHT OPERAND{8163
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{8164
{{ERR{1,005{26,Alternation right operand is not pattern{{{8165
*
*      MERGE HERE FROM SPECIAL (LEFT ALTERNATION) CASE
*
{OALT1{MOV{8,WB{22,=P_ALT{{SET PCODE FOR ALTERNATIVE NODE{8169
{{JSR{6,PBILD{{{BUILD ALTERNATIVE NODE{8170
{{MOV{7,XL{7,XR{{SAVE ADDRESS OF ALTERNATIVE NODE{8171
{{MOV{7,XR{10,(XS)+{{LOAD LEFT OPERAND{8172
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{8173
{{ERR{1,006{26,Alternation left operand is not pattern{{{8174
{{BEQ{7,XR{22,=P_ALT{6,OALT2{JUMP IF LEFT ARG IS ALTERNATION{8175
{{MOV{13,PTHEN(XL){7,XR{{SET LEFT OPERAND AS SUCCESSOR{8176
{{MOV{11,-(XS){7,XL{{STACK RESULT{8177
{{LCW{7,XR{{{GET NEXT CODE WORD{8178
{{BRI{9,(XR){{{EXECUTE IT{8179
*
*      COME HERE IF LEFT ARGUMENT IS ITSELF AN ALTERNATION
*
*      THE RESULT IS MORE EFFICIENT IF WE MAKE THE REPLACEMENT
*
*      (A / B) / C = A / (B / C)
*
{OALT2{MOV{13,PTHEN(XL){13,PARM1(XR){{BUILD THE (B / C) NODE{8187
{{MOV{11,-(XS){13,PTHEN(XR){{SET A AS NEW LEFT ARG{8188
{{MOV{7,XR{7,XL{{SET (B / C) AS NEW RIGHT ARG{8189
{{BRN{6,OALT1{{{MERGE BACK TO BUILD A / (B / C){8190
{{EJC{{{{{8191
*
*      ARRAY REFERENCE (MULTIPLE SUBSCRIPTS, BY NAME)
*
{O_AMN{ENT{{{{ENTRY POINT{8195
{{LCW{7,XR{{{LOAD NUMBER OF SUBSCRIPTS{8196
{{MOV{8,WB{7,XR{{SET FLAG FOR BY NAME{8197
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{8198
{{EJC{{{{{8199
*
*      ARRAY REFERENCE (MULTIPLE SUBSCRIPTS, BY VALUE)
*
{O_AMV{ENT{{{{ENTRY POINT{8203
{{LCW{7,XR{{{LOAD NUMBER OF SUBSCRIPTS{8204
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{8205
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{8206
{{EJC{{{{{8207
*
*      ARRAY REFERENCE (ONE SUBSCRIPT, BY NAME)
*
{O_AON{ENT{{{{ENTRY POINT{8211
{{MOV{7,XR{9,(XS){{LOAD SUBSCRIPT VALUE{8212
{{MOV{7,XL{13,NUM01(XS){{LOAD ARRAY VALUE{8213
{{MOV{8,WA{9,(XL){{LOAD FIRST WORD OF ARRAY OPERAND{8214
{{BEQ{8,WA{22,=B_VCT{6,OAON2{JUMP IF VECTOR REFERENCE{8215
{{BEQ{8,WA{22,=B_TBT{6,OAON3{JUMP IF TABLE REFERENCE{8216
*
*      HERE TO USE CENTRAL ARRAY REFERENCE ROUTINE
*
{OAON1{MOV{7,XR{18,=NUM01{{SET NUMBER OF SUBSCRIPTS TO ONE{8220
{{MOV{8,WB{7,XR{{SET FLAG FOR BY NAME{8221
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{8222
*
*      HERE IF WE HAVE A VECTOR REFERENCE
*
{OAON2{BNE{9,(XR){22,=B_ICL{6,OAON1{USE LONG ROUTINE IF NOT INTEGER{8226
{{LDI{13,ICVAL(XR){{{LOAD INTEGER SUBSCRIPT VALUE{8227
{{MFI{8,WA{6,EXFAL{{COPY AS ADDRESS INT, FAIL IF OVFLO{8228
{{BZE{8,WA{6,EXFAL{{FAIL IF ZERO{8229
{{ADD{8,WA{18,=VCVLB{{COMPUTE OFFSET IN WORDS{8230
{{WTB{8,WA{{{CONVERT TO BYTES{8231
{{MOV{9,(XS){8,WA{{COMPLETE NAME ON STACK{8232
{{BLT{8,WA{13,VCLEN(XL){6,OAON4{EXIT IF SUBSCRIPT NOT TOO LARGE{8233
{{BRN{6,EXFAL{{{ELSE FAIL{8234
*
*      HERE FOR TABLE REFERENCE
*
{OAON3{MNZ{8,WB{{{SET FLAG FOR NAME REFERENCE{8238
{{JSR{6,TFIND{{{LOCATE/CREATE TABLE ELEMENT{8239
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{8240
{{MOV{13,NUM01(XS){7,XL{{STORE NAME BASE ON STACK{8241
{{MOV{9,(XS){8,WA{{STORE NAME OFFSET ON STACK{8242
*
*      HERE TO EXIT WITH RESULT ON STACK
*
{OAON4{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{8246
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{8247
{{EJC{{{{{8248
*
*      ARRAY REFERENCE (ONE SUBSCRIPT, BY VALUE)
*
{O_AOV{ENT{{{{ENTRY POINT{8252
{{MOV{7,XR{10,(XS)+{{LOAD SUBSCRIPT VALUE{8253
{{MOV{7,XL{10,(XS)+{{LOAD ARRAY VALUE{8254
{{MOV{8,WA{9,(XL){{LOAD FIRST WORD OF ARRAY OPERAND{8255
{{BEQ{8,WA{22,=B_VCT{6,OAOV2{JUMP IF VECTOR REFERENCE{8256
{{BEQ{8,WA{22,=B_TBT{6,OAOV3{JUMP IF TABLE REFERENCE{8257
*
*      HERE TO USE CENTRAL ARRAY REFERENCE ROUTINE
*
{OAOV1{MOV{11,-(XS){7,XL{{RESTACK ARRAY VALUE{8261
{{MOV{11,-(XS){7,XR{{RESTACK SUBSCRIPT{8262
{{MOV{7,XR{18,=NUM01{{SET NUMBER OF SUBSCRIPTS TO ONE{8263
{{ZER{8,WB{{{SET FLAG FOR VALUE CALL{8264
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{8265
*
*      HERE IF WE HAVE A VECTOR REFERENCE
*
{OAOV2{BNE{9,(XR){22,=B_ICL{6,OAOV1{USE LONG ROUTINE IF NOT INTEGER{8269
{{LDI{13,ICVAL(XR){{{LOAD INTEGER SUBSCRIPT VALUE{8270
{{MFI{8,WA{6,EXFAL{{MOVE AS ONE WORD INT, FAIL IF OVFLO{8271
{{BZE{8,WA{6,EXFAL{{FAIL IF ZERO{8272
{{ADD{8,WA{18,=VCVLB{{COMPUTE OFFSET IN WORDS{8273
{{WTB{8,WA{{{CONVERT TO BYTES{8274
{{BGE{8,WA{13,VCLEN(XL){6,EXFAL{FAIL IF SUBSCRIPT TOO LARGE{8275
{{JSR{6,ACESS{{{ACCESS VALUE{8276
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{8277
{{MOV{11,-(XS){7,XR{{STACK RESULT{8278
{{LCW{7,XR{{{GET NEXT CODE WORD{8279
{{BRI{9,(XR){{{EXECUTE IT{8280
*
*      HERE FOR TABLE REFERENCE BY VALUE
*
{OAOV3{ZER{8,WB{{{SET FLAG FOR VALUE REFERENCE{8284
{{JSR{6,TFIND{{{CALL TABLE SEARCH ROUTINE{8285
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{8286
{{MOV{11,-(XS){7,XR{{STACK RESULT{8287
{{LCW{7,XR{{{GET NEXT CODE WORD{8288
{{BRI{9,(XR){{{EXECUTE IT{8289
{{EJC{{{{{8290
*
*      ASSIGNMENT
*
{O_ASS{ENT{{{{ENTRY POINT{8294
*
*      O_RPL (PATTERN REPLACEMENT) MERGES HERE
*
{OASS0{MOV{8,WB{10,(XS)+{{LOAD VALUE TO BE ASSIGNED{8298
{{MOV{8,WA{10,(XS)+{{LOAD NAME OFFSET{8299
{{MOV{7,XL{9,(XS){{LOAD NAME BASE{8300
{{MOV{9,(XS){8,WB{{STORE ASSIGNED VALUE AS RESULT{8301
{{JSR{6,ASIGN{{{PERFORM ASSIGNMENT{8302
{{PPM{6,EXFAL{{{FAIL IF ASSIGNMENT FAILS{8303
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{8304
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{8305
{{EJC{{{{{8306
*
*      COMPILATION ERROR
*
{O_CER{ENT{{{{ENTRY POINT{8310
{{ERB{1,007{26,Compilation error encountered during execution{{{8311
{{EJC{{{{{8312
*
*      UNARY AT (CURSOR ASSIGNMENT)
*
{O_CAS{ENT{{{{ENTRY POINT{8316
{{MOV{8,WC{10,(XS)+{{LOAD NAME OFFSET (PARM2){8317
{{MOV{7,XR{10,(XS)+{{LOAD NAME BASE (PARM1){8318
{{MOV{8,WB{22,=P_CAS{{SET PCODE FOR CURSOR ASSIGNMENT{8319
{{JSR{6,PBILD{{{BUILD NODE{8320
{{MOV{11,-(XS){7,XR{{STACK RESULT{8321
{{LCW{7,XR{{{GET NEXT CODE WORD{8322
{{BRI{9,(XR){{{EXECUTE IT{8323
{{EJC{{{{{8324
*
*      CONCATENATION
*
{O_CNC{ENT{{{{ENTRY POINT{8328
{{MOV{7,XR{9,(XS){{LOAD RIGHT ARGUMENT{8329
{{BEQ{7,XR{21,=NULLS{6,OCNC3{JUMP IF RIGHT ARG IS NULL{8330
{{MOV{7,XL{12,1(XS){{LOAD LEFT ARGUMENT{8331
{{BEQ{7,XL{21,=NULLS{6,OCNC4{JUMP IF LEFT ARGUMENT IS NULL{8332
{{MOV{8,WA{22,=B_SCL{{GET CONSTANT TO TEST FOR STRING{8333
{{BNE{8,WA{9,(XL){6,OCNC2{JUMP IF LEFT ARG NOT A STRING{8334
{{BNE{8,WA{9,(XR){6,OCNC2{JUMP IF RIGHT ARG NOT A STRING{8335
*
*      MERGE HERE TO CONCATENATE TWO STRINGS
*
{OCNC1{MOV{8,WA{13,SCLEN(XL){{LOAD LEFT ARGUMENT LENGTH{8339
{{ADD{8,WA{13,SCLEN(XR){{COMPUTE RESULT LENGTH{8340
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR RESULT{8341
{{MOV{12,1(XS){7,XR{{STORE RESULT PTR OVER LEFT ARGUMENT{8342
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{8343
{{MOV{8,WA{13,SCLEN(XL){{GET NUMBER OF CHARS IN LEFT ARG{8344
{{PLC{7,XL{{{PREPARE TO LOAD LEFT ARG CHARS{8345
{{MVC{{{{MOVE CHARACTERS OF LEFT ARGUMENT{8346
{{MOV{7,XL{10,(XS)+{{LOAD RIGHT ARG POINTER, POP STACK{8347
{{MOV{8,WA{13,SCLEN(XL){{LOAD NUMBER OF CHARS IN RIGHT ARG{8348
{{PLC{7,XL{{{PREPARE TO LOAD RIGHT ARG CHARS{8349
{{MVC{{{{MOVE CHARACTERS OF RIGHT ARGUMENT{8350
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{8351
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{8352
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{8353
*
*      COME HERE IF ARGUMENTS ARE NOT BOTH STRINGS
*
{OCNC2{JSR{6,GTSTG{{{CONVERT RIGHT ARG TO STRING{8357
{{PPM{6,OCNC5{{{JUMP IF RIGHT ARG IS NOT STRING{8358
{{MOV{7,XL{7,XR{{SAVE RIGHT ARG PTR{8359
{{JSR{6,GTSTG{{{CONVERT LEFT ARG TO STRING{8360
{{PPM{6,OCNC6{{{JUMP IF LEFT ARG IS NOT A STRING{8361
{{MOV{11,-(XS){7,XR{{STACK LEFT ARGUMENT{8362
{{MOV{11,-(XS){7,XL{{STACK RIGHT ARGUMENT{8363
{{MOV{7,XL{7,XR{{MOVE LEFT ARG TO PROPER REG{8364
{{MOV{7,XR{9,(XS){{MOVE RIGHT ARG TO PROPER REG{8365
{{BRN{6,OCNC1{{{MERGE BACK TO CONCATENATE STRINGS{8366
{{EJC{{{{{8367
*
*      CONCATENATION (CONTINUED)
*
*      COME HERE FOR NULL RIGHT ARGUMENT
*
{OCNC3{ICA{7,XS{{{REMOVE RIGHT ARG FROM STACK{8373
{{LCW{7,XR{{{LEFT ARGUMENT ON STACK{8374
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{8375
*
*      HERE FOR NULL LEFT ARGUMENT
*
{OCNC4{ICA{7,XS{{{UNSTACK ONE ARGUMENT{8379
{{MOV{9,(XS){7,XR{{STORE RIGHT ARGUMENT{8380
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{8381
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{8382
*
*      HERE IF RIGHT ARGUMENT IS NOT A STRING
*
{OCNC5{MOV{7,XL{7,XR{{MOVE RIGHT ARGUMENT PTR{8386
{{MOV{7,XR{10,(XS)+{{LOAD LEFT ARG POINTER{8387
*
*      MERGE HERE WHEN LEFT ARGUMENT IS NOT A STRING
*
{OCNC6{JSR{6,GTPAT{{{CONVERT LEFT ARG TO PATTERN{8391
{{ERR{1,008{26,Concatenation left operand is not a string or pattern{{{8392
{{MOV{11,-(XS){7,XR{{SAVE RESULT ON STACK{8393
{{MOV{7,XR{7,XL{{POINT TO RIGHT OPERAND{8394
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{8395
{{ERR{1,009{26,Concatenation right operand is not a string or pattern{{{8396
{{MOV{7,XL{7,XR{{MOVE FOR PCONC{8397
{{MOV{7,XR{10,(XS)+{{RELOAD LEFT OPERAND PTR{8398
{{JSR{6,PCONC{{{CONCATENATE PATTERNS{8399
{{MOV{11,-(XS){7,XR{{STACK RESULT{8400
{{LCW{7,XR{{{GET NEXT CODE WORD{8401
{{BRI{9,(XR){{{EXECUTE IT{8402
{{EJC{{{{{8403
*
*      COMPLEMENTATION
*
{O_COM{ENT{{{{ENTRY POINT{8407
{{MOV{7,XR{10,(XS)+{{LOAD OPERAND{8408
{{MOV{8,WA{9,(XR){{LOAD TYPE WORD{8409
*
*      MERGE BACK HERE AFTER CONVERSION
*
{OCOM1{BEQ{8,WA{22,=B_ICL{6,OCOM2{JUMP IF INTEGER{8413
{{BEQ{8,WA{22,=B_RCL{6,OCOM3{JUMP IF REAL{8416
{{JSR{6,GTNUM{{{ELSE CONVERT TO NUMERIC{8418
{{ERR{1,010{26,Negation operand is not numeric{{{8419
{{BRN{6,OCOM1{{{BACK TO CHECK CASES{8420
*
*      HERE TO COMPLEMENT INTEGER
*
{OCOM2{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{8424
{{NGI{{{{NEGATE{8425
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{8426
{{ERB{1,011{26,Negation caused integer overflow{{{8427
*
*      HERE TO COMPLEMENT REAL
*
{OCOM3{LDR{13,RCVAL(XR){{{LOAD REAL VALUE{8433
{{NGR{{{{NEGATE{8434
{{BRN{6,EXREA{{{RETURN REAL RESULT{8435
{{EJC{{{{{8437
*
*      BINARY SLASH (DIVISION)
*
{O_DVD{ENT{{{{ENTRY POINT{8441
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{8442
{{ERR{1,012{26,Division left operand is not numeric{{{8443
{{ERR{1,013{26,Division right operand is not numeric{{{8444
{{PPM{6,ODVD2{{{JUMP IF REAL OPERANDS{8447
*
*      HERE TO DIVIDE TWO INTEGERS
*
{{DVI{13,ICVAL(XL){{{DIVIDE LEFT OPERAND BY RIGHT{8452
{{INO{6,EXINT{{{RESULT OK IF NO OVERFLOW{8453
{{ERB{1,014{26,Division caused integer overflow{{{8454
*
*      HERE TO DIVIDE TWO REALS
*
{ODVD2{DVR{13,RCVAL(XL){{{DIVIDE LEFT OPERAND BY RIGHT{8460
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{8461
{{ERB{1,262{26,Division caused real overflow{{{8462
{{EJC{{{{{8464
*
*      EXPONENTIATION
*
{O_EXP{ENT{{{{ENTRY POINT{8468
{{MOV{7,XR{10,(XS)+{{LOAD EXPONENT{8469
{{JSR{6,GTNUM{{{CONVERT TO NUMBER{8470
{{ERR{1,015{26,Exponentiation right operand is not numeric{{{8471
{{MOV{7,XL{7,XR{{MOVE EXPONENT TO XL{8472
{{MOV{7,XR{10,(XS)+{{LOAD BASE{8473
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{8474
{{ERR{1,016{26,Exponentiation left operand is not numeric{{{8475
{{BEQ{9,(XL){22,=B_RCL{6,OEXP7{JUMP IF REAL EXPONENT{8478
{{LDI{13,ICVAL(XL){{{LOAD EXPONENT{8480
{{ILT{6,OEX12{{{JUMP IF NEGATIVE EXPONENT{8481
{{BEQ{8,WA{22,=B_RCL{6,OEXP3{JUMP IF BASE IS REAL{8484
*
*      HERE TO EXPONENTIATE AN INTEGER BASE AND INTEGER EXPONENT
*
{{MFI{8,WA{6,OEXP2{{CONVERT EXPONENT TO 1 WORD INTEGER{8489
{{LCT{8,WA{8,WA{{SET LOOP COUNTER{8490
{{LDI{13,ICVAL(XR){{{LOAD BASE AS INITIAL VALUE{8491
{{BNZ{8,WA{6,OEXP1{{JUMP INTO LOOP IF NON-ZERO EXPONENT{8492
{{IEQ{6,OEXP4{{{ERROR IF 0**0{8493
{{LDI{4,INTV1{{{NONZERO**0{8494
{{BRN{6,EXINT{{{GIVE ONE AS RESULT FOR NONZERO**0{8495
*
*      LOOP TO PERFORM EXPONENTIATION
*
{OEX13{MLI{13,ICVAL(XR){{{MULTIPLY BY BASE{8499
{{IOV{6,OEXP2{{{JUMP IF OVERFLOW{8500
{OEXP1{BCT{8,WA{6,OEX13{{LOOP IF MORE TO GO{8501
{{BRN{6,EXINT{{{ELSE RETURN INTEGER RESULT{8502
*
*      HERE IF INTEGER OVERFLOW
*
{OEXP2{ERB{1,017{26,Exponentiation caused integer overflow{{{8506
{{EJC{{{{{8507
*
*      EXPONENTIATION (CONTINUED)
*
*      HERE TO EXPONENTIATE A REAL TO AN INTEGER POWER
*
{OEXP3{MFI{8,WA{6,OEXP6{{CONVERT EXPONENT TO ONE WORD{8515
{{LCT{8,WA{8,WA{{SET LOOP COUNTER{8516
{{LDR{13,RCVAL(XR){{{LOAD BASE AS INITIAL VALUE{8517
{{BNZ{8,WA{6,OEXP5{{JUMP INTO LOOP IF NON-ZERO EXPONENT{8518
{{REQ{6,OEXP4{{{ERROR IF 0.0**0{8519
{{LDR{4,REAV1{{{NONZERO**0{8520
{{BRN{6,EXREA{{{RETURN 1.0 IF NONZERO**ZERO{8521
*
*      HERE FOR ERROR OF 0**0 OR 0.0**0
*
{OEXP4{ERB{1,018{26,Exponentiation result is undefined{{{8526
*
*      LOOP TO PERFORM EXPONENTIATION
*
{OEX14{MLR{13,RCVAL(XR){{{MULTIPLY BY BASE{8532
{{ROV{6,OEXP6{{{JUMP IF OVERFLOW{8533
{OEXP5{BCT{8,WA{6,OEX14{{LOOP TILL COMPUTATION COMPLETE{8534
{{BRN{6,EXREA{{{THEN RETURN REAL RESULT{8535
*
*      HERE IF REAL OVERFLOW
*
{OEXP6{ERB{1,266{26,Exponentiation caused real overflow{{{8539
*
*      HERE WITH REAL EXPONENT IN (XL), NUMERIC BASE IN (XR)
*
{OEXP7{BEQ{9,(XR){22,=B_RCL{6,OEXP8{JUMP IF BASE REAL{8544
{{LDI{13,ICVAL(XR){{{LOAD INTEGER BASE{8545
{{ITR{{{{CONVERT TO REAL{8546
{{JSR{6,RCBLD{{{CREATE REAL IN (XR){8547
*
*      HERE WITH REAL EXPONENT IN (XL)
*      NUMERIC BASE IN (XR) AND RA
*
{OEXP8{ZER{8,WB{{{SET POSITIVE RESULT FLAG{8552
{{LDR{13,RCVAL(XR){{{LOAD BASE TO RA{8553
{{RNE{6,OEXP9{{{JUMP IF BASE NON-ZERO{8554
{{LDR{13,RCVAL(XL){{{BASE IS ZERO.  CHECK EXPONENT{8555
{{REQ{6,OEXP4{{{JUMP IF 0.0 ** 0.0{8556
{{LDR{4,REAV0{{{0.0 TO NON-ZERO EXPONENT YIELDS 0.0{8557
{{BRN{6,EXREA{{{RETURN ZERO RESULT{8558
*
*      HERE WITH NON-ZERO BASE IN (XR) AND RA, EXPONENT IN (XL)
*
*      A NEGATIVE BASE IS ALLOWED IF THE EXPONENT IS INTEGRAL.
*
{OEXP9{RGT{6,OEX10{{{JUMP IF BASE GT 0.0{8564
{{NGR{{{{MAKE BASE POSITIVE{8565
{{JSR{6,RCBLD{{{CREATE POSITIVE BASE IN (XR){8566
{{LDR{13,RCVAL(XL){{{EXAMINE EXPONENT{8567
{{CHP{{{{CHOP TO INTEGRAL VALUE{8568
{{RTI{6,OEXP6{{{CONVERT TO INTEGER, BR IF TOO LARGE{8569
{{SBR{13,RCVAL(XL){{{CHOP(EXPONENT) - EXPONENT{8570
{{RNE{6,OEX11{{{NON-INTEGRAL POWER WITH NEG BASE{8571
{{MFI{8,WB{{{RECORD EVEN/ODD EXPONENT{8572
{{ANB{8,WB{4,BITS1{{ODD EXPONENT YIELDS NEGATIVE RESULT{8573
{{LDR{13,RCVAL(XR){{{RESTORE BASE TO RA{8574
*
*      HERE WITH POSITIVE BASE IN RA AND (XR), EXPONENT IN (XL)
*
{OEX10{LNF{{{{LOG OF BASE{8578
{{ROV{6,OEXP6{{{TOO LARGE{8579
{{MLR{13,RCVAL(XL){{{TIMES EXPONENT{8580
{{ROV{6,OEXP6{{{TOO LARGE{8581
{{ETX{{{{E ** (EXPONENT * LN(BASE)){8582
{{ROV{6,OEXP6{{{TOO LARGE{8583
{{BZE{8,WB{6,EXREA{{IF NO SIGN FIXUP REQUIRED{8584
{{NGR{{{{NEGATIVE RESULT NEEDED{8585
{{BRN{6,EXREA{{{{8586
*
*      HERE FOR NON-INTEGRAL EXPONENT WITH NEGATIVE BASE
*
{OEX11{ERB{1,311{26,Exponentiation of negative base to non-integral power{{{8590
*
*      HERE WITH NEGATIVE INTEGER EXPONENT IN IA
*
{OEX12{MOV{11,-(XS){7,XR{{STACK BASE{8599
{{ITR{{{{CONVERT TO REAL EXPONENT{8600
{{JSR{6,RCBLD{{{REAL NEGATIVE EXPONENT IN (XR){8601
{{MOV{7,XL{7,XR{{PUT EXPONENT IN XL{8602
{{MOV{7,XR{10,(XS)+{{RESTORE BASE VALUE{8603
{{BRN{6,OEXP7{{{PROCESS REAL EXPONENT{8604
{{EJC{{{{{8608
*
*      FAILURE IN EXPRESSION EVALUATION
*
*      THIS ENTRY POINT IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, FAILS.
*      CONTROL IS RETURNED TO AN APPROPRIATE POINT IN EVALX.
*
{O_FEX{ENT{{{{ENTRY POINT{8616
{{BRN{6,EVLX6{{{JUMP TO FAILURE LOC IN EVALX{8617
{{EJC{{{{{8618
*
*      FAILURE DURING EVALUATION OF A COMPLEX OR DIRECT GOTO
*
{O_FIF{ENT{{{{ENTRY POINT{8622
{{ERB{1,020{26,Goto evaluation failure{{{8623
{{EJC{{{{{8624
*
*      FUNCTION CALL (MORE THAN ONE ARGUMENT)
*
{O_FNC{ENT{{{{ENTRY POINT{8628
{{LCW{8,WA{{{LOAD NUMBER OF ARGUMENTS{8629
{{LCW{7,XR{{{LOAD FUNCTION VRBLK POINTER{8630
{{MOV{7,XL{13,VRFNC(XR){{LOAD FUNCTION POINTER{8631
{{BNE{8,WA{13,FARGS(XL){6,CFUNC{USE CENTRAL ROUTINE IF WRONG NUM{8632
{{BRI{9,(XL){{{JUMP TO FUNCTION IF ARG COUNT OK{8633
{{EJC{{{{{8634
*
*      FUNCTION NAME ERROR
*
{O_FNE{ENT{{{{ENTRY POINT{8638
{{LCW{8,WA{{{GET NEXT CODE WORD{8639
{{BNE{8,WA{21,=ORNM_{6,OFNE1{FAIL IF NOT EVALUATING EXPRESSION{8640
{{BZE{13,NUM02(XS){6,EVLX3{{OK IF EXPR. WAS WANTED BY VALUE{8641
*
*      HERE FOR ERROR
*
{OFNE1{ERB{1,021{26,Function called by name returned a value{{{8645
{{EJC{{{{{8646
*
*      FUNCTION CALL (SINGLE ARGUMENT)
*
{O_FNS{ENT{{{{ENTRY POINT{8650
{{LCW{7,XR{{{LOAD FUNCTION VRBLK POINTER{8651
{{MOV{8,WA{18,=NUM01{{SET NUMBER OF ARGUMENTS TO ONE{8652
{{MOV{7,XL{13,VRFNC(XR){{LOAD FUNCTION POINTER{8653
{{BNE{8,WA{13,FARGS(XL){6,CFUNC{USE CENTRAL ROUTINE IF WRONG NUM{8654
{{BRI{9,(XL){{{JUMP TO FUNCTION IF ARG COUNT OK{8655
{{EJC{{{{{8656
*      CALL TO UNDEFINED FUNCTION
*
{O_FUN{ENT{{{{ENTRY POINT{8659
{{ERB{1,022{26,Undefined function called{{{8660
{{EJC{{{{{8661
*
*      EXECUTE COMPLEX GOTO
*
{O_GOC{ENT{{{{ENTRY POINT{8665
{{MOV{7,XR{13,NUM01(XS){{LOAD NAME BASE POINTER{8666
{{BHI{7,XR{3,STATE{6,OGOC1{JUMP IF NOT NATURAL VARIABLE{8667
{{ADD{7,XR{19,*VRTRA{{ELSE POINT TO VRTRA FIELD{8668
{{BRI{9,(XR){{{AND JUMP THROUGH IT{8669
*
*      HERE IF GOTO OPERAND IS NOT NATURAL VARIABLE
*
{OGOC1{ERB{1,023{26,Goto operand is not a natural variable{{{8673
{{EJC{{{{{8674
*
*      EXECUTE DIRECT GOTO
*
{O_GOD{ENT{{{{ENTRY POINT{8678
{{MOV{7,XR{9,(XS){{LOAD OPERAND{8679
{{MOV{8,WA{9,(XR){{LOAD FIRST WORD{8680
{{BEQ{8,WA{22,=B_CDS{6,BCDS0{JUMP IF CODE BLOCK TO CODE ROUTINE{8681
{{BEQ{8,WA{22,=B_CDC{6,BCDC0{JUMP IF CODE BLOCK TO CODE ROUTINE{8682
{{ERB{1,024{26,Goto operand in direct goto is not code{{{8683
{{EJC{{{{{8684
*
*      SET GOTO FAILURE TRAP
*
*      THIS ROUTINE IS EXECUTED AT THE START OF A COMPLEX OR
*      DIRECT FAILURE GOTO TO TRAP A SUBSEQUENT FAIL (SEE EXFAL)
*
{O_GOF{ENT{{{{ENTRY POINT{8691
{{MOV{7,XR{3,FLPTR{{POINT TO FAIL OFFSET ON STACK{8692
{{ICA{9,(XR){{{POINT FAILURE TO O_FIF WORD{8693
{{ICP{{{{POINT TO NEXT CODE WORD{8694
{{LCW{7,XR{{{FETCH NEXT CODE WORD{8695
{{BRI{9,(XR){{{EXECUTE IT{8696
{{EJC{{{{{8697
*
*      BINARY DOLLAR (IMMEDIATE ASSIGNMENT)
*
*      THE PATTERN BUILT BY BINARY DOLLAR IS A COMPOUND PATTERN.
*      SEE DESCRIPTION AT START OF PATTERN MATCH SECTION FOR
*      DETAILS OF THE STRUCTURE WHICH IS CONSTRUCTED.
*
{O_IMA{ENT{{{{ENTRY POINT{8705
{{MOV{8,WB{22,=P_IMC{{SET PCODE FOR LAST NODE{8706
{{MOV{8,WC{10,(XS)+{{POP NAME OFFSET (PARM2){8707
{{MOV{7,XR{10,(XS)+{{POP NAME BASE (PARM1){8708
{{JSR{6,PBILD{{{BUILD P_IMC NODE{8709
{{MOV{7,XL{7,XR{{SAVE PTR TO NODE{8710
{{MOV{7,XR{9,(XS){{LOAD LEFT ARGUMENT{8711
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{8712
{{ERR{1,025{26,Immediate assignment left operand is not pattern{{{8713
{{MOV{9,(XS){7,XR{{SAVE PTR TO LEFT OPERAND PATTERN{8714
{{MOV{8,WB{22,=P_IMA{{SET PCODE FOR FIRST NODE{8715
{{JSR{6,PBILD{{{BUILD P_IMA NODE{8716
{{MOV{13,PTHEN(XR){10,(XS)+{{SET LEFT OPERAND AS P_IMA SUCCESSOR{8717
{{JSR{6,PCONC{{{CONCATENATE TO FORM FINAL PATTERN{8718
{{MOV{11,-(XS){7,XR{{STACK RESULT{8719
{{LCW{7,XR{{{GET NEXT CODE WORD{8720
{{BRI{9,(XR){{{EXECUTE IT{8721
{{EJC{{{{{8722
*
*      INDIRECTION (BY NAME)
*
{O_INN{ENT{{{{ENTRY POINT{8726
{{MNZ{8,WB{{{SET FLAG FOR RESULT BY NAME{8727
{{BRN{6,INDIR{{{JUMP TO COMMON ROUTINE{8728
{{EJC{{{{{8729
*
*      INTERROGATION
*
{O_INT{ENT{{{{ENTRY POINT{8733
{{MOV{9,(XS){21,=NULLS{{REPLACE OPERAND WITH NULL{8734
{{LCW{7,XR{{{GET NEXT CODE WORD{8735
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{8736
{{EJC{{{{{8737
*
*      INDIRECTION (BY VALUE)
*
{O_INV{ENT{{{{ENTRY POINT{8741
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{8742
{{BRN{6,INDIR{{{JUMP TO COMMON ROUTINE{8743
{{EJC{{{{{8744
*
*      KEYWORD REFERENCE (BY NAME)
*
{O_KWN{ENT{{{{ENTRY POINT{8748
{{JSR{6,KWNAM{{{GET KEYWORD NAME{8749
{{BRN{6,EXNAM{{{EXIT WITH RESULT NAME{8750
{{EJC{{{{{8751
*
*      KEYWORD REFERENCE (BY VALUE)
*
{O_KWV{ENT{{{{ENTRY POINT{8755
{{JSR{6,KWNAM{{{GET KEYWORD NAME{8756
{{MOV{3,DNAMP{7,XR{{DELETE KVBLK{8757
{{JSR{6,ACESS{{{ACCESS VALUE{8758
{{PPM{6,EXNUL{{{DUMMY (UNUSED) FAILURE RETURN{8759
{{MOV{11,-(XS){7,XR{{STACK RESULT{8760
{{LCW{7,XR{{{GET NEXT CODE WORD{8761
{{BRI{9,(XR){{{EXECUTE IT{8762
{{EJC{{{{{8763
*
*      LOAD EXPRESSION BY NAME
*
{O_LEX{ENT{{{{ENTRY POINT{8767
{{MOV{8,WA{19,*EVSI_{{SET SIZE OF EVBLK{8768
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR EVBLK{8769
{{MOV{9,(XR){22,=B_EVT{{SET TYPE WORD{8770
{{MOV{13,EVVAR(XR){21,=TRBEV{{SET DUMMY TRBLK POINTER{8771
{{LCW{8,WA{{{LOAD EXBLK POINTER{8772
{{MOV{13,EVEXP(XR){8,WA{{SET EXBLK POINTER{8773
{{MOV{7,XL{7,XR{{MOVE NAME BASE TO PROPER REG{8774
{{MOV{8,WA{19,*EVVAR{{SET NAME OFFSET = ZERO{8775
{{BRN{6,EXNAM{{{EXIT WITH NAME IN (XL,WA){8776
{{EJC{{{{{8777
*
*      LOAD PATTERN VALUE
*
{O_LPT{ENT{{{{ENTRY POINT{8781
{{LCW{7,XR{{{LOAD PATTERN POINTER{8782
{{MOV{11,-(XS){7,XR{{STACK RESULT{8783
{{LCW{7,XR{{{GET NEXT CODE WORD{8784
{{BRI{9,(XR){{{EXECUTE IT{8785
{{EJC{{{{{8786
*
*      LOAD VARIABLE NAME
*
{O_LVN{ENT{{{{ENTRY POINT{8790
{{LCW{8,WA{{{LOAD VRBLK POINTER{8791
{{MOV{11,-(XS){8,WA{{STACK VRBLK PTR (NAME BASE){8792
{{MOV{11,-(XS){19,*VRVAL{{STACK NAME OFFSET{8793
{{LCW{7,XR{{{GET NEXT CODE WORD{8794
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{8795
{{EJC{{{{{8796
*
*      BINARY ASTERISK (MULTIPLICATION)
*
{O_MLT{ENT{{{{ENTRY POINT{8800
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{8801
{{ERR{1,026{26,Multiplication left operand is not numeric{{{8802
{{ERR{1,027{26,Multiplication right operand is not numeric{{{8803
{{PPM{6,OMLT1{{{JUMP IF REAL OPERANDS{8806
*
*      HERE TO MULTIPLY TWO INTEGERS
*
{{MLI{13,ICVAL(XL){{{MULTIPLY LEFT OPERAND BY RIGHT{8811
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{8812
{{ERB{1,028{26,Multiplication caused integer overflow{{{8813
*
*      HERE TO MULTIPLY TWO REALS
*
{OMLT1{MLR{13,RCVAL(XL){{{MULTIPLY LEFT OPERAND BY RIGHT{8819
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{8820
{{ERB{1,263{26,Multiplication caused real overflow{{{8821
{{EJC{{{{{8823
*
*      NAME REFERENCE
*
{O_NAM{ENT{{{{ENTRY POINT{8827
{{MOV{8,WA{19,*NMSI_{{SET LENGTH OF NMBLK{8828
{{JSR{6,ALLOC{{{ALLOCATE NMBLK{8829
{{MOV{9,(XR){22,=B_NML{{SET NAME BLOCK CODE{8830
{{MOV{13,NMOFS(XR){10,(XS)+{{SET NAME OFFSET FROM OPERAND{8831
{{MOV{13,NMBAS(XR){10,(XS)+{{SET NAME BASE FROM OPERAND{8832
{{MOV{11,-(XS){7,XR{{STACK RESULT{8833
{{LCW{7,XR{{{GET NEXT CODE WORD{8834
{{BRI{9,(XR){{{EXECUTE IT{8835
{{EJC{{{{{8836
*
*      NEGATION
*
*      INITIAL ENTRY
*
{O_NTA{ENT{{{{ENTRY POINT{8842
{{LCW{8,WA{{{LOAD NEW FAILURE OFFSET{8843
{{MOV{11,-(XS){3,FLPTR{{STACK OLD FAILURE POINTER{8844
{{MOV{11,-(XS){8,WA{{STACK NEW FAILURE OFFSET{8845
{{MOV{3,FLPTR{7,XS{{SET NEW FAILURE POINTER{8846
{{LCW{7,XR{{{GET NEXT CODE WORD{8847
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{8848
*
*      ENTRY AFTER SUCCESSFUL EVALUATION OF OPERAND
*
{O_NTB{ENT{{{{ENTRY POINT{8852
{{MOV{3,FLPTR{13,NUM02(XS){{RESTORE OLD FAILURE POINTER{8853
{{BRN{6,EXFAL{{{AND FAIL{8854
*
*      ENTRY FOR FAILURE DURING OPERAND EVALUATION
*
{O_NTC{ENT{{{{ENTRY POINT{8858
{{ICA{7,XS{{{POP FAILURE OFFSET{8859
{{MOV{3,FLPTR{10,(XS)+{{RESTORE OLD FAILURE POINTER{8860
{{BRN{6,EXNUL{{{EXIT GIVING NULL RESULT{8861
{{EJC{{{{{8862
*
*      USE OF UNDEFINED OPERATOR
*
{O_OUN{ENT{{{{ENTRY POINT{8866
{{ERB{1,029{26,Undefined operator referenced{{{8867
{{EJC{{{{{8868
*
*      BINARY DOT (PATTERN ASSIGNMENT)
*
*      THE PATTERN BUILT BY BINARY DOT IS A COMPOUND PATTERN.
*      SEE DESCRIPTION AT START OF PATTERN MATCH SECTION FOR
*      DETAILS OF THE STRUCTURE WHICH IS CONSTRUCTED.
*
{O_PAS{ENT{{{{ENTRY POINT{8876
{{MOV{8,WB{22,=P_PAC{{LOAD PCODE FOR P_PAC NODE{8877
{{MOV{8,WC{10,(XS)+{{LOAD NAME OFFSET (PARM2){8878
{{MOV{7,XR{10,(XS)+{{LOAD NAME BASE (PARM1){8879
{{JSR{6,PBILD{{{BUILD P_PAC NODE{8880
{{MOV{7,XL{7,XR{{SAVE PTR TO NODE{8881
{{MOV{7,XR{9,(XS){{LOAD LEFT OPERAND{8882
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{8883
{{ERR{1,030{26,Pattern assignment left operand is not pattern{{{8884
{{MOV{9,(XS){7,XR{{SAVE PTR TO LEFT OPERAND PATTERN{8885
{{MOV{8,WB{22,=P_PAA{{SET PCODE FOR P_PAA NODE{8886
{{JSR{6,PBILD{{{BUILD P_PAA NODE{8887
{{MOV{13,PTHEN(XR){10,(XS)+{{SET LEFT OPERAND AS P_PAA SUCCESSOR{8888
{{JSR{6,PCONC{{{CONCATENATE TO FORM FINAL PATTERN{8889
{{MOV{11,-(XS){7,XR{{STACK RESULT{8890
{{LCW{7,XR{{{GET NEXT CODE WORD{8891
{{BRI{9,(XR){{{EXECUTE IT{8892
{{EJC{{{{{8893
*
*      PATTERN MATCH (BY NAME, FOR REPLACEMENT)
*
{O_PMN{ENT{{{{ENTRY POINT{8897
{{ZER{8,WB{{{SET TYPE CODE FOR MATCH BY NAME{8898
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{8899
{{EJC{{{{{8900
*
*      PATTERN MATCH (STATEMENT)
*
*      O_PMS IS USED IN PLACE OF O_PMV WHEN THE PATTERN MATCH
*      OCCURS AT THE OUTER (STATEMENT) LEVEL SINCE IN THIS
*      CASE THE SUBSTRING VALUE NEED NOT BE CONSTRUCTED.
*
{O_PMS{ENT{{{{ENTRY POINT{8908
{{MOV{8,WB{18,=NUM02{{SET FLAG FOR STATEMENT TO MATCH{8909
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{8910
{{EJC{{{{{8911
*
*      PATTERN MATCH (BY VALUE)
*
{O_PMV{ENT{{{{ENTRY POINT{8915
{{MOV{8,WB{18,=NUM01{{SET TYPE CODE FOR VALUE MATCH{8916
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{8917
{{EJC{{{{{8918
*
*      POP TOP ITEM ON STACK
*
{O_POP{ENT{{{{ENTRY POINT{8922
{{ICA{7,XS{{{POP TOP STACK ENTRY{8923
{{LCW{7,XR{{{GET NEXT CODE WORD{8924
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{8925
{{EJC{{{{{8926
*
*      TERMINATE EXECUTION (CODE COMPILED FOR END STATEMENT)
*
{O_STP{ENT{{{{ENTRY POINT{8930
{{BRN{6,LEND0{{{JUMP TO END CIRCUIT{8931
{{EJC{{{{{8932
*
*      RETURN NAME FROM EXPRESSION
*      THIS ENTRY POINTS IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, RETURNS
*      A NAME. CONTROL IS RETURNED TO THE PROPER POINT IN EVALX.
*
{O_RNM{ENT{{{{ENTRY POINT{8939
{{BRN{6,EVLX4{{{RETURN TO EVALX PROCEDURE{8940
{{EJC{{{{{8941
*
*      PATTERN REPLACEMENT
*
*      WHEN THIS ROUTINE GETS CONTROL, THE FOLLOWING STACK
*      ENTRIES HAVE BEEN MADE (SEE END OF MATCH ROUTINE P_NTH)
*
*                            SUBJECT NAME BASE
*                            SUBJECT NAME OFFSET
*                            INITIAL CURSOR VALUE
*                            FINAL CURSOR VALUE
*                            SUBJECT STRING POINTER
*      (XS) ---------------- REPLACEMENT VALUE
*
{O_RPL{ENT{{{{ENTRY POINT{8955
{{JSR{6,GTSTG{{{CONVERT REPLACEMENT VAL TO STRING{8956
{{ERR{1,031{26,Pattern replacement right operand is not a string{{{8957
*
*      GET RESULT LENGTH AND ALLOCATE RESULT SCBLK
*
{{MOV{7,XL{9,(XS){{LOAD SUBJECT STRING POINTER{8961
{{ADD{8,WA{13,SCLEN(XL){{ADD SUBJECT STRING LENGTH{8966
{{ADD{8,WA{13,NUM02(XS){{ADD STARTING CURSOR{8967
{{SUB{8,WA{13,NUM01(XS){{MINUS FINAL CURSOR = TOTAL LENGTH{8968
{{BZE{8,WA{6,ORPL3{{JUMP IF RESULT IS NULL{8969
{{MOV{11,-(XS){7,XR{{RESTACK REPLACEMENT STRING{8970
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR RESULT{8971
{{MOV{8,WA{13,NUM03(XS){{GET INITIAL CURSOR (PART 1 LEN){8972
{{MOV{13,NUM03(XS){7,XR{{STACK RESULT POINTER{8973
{{PSC{7,XR{{{POINT TO CHARACTERS OF RESULT{8974
*
*      MOVE PART 1 (START OF SUBJECT) TO RESULT
*
{{BZE{8,WA{6,ORPL1{{JUMP IF FIRST PART IS NULL{8978
{{MOV{7,XL{13,NUM01(XS){{ELSE POINT TO SUBJECT STRING{8979
{{PLC{7,XL{{{POINT TO SUBJECT STRING CHARS{8980
{{MVC{{{{MOVE FIRST PART TO RESULT{8981
{{EJC{{{{{8982
*      PATTERN REPLACEMENT (CONTINUED)
*
*      NOW MOVE IN REPLACEMENT VALUE
*
{ORPL1{MOV{7,XL{10,(XS)+{{LOAD REPLACEMENT STRING, POP{8987
{{MOV{8,WA{13,SCLEN(XL){{LOAD LENGTH{8988
{{BZE{8,WA{6,ORPL2{{JUMP IF NULL REPLACEMENT{8989
{{PLC{7,XL{{{ELSE POINT TO CHARS OF REPLACEMENT{8990
{{MVC{{{{MOVE IN CHARS (PART 2){8991
*
*      NOW MOVE IN REMAINDER OF STRING (PART 3)
*
{ORPL2{MOV{7,XL{10,(XS)+{{LOAD SUBJECT STRING POINTER, POP{8995
{{MOV{8,WC{10,(XS)+{{LOAD FINAL CURSOR, POP{8996
{{MOV{8,WA{13,SCLEN(XL){{LOAD SUBJECT STRING LENGTH{8997
{{SUB{8,WA{8,WC{{MINUS FINAL CURSOR = PART 3 LENGTH{8998
{{BZE{8,WA{6,OASS0{{JUMP TO ASSIGN IF PART 3 IS NULL{8999
{{PLC{7,XL{8,WC{{ELSE POINT TO LAST PART OF STRING{9000
{{MVC{{{{MOVE PART 3 TO RESULT{9001
{{BRN{6,OASS0{{{JUMP TO PERFORM ASSIGNMENT{9002
*
*      HERE IF RESULT IS NULL
*
{ORPL3{ADD{7,XS{19,*NUM02{{POP SUBJECT STR PTR, FINAL CURSOR{9006
{{MOV{9,(XS){21,=NULLS{{SET NULL RESULT{9007
{{BRN{6,OASS0{{{JUMP TO ASSIGN NULL VALUE{9008
{{EJC{{{{{9027
*
*      RETURN VALUE FROM EXPRESSION
*
*      THIS ENTRY POINTS IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, RETURNS
*      A VALUE. CONTROL IS RETURNED TO THE PROPER POINT IN EVALX
*
{O_RVL{ENT{{{{ENTRY POINT{9035
{{BRN{6,EVLX3{{{RETURN TO EVALX PROCEDURE{9036
{{EJC{{{{{9037
*
*      SELECTION
*
*      INITIAL ENTRY
*
{O_SLA{ENT{{{{ENTRY POINT{9043
{{LCW{8,WA{{{LOAD NEW FAILURE OFFSET{9044
{{MOV{11,-(XS){3,FLPTR{{STACK OLD FAILURE POINTER{9045
{{MOV{11,-(XS){8,WA{{STACK NEW FAILURE OFFSET{9046
{{MOV{3,FLPTR{7,XS{{SET NEW FAILURE POINTER{9047
{{LCW{7,XR{{{GET NEXT CODE WORD{9048
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{9049
*
*      ENTRY AFTER SUCCESSFUL EVALUATION OF ALTERNATIVE
*
{O_SLB{ENT{{{{ENTRY POINT{9053
{{MOV{7,XR{10,(XS)+{{LOAD RESULT{9054
{{ICA{7,XS{{{POP FAIL OFFSET{9055
{{MOV{3,FLPTR{9,(XS){{RESTORE OLD FAILURE POINTER{9056
{{MOV{9,(XS){7,XR{{RESTACK RESULT{9057
{{LCW{8,WA{{{LOAD NEW CODE OFFSET{9058
{{ADD{8,WA{3,R_COD{{POINT TO ABSOLUTE CODE LOCATION{9059
{{LCP{8,WA{{{SET NEW CODE POINTER{9060
{{LCW{7,XR{{{GET NEXT CODE WORD{9061
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{9062
*
*      ENTRY AT START OF SUBSEQUENT ALTERNATIVES
*
{O_SLC{ENT{{{{ENTRY POINT{9066
{{LCW{8,WA{{{LOAD NEW FAIL OFFSET{9067
{{MOV{9,(XS){8,WA{{STORE NEW FAIL OFFSET{9068
{{LCW{7,XR{{{GET NEXT CODE WORD{9069
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{9070
*
*      ENTRY AT START OF LAST ALTERNATIVE
*
{O_SLD{ENT{{{{ENTRY POINT{9074
{{ICA{7,XS{{{POP FAILURE OFFSET{9075
{{MOV{3,FLPTR{10,(XS)+{{RESTORE OLD FAILURE POINTER{9076
{{LCW{7,XR{{{GET NEXT CODE WORD{9077
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{9078
{{EJC{{{{{9079
*
*      BINARY MINUS (SUBTRACTION)
*
{O_SUB{ENT{{{{ENTRY POINT{9083
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{9084
{{ERR{1,032{26,Subtraction left operand is not numeric{{{9085
{{ERR{1,033{26,Subtraction right operand is not numeric{{{9086
{{PPM{6,OSUB1{{{JUMP IF REAL OPERANDS{9089
*
*      HERE TO SUBTRACT TWO INTEGERS
*
{{SBI{13,ICVAL(XL){{{SUBTRACT RIGHT OPERAND FROM LEFT{9094
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{9095
{{ERB{1,034{26,Subtraction caused integer overflow{{{9096
*
*      HERE TO SUBTRACT TWO REALS
*
{OSUB1{SBR{13,RCVAL(XL){{{SUBTRACT RIGHT OPERAND FROM LEFT{9102
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{9103
{{ERB{1,264{26,Subtraction caused real overflow{{{9104
{{EJC{{{{{9106
*
*      DUMMY OPERATOR TO RETURN CONTROL TO TRXEQ PROCEDURE
*
{O_TXR{ENT{{{{ENTRY POINT{9110
{{BRN{6,TRXQ1{{{JUMP INTO TRXEQ PROCEDURE{9111
{{EJC{{{{{9112
*
*      UNEXPECTED FAILURE
*
*      NOTE THAT IF A SETEXIT TRAP IS OPERATING THEN
*      TRANSFER TO SYSTEM LABEL CONTINUE
*      WILL RESULT IN LOOPING HERE.  DIFFICULT TO AVOID EXCEPT
*      WITH A CONSIDERABLE OVERHEAD WHICH IS NOT WORTHWHILE OR
*      ELSE BY A TECHNIQUE SUCH AS SETTING KVERL TO ZERO.
*
{O_UNF{ENT{{{{ENTRY POINT{9122
{{ERB{1,035{26,Unexpected failure in -NOFAIL mode{{{9123
{{TTL{27,S P I T B O L -- BLOCK ACTION ROUTINES{{{{9124
*
*      THE FIRST WORD OF EVERY BLOCK IN DYNAMIC STORAGE AND THE
*      VRGET, VRSTO AND VRTRA FIELDS OF A VRBLK CONTAIN A
*      POINTER TO AN ENTRY POINT IN THE PROGRAM. ALL SUCH ENTRY
*      POINTS ARE IN THE FOLLOWING SECTION EXCEPT THOSE FOR
*      PATTERN BLOCKS WHICH ARE IN THE PATTERN MATCHING SEGMENT
*      LATER ON (LABELS OF THE FORM P_XXX), AND DOPE VECTORS
*      (D_XXX) WHICH ARE IN THE DOPE VECTOR SECTION FOLLOWING
*      THE PATTERN ROUTINES (DOPE VECTORS ARE USED FOR CMBLKS).
*
*      THE ENTRY POINTS IN THIS SECTION HAVE LABELS OF THE
*      FORM B_XXY WHERE XX IS THE TWO CHARACTER BLOCK TYPE FOR
*      THE CORRESPONDING BLOCK AND Y IS ANY LETTER.
*
*      IN SOME CASES, THE POINTERS SERVE NO OTHER PURPOSE THAN
*      TO IDENTIFY THE BLOCK TYPE. IN THIS CASE THE ROUTINE
*      IS NEVER EXECUTED AND THUS NO CODE IS ASSEMBLED.
*
*      FOR EACH OF THESE ENTRY POINTS CORRESPONDING TO A BLOCK
*      AN ENTRY POINT IDENTIFICATION IS ASSEMBLED (BL_XX).
*
*      THE EXACT ENTRY CONDITIONS DEPEND ON THE MANNER IN
*      WHICH THE ROUTINE IS ACCESSED AND ARE DOCUMENTED WITH
*      THE INDIVIDUAL ROUTINES AS REQUIRED.
*
*      THE ORDER OF THESE ROUTINES IS ALPHABETICAL WITH THE
*      FOLLOWING EXCEPTIONS.
*
*      THE ROUTINES FOR SEBLK AND EXBLK ENTRIES OCCUR FIRST SO
*      THAT EXPRESSIONS CAN BE QUICKLY IDENTIFIED FROM THE FACT
*      THAT THEIR ROUTINES LIE BEFORE THE SYMBOL B_E__.
*
*      THESE ARE IMMEDIATELY FOLLOWED BY THE ROUTINE FOR A TRBLK
*      SO THAT THE TEST AGAINST THE SYMBOL B_T__ CHECKS FOR
*      TRAPPED VALUES OR EXPRESSION VALUES (SEE PROCEDURE EVALP)
*
*      THE PATTERN ROUTINES LIE AFTER THIS SECTION SO THAT
*      PATTERNS ARE IDENTIFIED WITH ROUTINES STARTING AT OR
*      AFTER THE INITIAL INSTRUCTION IN THESE ROUTINES (P_AAA).
*
*      THE SYMBOL B_AAA DEFINES THE FIRST LOCATION FOR BLOCK
*      ROUTINES AND THE SYMBOL P_YYY (AT THE END OF THE PATTERN
*      MATCH ROUTINES SECTION) DEFINES THE LAST SUCH ENTRY POINT
*
{B_AAA{ENT{2,BL__I{{{ENTRY POINT OF FIRST BLOCK ROUTINE{9169
{{EJC{{{{{9170
*
*      EXBLK
*
*      THE ROUTINE FOR AN EXBLK LOADS THE EXPRESSION ONTO
*      THE STACK AS A VALUE.
*
*      (XR)                  POINTER TO EXBLK
*
{B_EXL{ENT{2,BL_EX{{{ENTRY POINT (EXBLK){9179
{{MOV{11,-(XS){7,XR{{STACK RESULT{9180
{{LCW{7,XR{{{GET NEXT CODE WORD{9181
{{BRI{9,(XR){{{EXECUTE IT{9182
{{EJC{{{{{9183
*
*      SEBLK
*
*      THE ROUTINE FOR SEBLK IS ACCESSED FROM THE GENERATED
*      CODE TO LOAD THE EXPRESSION VALUE ONTO THE STACK.
*
{B_SEL{ENT{2,BL_SE{{{ENTRY POINT (SEBLK){9190
{{MOV{11,-(XS){7,XR{{STACK RESULT{9191
{{LCW{7,XR{{{GET NEXT CODE WORD{9192
{{BRI{9,(XR){{{EXECUTE IT{9193
*
*      DEFINE SYMBOL WHICH MARKS END OF ENTRIES FOR EXPRESSIONS
*
{B_E__{ENT{2,BL__I{{{ENTRY POINT{9197
{{EJC{{{{{9198
*
*      TRBLK
*
*      THE ROUTINE FOR A TRBLK IS NEVER EXECUTED
*
{B_TRT{ENT{2,BL_TR{{{ENTRY POINT (TRBLK){9204
*
*      DEFINE SYMBOL MARKING END OF TRAP AND EXPRESSION BLOCKS
*
{B_T__{ENT{2,BL__I{{{END OF TRBLK,SEBLK,EXBLK ENTRIES{9208
{{EJC{{{{{9209
*
*      ARBLK
*
*      THE ROUTINE FOR ARBLK IS NEVER EXECUTED
*
{B_ART{ENT{2,BL_AR{{{ENTRY POINT (ARBLK){9215
{{EJC{{{{{9216
*
*      BCBLK
*
*      THE ROUTINE FOR A BCBLK IS NEVER EXECUTED
*
*      (XR)                  POINTER TO BCBLK
*
{B_BCT{ENT{2,BL_BC{{{ENTRY POINT (BCBLK){9224
{{EJC{{{{{9225
*
*      BFBLK
*
*      THE ROUTINE FOR A BFBLK IS NEVER EXECUTED
*
*      (XR)                  POINTER TO BFBLK
*
{B_BFT{ENT{2,BL_BF{{{ENTRY POINT (BFBLK){9233
{{EJC{{{{{9234
*
*      CCBLK
*
*      THE ROUTINE FOR CCBLK IS NEVER ENTERED
*
{B_CCT{ENT{2,BL_CC{{{ENTRY POINT (CCBLK){9240
{{EJC{{{{{9241
*
*      CDBLK
*
*      THE CDBLK ROUTINES ARE EXECUTED FROM THE GENERATED CODE.
*      THERE ARE TWO CASES DEPENDING ON THE FORM OF CDFAL.
*
*      ENTRY FOR COMPLEX FAILURE CODE AT CDFAL
*
*      (XR)                  POINTER TO CDBLK
*
{B_CDC{ENT{2,BL_CD{{{ENTRY POINT (CDBLK){9252
{BCDC0{MOV{7,XS{3,FLPTR{{POP GARBAGE OFF STACK{9253
{{MOV{9,(XS){13,CDFAL(XR){{SET FAILURE OFFSET{9254
{{BRN{6,STMGO{{{ENTER STMT{9255
{{EJC{{{{{9256
*
*      CDBLK (CONTINUED)
*
*      ENTRY FOR SIMPLE FAILURE CODE AT CDFAL
*
*      (XR)                  POINTER TO CDBLK
*
{B_CDS{ENT{2,BL_CD{{{ENTRY POINT (CDBLK){9264
{BCDS0{MOV{7,XS{3,FLPTR{{POP GARBAGE OFF STACK{9265
{{MOV{9,(XS){19,*CDFAL{{SET FAILURE OFFSET{9266
{{BRN{6,STMGO{{{ENTER STMT{9267
{{EJC{{{{{9268
*
*      CMBLK
*
*      THE ROUTINE FOR A CMBLK IS NEVER EXECUTED
*
{B_CMT{ENT{2,BL_CM{{{ENTRY POINT (CMBLK){9274
{{EJC{{{{{9275
*
*      CTBLK
*
*      THE ROUTINE FOR A CTBLK IS NEVER EXECUTED
*
{B_CTT{ENT{2,BL_CT{{{ENTRY POINT (CTBLK){9281
{{EJC{{{{{9282
*
*      DFBLK
*
*      THE ROUTINE FOR A DFBLK IS ACCESSED FROM THE O_FNC ENTRY
*      TO CALL A DATATYPE FUNCTION AND BUILD A PDBLK.
*
*      (XL)                  POINTER TO DFBLK
*
{B_DFC{ENT{2,BL_DF{{{ENTRY POINT{9291
{{MOV{8,WA{13,DFPDL(XL){{LOAD LENGTH OF PDBLK{9292
{{JSR{6,ALLOC{{{ALLOCATE PDBLK{9293
{{MOV{9,(XR){22,=B_PDT{{STORE TYPE WORD{9294
{{MOV{13,PDDFP(XR){7,XL{{STORE DFBLK POINTER{9295
{{MOV{8,WC{7,XR{{SAVE POINTER TO PDBLK{9296
{{ADD{7,XR{8,WA{{POINT PAST PDBLK{9297
{{LCT{8,WA{13,FARGS(XL){{SET TO COUNT FIELDS{9298
*
*      LOOP TO ACQUIRE FIELD VALUES FROM STACK
*
{BDFC1{MOV{11,-(XR){10,(XS)+{{MOVE A FIELD VALUE{9302
{{BCT{8,WA{6,BDFC1{{LOOP TILL ALL MOVED{9303
{{MOV{7,XR{8,WC{{RECALL POINTER TO PDBLK{9304
{{BRN{6,EXSID{{{EXIT SETTING ID FIELD{9305
{{EJC{{{{{9306
*
*      EFBLK
*
*      THE ROUTINE FOR AN EFBLK IS PASSED CONTROL FORM THE O_FNC
*      ENTRY TO CALL AN EXTERNAL FUNCTION.
*
*      (XL)                  POINTER TO EFBLK
*
{B_EFC{ENT{2,BL_EF{{{ENTRY POINT (EFBLK){9315
{{MOV{8,WC{13,FARGS(XL){{LOAD NUMBER OF ARGUMENTS{9318
{{WTB{8,WC{{{CONVERT TO OFFSET{9319
{{MOV{11,-(XS){7,XL{{SAVE POINTER TO EFBLK{9320
{{MOV{7,XT{7,XS{{COPY POINTER TO ARGUMENTS{9321
*
*      LOOP TO CONVERT ARGUMENTS
*
{BEFC1{ICA{7,XT{{{POINT TO NEXT ENTRY{9325
{{MOV{7,XR{9,(XS){{LOAD POINTER TO EFBLK{9326
{{DCA{8,WC{{{DECREMENT EFTAR OFFSET{9327
{{ADD{7,XR{8,WC{{POINT TO NEXT EFTAR ENTRY{9328
{{MOV{7,XR{13,EFTAR(XR){{LOAD EFTAR ENTRY{9329
{{BSW{7,XR{1,5{{SWITCH ON TYPE{9338
{{IFF{1,0{6,BEFC7{{NO CONVERSION NEEDED{9356
{{IFF{1,1{6,BEFC2{{STRING{9356
{{IFF{1,2{6,BEFC3{{INTEGER{9356
{{IFF{1,3{6,BEFC4{{REAL{9356
{{IFF{1,4{6,BEFF1{{FILE{9356
{{ESW{{{{END OF SWITCH ON TYPE{9356
*
*      HERE TO CONVERT TO FILE
*
{BEFF1{MOV{11,-(XS){7,XT{{SAVE ENTRY POINTER{9361
{{MOV{3,BEFOF{8,WC{{SAVE OFFSET{9362
{{MOV{11,-(XS){9,(XT){{STACK ARG POINTER{9363
{{JSR{6,IOFCB{{{CONVERT TO FCB{9364
{{ERR{1,298{26,External function argument is not file{{{9365
{{ERR{1,298{26,External function argument is not file{{{9366
{{ERR{1,298{26,External function argument is not file{{{9367
{{MOV{7,XR{8,WA{{POINT TO FCB{9368
{{MOV{7,XT{10,(XS)+{{RELOAD ENTRY POINTER{9369
{{BRN{6,BEFC5{{{JUMP TO MERGE{9370
*
*      HERE TO CONVERT TO STRING
*
{BEFC2{MOV{11,-(XS){9,(XT){{STACK ARG PTR{9375
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{9376
{{ERR{1,039{26,External function argument is not a string{{{9377
{{BRN{6,BEFC6{{{JUMP TO MERGE{9378
{{EJC{{{{{9379
*
*      EFBLK (CONTINUED)
*
*      HERE TO CONVERT AN INTEGER
*
{BEFC3{MOV{7,XR{9,(XT){{LOAD NEXT ARGUMENT{9385
{{MOV{3,BEFOF{8,WC{{SAVE OFFSET{9386
{{JSR{6,GTINT{{{CONVERT TO INTEGER{9387
{{ERR{1,040{26,External function argument is not integer{{{9388
{{BRN{6,BEFC5{{{MERGE WITH REAL CASE{9391
*
*      HERE TO CONVERT A REAL
*
{BEFC4{MOV{7,XR{9,(XT){{LOAD NEXT ARGUMENT{9395
{{MOV{3,BEFOF{8,WC{{SAVE OFFSET{9396
{{JSR{6,GTREA{{{CONVERT TO REAL{9397
{{ERR{1,265{26,External function argument is not real{{{9398
*
*      INTEGER CASE MERGES HERE
*
{BEFC5{MOV{8,WC{3,BEFOF{{RESTORE OFFSET{9403
*
*      STRING MERGES HERE
*
{BEFC6{MOV{9,(XT){7,XR{{STORE CONVERTED RESULT{9407
*
*      NO CONVERSION MERGES HERE
*
{BEFC7{BNZ{8,WC{6,BEFC1{{LOOP BACK IF MORE TO GO{9411
*
*      HERE AFTER CONVERTING ALL THE ARGUMENTS
*
{{MOV{7,XL{10,(XS)+{{RESTORE EFBLK POINTER{9415
{{MOV{8,WA{13,FARGS(XL){{GET NUMBER OF ARGS{9416
{{JSR{6,SYSEX{{{CALL ROUTINE TO CALL EXTERNAL FNC{9417
{{PPM{6,EXFAL{{{FAIL IF FAILURE{9418
{{ERR{1,327{26,Calling external function - not found{{{9419
{{ERR{1,326{26,Calling external function - bad argument type{{{9420
{{WTB{8,WA{{{CONVERT NUMBER OF ARGS TO BYTES{9422
{{ADD{7,XS{8,WA{{REMOVE ARGUMENTS FROM STACK{9423
{{EJC{{{{{9425
*
*      EFBLK (CONTINUED)
*
*      RETURN HERE WITH RESULT IN XR
*
*      FIRST DEFEND AGAINST NON-STANDARD NULL STRING RETURNED
*
{{MOV{8,WB{13,EFRSL(XL){{GET RESULT TYPE ID{9433
{{BNZ{8,WB{6,BEFA8{{BRANCH IF NOT UNCONVERTED{9434
{{BNE{9,(XR){22,=B_SCL{6,BEFC8{JUMP IF NOT A STRING{9435
{{BZE{13,SCLEN(XR){6,EXNUL{{RETURN NULL IF NULL{9436
*
*      HERE IF CONVERTED RESULT TO CHECK FOR NULL STRING
*
{BEFA8{BNE{8,WB{18,=NUM01{6,BEFC8{JUMP IF NOT A STRING{9440
{{BZE{13,SCLEN(XR){6,EXNUL{{RETURN NULL IF NULL{9441
*
*      RETURN IF RESULT IS IN DYNAMIC STORAGE
*
{BEFC8{BLT{7,XR{3,DNAMB{6,BEFC9{JUMP IF NOT IN DYNAMIC STORAGE{9445
{{BLE{7,XR{3,DNAMP{6,EXIXR{RETURN RESULT IF ALREADY DYNAMIC{9446
*
*      HERE WE COPY A RESULT INTO THE DYNAMIC REGION
*
{BEFC9{MOV{8,WA{9,(XR){{GET POSSIBLE TYPE WORD{9450
{{BZE{8,WB{6,BEF11{{JUMP IF UNCONVERTED RESULT{9451
{{MOV{8,WA{22,=B_SCL{{STRING{9452
{{BEQ{8,WB{18,=NUM01{6,BEF10{YES JUMP{9453
{{MOV{8,WA{22,=B_ICL{{INTEGER{9454
{{BEQ{8,WB{18,=NUM02{6,BEF10{YES JUMP{9455
{{MOV{8,WA{22,=B_RCL{{REAL{9458
*
*      STORE TYPE WORD IN RESULT
*
{BEF10{MOV{9,(XR){8,WA{{STORED BEFORE COPYING TO DYNAMIC{9463
*
*      MERGE FOR UNCONVERTED RESULT
*
{BEF11{BEQ{9,(XR){22,=B_SCL{6,BEF12{BRANCH IF STRING RESULT{9467
{{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{9468
{{MOV{7,XL{7,XR{{COPY ADDRESS OF OLD BLOCK{9469
{{JSR{6,ALLOC{{{ALLOCATE DYNAMIC BLOCK SAME SIZE{9470
{{MOV{11,-(XS){7,XR{{SET POINTER TO NEW BLOCK AS RESULT{9471
{{MVW{{{{COPY OLD BLOCK TO DYNAMIC BLOCK{9472
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{9473
{{LCW{7,XR{{{GET NEXT CODE WORD{9474
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{9475
*
*      HERE TO RETURN A STRING RESULT THAT WAS NOT IN DYNAMIC.
*      CANNOT USE THE SIMPLE WORD COPY ABOVE BECAUSE IT WILL NOT
*      GUARANTEE ZERO PADDING IN THE LAST WORD.
*
{BEF12{MOV{7,XL{7,XR{{SAVE SOURCE STRING POINTER{9481
{{MOV{8,WA{13,SCLEN(XR){{FETCH STRING LENGTH{9482
{{BZE{8,WA{6,EXNUL{{RETURN NULL STRING IF LENGTH ZERO{9483
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR STRING{9484
{{MOV{11,-(XS){7,XR{{SAVE AS RESULT POINTER{9485
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{9486
{{PLC{7,XL{{{POINT TO CHARS IN SOURCE STRING{9487
{{MOV{8,WA{8,WC{{NUMBER OF CHARACTERS TO COPY{9488
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{9489
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{9490
{{LCW{7,XR{{{GET NEXT CODE WORD{9491
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{9492
{{EJC{{{{{9494
*
*      EVBLK
*
*      THE ROUTINE FOR AN EVBLK IS NEVER EXECUTED
*
{B_EVT{ENT{2,BL_EV{{{ENTRY POINT (EVBLK){9500
{{EJC{{{{{9501
*
*      FFBLK
*
*      THE ROUTINE FOR AN FFBLK IS EXECUTED FROM THE O_FNC ENTRY
*      TO CALL A FIELD FUNCTION AND EXTRACT A FIELD VALUE/NAME.
*
*      (XL)                  POINTER TO FFBLK
*
{B_FFC{ENT{2,BL_FF{{{ENTRY POINT (FFBLK){9510
{{MOV{7,XR{7,XL{{COPY FFBLK POINTER{9511
{{LCW{8,WC{{{LOAD NEXT CODE WORD{9512
{{MOV{7,XL{9,(XS){{LOAD PDBLK POINTER{9513
{{BNE{9,(XL){22,=B_PDT{6,BFFC2{JUMP IF NOT PDBLK AT ALL{9514
{{MOV{8,WA{13,PDDFP(XL){{LOAD DFBLK POINTER FROM PDBLK{9515
*
*      LOOP TO FIND CORRECT FFBLK FOR THIS PDBLK
*
{BFFC1{BEQ{8,WA{13,FFDFP(XR){6,BFFC3{JUMP IF THIS IS THE CORRECT FFBLK{9519
{{MOV{7,XR{13,FFNXT(XR){{ELSE LINK TO NEXT FFBLK ON CHAIN{9520
{{BNZ{7,XR{6,BFFC1{{LOOP BACK IF ANOTHER ENTRY TO CHECK{9521
*
*      HERE FOR BAD ARGUMENT
*
{BFFC2{ERB{1,041{26,FIELD function argument is wrong datatype{{{9525
{{EJC{{{{{9526
*
*      FFBLK (CONTINUED)
*
*      HERE AFTER LOCATING CORRECT FFBLK
*
{BFFC3{MOV{8,WA{13,FFOFS(XR){{LOAD FIELD OFFSET{9532
{{BEQ{8,WC{21,=OFNE_{6,BFFC5{JUMP IF CALLED BY NAME{9533
{{ADD{7,XL{8,WA{{ELSE POINT TO VALUE FIELD{9534
{{MOV{7,XR{9,(XL){{LOAD VALUE{9535
{{BNE{9,(XR){22,=B_TRT{6,BFFC4{JUMP IF NOT TRAPPED{9536
{{SUB{7,XL{8,WA{{ELSE RESTORE NAME BASE,OFFSET{9537
{{MOV{9,(XS){8,WC{{SAVE NEXT CODE WORD OVER PDBLK PTR{9538
{{JSR{6,ACESS{{{ACCESS VALUE{9539
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{9540
{{MOV{8,WC{9,(XS){{RESTORE NEXT CODE WORD{9541
*
*      HERE AFTER GETTING VALUE IN (XR), XL IS GARBAGE
*
{BFFC4{MOV{9,(XS){7,XR{{STORE VALUE ON STACK (OVER PDBLK){9545
{{MOV{7,XR{8,WC{{COPY NEXT CODE WORD{9546
{{MOV{7,XL{9,(XR){{LOAD ENTRY ADDRESS{9547
{{BRI{7,XL{{{JUMP TO ROUTINE FOR NEXT CODE WORD{9548
*
*      HERE IF CALLED BY NAME
*
{BFFC5{MOV{11,-(XS){8,WA{{STORE NAME OFFSET (BASE IS SET){9552
{{LCW{7,XR{{{GET NEXT CODE WORD{9553
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{9554
{{EJC{{{{{9555
*
*      ICBLK
*
*      THE ROUTINE FOR ICBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD AN INTEGER VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO ICBLK
*
{B_ICL{ENT{2,BL_IC{{{ENTRY POINT (ICBLK){9564
{{MOV{11,-(XS){7,XR{{STACK RESULT{9565
{{LCW{7,XR{{{GET NEXT CODE WORD{9566
{{BRI{9,(XR){{{EXECUTE IT{9567
{{EJC{{{{{9568
*
*      KVBLK
*
*      THE ROUTINE FOR A KVBLK IS NEVER EXECUTED.
*
{B_KVT{ENT{2,BL_KV{{{ENTRY POINT (KVBLK){9574
{{EJC{{{{{9575
*
*      NMBLK
*
*      THE ROUTINE FOR A NMBLK IS EXECUTED FROM THE GENERATED
*      CODE FOR THE CASE OF LOADING A NAME ONTO THE STACK
*      WHERE THE NAME IS THAT OF A NATURAL VARIABLE WHICH CAN
*      BE PREEVALUATED AT COMPILE TIME.
*
*      (XR)                  POINTER TO NMBLK
*
{B_NML{ENT{2,BL_NM{{{ENTRY POINT (NMBLK){9586
{{MOV{11,-(XS){7,XR{{STACK RESULT{9587
{{LCW{7,XR{{{GET NEXT CODE WORD{9588
{{BRI{9,(XR){{{EXECUTE IT{9589
{{EJC{{{{{9590
*
*      PDBLK
*
*      THE ROUTINE FOR A PDBLK IS NEVER EXECUTED
*
{B_PDT{ENT{2,BL_PD{{{ENTRY POINT (PDBLK){9596
{{EJC{{{{{9597
*
*      PFBLK
*
*      THE ROUTINE FOR A PFBLK IS EXECUTED FROM THE ENTRY O_FNC
*      TO CALL A PROGRAM DEFINED FUNCTION.
*
*      (XL)                  POINTER TO PFBLK
*
*      THE FOLLOWING STACK ENTRIES ARE MADE BEFORE PASSING
*      CONTROL TO THE PROGRAM DEFINED FUNCTION.
*
*                            SAVED VALUE OF FIRST ARGUMENT
*                            .
*                            SAVED VALUE OF LAST ARGUMENT
*                            SAVED VALUE OF FIRST LOCAL
*                            .
*                            SAVED VALUE OF LAST LOCAL
*                            SAVED VALUE OF FUNCTION NAME
*                            SAVED CODE BLOCK PTR (R_COD)
*                            SAVED CODE POINTER (-R_COD)
*                            SAVED VALUE OF FLPRT
*                            SAVED VALUE OF FLPTR
*                            POINTER TO PFBLK
*      FLPTR --------------- ZERO (TO BE OVERWRITTEN WITH OFFS)
*
{B_PFC{ENT{2,BL_PF{{{ENTRY POINT (PFBLK){9623
{{MOV{3,BPFPF{7,XL{{SAVE PFBLK PTR (NEED NOT BE RELOC){9624
{{MOV{7,XR{7,XL{{COPY FOR THE MOMENT{9625
{{MOV{7,XL{13,PFVBL(XR){{POINT TO VRBLK FOR FUNCTION{9626
*
*      LOOP TO FIND OLD VALUE OF FUNCTION
*
{BPF01{MOV{8,WB{7,XL{{SAVE POINTER{9630
{{MOV{7,XL{13,VRVAL(XL){{LOAD VALUE{9631
{{BEQ{9,(XL){22,=B_TRT{6,BPF01{LOOP IF TRBLK{9632
*
*      SET VALUE TO NULL AND SAVE OLD FUNCTION VALUE
*
{{MOV{3,BPFSV{7,XL{{SAVE OLD VALUE{9636
{{MOV{7,XL{8,WB{{POINT BACK TO BLOCK WITH VALUE{9637
{{MOV{13,VRVAL(XL){21,=NULLS{{SET VALUE TO NULL{9638
{{MOV{8,WA{13,FARGS(XR){{LOAD NUMBER OF ARGUMENTS{9639
{{ADD{7,XR{19,*PFARG{{POINT TO PFARG ENTRIES{9640
{{BZE{8,WA{6,BPF04{{JUMP IF NO ARGUMENTS{9641
{{MOV{7,XT{7,XS{{PTR TO LAST ARG{9642
{{WTB{8,WA{{{CONVERT NO. OF ARGS TO BYTES OFFSET{9643
{{ADD{7,XT{8,WA{{POINT BEFORE FIRST ARG{9644
{{MOV{3,BPFXT{7,XT{{REMEMBER ARG POINTER{9645
{{EJC{{{{{9646
*
*      PFBLK (CONTINUED)
*
*      LOOP TO SAVE OLD ARGUMENT VALUES AND SET NEW ONES
*
{BPF02{MOV{7,XL{10,(XR)+{{LOAD VRBLK PTR FOR NEXT ARGUMENT{9652
*
*      LOOP THROUGH POSSIBLE TRBLK CHAIN TO FIND VALUE
*
{BPF03{MOV{8,WC{7,XL{{SAVE POINTER{9656
{{MOV{7,XL{13,VRVAL(XL){{LOAD NEXT VALUE{9657
{{BEQ{9,(XL){22,=B_TRT{6,BPF03{LOOP BACK IF TRBLK{9658
*
*      SAVE OLD VALUE AND GET NEW VALUE
*
{{MOV{8,WA{7,XL{{KEEP OLD VALUE{9662
{{MOV{7,XT{3,BPFXT{{POINT BEFORE NEXT STACKED ARG{9663
{{MOV{8,WB{11,-(XT){{LOAD ARGUMENT (NEW VALUE){9664
{{MOV{9,(XT){8,WA{{SAVE OLD VALUE{9665
{{MOV{3,BPFXT{7,XT{{KEEP ARG PTR FOR NEXT TIME{9666
{{MOV{7,XL{8,WC{{POINT BACK TO BLOCK WITH VALUE{9667
{{MOV{13,VRVAL(XL){8,WB{{SET NEW VALUE{9668
{{BNE{7,XS{3,BPFXT{6,BPF02{LOOP IF NOT ALL DONE{9669
*
*      NOW PROCESS LOCALS
*
{BPF04{MOV{7,XL{3,BPFPF{{RESTORE PFBLK POINTER{9673
{{MOV{8,WA{13,PFNLO(XL){{LOAD NUMBER OF LOCALS{9674
{{BZE{8,WA{6,BPF07{{JUMP IF NO LOCALS{9675
{{MOV{8,WB{21,=NULLS{{GET NULL CONSTANT{9676
{{LCT{8,WA{8,WA{{SET LOCAL COUNTER{9677
*
*      LOOP TO PROCESS LOCALS
*
{BPF05{MOV{7,XL{10,(XR)+{{LOAD VRBLK PTR FOR NEXT LOCAL{9681
*
*      LOOP THROUGH POSSIBLE TRBLK CHAIN TO FIND VALUE
*
{BPF06{MOV{8,WC{7,XL{{SAVE POINTER{9685
{{MOV{7,XL{13,VRVAL(XL){{LOAD NEXT VALUE{9686
{{BEQ{9,(XL){22,=B_TRT{6,BPF06{LOOP BACK IF TRBLK{9687
*
*      SAVE OLD VALUE AND SET NULL AS NEW VALUE
*
{{MOV{11,-(XS){7,XL{{STACK OLD VALUE{9691
{{MOV{7,XL{8,WC{{POINT BACK TO BLOCK WITH VALUE{9692
{{MOV{13,VRVAL(XL){8,WB{{SET NULL AS NEW VALUE{9693
{{BCT{8,WA{6,BPF05{{LOOP TILL ALL LOCALS PROCESSED{9694
{{EJC{{{{{9695
*
*      PFBLK (CONTINUED)
*
*      HERE AFTER PROCESSING ARGUMENTS AND LOCALS
*
{BPF07{ZER{7,XR{{{ZERO REG XR IN CASE{9704
{{BZE{3,KVPFL{6,BPF7C{{SKIP IF PROFILING IS OFF{9705
{{BEQ{3,KVPFL{18,=NUM02{6,BPF7A{BRANCH ON TYPE OF PROFILE{9706
*
*      HERE IF &PROFILE = 1
*
{{JSR{6,SYSTM{{{GET CURRENT TIME{9710
{{STI{3,PFETM{{{SAVE FOR A SEC{9711
{{SBI{3,PFSTM{{{FIND TIME USED BY CALLER{9712
{{JSR{6,ICBLD{{{BUILD INTO AN ICBLK{9713
{{LDI{3,PFETM{{{RELOAD CURRENT TIME{9714
{{BRN{6,BPF7B{{{MERGE{9715
*
*       HERE IF &PROFILE = 2
*
{BPF7A{LDI{3,PFSTM{{{GET START TIME OF CALLING STMT{9719
{{JSR{6,ICBLD{{{ASSEMBLE AN ICBLK ROUND IT{9720
{{JSR{6,SYSTM{{{GET NOW TIME{9721
*
*      BOTH TYPES OF PROFILE MERGE HERE
*
{BPF7B{STI{3,PFSTM{{{SET START TIME OF 1ST FUNC STMT{9725
{{MNZ{3,PFFNC{{{FLAG FUNCTION ENTRY{9726
*
*      NO PROFILING MERGES HERE
*
{BPF7C{MOV{11,-(XS){7,XR{{STACK ICBLK PTR (OR ZERO){9730
{{MOV{8,WA{3,R_COD{{LOAD OLD CODE BLOCK POINTER{9731
{{SCP{8,WB{{{GET CODE POINTER{9733
{{SUB{8,WB{8,WA{{MAKE CODE POINTER INTO OFFSET{9734
{{MOV{7,XL{3,BPFPF{{RECALL PFBLK POINTER{9735
{{MOV{11,-(XS){3,BPFSV{{STACK OLD VALUE OF FUNCTION NAME{9736
{{MOV{11,-(XS){8,WA{{STACK CODE BLOCK POINTER{9737
{{MOV{11,-(XS){8,WB{{STACK CODE OFFSET{9738
{{MOV{11,-(XS){3,FLPRT{{STACK OLD FLPRT{9739
{{MOV{11,-(XS){3,FLPTR{{STACK OLD FAILURE POINTER{9740
{{MOV{11,-(XS){7,XL{{STACK POINTER TO PFBLK{9741
{{ZER{11,-(XS){{{DUMMY ZERO ENTRY FOR FAIL RETURN{9742
{{CHK{{{{CHECK FOR STACK OVERFLOW{9743
{{MOV{3,FLPTR{7,XS{{SET NEW FAIL RETURN VALUE{9744
{{MOV{3,FLPRT{7,XS{{SET NEW FLPRT{9745
{{MOV{8,WA{3,KVTRA{{LOAD TRACE VALUE{9746
{{ADD{8,WA{3,KVFTR{{ADD FTRACE VALUE{9747
{{BNZ{8,WA{6,BPF09{{JUMP IF TRACING POSSIBLE{9748
{{ICV{3,KVFNC{{{ELSE BUMP FNCLEVEL{9749
*
*      HERE TO ACTUALLY JUMP TO FUNCTION
*
{BPF08{MOV{7,XR{13,PFCOD(XL){{POINT TO VRBLK OF ENTRY LABEL{9753
{{MOV{7,XR{13,VRLBL(XR){{POINT TO TARGET CODE{9754
{{BEQ{7,XR{21,=STNDL{6,BPF17{TEST FOR UNDEFINED LABEL{9755
{{BNE{9,(XR){22,=B_TRT{6,BPF8A{JUMP IF NOT TRAPPED{9756
{{MOV{7,XR{13,TRLBL(XR){{ELSE LOAD PTR TO REAL LABEL CODE{9757
{BPF8A{BRI{9,(XR){{{OFF TO EXECUTE FUNCTION{9758
*
*      HERE IF TRACING IS POSSIBLE
*
{BPF09{MOV{7,XR{13,PFCTR(XL){{LOAD POSSIBLE CALL TRACE TRBLK{9762
{{MOV{7,XL{13,PFVBL(XL){{LOAD VRBLK POINTER FOR FUNCTION{9763
{{MOV{8,WA{19,*VRVAL{{SET NAME OFFSET FOR VARIABLE{9764
{{BZE{3,KVTRA{6,BPF10{{JUMP IF TRACE MODE IS OFF{9765
{{BZE{7,XR{6,BPF10{{OR IF THERE IS NO CALL TRACE{9766
*
*      HERE IF CALL TRACED
*
{{DCV{3,KVTRA{{{DECREMENT TRACE COUNT{9770
{{BZE{13,TRFNC(XR){6,BPF11{{JUMP IF PRINT TRACE{9771
{{JSR{6,TRXEQ{{{EXECUTE FUNCTION TYPE TRACE{9772
{{EJC{{{{{9773
*
*      PFBLK (CONTINUED)
*
*      HERE TO TEST FOR FTRACE TRACE
*
{BPF10{BZE{3,KVFTR{6,BPF16{{JUMP IF FTRACE IS OFF{9779
{{DCV{3,KVFTR{{{ELSE DECREMENT FTRACE{9780
*
*      HERE FOR PRINT TRACE
*
{BPF11{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{9784
{{JSR{6,PRTNM{{{PRINT FUNCTION NAME{9785
{{MOV{8,WA{18,=CH_PP{{LOAD LEFT PAREN{9786
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{9787
{{MOV{7,XL{13,NUM01(XS){{RECOVER PFBLK POINTER{9788
{{BZE{13,FARGS(XL){6,BPF15{{SKIP IF NO ARGUMENTS{9789
{{ZER{8,WB{{{ELSE SET ARGUMENT COUNTER{9790
{{BRN{6,BPF13{{{JUMP INTO LOOP{9791
*
*      LOOP TO PRINT ARGUMENT VALUES
*
{BPF12{MOV{8,WA{18,=CH_CM{{LOAD COMMA{9795
{{JSR{6,PRTCH{{{PRINT TO SEPARATE FROM LAST ARG{9796
*
*      MERGE HERE FIRST TIME (NO COMMA REQUIRED)
*
{BPF13{MOV{9,(XS){8,WB{{SAVE ARG CTR (OVER FAILOFFS IS OK){9800
{{WTB{8,WB{{{CONVERT TO BYTE OFFSET{9801
{{ADD{7,XL{8,WB{{POINT TO NEXT ARGUMENT POINTER{9802
{{MOV{7,XR{13,PFARG(XL){{LOAD NEXT ARGUMENT VRBLK PTR{9803
{{SUB{7,XL{8,WB{{RESTORE PFBLK POINTER{9804
{{MOV{7,XR{13,VRVAL(XR){{LOAD NEXT VALUE{9805
{{JSR{6,PRTVL{{{PRINT ARGUMENT VALUE{9806
{{EJC{{{{{9807
*
*      HERE AFTER DEALING WITH ONE ARGUMENT
*
{{MOV{8,WB{9,(XS){{RESTORE ARGUMENT COUNTER{9811
{{ICV{8,WB{{{INCREMENT ARGUMENT COUNTER{9812
{{BLT{8,WB{13,FARGS(XL){6,BPF12{LOOP IF MORE TO PRINT{9813
*
*      MERGE HERE IN NO ARGS CASE TO PRINT PAREN
*
{BPF15{MOV{8,WA{18,=CH_RP{{LOAD RIGHT PAREN{9817
{{JSR{6,PRTCH{{{PRINT TO TERMINATE OUTPUT{9818
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{9819
*
*      MERGE HERE TO EXIT WITH TEST FOR FNCLEVEL TRACE
*
{BPF16{ICV{3,KVFNC{{{INCREMENT FNCLEVEL{9823
{{MOV{7,XL{3,R_FNC{{LOAD PTR TO POSSIBLE TRBLK{9824
{{JSR{6,KTREX{{{CALL KEYWORD TRACE ROUTINE{9825
*
*      CALL FUNCTION AFTER TRACE TESTS COMPLETE
*
{{MOV{7,XL{13,NUM01(XS){{RESTORE PFBLK POINTER{9829
{{BRN{6,BPF08{{{JUMP BACK TO EXECUTE FUNCTION{9830
*
*      HERE IF CALLING A FUNCTION WHOSE ENTRY LABEL IS UNDEFINED
*
{BPF17{MOV{3,FLPTR{13,NUM02(XS){{RESET SO EXFAL CAN RETURN TO EVALX{9834
{{ERB{1,286{26,Function call to undefined entry label{{{9835
{{EJC{{{{{9838
*
*      RCBLK
*
*      THE ROUTINE FOR AN RCBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD A REAL VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO RCBLK
*
{B_RCL{ENT{2,BL_RC{{{ENTRY POINT (RCBLK){9847
{{MOV{11,-(XS){7,XR{{STACK RESULT{9848
{{LCW{7,XR{{{GET NEXT CODE WORD{9849
{{BRI{9,(XR){{{EXECUTE IT{9850
{{EJC{{{{{9852
*
*      SCBLK
*
*      THE ROUTINE FOR AN SCBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD A STRING VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO SCBLK
*
{B_SCL{ENT{2,BL_SC{{{ENTRY POINT (SCBLK){9861
{{MOV{11,-(XS){7,XR{{STACK RESULT{9862
{{LCW{7,XR{{{GET NEXT CODE WORD{9863
{{BRI{9,(XR){{{EXECUTE IT{9864
{{EJC{{{{{9865
*
*      TBBLK
*
*      THE ROUTINE FOR A TBBLK IS NEVER EXECUTED
*
{B_TBT{ENT{2,BL_TB{{{ENTRY POINT (TBBLK){9871
{{EJC{{{{{9872
*
*      TEBLK
*
*      THE ROUTINE FOR A TEBLK IS NEVER EXECUTED
*
{B_TET{ENT{2,BL_TE{{{ENTRY POINT (TEBLK){9878
{{EJC{{{{{9879
*
*      VCBLK
*
*      THE ROUTINE FOR A VCBLK IS NEVER EXECUTED
*
{B_VCT{ENT{2,BL_VC{{{ENTRY POINT (VCBLK){9885
{{EJC{{{{{9886
*
*      VRBLK
*
*      THE VRBLK ROUTINES ARE EXECUTED FROM THE GENERATED CODE.
*      THERE ARE SIX ENTRIES FOR VRBLK COVERING VARIOUS CASES
*
{B_VR_{ENT{2,BL__I{{{MARK START OF VRBLK ENTRY POINTS{9893
*
*      ENTRY FOR VRGET (TRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO LOAD THE VALUE OF A VARIABLE.
*      THIS ENTRY POINT IS USED IF AN ACCESS TRACE OR INPUT
*      ASSOCIATION IS CURRENTLY ACTIVE.
*
*      (XR)                  POINTER TO VRGET FIELD OF VRBLK
*
{B_VRA{ENT{2,BL__I{{{ENTRY POINT{9902
{{MOV{7,XL{7,XR{{COPY NAME BASE (VRGET = 0){9903
{{MOV{8,WA{19,*VRVAL{{SET NAME OFFSET{9904
{{JSR{6,ACESS{{{ACCESS VALUE{9905
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{9906
{{MOV{11,-(XS){7,XR{{STACK RESULT{9907
{{LCW{7,XR{{{GET NEXT CODE WORD{9908
{{BRI{9,(XR){{{EXECUTE IT{9909
{{EJC{{{{{9910
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (ERROR CASE. THIS ROUTINE IS CALLED FROM
*      THE EXECUTED CODE FOR AN ATTEMPT TO MODIFY THE VALUE
*      OF A PROTECTED (PATTERN VALUED) NATURAL VARIABLE.
*
{B_VRE{ENT{{{{ENTRY POINT{9918
{{ERB{1,042{26,Attempt to change value of protected variable{{{9919
{{EJC{{{{{9920
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRTRA (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE EXECUTED CODE TO TRANSFER TO A LABEL.
*
*      (XR)                  POINTER TO VRTRA FIELD OF VRBLK
*
{B_VRG{ENT{{{{ENTRY POINT{9929
{{MOV{7,XR{13,VRLBO(XR){{LOAD CODE POINTER{9930
{{MOV{7,XL{9,(XR){{LOAD ENTRY ADDRESS{9931
{{BRI{7,XL{{{JUMP TO ROUTINE FOR NEXT CODE WORD{9932
{{EJC{{{{{9933
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRGET (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO LOAD THE VALUE OF A VARIABLE.
*
*      (XR)                  POINTS TO VRGET FIELD OF VRBLK
*
{B_VRL{ENT{{{{ENTRY POINT{9942
{{MOV{11,-(XS){13,VRVAL(XR){{LOAD VALUE ONTO STACK (VRGET = 0){9943
{{LCW{7,XR{{{GET NEXT CODE WORD{9944
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{9945
{{EJC{{{{{9946
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO STORE THE VALUE OF A VARIABLE.
*
*      (XR)                  POINTER TO VRSTO FIELD OF VRBLK
*
{B_VRS{ENT{{{{ENTRY POINT{9955
{{MOV{13,VRVLO(XR){9,(XS){{STORE VALUE, LEAVE ON STACK{9956
{{LCW{7,XR{{{GET NEXT CODE WORD{9957
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{9958
{{EJC{{{{{9959
*
*      VRBLK (CONTINUED)
*
*      VRTRA (TRAPPED CASE). THIS ROUTINE IS CALLED FROM THE
*      GENERATED CODE TO TRANSFER TO A LABEL WHEN A LABEL
*      TRACE IS CURRENTLY ACTIVE.
*
{B_VRT{ENT{{{{ENTRY POINT{9967
{{SUB{7,XR{19,*VRTRA{{POINT BACK TO START OF VRBLK{9968
{{MOV{7,XL{7,XR{{COPY VRBLK POINTER{9969
{{MOV{8,WA{19,*VRVAL{{SET NAME OFFSET{9970
{{MOV{7,XR{13,VRLBL(XL){{LOAD POINTER TO TRBLK{9971
{{BZE{3,KVTRA{6,BVRT2{{JUMP IF TRACE IS OFF{9972
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{9973
{{BZE{13,TRFNC(XR){6,BVRT1{{JUMP IF PRINT TRACE CASE{9974
{{JSR{6,TRXEQ{{{ELSE EXECUTE FULL TRACE{9975
{{BRN{6,BVRT2{{{MERGE TO JUMP TO LABEL{9976
*
*      HERE FOR PRINT TRACE -- PRINT COLON ( LABEL NAME )
*
{BVRT1{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{9980
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{9981
{{MOV{8,WA{18,=CH_CL{{COLON{9982
{{JSR{6,PRTCH{{{PRINT IT{9983
{{MOV{8,WA{18,=CH_PP{{LEFT PAREN{9984
{{JSR{6,PRTCH{{{PRINT IT{9985
{{JSR{6,PRTVN{{{PRINT LABEL NAME{9986
{{MOV{8,WA{18,=CH_RP{{RIGHT PAREN{9987
{{JSR{6,PRTCH{{{PRINT IT{9988
{{JSR{6,PRTNL{{{TERMINATE LINE{9989
{{MOV{7,XR{13,VRLBL(XL){{POINT BACK TO TRBLK{9990
*
*      MERGE HERE TO JUMP TO LABEL
*
{BVRT2{MOV{7,XR{13,TRLBL(XR){{LOAD POINTER TO ACTUAL CODE{9994
{{BRI{9,(XR){{{EXECUTE STATEMENT AT LABEL{9995
{{EJC{{{{{9996
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (TRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO STORE THE VALUE OF A VARIABLE.
*      THIS ENTRY IS USED WHEN A VALUE TRACE OR OUTPUT
*      ASSOCIATION IS CURRENTLY ACTIVE.
*
*      (XR)                  POINTER TO VRSTO FIELD OF VRBLK
*
{B_VRV{ENT{{{{ENTRY POINT{10007
{{MOV{8,WB{9,(XS){{LOAD VALUE (LEAVE COPY ON STACK){10008
{{SUB{7,XR{19,*VRSTO{{POINT TO VRBLK{10009
{{MOV{7,XL{7,XR{{COPY VRBLK POINTER{10010
{{MOV{8,WA{19,*VRVAL{{SET OFFSET{10011
{{JSR{6,ASIGN{{{CALL ASSIGNMENT ROUTINE{10012
{{PPM{6,EXFAL{{{FAIL IF ASSIGNMENT FAILS{10013
{{LCW{7,XR{{{ELSE GET NEXT CODE WORD{10014
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{10015
{{EJC{{{{{10016
*
*      XNBLK
*
*      THE ROUTINE FOR AN XNBLK IS NEVER EXECUTED
*
{B_XNT{ENT{2,BL_XN{{{ENTRY POINT (XNBLK){10022
{{EJC{{{{{10023
*
*      XRBLK
*
*      THE ROUTINE FOR AN XRBLK IS NEVER EXECUTED
*
{B_XRT{ENT{2,BL_XR{{{ENTRY POINT (XRBLK){10029
*
*      MARK ENTRY ADDRESS PAST LAST BLOCK ACTION ROUTINE
*
{B_YYY{ENT{2,BL__I{{{LAST BLOCK ROUTINE ENTRY POINT{10033
{{TTL{27,S P I T B O L -- PATTERN MATCHING ROUTINES{{{{10034
*
*      THE FOLLOWING SECTION CONSISTS OF THE PATTERN MATCHING
*      ROUTINES. ALL PATTERN NODES CONTAIN A POINTER (PCODE)
*      TO ONE OF THE ROUTINES IN THIS SECTION (P_XXX).
*
*      NOTE THAT THIS SECTION FOLLOWS THE B_XXX ROUTINES TO
*      ENABLE A FAST TEST FOR THE PATTERN DATATYPE.
*
{P_AAA{ENT{2,BL__I{{{ENTRY TO MARK FIRST PATTERN{10043
*
*
*      THE ENTRY CONDITIONS TO THE MATCH ROUTINE ARE AS FOLLOWS
*      (SEE O_PMN, O_PMV, O_PMS AND PROCEDURE MATCH).
*
*      STACK CONTENTS.
*
*                            NAME BASE (O_PMN ONLY)
*                            NAME OFFSET (O_PMN ONLY)
*                            TYPE (0-O_PMN, 1-O_PMV, 2-O_PMS)
*      PMHBS --------------- INITIAL CURSOR (ZERO)
*                            INITIAL NODE POINTER
*      XS ------------------ =NDABO (ANCHORED), =NDUNA (UNANCH)
*
*      REGISTER VALUES.
*
*           (XS)             SET AS SHOWN IN STACK DIAGRAM
*           (XR)             POINTER TO INITIAL PATTERN NODE
*           (WB)             INITIAL CURSOR (ZERO)
*
*      GLOBAL PATTERN VALUES
*
*           R_PMS            POINTER TO SUBJECT STRING SCBLK
*           PMSSL            LENGTH OF SUBJECT STRING IN CHARS
*           PMDFL            DOT FLAG, INITIALLY ZERO
*           PMHBS            SET AS SHOWN IN STACK DIAGRAM
*
*      CONTROL IS PASSED BY BRANCHING THROUGH THE PCODE
*      FIELD OF THE INITIAL PATTERN NODE (BRI (XR)).
{{EJC{{{{{10073
*
*      DESCRIPTION OF ALGORITHM
*
*      A PATTERN STRUCTURE IS REPRESENTED AS A LINKED GRAPH
*      OF NODES WITH THE FOLLOWING STRUCTURE.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*           I                PARM2               I
*           +------------------------------------+
*
*      PCODE IS A POINTER TO THE ROUTINE WHICH WILL PERFORM
*      THE MATCH OF THIS PARTICULAR NODE TYPE.
*
*      PTHEN IS A POINTER TO THE SUCCESSOR NODE. I.E. THE NODE
*      TO BE MATCHED IF THE ATTEMPT TO MATCH THIS NODE SUCCEEDS.
*      IF THIS IS THE LAST NODE OF THE PATTERN PTHEN POINTS
*      TO THE DUMMY NODE NDNTH WHICH INITIATES PATTERN EXIT.
*
*      PARM1, PARM2 ARE PARAMETERS WHOSE USE VARIES WITH THE
*      PARTICULAR NODE. THEY ARE ONLY PRESENT IF REQUIRED.
*
*      ALTERNATIVES ARE HANDLED WITH THE SPECIAL ALTERNATIVE
*      NODE WHOSE PARAMETER POINTS TO THE NODE TO BE MATCHED
*      IF THERE IS A FAILURE ON THE SUCCESSOR PATH.
*
*      THE FOLLOWING EXAMPLE ILLUSTRATES THE MANNER IN WHICH
*      THE STRUCTURE IS BUILT UP. THE PATTERN IS
*
*      (A / B / C) (D / E)   WHERE / IS ALTERNATION
*
*      IN THE DIAGRAM, THE NODE MARKED + REPRESENTS AN
*      ALTERNATIVE NODE AND THE DOTTED LINE FROM A + NODE
*      REPRESENTS THE PARAMETER POINTER TO THE ALTERNATIVE.
*
*      +---+     +---+     +---+     +---+
*      I + I-----I A I-----I + I-----I D I-----
*      +---+     +---+  I  +---+     +---+
*        .              I    .
*        .              I    .
*      +---+     +---+  I  +---+
*      I + I-----I B I--I  I E I-----
*      +---+     +---+  I  +---+
*        .              I
*        .              I
*      +---+            I
*      I C I------------I
*      +---+
{{EJC{{{{{10127
*
*      DURING THE MATCH, THE REGISTERS ARE USED AS FOLLOWS.
*
*      (XR)                  POINTS TO THE CURRENT NODE
*      (XL)                  SCRATCH
*      (XS)                  MAIN STACK POINTER
*      (WB)                  CURSOR (NUMBER OF CHARS MATCHED)
*      (WA,WC)               SCRATCH
*
*      TO KEEP TRACK OF ALTERNATIVES, THE MAIN STACK IS USED AS
*      A HISTORY STACK AND CONTAINS TWO WORD ENTRIES.
*
*      WORD 1                SAVED CURSOR VALUE
*      WORD 2                NODE TO MATCH ON FAILURE
*
*      WHEN A FAILURE OCCURS, THE MOST RECENT ENTRY ON THIS
*      STACK IS POPPED OFF TO RESTORE THE CURSOR AND POINT
*      TO THE NODE TO BE MATCHED AS AN ALTERNATIVE. THE ENTRY
*      AT THE BOTTOM OF THE STACK POINTS TO THE FOLLOWING
*      SPECIAL NODES DEPENDING ON THE SCAN MODE.
*
*      ANCHORED MODE         THE BOTTOM ENTRY POINTS TO THE
*                            SPECIAL NODE NDABO WHICH CAUSES AN
*                            ABORT. THE CURSOR VALUE STORED
*                            WITH THIS ENTRY IS ALWAYS ZERO.
*
*      UNANCHORED MODE       THE BOTTOM ENTRY POINTS TO THE
*                            SPECIAL NODE NDUNA WHICH MOVES THE
*                            ANCHOR POINT AND RESTARTS THE MATCH
*                            THE CURSOR SAVED WITH THIS ENTRY
*                            IS THE NUMBER OF CHARACTERS WHICH
*                            LIE BEFORE THE INITIAL ANCHOR POINT
*                            (I.E. THE NUMBER OF ANCHOR MOVES).
*                            THIS ENTRY IS THREE WORDS LONG AND
*                            ALSO CONTAINS THE INITIAL PATTERN.
*
*      ENTRIES ARE MADE ON THIS HISTORY STACK BY ALTERNATIVE
*      NODES AND BY SOME SPECIAL COMPOUND PATTERNS AS DESCRIBED
*      LATER ON. THE FOLLOWING GLOBAL LOCATIONS ARE USED DURING
*      PATTERN MATCHING.
*
*      R_PMS                 POINTER TO SUBJECT STRING
*      PMSSL                 LENGTH OF SUBJECT STRING
*      PMDFL                 FLAG SET NON-ZERO FOR DOT PATTERNS
*      PMHBS                 BASE PTR FOR CURRENT HISTORY STACK
*
*      THE FOLLOWING EXIT POINTS ARE AVAILABLE TO MATCH ROUTINES
*
*      SUCCP                 SUCCESS IN MATCHING CURRENT NODE
*      FAILP                 FAILURE IN MATCHING CURRENT NODE
{{EJC{{{{{10178
*
*      COMPOUND PATTERNS
*
*      SOME PATTERNS HAVE IMPLICIT ALTERNATIVES AND THEIR
*      REPRESENTATION IN THE PATTERN STRUCTURE CONSISTS OF A
*      LINKED SET OF NODES AS INDICATED BY THESE DIAGRAMS.
*
*      AS BEFORE, THE + REPRESENTS AN ALTERNATIVE NODE AND
*      THE DOTTED LINE FROM A + NODE IS THE PARAMETER POINTER
*      TO THE ALTERNATIVE PATTERN.
*
*      ARB
*      ---
*
*           +---+            THIS NODE (P_ARB) MATCHES NULL
*           I B I-----       AND STACKS CURSOR, SUCCESSOR PTR,
*           +---+            CURSOR (COPY) AND A PTR TO NDARC.
*
*
*
*
*      BAL
*      ---
*
*           +---+            THE P_BAL NODE SCANS A BALANCED
*           I B I-----       STRING AND THEN STACKS A POINTER
*           +---+            TO ITSELF ON THE HISTORY STACK.
{{EJC{{{{{10206
*
*      COMPOUND PATTERN STRUCTURES (CONTINUED)
*
*
*      ARBNO
*      -----
*
*           +---+            THIS ALTERNATIVE NODE MATCHES NULL
*      +----I + I-----       THE FIRST TIME AND STACKS A POINTER
*      I    +---+            TO THE ARGUMENT PATTERN X.
*      I      .
*      I      .
*      I    +---+            NODE (P_ABA) TO STACK CURSOR
*      I    I A I            AND HISTORY STACK BASE PTR.
*      I    +---+
*      I      I
*      I      I
*      I    +---+            THIS IS THE ARGUMENT PATTERN. AS
*      I    I X I            INDICATED, THE SUCCESSOR OF THE
*      I    +---+            PATTERN IS THE P_ABC NODE
*      I      I
*      I      I
*      I    +---+            THIS NODE (P_ABC) POPS PMHBS,
*      +----I C I            STACKS OLD PMHBS AND PTR TO NDABD
*           +---+            (UNLESS OPTIMIZATION HAS OCCURRED)
*
*      STRUCTURE AND EXECUTION OF THIS PATTERN RESEMBLE THOSE OF
*      RECURSIVE PATTERN MATCHING AND IMMEDIATE ASSIGNMENT.
*      THE ALTERNATIVE NODE AT THE HEAD OF THE STRUCTURE MATCHES
*      NULL INITIALLY BUT ON SUBSEQUENT FAILURE ENSURES ATTEMPT
*      TO MATCH THE ARGUMENT.  BEFORE THE ARGUMENT IS MATCHED
*      P_ABA STACKS THE CURSOR, PMHBS AND A PTR TO P_ABB.  IF
*      THE ARGUMENT CANT BE MATCHED , P_ABB REMOVES THIS SPECIAL
*      STACK ENTRY AND FAILS.
*      IF ARGUMENT IS MATCHED , P_ABC RESTORES THE OUTER PMHBS
*      VALUE (SAVED BY P_ABA) .  THEN IF THE ARGUMENT HAS LEFT
*      ALTERNATIVES ON STACK IT STACKS THE INNER VALUE OF PMHBS
*      AND A PTR TO NDABD. IF ARGUMENT LEFT NOTHING ON THE STACK
*      IT OPTIMISES BY REMOVING ITEMS STACKED BY P_ABA.  FINALLY
*      A CHECK IS MADE THAT ARGUMENT MATCHED MORE THAN THE NULL
*      STRING (CHECK IS INTENDED TO PREVENT USELESS LOOPING).
*      IF SO THE SUCCESSOR IS AGAIN THE ALTERNATIVE NODE AT THE
*      HEAD OF THE STRUCTURE , ENSURING A POSSIBLE EXTRA ATTEMPT
*      TO MATCH THE ARG IF NECESSARY.  IF NOT , THE SUCCESSOR TO
*      ALTERNATIVE IS TAKEN SO AS TO TERMINATE THE LOOP.  P_ABD
*      RESTORES INNER PMHBS PTR AND FAILS , THUS TRYING TO MATCH
*      ALTERNATIVES LEFT BY THE ARBNO ARGUMENT.
{{EJC{{{{{10254
*
*      COMPOUND PATTERN STRUCTURES (CONTINUED)
*
*      BREAKX
*      ------
*
*           +---+            THIS NODE IS A BREAK NODE FOR
*      +----I B I            THE ARGUMENT TO BREAKX, IDENTICAL
*      I    +---+            TO AN ORDINARY BREAK NODE.
*      I      I
*      I      I
*      I    +---+            THIS ALTERNATIVE NODE STACKS A
*      I    I + I-----       POINTER TO THE BREAKX NODE TO
*      I    +---+            ALLOW FOR SUBSEQUENT FAILURE
*      I      .
*      I      .
*      I    +---+            THIS IS THE BREAKX NODE ITSELF. IT
*      +----I X I            MATCHES ONE CHARACTER AND THEN
*           +---+            PROCEEDS BACK TO THE BREAK NODE.
*
*
*
*
*      FENCE
*      -----
*
*           +---+            THE FENCE NODE MATCHES NULL AND
*           I F I-----       STACKS A POINTER TO NODE NDABO TO
*           +---+            ABORT ON A SUBSEQUENT REMATCH
*
*
*
*
*      SUCCEED
*      -------
*
*           +---+            THE NODE FOR SUCCEED MATCHES NULL
*           I S I-----       AND STACKS A POINTER TO ITSELF
*           +---+            TO REPEAT THE MATCH ON A FAILURE.
{{EJC{{{{{10294
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      BINARY DOT (PATTERN ASSIGNMENT)
*      -------------------------------
*
*           +---+            THIS NODE (P_PAA) SAVES THE CURRENT
*           I A I            CURSOR AND A POINTER TO THE
*           +---+            SPECIAL NODE NDPAB ON THE STACK.
*             I
*             I
*           +---+            THIS IS THE STRUCTURE FOR THE
*           I X I            PATTERN LEFT ARGUMENT OF THE
*           +---+            PATTERN ASSIGNMENT CALL.
*             I
*             I
*           +---+            THIS NODE (P_PAC) SAVES THE CURSOR,
*           I C I-----       A PTR TO ITSELF, THE CURSOR (COPY)
*           +---+            AND A PTR TO NDPAD ON THE STACK.
*
*
*      THE FUNCTION OF THE MATCH ROUTINE FOR NDPAB (P_PAB)
*      IS SIMPLY TO UNSTACK ITSELF AND FAIL BACK ONTO THE STACK.
*
*      THE MATCH ROUTINE FOR P_PAC ALSO SETS THE GLOBAL PATTERN
*      FLAG PMDFL NON-ZERO TO INDICATE THAT PATTERN ASSIGNMENTS
*      MAY HAVE OCCURED IN THE PATTERN MATCH
*
*      IF PMDFL IS SET AT THE END OF THE MATCH (SEE P_NTH), THE
*      HISTORY STACK IS SCANNED FOR MATCHING NDPAB-NDPAD PAIRS
*      AND THE CORRESPONDING PATTERN ASSIGNMENTS ARE EXECUTED.
*
*      THE FUNCTION OF THE MATCH ROUTINE FOR NDPAD (P_PAD)
*      IS SIMPLY TO REMOVE ITS ENTRY FROM THE STACK AND FAIL.
*      THIS INCLUDES REMOVING THE SPECIAL NODE POINTER STORED
*      IN ADDITION TO THE STANDARD TWO ENTRIES ON THE STACK.
{{EJC{{{{{10331
*
*      COMPOUNT PATTERN STRUCTURES (CONTINUED)
*
*      FENCE (FUNCTION)
*      ----------------
*
*           +---+            THIS NODE (P_FNA) SAVES THE
*           I A I            CURRENT HISTORY STACK AND A
*           +---+            POINTER TO NDFNB ON THE STACK.
*             I
*             I
*           +---+            THIS IS THE PATTERN STRUCTURE
*           I X I            GIVEN AS THE ARGUMENT TO THE
*           +---+            FENCE FUNCTION.
*             I
*             I
*           +---+            THIS NODE P_FNC RESTORES THE OUTER
*           I C I            HISTORY STACK PTR SAVED IN P_FNA,
*           +---+            AND STACKS THE INNER STACK BASE
*                            PTR AND A POINTER TO NDFND ON THE
*                            STACK.
*
*      NDFNB (F_FNB) SIMPLY IS THE FAILURE EXIT FOR PATTERN
*      ARGUMENT FAILURE, AND IT POPS ITSELF AND FAILS ONTO THE
*      STACK.
*
*      THE MATCH ROUTINE P_FNC ALLOWS FOR AN OPTIMIZATION WHEN
*      THE FENCE PATTERN LEAVES NO ALTERNATIVES.  IN THIS CASE,
*      THE NDFNB ENTRY IS POPPED, AND THE MATCH CONTINUES.
*
*      NDFND (P_FND) IS ENTERED WHEN THE PATTERN FAILS AFTER
*      GOING THROUGH A NON-OPTIMIZED P_FNC, AND IT POPS THE
*      STACK BACK PAST THE INNTER STACK BASE CREATED BY P_FNA
{{EJC{{{{{10365
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      EXPRESSION PATTERNS (RECURSIVE PATTERN MATCHES)
*      -----------------------------------------------
*
*      INITIAL ENTRY FOR A PATTERN NODE IS TO THE ROUTINE P_EXA.
*      IF THE EVALUATED RESULT OF THE EXPRESSION IS ITSELF A
*      PATTERN, THEN THE FOLLOWING STEPS ARE TAKEN TO ARRANGE
*      FOR PROPER RECURSIVE PROCESSING.
*
*      1)   A POINTER TO THE CURRENT NODE (THE P_EXA NODE) IS
*           STORED ON THE HISTORY STACK WITH A DUMMY CURSOR.
*
*      2)   A SPECIAL HISTORY STACK ENTRY IS MADE IN WHICH THE
*           NODE POINTER POINTS TO NDEXB, AND THE CURSOR VALUE
*           IS THE SAVED VALUE OF PMHBS ON ENTRY TO THIS NODE.
*           THE MATCH ROUTINE FOR NDEXB (P_EXB) RESTORES PMHBS
*           FROM THIS CURSOR ENTRY, POPS OFF THE P_EXA NODE
*           POINTER AND FAILS.
*
*      3)   THE RESULTING HISTORY STACK POINTER IS SAVED IN
*           PMHBS TO ESTABLISH A NEW LEVEL OF HISTORY STACK.
*
*      AFTER MATCHING A PATTERN, THE END OF MATCH ROUTINE GETS
*      CONTROL (P_NTH). THIS ROUTINE PROCEEDS AS FOLLOWS.
*
*      1)   LOAD THE CURRENT VALUE OF PMHBS AND RECOGNIZE THE
*           OUTER LEVEL CASE BY THE FACT THAT THE ASSOCIATED
*           CURSOR IN THIS CASE IS THE PATTERN MATCH TYPE CODE
*           WHICH IS LESS THAN 3. TERMINATE THE MATCH IN THIS
*           CASE AND CONTINUE EXECUTION OF THE PROGRAM.
*
*      2)   OTHERWISE MAKE A SPECIAL HISTORY STACK ENTRY IN
*           WHICH THE NODE POINTER POINTS TO THE SPECIAL NODE
*           NDEXC AND THE CURSOR IS THE CURRENT VALUE OF PMHBS.
*           THE MATCH ROUTINE FOR NDEXC (P_EXC) RESETS PMHBS TO
*           THIS (INNER) VALUE AND AND THEN FAILS.
*
*      3)   USING THE HISTORY STACK ENTRY MADE ON STARTING THE
*           EXPRESSION (ACCESSIBLE WITH THE CURRENT VALUE OF
*           PMHBS), RESTORE THE P_EXA NODE POINTER AND THE OLD
*           PMHBS SETTING. TAKE THE SUCCESSOR AND CONTINUE.
*
*      AN OPTIMIZATION IS POSSIBLE IF THE EXPRESSION PATTERN
*      MAKES NO ENTRIES ON THE HISTORY STACK. IN THIS CASE,
*      INSTEAD OF BUILDING THE P_EXC NODE IN STEP 2, IT IS MORE
*      EFFICIENT TO SIMPLY POP OFF THE P_EXB ENTRY AND ITS
*      ASSOCIATED NODE POINTER. THE EFFECT IS THE SAME.
{{EJC{{{{{10415
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      BINARY DOLLAR (IMMEDIATE ASSIGNMENT)
*      ------------------------------------
*
*           +---+            THIS NODE (P_IMA) STACKS THE CURSOR
*           I A I            PMHBS AND A PTR TO NDIMB AND RESETS
*           +---+            THE STACK PTR PMHBS.
*             I
*             I
*           +---+            THIS IS THE LEFT STRUCTURE FOR THE
*           I X I            PATTERN LEFT ARGUMENT OF THE
*           +---+            IMMEDIATE ASSIGNMENT CALL.
*             I
*             I
*           +---+            THIS NODE (P_IMC) PERFORMS THE
*           I C I-----       ASSIGNMENT, POPS PMHBS AND STACKS
*           +---+            THE OLD PMHBS AND A PTR TO NDIMD.
*
*
*      THE STRUCTURE AND EXECUTION OF THIS PATTERN ARE SIMILAR
*      TO THOSE OF THE RECURSIVE EXPRESSION PATTERN MATCHING.
*
*      THE MATCH ROUTINE FOR NDIMB (P_IMB) RESTORES THE OUTER
*      LEVEL VALUE OF PMHBS, UNSTACKS THE SAVED CURSOR AND FAILS
*
*      THE MATCH ROUTINE P_IMC USES THE CURRENT VALUE OF PMHBS
*      TO LOCATE THE P_IMB ENTRY. THIS ENTRY IS USED TO MAKE
*      THE ASSIGNMENT AND RESTORE THE OUTER LEVEL VALUE OF
*      PMHBS. FINALLY, THE INNER LEVEL VALUE OF PMHBS AND A
*      POINTER TO THE SPECIAL NODE NDIMD ARE STACKED.
*
*      THE MATCH ROUTINE FOR NDIMD (P_IMD) RESTORES THE INNER
*      LEVEL VALUE OF PMHBS AND FAILS BACK INTO THE STACK.
*
*      AN OPTIMIZATION OCCURS IF THE INNER PATTERN MAKES NO
*      ENTRIES ON THE HISTORY STACK. IN THIS CASE, P_IMC POPS
*      THE P_IMB ENTRY INSTEAD OF MAKING A P_IMD ENTRY.
{{EJC{{{{{10455
*
*      ARBNO
*
*      SEE COMPOUND PATTERNS SECTION FOR STUCTURE AND
*      ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P_ABA{ENT{2,BL_P0{{{P0BLK{10464
{{MOV{11,-(XS){8,WB{{STACK CURSOR{10465
{{MOV{11,-(XS){7,XR{{STACK DUMMY NODE PTR{10466
{{MOV{11,-(XS){3,PMHBS{{STACK OLD STACK BASE PTR{10467
{{MOV{11,-(XS){21,=NDABB{{STACK PTR TO NODE NDABB{10468
{{MOV{3,PMHBS{7,XS{{STORE NEW STACK BASE PTR{10469
{{BRN{6,SUCCP{{{SUCCEED{10470
{{EJC{{{{{10471
*
*      ARBNO (REMOVE P_ABA SPECIAL STACK ENTRY)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_ABB{ENT{{{{ENTRY POINT{10477
{{MOV{3,PMHBS{8,WB{{RESTORE HISTORY STACK BASE PTR{10478
{{BRN{6,FLPOP{{{FAIL AND POP DUMMY NODE PTR{10479
{{EJC{{{{{10480
*
*      ARBNO (CHECK IF ARG MATCHED NULL STRING)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_ABC{ENT{2,BL_P0{{{P0BLK{10486
{{MOV{7,XT{3,PMHBS{{KEEP P_ABB STACK BASE{10487
{{MOV{8,WA{13,NUM03(XT){{LOAD INITIAL CURSOR{10488
{{MOV{3,PMHBS{13,NUM01(XT){{RESTORE OUTER STACK BASE PTR{10489
{{BEQ{7,XT{7,XS{6,PABC1{JUMP IF NO HISTORY STACK ENTRIES{10490
{{MOV{11,-(XS){7,XT{{ELSE SAVE INNER PMHBS ENTRY{10491
{{MOV{11,-(XS){21,=NDABD{{STACK PTR TO SPECIAL NODE NDABD{10492
{{BRN{6,PABC2{{{MERGE{10493
*
*      OPTIMISE CASE OF NO EXTRA ENTRIES ON STACK FROM ARBNO ARG
*
{PABC1{ADD{7,XS{19,*NUM04{{REMOVE NDABB ENTRY AND CURSOR{10497
*
*      MERGE TO CHECK FOR MATCHING OF NULL STRING
*
{PABC2{BNE{8,WA{8,WB{6,SUCCP{ALLOW FURTHER ATTEMPT IF NON-NULL{10501
{{MOV{7,XR{13,PTHEN(XR){{BYPASS ALTERNATIVE NODE SO AS TO ...{10502
{{BRN{6,SUCCP{{{... REFUSE FURTHER MATCH ATTEMPTS{10503
{{EJC{{{{{10504
*
*      ARBNO (TRY FOR ALTERNATIVES IN ARBNO ARGUMENT)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_ABD{ENT{{{{ENTRY POINT{10510
{{MOV{3,PMHBS{8,WB{{RESTORE INNER STACK BASE PTR{10511
{{BRN{6,FAILP{{{AND FAIL{10512
{{EJC{{{{{10513
*
*      ABORT
*
*      NO PARAMETERS
*
{P_ABO{ENT{2,BL_P0{{{P0BLK{10519
{{BRN{6,EXFAL{{{SIGNAL STATEMENT FAILURE{10520
{{EJC{{{{{10521
*
*      ALTERNATION
*
*      PARM1                 ALTERNATIVE NODE
*
{P_ALT{ENT{2,BL_P1{{{P1BLK{10527
{{MOV{11,-(XS){8,WB{{STACK CURSOR{10528
{{MOV{11,-(XS){13,PARM1(XR){{STACK POINTER TO ALTERNATIVE{10529
{{CHK{{{{CHECK FOR STACK OVERFLOW{10530
{{BRN{6,SUCCP{{{IF ALL OK, THEN SUCCEED{10531
{{EJC{{{{{10532
*
*      ANY (ONE CHARACTER ARGUMENT) (1-CHAR STRING ALSO)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P_ANS{ENT{2,BL_P1{{{P1BLK{10538
{{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARS LEFT{10539
{{MOV{7,XL{3,R_PMS{{ELSE POINT TO SUBJECT STRING{10540
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{10541
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{10542
{{BNE{8,WA{13,PARM1(XR){6,FAILP{FAIL IF NO MATCH{10543
{{ICV{8,WB{{{ELSE BUMP CURSOR{10544
{{BRN{6,SUCCP{{{AND SUCCEED{10545
{{EJC{{{{{10546
*
*      ANY (MULTI-CHARACTER ARGUMENT CASE)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT IN CTBLK
*
{P_ANY{ENT{2,BL_P2{{{P2BLK{10553
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PANY1{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARACTERS LEFT{10557
{{MOV{7,XL{3,R_PMS{{ELSE POINT TO SUBJECT STRING{10558
{{PLC{7,XL{8,WB{{GET CHAR PTR TO CURRENT CHARACTER{10559
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{10560
{{MOV{7,XL{13,PARM1(XR){{POINT TO CTBLK{10561
{{WTB{8,WA{{{CHANGE TO BYTE OFFSET{10562
{{ADD{7,XL{8,WA{{POINT TO ENTRY IN CTBLK{10563
{{MOV{8,WA{13,CTCHS(XL){{LOAD WORD FROM CTBLK{10564
{{ANB{8,WA{13,PARM2(XR){{AND WITH SELECTED BIT{10565
{{ZRB{8,WA{6,FAILP{{FAIL IF NO MATCH{10566
{{ICV{8,WB{{{ELSE BUMP CURSOR{10567
{{BRN{6,SUCCP{{{AND SUCCEED{10568
{{EJC{{{{{10569
*
*      ANY (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P_AYD{ENT{2,BL_P1{{{P1BLK{10575
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{10576
{{ERR{1,043{26,ANY evaluated argument is not a string{{{10577
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILURE{10578
{{PPM{6,PANY1{{{MERGE MULTI-CHAR CASE IF OK{10579
{{EJC{{{{{10580
*
*      P_ARB                 INITIAL ARB MATCH
*
*      NO PARAMETERS
*
*      THE P_ARB NODE IS PART OF A COMPOUND PATTERN STRUCTURE
*      FOR AN ARB PATTERN (SEE DESCRIPTION OF COMPOUND PATTERNS)
*
{P_ARB{ENT{2,BL_P0{{{P0BLK{10589
{{MOV{7,XR{13,PTHEN(XR){{LOAD SUCCESSOR POINTER{10590
{{MOV{11,-(XS){8,WB{{STACK DUMMY CURSOR{10591
{{MOV{11,-(XS){7,XR{{STACK SUCCESSOR POINTER{10592
{{MOV{11,-(XS){8,WB{{STACK CURSOR{10593
{{MOV{11,-(XS){21,=NDARC{{STACK PTR TO SPECIAL NODE NDARC{10594
{{BRI{9,(XR){{{EXECUTE NEXT NODE MATCHING NULL{10595
{{EJC{{{{{10596
*
*      P_ARC                 EXTEND ARB MATCH
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_ARC{ENT{{{{ENTRY POINT{10602
{{BEQ{8,WB{3,PMSSL{6,FLPOP{FAIL AND POP STACK TO SUCCESSOR{10603
{{ICV{8,WB{{{ELSE BUMP CURSOR{10604
{{MOV{11,-(XS){8,WB{{STACK UPDATED CURSOR{10605
{{MOV{11,-(XS){7,XR{{RESTACK POINTER TO NDARC NODE{10606
{{MOV{7,XR{13,NUM02(XS){{LOAD SUCCESSOR POINTER{10607
{{BRI{9,(XR){{{OFF TO REEXECUTE SUCCESSOR NODE{10608
{{EJC{{{{{10609
*
*      BAL
*
*      NO PARAMETERS
*
*      THE P_BAL NODE IS PART OF THE COMPOUND STRUCTURE BUILT
*      FOR BAL (SEE SECTION ON COMPOUND PATTERNS).
*
{P_BAL{ENT{2,BL_P0{{{P0BLK{10618
{{ZER{8,WC{{{ZERO PARENTHESES LEVEL COUNTER{10619
{{MOV{7,XL{3,R_PMS{{POINT TO SUBJECT STRING{10620
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{10621
{{BRN{6,PBAL2{{{JUMP INTO SCAN LOOP{10622
*
*      LOOP TO SCAN OUT CHARACTERS
*
{PBAL1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{10626
{{ICV{8,WB{{{PUSH CURSOR FOR CHARACTER{10627
{{BEQ{8,WA{18,=CH_PP{6,PBAL3{JUMP IF LEFT PAREN{10628
{{BEQ{8,WA{18,=CH_RP{6,PBAL4{JUMP IF RIGHT PAREN{10629
{{BZE{8,WC{6,PBAL5{{ELSE SUCCEED IF AT OUTER LEVEL{10630
*
*      HERE AFTER PROCESSING ONE CHARACTER
*
{PBAL2{BNE{8,WB{3,PMSSL{6,PBAL1{LOOP BACK UNLESS END OF STRING{10634
{{BRN{6,FAILP{{{IN WHICH CASE, FAIL{10635
*
*      HERE ON LEFT PAREN
*
{PBAL3{ICV{8,WC{{{BUMP PAREN LEVEL{10639
{{BRN{6,PBAL2{{{LOOP BACK TO CHECK END OF STRING{10640
*
*      HERE FOR RIGHT PAREN
*
{PBAL4{BZE{8,WC{6,FAILP{{FAIL IF NO MATCHING LEFT PAREN{10644
{{DCV{8,WC{{{ELSE DECREMENT LEVEL COUNTER{10645
{{BNZ{8,WC{6,PBAL2{{LOOP BACK IF NOT AT OUTER LEVEL{10646
*
*      HERE AFTER SUCCESSFULLY SCANNING A BALANCED STRING
*
{PBAL5{MOV{11,-(XS){8,WB{{STACK CURSOR{10650
{{MOV{11,-(XS){7,XR{{STACK PTR TO BAL NODE FOR EXTEND{10651
{{BRN{6,SUCCP{{{AND SUCCEED{10652
{{EJC{{{{{10653
*
*      BREAK (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P_BKD{ENT{2,BL_P1{{{P1BLK{10659
{{JSR{6,EVALS{{{EVALUATE STRING EXPRESSION{10660
{{ERR{1,044{26,BREAK evaluated argument is not a string{{{10661
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{10662
{{PPM{6,PBRK1{{{MERGE WITH MULTI-CHAR CASE IF OK{10663
{{EJC{{{{{10664
*
*      BREAK (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P_BKS{ENT{2,BL_P1{{{P1BLK{10670
{{MOV{8,WC{3,PMSSL{{GET SUBJECT STRING LENGTH{10671
{{SUB{8,WC{8,WB{{GET NUMBER OF CHARACTERS LEFT{10672
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{10673
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARS LEFT{10674
{{MOV{7,XL{3,R_PMS{{POINT TO SUBJECT STRING{10675
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{10676
*
*      LOOP TO SCAN TILL BREAK CHARACTER FOUND
*
{PBKS1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHAR, BUMP POINTER{10680
{{BEQ{8,WA{13,PARM1(XR){6,SUCCP{SUCCEED IF BREAK CHARACTER FOUND{10681
{{ICV{8,WB{{{ELSE PUSH CURSOR{10682
{{BCT{8,WC{6,PBKS1{{LOOP BACK IF MORE TO GO{10683
{{BRN{6,FAILP{{{FAIL IF END OF STRING, NO BREAK CHR{10684
{{EJC{{{{{10685
*
*      BREAK (MULTI-CHARACTER ARGUMENT)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P_BRK{ENT{2,BL_P2{{{P2BLK{10692
*
*      EXPRESSION ARGUMENT MERGES HERE
*
{PBRK1{MOV{8,WC{3,PMSSL{{LOAD SUBJECT STRING LENGTH{10696
{{SUB{8,WC{8,WB{{GET NUMBER OF CHARACTERS LEFT{10697
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{10698
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARACTERS LEFT{10699
{{MOV{7,XL{3,R_PMS{{ELSE POINT TO SUBJECT STRING{10700
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{10701
{{MOV{3,PSAVE{7,XR{{SAVE NODE POINTER{10702
*
*      LOOP TO SEARCH FOR BREAK CHARACTER
*
{PBRK2{LCH{8,WA{10,(XL)+{{LOAD NEXT CHAR, BUMP POINTER{10706
{{MOV{7,XR{13,PARM1(XR){{LOAD POINTER TO CTBLK{10707
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{10708
{{ADD{7,XR{8,WA{{POINT TO CTBLK ENTRY{10709
{{MOV{8,WA{13,CTCHS(XR){{LOAD CTBLK WORD{10710
{{MOV{7,XR{3,PSAVE{{RESTORE NODE POINTER{10711
{{ANB{8,WA{13,PARM2(XR){{AND WITH SELECTED BIT{10712
{{NZB{8,WA{6,SUCCP{{SUCCEED IF BREAK CHARACTER FOUND{10713
{{ICV{8,WB{{{ELSE PUSH CURSOR{10714
{{BCT{8,WC{6,PBRK2{{LOOP BACK UNLESS END OF STRING{10715
{{BRN{6,FAILP{{{FAIL IF END OF STRING, NO BREAK CHR{10716
{{EJC{{{{{10717
*
*      BREAKX (EXTENSION)
*
*      THIS IS THE ENTRY WHICH CAUSES AN EXTENSION OF A BREAKX
*      MATCH WHEN FAILURE OCCURS. SEE SECTION ON COMPOUND
*      PATTERNS FOR FULL DETAILS OF BREAKX MATCHING.
*
*      NO PARAMETERS
*
{P_BKX{ENT{2,BL_P0{{{P0BLK{10727
{{ICV{8,WB{{{STEP CURSOR PAST PREVIOUS BREAK CHR{10728
{{BRN{6,SUCCP{{{SUCCEED TO REMATCH BREAK{10729
{{EJC{{{{{10730
*
*      BREAKX (EXPRESSION ARGUMENT)
*
*      SEE SECTION ON COMPOUND PATTERNS FOR FULL STRUCTURE OF
*      BREAKX PATTERN. THE ACTUAL CHARACTER MATCHING USES A
*      BREAK NODE. HOWEVER, THE ENTRY FOR THE EXPRESSION
*      ARGUMENT CASE IS SEPARATED TO GET PROPER ERROR MESSAGES.
*
*      PARM1                 EXPRESSION POINTER
*
{P_BXD{ENT{2,BL_P1{{{P1BLK{10741
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{10742
{{ERR{1,045{26,BREAKX evaluated argument is not a string{{{10743
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{10744
{{PPM{6,PBRK1{{{MERGE WITH BREAK IF ALL OK{10745
{{EJC{{{{{10746
*
*      CURSOR ASSIGNMENT
*
*      PARM1                 NAME BASE
*      PARM2                 NAME OFFSET
*
{P_CAS{ENT{2,BL_P2{{{P2BLK{10753
{{MOV{11,-(XS){7,XR{{SAVE NODE POINTER{10754
{{MOV{11,-(XS){8,WB{{SAVE CURSOR{10755
{{MOV{7,XL{13,PARM1(XR){{LOAD NAME BASE{10756
{{MTI{8,WB{{{LOAD CURSOR AS INTEGER{10757
{{MOV{8,WB{13,PARM2(XR){{LOAD NAME OFFSET{10758
{{JSR{6,ICBLD{{{GET ICBLK FOR CURSOR VALUE{10759
{{MOV{8,WA{8,WB{{MOVE NAME OFFSET{10760
{{MOV{8,WB{7,XR{{MOVE VALUE TO ASSIGN{10761
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{10762
{{PPM{6,FLPOP{{{FAIL ON ASSIGNMENT FAILURE{10763
{{MOV{8,WB{10,(XS)+{{ELSE RESTORE CURSOR{10764
{{MOV{7,XR{10,(XS)+{{RESTORE NODE POINTER{10765
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{10766
{{EJC{{{{{10767
*
*      EXPRESSION NODE (P_EXA, INITIAL ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      PARM1                 EXPRESSION POINTER
*
{P_EXA{ENT{2,BL_P1{{{P1BLK{10776
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{10777
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{10778
{{BLO{8,WA{22,=P_AAA{6,PEXA1{JUMP IF RESULT IS NOT A PATTERN{10779
*
*      HERE IF RESULT OF EXPRESSION IS A PATTERN
*
{{MOV{11,-(XS){8,WB{{STACK DUMMY CURSOR{10783
{{MOV{11,-(XS){7,XR{{STACK PTR TO P_EXA NODE{10784
{{MOV{11,-(XS){3,PMHBS{{STACK HISTORY STACK BASE PTR{10785
{{MOV{11,-(XS){21,=NDEXB{{STACK PTR TO SPECIAL NODE NDEXB{10786
{{MOV{3,PMHBS{7,XS{{STORE NEW STACK BASE POINTER{10787
{{MOV{7,XR{7,XL{{COPY NODE POINTER{10788
{{BRI{9,(XR){{{MATCH FIRST NODE IN EXPRESSION PAT{10789
*
*      HERE IF RESULT OF EXPRESSION IS NOT A PATTERN
*
{PEXA1{BEQ{8,WA{22,=B_SCL{6,PEXA2{JUMP IF IT IS ALREADY A STRING{10793
{{MOV{11,-(XS){7,XL{{ELSE STACK RESULT{10794
{{MOV{7,XL{7,XR{{SAVE NODE POINTER{10795
{{JSR{6,GTSTG{{{CONVERT RESULT TO STRING{10796
{{ERR{1,046{26,Expression does not evaluate to pattern{{{10797
{{MOV{8,WC{7,XR{{COPY STRING POINTER{10798
{{MOV{7,XR{7,XL{{RESTORE NODE POINTER{10799
{{MOV{7,XL{8,WC{{COPY STRING POINTER AGAIN{10800
*
*      MERGE HERE WITH STRING POINTER IN XL
*
{PEXA2{BZE{13,SCLEN(XL){6,SUCCP{{JUST SUCCEED IF NULL STRING{10804
{{BRN{6,PSTR1{{{ELSE MERGE WITH STRING CIRCUIT{10805
{{EJC{{{{{10806
*
*      EXPRESSION NODE (P_EXB, REMOVE NDEXB ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_EXB{ENT{{{{ENTRY POINT{10815
{{MOV{3,PMHBS{8,WB{{RESTORE OUTER LEVEL STACK POINTER{10816
{{BRN{6,FLPOP{{{FAIL AND POP P_EXA NODE PTR{10817
{{EJC{{{{{10818
*
*      EXPRESSION NODE (P_EXC, REMOVE NDEXC ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_EXC{ENT{{{{ENTRY POINT{10827
{{MOV{3,PMHBS{8,WB{{RESTORE INNER STACK BASE POINTER{10828
{{BRN{6,FAILP{{{AND FAIL INTO EXPR PATTERN ALTERNVS{10829
{{EJC{{{{{10830
*
*      FAIL
*
*      NO PARAMETERS
*
{P_FAL{ENT{2,BL_P0{{{P0BLK{10836
{{BRN{6,FAILP{{{JUST SIGNAL FAILURE{10837
{{EJC{{{{{10838
*
*      FENCE
*
*      SEE COMPOUND PATTERNS SECTION FOR THE STRUCTURE AND
*      ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P_FEN{ENT{2,BL_P0{{{P0BLK{10847
{{MOV{11,-(XS){8,WB{{STACK DUMMY CURSOR{10848
{{MOV{11,-(XS){21,=NDABO{{STACK PTR TO ABORT NODE{10849
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{10850
{{EJC{{{{{10851
*
*      FENCE (FUNCTION)
*
*      SEE COMPOUND PATTERNS COMMENTS AT START OF THIS SECTION
*      FOR DETAILS OF SCHEME
*
*      NO PARAMETERS
*
{P_FNA{ENT{2,BL_P0{{{P0BLK{10860
{{MOV{11,-(XS){3,PMHBS{{STACK CURRENT HISTORY STACK BASE{10861
{{MOV{11,-(XS){21,=NDFNB{{STACK INDIR PTR TO P_FNB (FAILURE){10862
{{MOV{3,PMHBS{7,XS{{BEGIN NEW HISTORY STACK{10863
{{BRN{6,SUCCP{{{SUCCEED{10864
{{EJC{{{{{10865
*
*      FENCE (FUNCTION) (RESET HISTORY STACK AND FAIL)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_FNB{ENT{2,BL_P0{{{P0BLK{10871
{{MOV{3,PMHBS{8,WB{{RESTORE OUTER PMHBS STACK BASE{10872
{{BRN{6,FAILP{{{...AND FAIL{10873
{{EJC{{{{{10874
*
*      FENCE (FUNCTION) (MAKE FENCE TRAP ENTRY ON STACK)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_FNC{ENT{2,BL_P0{{{P0BLK{10880
{{MOV{7,XT{3,PMHBS{{GET INNER STACK BASE PTR{10881
{{MOV{3,PMHBS{13,NUM01(XT){{RESTORE OUTER STACK BASE{10882
{{BEQ{7,XT{7,XS{6,PFNC1{OPTIMIZE IF NO ALTERNATIVES{10883
{{MOV{11,-(XS){7,XT{{ELSE STACK INNER STACK BASE{10884
{{MOV{11,-(XS){21,=NDFND{{STACK PTR TO NDFND{10885
{{BRN{6,SUCCP{{{SUCCEED{10886
*
*      HERE WHEN FENCE FUNCTION LEFT NOTHING ON THE STACK
*
{PFNC1{ADD{7,XS{19,*NUM02{{POP OFF P_FNB ENTRY{10890
{{BRN{6,SUCCP{{{SUCCEED{10891
{{EJC{{{{{10892
*
*      FENCE (FUNCTION) (SKIP PAST ALTERNATIVES ON FAILURE)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_FND{ENT{2,BL_P0{{{P0BLK{10898
{{MOV{7,XS{8,WB{{POP STACK TO FENCE() HISTORY BASE{10899
{{BRN{6,FLPOP{{{POP BASE ENTRY AND FAIL{10900
{{EJC{{{{{10901
*
*      IMMEDIATE ASSIGNMENT (INITIAL ENTRY, SAVE CURRENT CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P_IMA{ENT{2,BL_P0{{{P0BLK{10910
{{MOV{11,-(XS){8,WB{{STACK CURSOR{10911
{{MOV{11,-(XS){7,XR{{STACK DUMMY NODE POINTER{10912
{{MOV{11,-(XS){3,PMHBS{{STACK OLD STACK BASE POINTER{10913
{{MOV{11,-(XS){21,=NDIMB{{STACK PTR TO SPECIAL NODE NDIMB{10914
{{MOV{3,PMHBS{7,XS{{STORE NEW STACK BASE POINTER{10915
{{BRN{6,SUCCP{{{AND SUCCEED{10916
{{EJC{{{{{10917
*
*      IMMEDIATE ASSIGNMENT (REMOVE CURSOR MARK ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_IMB{ENT{{{{ENTRY POINT{10926
{{MOV{3,PMHBS{8,WB{{RESTORE HISTORY STACK BASE PTR{10927
{{BRN{6,FLPOP{{{FAIL AND POP DUMMY NODE PTR{10928
{{EJC{{{{{10929
*
*      IMMEDIATE ASSIGNMENT (PERFORM ACTUAL ASSIGNMENT)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      PARM1                 NAME BASE OF VARIABLE
*      PARM2                 NAME OFFSET OF VARIABLE
*
{P_IMC{ENT{2,BL_P2{{{P2BLK{10939
{{MOV{7,XT{3,PMHBS{{LOAD POINTER TO P_IMB ENTRY{10940
{{MOV{8,WA{8,WB{{COPY FINAL CURSOR{10941
{{MOV{8,WB{13,NUM03(XT){{LOAD INITIAL CURSOR{10942
{{MOV{3,PMHBS{13,NUM01(XT){{RESTORE OUTER STACK BASE POINTER{10943
{{BEQ{7,XT{7,XS{6,PIMC1{JUMP IF NO HISTORY STACK ENTRIES{10944
{{MOV{11,-(XS){7,XT{{ELSE SAVE INNER PMHBS POINTER{10945
{{MOV{11,-(XS){21,=NDIMD{{AND A PTR TO SPECIAL NODE NDIMD{10946
{{BRN{6,PIMC2{{{MERGE{10947
*
*      HERE IF NO ENTRIES MADE ON HISTORY STACK
*
{PIMC1{ADD{7,XS{19,*NUM04{{REMOVE NDIMB ENTRY AND CURSOR{10951
*
*      MERGE HERE TO PERFORM ASSIGNMENT
*
{PIMC2{MOV{11,-(XS){8,WA{{SAVE CURRENT (FINAL) CURSOR{10955
{{MOV{11,-(XS){7,XR{{SAVE CURRENT NODE POINTER{10956
{{MOV{7,XL{3,R_PMS{{POINT TO SUBJECT STRING{10957
{{SUB{8,WA{8,WB{{COMPUTE SUBSTRING LENGTH{10958
{{JSR{6,SBSTR{{{BUILD SUBSTRING{10959
{{MOV{8,WB{7,XR{{MOVE RESULT{10960
{{MOV{7,XR{9,(XS){{RELOAD NODE POINTER{10961
{{MOV{7,XL{13,PARM1(XR){{LOAD NAME BASE{10962
{{MOV{8,WA{13,PARM2(XR){{LOAD NAME OFFSET{10963
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{10964
{{PPM{6,FLPOP{{{FAIL IF ASSIGNMENT FAILS{10965
{{MOV{7,XR{10,(XS)+{{ELSE RESTORE NODE POINTER{10966
{{MOV{8,WB{10,(XS)+{{RESTORE CURSOR{10967
{{BRN{6,SUCCP{{{AND SUCCEED{10968
{{EJC{{{{{10969
*
*      IMMEDIATE ASSIGNMENT (REMOVE NDIMD ENTRY ON FAILURE)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_IMD{ENT{{{{ENTRY POINT{10978
{{MOV{3,PMHBS{8,WB{{RESTORE INNER STACK BASE POINTER{10979
{{BRN{6,FAILP{{{AND FAIL{10980
{{EJC{{{{{10981
*
*      LEN (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P_LEN{ENT{2,BL_P1{{{P1BLK{10987
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PLEN1{ADD{8,WB{13,PARM1(XR){{PUSH CURSOR INDICATED AMOUNT{10991
{{BLE{8,WB{3,PMSSL{6,SUCCP{SUCCEED IF NOT OFF END{10992
{{BRN{6,FAILP{{{ELSE FAIL{10993
{{EJC{{{{{10994
*
*      LEN (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P_LND{ENT{2,BL_P1{{{P1BLK{11000
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{11001
{{ERR{1,047{26,LEN evaluated argument is not integer{{{11002
{{ERR{1,048{26,LEN evaluated argument is negative or too large{{{11003
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{11004
{{PPM{6,PLEN1{{{MERGE WITH NORMAL CIRCUIT IF OK{11005
{{EJC{{{{{11006
*
*      NOTANY (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P_NAD{ENT{2,BL_P1{{{P1BLK{11012
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{11013
{{ERR{1,049{26,NOTANY evaluated argument is not a string{{{11014
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{11015
{{PPM{6,PNAY1{{{MERGE WITH MULTI-CHAR CASE IF OK{11016
{{EJC{{{{{11017
*
*      NOTANY (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P_NAS{ENT{2,BL_P1{{{ENTRY POINT{11023
{{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARS LEFT{11024
{{MOV{7,XL{3,R_PMS{{ELSE POINT TO SUBJECT STRING{11025
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER IN STRIN{11026
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{11027
{{BEQ{8,WA{13,PARM1(XR){6,FAILP{FAIL IF MATCH{11028
{{ICV{8,WB{{{ELSE BUMP CURSOR{11029
{{BRN{6,SUCCP{{{AND SUCCEED{11030
{{EJC{{{{{11031
*
*      NOTANY (MULTI-CHARACTER STRING ARGUMENT)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P_NAY{ENT{2,BL_P2{{{P2BLK{11038
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PNAY1{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARACTERS LEFT{11042
{{MOV{7,XL{3,R_PMS{{ELSE POINT TO SUBJECT STRING{11043
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{11044
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{11045
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{11046
{{MOV{7,XL{13,PARM1(XR){{LOAD POINTER TO CTBLK{11047
{{ADD{7,XL{8,WA{{POINT TO ENTRY IN CTBLK{11048
{{MOV{8,WA{13,CTCHS(XL){{LOAD ENTRY FROM CTBLK{11049
{{ANB{8,WA{13,PARM2(XR){{AND WITH SELECTED BIT{11050
{{NZB{8,WA{6,FAILP{{FAIL IF CHARACTER IS MATCHED{11051
{{ICV{8,WB{{{ELSE BUMP CURSOR{11052
{{BRN{6,SUCCP{{{AND SUCCEED{11053
{{EJC{{{{{11054
*
*      END OF PATTERN MATCH
*
*      THIS ROUTINE IS ENTERED ON SUCCESSFUL COMPLETION.
*      SEE DESCRIPTION OF EXPRESSION PATTERNS IN COMPOUND
*      PATTERN SECTION FOR HANDLING OF RECURSION IN MATCHING.
*
*      THIS PATTERN ALSO RESULTS FROM AN ATTEMPT TO CONVERT THE
*      NULL STRING TO A PATTERN VIA CONVERT()
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_NTH{ENT{2,BL_P0{{{P0BLK (DUMMY){11067
{{MOV{7,XT{3,PMHBS{{LOAD POINTER TO BASE OF STACK{11068
{{MOV{8,WA{13,NUM01(XT){{LOAD SAVED PMHBS (OR PATTERN TYPE){11069
{{BLE{8,WA{18,=NUM02{6,PNTH2{JUMP IF OUTER LEVEL (PATTERN TYPE){11070
*
*      HERE WE ARE AT THE END OF MATCHING AN EXPRESSION PATTERN
*
{{MOV{3,PMHBS{8,WA{{RESTORE OUTER STACK BASE POINTER{11074
{{MOV{7,XR{13,NUM02(XT){{RESTORE POINTER TO P_EXA NODE{11075
{{BEQ{7,XT{7,XS{6,PNTH1{JUMP IF NO HISTORY STACK ENTRIES{11076
{{MOV{11,-(XS){7,XT{{ELSE STACK INNER STACK BASE PTR{11077
{{MOV{11,-(XS){21,=NDEXC{{STACK PTR TO SPECIAL NODE NDEXC{11078
{{BRN{6,SUCCP{{{AND SUCCEED{11079
*
*      HERE IF NO HISTORY STACK ENTRIES DURING PATTERN
*
{PNTH1{ADD{7,XS{19,*NUM04{{REMOVE P_EXB ENTRY AND NODE PTR{11083
{{BRN{6,SUCCP{{{AND SUCCEED{11084
*
*      HERE IF END OF MATCH AT OUTER LEVEL
*
{PNTH2{MOV{3,PMSSL{8,WB{{SAVE FINAL CURSOR IN SAFE PLACE{11088
{{BZE{3,PMDFL{6,PNTH6{{JUMP IF NO PATTERN ASSIGNMENTS{11089
{{EJC{{{{{11090
*
*      END OF PATTERN MATCH (CONTINUED)
*
*      NOW WE MUST PERFORM PATTERN ASSIGNMENTS. THIS IS DONE BY
*      SCANNING THE HISTORY STACK FOR MATCHING NDPAB-NDPAD PAIRS
*
{PNTH3{DCA{7,XT{{{POINT PAST CURSOR ENTRY{11097
{{MOV{8,WA{11,-(XT){{LOAD NODE POINTER{11098
{{BEQ{8,WA{21,=NDPAD{6,PNTH4{JUMP IF NDPAD ENTRY{11099
{{BNE{8,WA{21,=NDPAB{6,PNTH5{JUMP IF NOT NDPAB ENTRY{11100
*
*      HERE FOR NDPAB ENTRY, STACK INITIAL CURSOR
*      NOTE THAT THERE MUST BE MORE ENTRIES ON THE STACK.
*
{{MOV{11,-(XS){13,NUM01(XT){{STACK INITIAL CURSOR{11105
{{CHK{{{{CHECK FOR STACK OVERFLOW{11106
{{BRN{6,PNTH3{{{LOOP BACK IF OK{11107
*
*      HERE FOR NDPAD ENTRY. THE STARTING CURSOR FROM THE
*      MATCHING NDPAD ENTRY IS NOW THE TOP STACK ENTRY.
*
{PNTH4{MOV{8,WA{13,NUM01(XT){{LOAD FINAL CURSOR{11112
{{MOV{8,WB{9,(XS){{LOAD INITIAL CURSOR FROM STACK{11113
{{MOV{9,(XS){7,XT{{SAVE HISTORY STACK SCAN PTR{11114
{{SUB{8,WA{8,WB{{COMPUTE LENGTH OF STRING{11115
*
*      BUILD SUBSTRING AND PERFORM ASSIGNMENT
*
{{MOV{7,XL{3,R_PMS{{POINT TO SUBJECT STRING{11119
{{JSR{6,SBSTR{{{CONSTRUCT SUBSTRING{11120
{{MOV{8,WB{7,XR{{COPY SUBSTRING POINTER{11121
{{MOV{7,XT{9,(XS){{RELOAD HISTORY STACK SCAN PTR{11122
{{MOV{7,XL{13,NUM02(XT){{LOAD POINTER TO P_PAC NODE WITH NAM{11123
{{MOV{8,WA{13,PARM2(XL){{LOAD NAME OFFSET{11124
{{MOV{7,XL{13,PARM1(XL){{LOAD NAME BASE{11125
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{11126
{{PPM{6,EXFAL{{{MATCH FAILS IF NAME EVAL FAILS{11127
{{MOV{7,XT{10,(XS)+{{ELSE RESTORE HISTORY STACK PTR{11128
{{EJC{{{{{11129
*
*      END OF PATTERN MATCH (CONTINUED)
*
*      HERE CHECK FOR END OF ENTRIES
*
{PNTH5{BNE{7,XT{7,XS{6,PNTH3{LOOP IF MORE ENTRIES TO SCAN{11135
*
*      HERE AFTER DEALING WITH PATTERN ASSIGNMENTS
*
{PNTH6{MOV{7,XS{3,PMHBS{{WIPE OUT HISTORY STACK{11139
{{MOV{8,WB{10,(XS)+{{LOAD INITIAL CURSOR{11140
{{MOV{8,WC{10,(XS)+{{LOAD MATCH TYPE CODE{11141
{{MOV{8,WA{3,PMSSL{{LOAD FINAL CURSOR VALUE{11142
{{MOV{7,XL{3,R_PMS{{POINT TO SUBJECT STRING{11143
{{ZER{3,R_PMS{{{CLEAR SUBJECT STRING PTR FOR GBCOL{11144
{{BZE{8,WC{6,PNTH7{{JUMP IF CALL BY NAME{11145
{{BEQ{8,WC{18,=NUM02{6,PNTH9{EXIT IF STATEMENT LEVEL CALL{11146
*
*      HERE WE HAVE A CALL BY VALUE, BUILD SUBSTRING
*
{{SUB{8,WA{8,WB{{COMPUTE LENGTH OF STRING{11150
{{JSR{6,SBSTR{{{BUILD SUBSTRING{11151
{{MOV{11,-(XS){7,XR{{STACK RESULT{11152
{{LCW{7,XR{{{GET NEXT CODE WORD{11153
{{BRI{9,(XR){{{EXECUTE IT{11154
*
*      HERE FOR CALL BY NAME, MAKE STACK ENTRIES FOR O_RPL
*
{PNTH7{MOV{11,-(XS){8,WB{{STACK INITIAL CURSOR{11158
{{MOV{11,-(XS){8,WA{{STACK FINAL CURSOR{11159
*
*      HERE WITH XL POINTING TO SCBLK OR BCBLK
*
{PNTH8{MOV{11,-(XS){7,XL{{STACK SUBJECT POINTER{11168
*
*      HERE TO OBEY NEXT CODE WORD
*
{PNTH9{LCW{7,XR{{{GET NEXT CODE WORD{11172
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11173
{{EJC{{{{{11174
*
*      POS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P_POS{ENT{2,BL_P1{{{P1BLK{11180
*
*      OPTIMIZE POS IF IT IS THE FIRST PATTERN ELEMENT,
*      UNANCHORED MODE, CURSOR IS ZERO AND POS ARGUMENT
*      IS NOT BEYOND END OF STRING.  FORCE CURSOR POSITION
*      AND NUMBER OF UNANCHORED MOVES.
*
*      THIS OPTIMIZATION IS PERFORMED INVISIBLE PROVIDED
*      THE ARGUMENT IS EITHER A SIMPLE INTEGER OR AN
*      EXPRESSION THAT IS AN UNTRACED VARIABLE (THAT IS,
*      IT HAS NO SIDE EFFECTS THAT WOULD BE LOST BY SHORT-
*      CIRCUITING THE NORMAL LOGIC OF FAILING AND MOVING THE
*      UNANCHORED STARTING POINT.)
*
*      POS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{{BEQ{8,WB{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{11198
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{11199
{{MOV{7,XT{3,PMHBS{{GET HISTORY STACK BASE PTR{11200
{{BNE{7,XR{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{11201
*
*      EXPRESSION ARGUMENT CIRCUIT MERGES HERE
*
{PPOS2{BNE{11,-(XT){21,=NDUNA{6,FAILP{FAIL IF NOT UNANCHORED MODE{11205
{{MOV{8,WB{13,PARM1(XR){{GET DESIRED CURSOR POSITION{11206
{{BGT{8,WB{3,PMSSL{6,EXFAL{ABORT IF OFF END{11207
{{MOV{13,NUM02(XT){8,WB{{FAKE NUMBER OF UNANCHORED MOVES{11208
{{BRN{6,SUCCP{{{CONTINUE MATCH WITH ADJUSTED CURSOR{11209
{{EJC{{{{{11210
*
*      POS (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P_PSD{ENT{2,BL_P1{{{P1BLK{11216
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{11217
{{ERR{1,050{26,POS evaluated argument is not integer{{{11218
{{ERR{1,051{26,POS evaluated argument is negative or too large{{{11219
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{11220
{{PPM{6,PPOS1{{{PROCESS EXPRESSION CASE{11221
*
{PPOS1{BEQ{8,WB{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{11223
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{11224
{{BNZ{3,EVLIF{6,FAILP{{FAIL IF COMPLEX ARGUMENT{11225
{{MOV{7,XT{3,PMHBS{{GET HISTORY STACK BASE PTR{11226
{{MOV{8,WA{3,EVLIO{{GET ORIGINAL NODE PTR{11227
{{BNE{8,WA{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{11228
{{BRN{6,PPOS2{{{MERGE WITH INTEGER ARGUMENT CODE{11229
{{EJC{{{{{11230
*
*      PATTERN ASSIGNMENT (INITIAL ENTRY, SAVE CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P_PAA{ENT{2,BL_P0{{{P0BLK{11239
{{MOV{11,-(XS){8,WB{{STACK INITIAL CURSOR{11240
{{MOV{11,-(XS){21,=NDPAB{{STACK PTR TO NDPAB SPECIAL NODE{11241
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{11242
{{EJC{{{{{11243
*
*      PATTERN ASSIGNMENT (REMOVE SAVED CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P_PAB{ENT{{{{ENTRY POINT{11252
{{BRN{6,FAILP{{{JUST FAIL (ENTRY IS ALREADY POPPED){11253
{{EJC{{{{{11254
*
*      PATTERN ASSIGNMENT (END OF MATCH, MAKE ASSIGN ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      PARM1                 NAME BASE OF VARIABLE
*      PARM2                 NAME OFFSET OF VARIABLE
*
{P_PAC{ENT{2,BL_P2{{{P2BLK{11264
{{MOV{11,-(XS){8,WB{{STACK DUMMY CURSOR VALUE{11265
{{MOV{11,-(XS){7,XR{{STACK POINTER TO P_PAC NODE{11266
{{MOV{11,-(XS){8,WB{{STACK FINAL CURSOR{11267
{{MOV{11,-(XS){21,=NDPAD{{STACK PTR TO SPECIAL NDPAD NODE{11268
{{MNZ{3,PMDFL{{{SET DOT FLAG NON-ZERO{11269
{{BRN{6,SUCCP{{{AND SUCCEED{11270
{{EJC{{{{{11271
*
*      PATTERN ASSIGNMENT (REMOVE ASSIGN ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY NODE)
*
{P_PAD{ENT{{{{ENTRY POINT{11280
{{BRN{6,FLPOP{{{FAIL AND REMOVE P_PAC NODE{11281
{{EJC{{{{{11282
*
*      REM
*
*      NO PARAMETERS
*
{P_REM{ENT{2,BL_P0{{{P0BLK{11288
{{MOV{8,WB{3,PMSSL{{POINT CURSOR TO END OF STRING{11289
{{BRN{6,SUCCP{{{AND SUCCEED{11290
{{EJC{{{{{11291
*
*      RPOS (EXPRESSION ARGUMENT)
*
*      OPTIMIZE RPOS IF IT IS THE FIRST PATTERN ELEMENT,
*      UNANCHORED MODE, CURSOR IS ZERO AND RPOS ARGUMENT
*      IS NOT BEYOND END OF STRING.  FORCE CURSOR POSITION
*      AND NUMBER OF UNANCHORED MOVES.
*
*      THIS OPTIMIZATION IS PERFORMED INVISIBLY PROVIDED
*      THE ARGUMENT IS EITHER A SIMPLE INTEGER OR AN
*      EXPRESSION THAT IS AN UNTRACED VARIABLE (THAT IS,
*      IT HAS NO SIDE EFFECTS THAT WOULD BE LOST BY SHORT-
*      CIRCUITING THE NORMAL LOGIC OF FAILING AND MOVING THE
*      UNANCHORED STARTING POINT).
*
*      PARM1                 EXPRESSION POINTER
*
{P_RPD{ENT{2,BL_P1{{{P1BLK{11309
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{11310
{{ERR{1,052{26,RPOS evaluated argument is not integer{{{11311
{{ERR{1,053{26,RPOS evaluated argument is negative or too large{{{11312
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{11313
{{PPM{6,PRPS1{{{MERGE WITH NORMAL CASE IF OK{11314
*
{PRPS1{MOV{8,WC{3,PMSSL{{GET LENGTH OF STRING{11316
{{SUB{8,WC{8,WB{{GET NUMBER OF CHARACTERS REMAINING{11317
{{BEQ{8,WC{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{11318
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{11319
{{BNZ{3,EVLIF{6,FAILP{{FAIL IF COMPLEX ARGUMENT{11320
{{MOV{7,XT{3,PMHBS{{GET HISTORY STACK BASE PTR{11321
{{MOV{8,WA{3,EVLIO{{GET ORIGINAL NODE PTR{11322
{{BNE{8,WA{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{11323
{{BRN{6,PRPS2{{{MERGE WITH INTEGER ARG CODE{11324
{{EJC{{{{{11325
*
*      RPOS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P_RPS{ENT{2,BL_P1{{{P1BLK{11331
*
*      RPOS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{{MOV{8,WC{3,PMSSL{{GET LENGTH OF STRING{11337
{{SUB{8,WC{8,WB{{GET NUMBER OF CHARACTERS REMAINING{11338
{{BEQ{8,WC{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{11339
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{11340
{{MOV{7,XT{3,PMHBS{{GET HISTORY STACK BASE PTR{11341
{{BNE{7,XR{11,-(XT){6,FAILP{FAIL IF RPOS IS NOT FIRST NODE{11342
*
*      EXPRESSION ARGUMENT MERGES HERE
*
{PRPS2{BNE{11,-(XT){21,=NDUNA{6,FAILP{FAIL IF NOT UNANCHORED MODE{11346
{{MOV{8,WB{3,PMSSL{{POINT TO END OF STRING{11347
{{BLT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF STRING NOT LONG ENOUGH{11348
{{SUB{8,WB{13,PARM1(XR){{ELSE SET NEW CURSOR{11349
{{MOV{13,NUM02(XT){8,WB{{FAKE NUMBER OF UNANCHORED MOVES{11350
{{BRN{6,SUCCP{{{CONTINUE MATCH WITH ADJUSTED CURSOR{11351
{{EJC{{{{{11352
*
*      RTAB (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P_RTB{ENT{2,BL_P1{{{P1BLK{11358
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PRTB1{MOV{8,WC{8,WB{{SAVE INITIAL CURSOR{11362
{{MOV{8,WB{3,PMSSL{{POINT TO END OF STRING{11363
{{BLT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF STRING NOT LONG ENOUGH{11364
{{SUB{8,WB{13,PARM1(XR){{ELSE SET NEW CURSOR{11365
{{BGE{8,WB{8,WC{6,SUCCP{AND SUCCEED IF NOT TOO FAR ALREADY{11366
{{BRN{6,FAILP{{{IN WHICH CASE, FAIL{11367
{{EJC{{{{{11368
*
*      RTAB (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P_RTD{ENT{2,BL_P1{{{P1BLK{11374
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{11375
{{ERR{1,054{26,RTAB evaluated argument is not integer{{{11376
{{ERR{1,055{26,RTAB evaluated argument is negative or too large{{{11377
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{11378
{{PPM{6,PRTB1{{{MERGE WITH NORMAL CASE IF SUCCESS{11379
{{EJC{{{{{11380
*
*      SPAN (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P_SPD{ENT{2,BL_P1{{{P1BLK{11386
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{11387
{{ERR{1,056{26,SPAN evaluated argument is not a string{{{11388
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{11389
{{PPM{6,PSPN1{{{MERGE WITH MULTI-CHAR CASE IF OK{11390
{{EJC{{{{{11391
*
*      SPAN (MULTI-CHARACTER ARGUMENT CASE)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P_SPN{ENT{2,BL_P2{{{P2BLK{11398
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PSPN1{MOV{8,WC{3,PMSSL{{COPY SUBJECT STRING LENGTH{11402
{{SUB{8,WC{8,WB{{CALCULATE NUMBER OF CHARACTERS LEFT{11403
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{11404
{{MOV{7,XL{3,R_PMS{{POINT TO SUBJECT STRING{11405
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{11406
{{MOV{3,PSAVC{8,WB{{SAVE INITIAL CURSOR{11407
{{MOV{3,PSAVE{7,XR{{SAVE NODE POINTER{11408
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARS LEFT{11409
*
*      LOOP TO SCAN MATCHING CHARACTERS
*
{PSPN2{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{11413
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{11414
{{MOV{7,XR{13,PARM1(XR){{POINT TO CTBLK{11415
{{ADD{7,XR{8,WA{{POINT TO CTBLK ENTRY{11416
{{MOV{8,WA{13,CTCHS(XR){{LOAD CTBLK ENTRY{11417
{{MOV{7,XR{3,PSAVE{{RESTORE NODE POINTER{11418
{{ANB{8,WA{13,PARM2(XR){{AND WITH SELECTED BIT{11419
{{ZRB{8,WA{6,PSPN3{{JUMP IF NO MATCH{11420
{{ICV{8,WB{{{ELSE PUSH CURSOR{11421
{{BCT{8,WC{6,PSPN2{{LOOP BACK UNLESS END OF STRING{11422
*
*      HERE AFTER SCANNING MATCHING CHARACTERS
*
{PSPN3{BNE{8,WB{3,PSAVC{6,SUCCP{SUCCEED IF CHARS MATCHED{11426
{{BRN{6,FAILP{{{ELSE FAIL IF NULL STRING MATCHED{11427
{{EJC{{{{{11428
*
*      SPAN (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P_SPS{ENT{2,BL_P1{{{P1BLK{11434
{{MOV{8,WC{3,PMSSL{{GET SUBJECT STRING LENGTH{11435
{{SUB{8,WC{8,WB{{CALCULATE NUMBER OF CHARACTERS LEFT{11436
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{11437
{{MOV{7,XL{3,R_PMS{{ELSE POINT TO SUBJECT STRING{11438
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{11439
{{MOV{3,PSAVC{8,WB{{SAVE INITIAL CURSOR{11440
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARACTERS LEFT{11441
*
*      LOOP TO SCAN MATCHING CHARACTERS
*
{PSPS1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{11445
{{BNE{8,WA{13,PARM1(XR){6,PSPS2{JUMP IF NO MATCH{11446
{{ICV{8,WB{{{ELSE PUSH CURSOR{11447
{{BCT{8,WC{6,PSPS1{{AND LOOP UNLESS END OF STRING{11448
*
*      HERE AFTER SCANNING MATCHING CHARACTERS
*
{PSPS2{BNE{8,WB{3,PSAVC{6,SUCCP{SUCCEED IF CHARS MATCHED{11452
{{BRN{6,FAILP{{{FAIL IF NULL STRING MATCHED{11453
{{EJC{{{{{11454
*
*      MULTI-CHARACTER STRING
*
*      NOTE THAT ONE CHARACTER STRINGS USE THE CIRCUIT FOR
*      ONE CHARACTER ANY ARGUMENTS (P_AN1).
*
*      PARM1                 POINTER TO SCBLK FOR STRING ARG
*
{P_STR{ENT{2,BL_P1{{{P1BLK{11463
{{MOV{7,XL{13,PARM1(XR){{GET POINTER TO STRING{11464
*
*      MERGE HERE AFTER EVALUATING EXPRESSION WITH STRING VALUE
*
{PSTR1{MOV{3,PSAVE{7,XR{{SAVE NODE POINTER{11468
{{MOV{7,XR{3,R_PMS{{LOAD SUBJECT STRING POINTER{11469
{{PLC{7,XR{8,WB{{POINT TO CURRENT CHARACTER{11470
{{ADD{8,WB{13,SCLEN(XL){{COMPUTE NEW CURSOR POSITION{11471
{{BGT{8,WB{3,PMSSL{6,FAILP{FAIL IF PAST END OF STRING{11472
{{MOV{3,PSAVC{8,WB{{SAVE UPDATED CURSOR{11473
{{MOV{8,WA{13,SCLEN(XL){{GET NUMBER OF CHARS TO COMPARE{11474
{{PLC{7,XL{{{POINT TO CHARS OF TEST STRING{11475
{{CMC{6,FAILP{6,FAILP{{COMPARE, FAIL IF NOT EQUAL{11476
{{MOV{7,XR{3,PSAVE{{IF ALL MATCHED, RESTORE NODE PTR{11477
{{MOV{8,WB{3,PSAVC{{RESTORE UPDATED CURSOR{11478
{{BRN{6,SUCCP{{{AND SUCCEED{11479
{{EJC{{{{{11480
*
*      SUCCEED
*
*      SEE SECTION ON COMPOUND PATTERNS FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE
*
*      NO PARAMETERS
*
{P_SUC{ENT{2,BL_P0{{{P0BLK{11489
{{MOV{11,-(XS){8,WB{{STACK CURSOR{11490
{{MOV{11,-(XS){7,XR{{STACK POINTER TO THIS NODE{11491
{{BRN{6,SUCCP{{{SUCCEED MATCHING NULL{11492
{{EJC{{{{{11493
*
*      TAB (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P_TAB{ENT{2,BL_P1{{{P1BLK{11499
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PTAB1{BGT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF TOO FAR ALREADY{11503
{{MOV{8,WB{13,PARM1(XR){{ELSE SET NEW CURSOR POSITION{11504
{{BLE{8,WB{3,PMSSL{6,SUCCP{SUCCEED IF NOT OFF END{11505
{{BRN{6,FAILP{{{ELSE FAIL{11506
{{EJC{{{{{11507
*
*      TAB (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P_TBD{ENT{2,BL_P1{{{P1BLK{11513
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{11514
{{ERR{1,057{26,TAB evaluated argument is not integer{{{11515
{{ERR{1,058{26,TAB evaluated argument is negative or too large{{{11516
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{11517
{{PPM{6,PTAB1{{{MERGE WITH NORMAL CASE IF OK{11518
{{EJC{{{{{11519
*
*      ANCHOR MOVEMENT
*
*      NO PARAMETERS (DUMMY NODE)
*
{P_UNA{ENT{{{{ENTRY POINT{11525
{{MOV{7,XR{8,WB{{COPY INITIAL PATTERN NODE POINTER{11526
{{MOV{8,WB{9,(XS){{GET INITIAL CURSOR{11527
{{BEQ{8,WB{3,PMSSL{6,EXFAL{MATCH FAILS IF AT END OF STRING{11528
{{ICV{8,WB{{{ELSE INCREMENT CURSOR{11529
{{MOV{9,(XS){8,WB{{STORE INCREMENTED CURSOR{11530
{{MOV{11,-(XS){7,XR{{RESTACK INITIAL NODE PTR{11531
{{MOV{11,-(XS){21,=NDUNA{{RESTACK UNANCHORED NODE{11532
{{BRI{9,(XR){{{REMATCH FIRST NODE{11533
{{EJC{{{{{11534
*
*      END OF PATTERN MATCH ROUTINES
*
*      THE FOLLOWING ENTRY POINT MARKS THE END OF THE PATTERN
*      MATCHING ROUTINES AND ALSO THE END OF THE ENTRY POINTS
*      REFERENCED FROM THE FIRST WORD OF BLOCKS IN DYNAMIC STORE
*
{P_YYY{ENT{2,BL__I{{{MARK LAST ENTRY IN PATTERN SECTION{11542
{{TTL{27,S P I T B O L -- SNOBOL4 BUILT-IN LABEL ROUTINES{{{{11543
*
*      THE FOLLOWING SECTION CONTAINS THE ROUTINES FOR LABELS
*      WHICH HAVE A PREDEFINED MEANING IN SNOBOL4.
*
*      CONTROL IS PASSED DIRECTLY TO THE LABEL NAME ENTRY POINT.
*
*      ENTRY NAMES ARE OF THE FORM L_XXX WHERE XXX IS THE THREE
*      LETTER VARIABLE NAME IDENTIFIER.
*
*      ENTRIES ARE IN ALPHABETICAL ORDER
{{EJC{{{{{11554
*
*      ABORT
*
{L_ABO{ENT{{{{ENTRY POINT{11558
*
*      MERGE HERE IF EXECUTION TERMINATES IN ERROR
*
{LABO1{MOV{8,WA{3,KVERT{{LOAD ERROR CODE{11562
{{BZE{8,WA{6,LABO3{{JUMP IF NO ERROR HAS OCCURED{11563
{{JSR{6,SYSAX{{{CALL AFTER EXECUTION PROC{11565
{{MOV{8,WC{3,KVSTN{{CURRENT STATEMENT{11569
{{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STATEMENT{11570
{{MOV{7,XR{3,R_COD{{CURRENT CODE BLOCK{11573
{{MOV{8,WC{13,CDSLN(XR){{LINE NUMBER{11574
{{ZER{8,WB{{{COLUMN NUMBER{11578
{{MOV{7,XR{3,STAGE{{{11579
{{JSR{6,SYSEA{{{ADVISE SYSTEM OF ERROR{11580
{{PPM{6,STPR4{{{IF SYSTEM DOES NOT WANT PRINT{11581
{{JSR{6,PRTPG{{{ELSE EJECT PRINTER{11583
{{BZE{7,XR{6,LABO2{{DID SYSEA REQUEST PRINT{11585
{{JSR{6,PRTST{{{PRINT TEXT FROM SYSEA{11586
{LABO2{JSR{6,ERMSG{{{PRINT ERROR MESSAGE{11588
{{ZER{7,XR{{{INDICATE NO MESSAGE TO PRINT{11589
{{BRN{6,STOPR{{{JUMP TO ROUTINE TO STOP RUN{11590
*
*      HERE IF NO ERROR HAD OCCURED
*
{LABO3{ERB{1,036{26,Goto ABORT with no preceding error{{{11594
{{EJC{{{{{11595
*
*      CONTINUE
*
{L_CNT{ENT{{{{ENTRY POINT{11599
*
*      MERGE HERE AFTER EXECUTION ERROR
*
{LCNT1{MOV{7,XR{3,R_CNT{{LOAD CONTINUATION CODE BLOCK PTR{11603
{{BZE{7,XR{6,LCNT3{{JUMP IF NO PREVIOUS ERROR{11604
{{ZER{3,R_CNT{{{CLEAR FLAG{11605
{{MOV{3,R_COD{7,XR{{ELSE STORE AS NEW CODE BLOCK PTR{11606
{{BNE{9,(XR){22,=B_CDC{6,LCNT2{JUMP IF NOT COMPLEX GO{11607
{{MOV{8,WA{3,STXOC{{GET OFFSET OF ERROR{11608
{{BGE{8,WA{3,STXOF{6,LCNT4{JUMP IF ERROR IN GOTO EVALUATION{11609
*
*      HERE IF ERROR DID NOT OCCUR IN COMPLEX FAILURE GOTO
*
{LCNT2{ADD{7,XR{3,STXOF{{ADD FAILURE OFFSET{11613
{{LCP{7,XR{{{LOAD CODE POINTER{11614
{{MOV{7,XS{3,FLPTR{{RESET STACK POINTER{11615
{{LCW{7,XR{{{GET NEXT CODE WORD{11616
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11617
*
*      HERE IF NO PREVIOUS ERROR
*
{LCNT3{ICV{3,ERRFT{{{FATAL ERROR{11621
{{ERB{1,037{26,Goto CONTINUE with no preceding error{{{11622
*
*      HERE IF ERROR IN EVALUATION OF FAILURE GOTO.
*      CANNOT CONTINUE BACK TO FAILURE GOTO!
*
{LCNT4{ICV{3,ERRFT{{{FATAL ERROR{11627
{{ERB{1,332{26,Goto CONTINUE with error in failure goto{{{11628
{{EJC{{{{{11629
*
*      END
*
{L_END{ENT{{{{ENTRY POINT{11633
*
*      MERGE HERE FROM END CODE CIRCUIT
*
{LEND0{MOV{7,XR{21,=ENDMS{{POINT TO MESSAGE /NORMAL TERM.../{11637
{{BRN{6,STOPR{{{JUMP TO ROUTINE TO STOP RUN{11638
{{EJC{{{{{11639
*
*      FRETURN
*
{L_FRT{ENT{{{{ENTRY POINT{11643
{{MOV{8,WA{21,=SCFRT{{POINT TO STRING /FRETURN/{11644
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{11645
{{EJC{{{{{11646
*
*      NRETURN
*
{L_NRT{ENT{{{{ENTRY POINT{11650
{{MOV{8,WA{21,=SCNRT{{POINT TO STRING /NRETURN/{11651
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{11652
{{EJC{{{{{11653
*
*      RETURN
*
{L_RTN{ENT{{{{ENTRY POINT{11657
{{MOV{8,WA{21,=SCRTN{{POINT TO STRING /RETURN/{11658
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{11659
{{EJC{{{{{11660
*
*      SCONTINUE
*
{L_SCN{ENT{{{{ENTRY POINT{11664
{{MOV{7,XR{3,R_CNT{{LOAD CONTINUATION CODE BLOCK PTR{11665
{{BZE{7,XR{6,LSCN2{{JUMP IF NO PREVIOUS ERROR{11666
{{ZER{3,R_CNT{{{CLEAR FLAG{11667
{{BNE{3,KVERT{18,=NM320{6,LSCN1{ERROR MUST BE USER INTERRUPT{11668
{{BEQ{3,KVERT{18,=NM321{6,LSCN2{DETECT SCONTINUE LOOP{11669
{{MOV{3,R_COD{7,XR{{ELSE STORE AS NEW CODE BLOCK PTR{11670
{{ADD{7,XR{3,STXOC{{ADD RESUME OFFSET{11671
{{LCP{7,XR{{{LOAD CODE POINTER{11672
{{LCW{7,XR{{{GET NEXT CODE WORD{11673
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11674
*
*      HERE IF NO USER INTERRUPT
*
{LSCN1{ICV{3,ERRFT{{{FATAL ERROR{11678
{{ERB{1,331{26,Goto SCONTINUE with no user interrupt{{{11679
*
*      HERE IF IN SCONTINUE LOOP OR IF NO PREVIOUS ERROR
*
{LSCN2{ICV{3,ERRFT{{{FATAL ERROR{11683
{{ERB{1,321{26,Goto SCONTINUE with no preceding error{{{11684
{{EJC{{{{{11685
*
*      UNDEFINED LABEL
*
{L_UND{ENT{{{{ENTRY POINT{11689
{{ERB{1,038{26,Goto undefined label{{{11690
{{TTL{27,S P I T B O L -- PREDEFINED SNOBOL4 FUNCTIONS{{{{11691
*
*      THE FOLLOWING SECTION CONTAINS CODING FOR FUNCTIONS
*      WHICH ARE PREDEFINED AND AVAILABLE AT THE SNOBOL LEVEL.
*
*      THESE ROUTINES RECEIVE CONTROL DIRECTLY FROM THE CODE OR
*      INDIRECTLY THROUGH THE O_FNC, O_FNS OR CFUNC ROUTINES.
*      IN BOTH CASES THE CONDITIONS ON ENTRY ARE AS FOLLOWS
*
*      THE ARGUMENTS ARE ON THE STACK. THE NUMBER OF ARGUMENTS
*      HAS BEEN ADJUSTED TO CORRESPOND TO THE SVBLK SVNAR FIELD.
*
*      IN CERTAIN FUNCTIONS THE DIRECT CALL IS NOT PERMITTED
*      AND IN THESE INSTANCES WE ALSO HAVE.
*
*      (WA)                  ACTUAL NUMBER OF ARGUMENTS IN CALL
*
*      CONTROL RETURNS BY PLACING THE FUNCTION RESULT VALUE ON
*      ON THE STACK AND CONTINUING EXECUTION WITH THE NEXT
*      WORD FROM THE GENERATED CODE.
*
*      THE NAMES OF THE ENTRY POINTS OF THESE FUNCTIONS ARE OF
*      THE FORM S_XXX WHERE XXX IS THE THREE LETTER CODE FOR
*      THE SYSTEM VARIABLE NAME. THE FUNCTIONS ARE IN ORDER
*      ALPHABETICALLY BY THEIR ENTRY NAMES.
{{EJC{{{{{11716
*
*      ANY
*
{S_ANY{ENT{{{{ENTRY POINT{11770
{{MOV{8,WB{22,=P_ANS{{SET PCODE FOR SINGLE CHAR CASE{11771
{{MOV{7,XL{22,=P_ANY{{PCODE FOR MULTI-CHAR CASE{11772
{{MOV{8,WC{22,=P_AYD{{PCODE FOR EXPRESSION CASE{11773
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{11774
{{ERR{1,059{26,ANY argument is not a string or expression{{{11775
{{MOV{11,-(XS){7,XR{{STACK RESULT{11776
{{LCW{7,XR{{{GET NEXT CODE WORD{11777
{{BRI{9,(XR){{{EXECUTE IT{11778
{{EJC{{{{{11779
*
*      APPLY
*
*      APPLY DOES NOT PERMIT THE DIRECT (FAST) CALL SO THAT
*      WA CONTAINS THE ACTUAL NUMBER OF ARGUMENTS PASSED.
*
{S_APP{ENT{{{{ENTRY POINT{11805
{{BZE{8,WA{6,SAPP3{{JUMP IF NO ARGUMENTS{11806
{{DCV{8,WA{{{ELSE GET APPLIED FUNC ARG COUNT{11807
{{MOV{8,WB{8,WA{{COPY{11808
{{WTB{8,WB{{{CONVERT TO BYTES{11809
{{MOV{7,XT{7,XS{{COPY STACK POINTER{11810
{{ADD{7,XT{8,WB{{POINT TO FUNCTION ARGUMENT ON STACK{11811
{{MOV{7,XR{9,(XT){{LOAD FUNCTION PTR (APPLY 1ST ARG){11812
{{BZE{8,WA{6,SAPP2{{JUMP IF NO ARGS FOR APPLIED FUNC{11813
{{LCT{8,WB{8,WA{{ELSE SET COUNTER FOR LOOP{11814
*
*      LOOP TO MOVE ARGUMENTS UP ON STACK
*
{SAPP1{DCA{7,XT{{{POINT TO NEXT ARGUMENT{11818
{{MOV{13,NUM01(XT){9,(XT){{MOVE ARGUMENT UP{11819
{{BCT{8,WB{6,SAPP1{{LOOP TILL ALL MOVED{11820
*
*      MERGE HERE TO CALL FUNCTION (WA = NUMBER OF ARGUMENTS)
*
{SAPP2{ICA{7,XS{{{ADJUST STACK PTR FOR APPLY 1ST ARG{11824
{{JSR{6,GTNVR{{{GET VARIABLE BLOCK ADDR FOR FUNC{11825
{{PPM{6,SAPP3{{{JUMP IF NOT NATURAL VARIABLE{11826
{{MOV{7,XL{13,VRFNC(XR){{ELSE POINT TO FUNCTION BLOCK{11827
{{BRN{6,CFUNC{{{GO CALL APPLIED FUNCTION{11828
*
*      HERE FOR INVALID FIRST ARGUMENT
*
{SAPP3{ERB{1,060{26,APPLY first arg is not natural variable name{{{11832
{{EJC{{{{{11833
*
*      ARBNO
*
*      ARBNO BUILDS A COMPOUND PATTERN. SEE DESCRIPTION AT
*      START OF PATTERN MATCHING SECTION FOR STRUCTURE FORMED.
*
{S_ABN{ENT{{{{ENTRY POINT{11840
{{ZER{7,XR{{{SET PARM1 = 0 FOR THE MOMENT{11841
{{MOV{8,WB{22,=P_ALT{{SET PCODE FOR ALTERNATIVE NODE{11842
{{JSR{6,PBILD{{{BUILD ALTERNATIVE NODE{11843
{{MOV{7,XL{7,XR{{SAVE PTR TO ALTERNATIVE PATTERN{11844
{{MOV{8,WB{22,=P_ABC{{PCODE FOR P_ABC{11845
{{ZER{7,XR{{{P0BLK{11846
{{JSR{6,PBILD{{{BUILD P_ABC NODE{11847
{{MOV{13,PTHEN(XR){7,XL{{PUT ALTERNATIVE NODE AS SUCCESSOR{11848
{{MOV{8,WA{7,XL{{REMEMBER ALTERNATIVE NODE POINTER{11849
{{MOV{7,XL{7,XR{{COPY P_ABC NODE PTR{11850
{{MOV{7,XR{9,(XS){{LOAD ARBNO ARGUMENT{11851
{{MOV{9,(XS){8,WA{{STACK ALTERNATIVE NODE POINTER{11852
{{JSR{6,GTPAT{{{GET ARBNO ARGUMENT AS PATTERN{11853
{{ERR{1,061{26,ARBNO argument is not pattern{{{11854
{{JSR{6,PCONC{{{CONCAT ARG WITH P_ABC NODE{11855
{{MOV{7,XL{7,XR{{REMEMBER PTR TO CONCD PATTERNS{11856
{{MOV{8,WB{22,=P_ABA{{PCODE FOR P_ABA{11857
{{ZER{7,XR{{{P0BLK{11858
{{JSR{6,PBILD{{{BUILD P_ABA NODE{11859
{{MOV{13,PTHEN(XR){7,XL{{CONCATENATE NODES{11860
{{MOV{7,XL{9,(XS){{RECALL PTR TO ALTERNATIVE NODE{11861
{{MOV{13,PARM1(XL){7,XR{{POINT ALTERNATIVE BACK TO ARGUMENT{11862
{{LCW{7,XR{{{GET NEXT CODE WORD{11863
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11864
{{EJC{{{{{11865
*
*      ARG
*
{S_ARG{ENT{{{{ENTRY POINT{11869
{{JSR{6,GTSMI{{{GET SECOND ARG AS SMALL INTEGER{11870
{{ERR{1,062{26,ARG second argument is not integer{{{11871
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE OR NEGATIVE{11872
{{MOV{8,WA{7,XR{{SAVE ARGUMENT NUMBER{11873
{{MOV{7,XR{10,(XS)+{{LOAD FIRST ARGUMENT{11874
{{JSR{6,GTNVR{{{LOCATE VRBLK{11875
{{PPM{6,SARG1{{{JUMP IF NOT NATURAL VARIABLE{11876
{{MOV{7,XR{13,VRFNC(XR){{ELSE LOAD FUNCTION BLOCK POINTER{11877
{{BNE{9,(XR){22,=B_PFC{6,SARG1{JUMP IF NOT PROGRAM DEFINED{11878
{{BZE{8,WA{6,EXFAL{{FAIL IF ARG NUMBER IS ZERO{11879
{{BGT{8,WA{13,FARGS(XR){6,EXFAL{FAIL IF ARG NUMBER IS TOO LARGE{11880
{{WTB{8,WA{{{ELSE CONVERT TO BYTE OFFSET{11881
{{ADD{7,XR{8,WA{{POINT TO ARGUMENT SELECTED{11882
{{MOV{7,XR{13,PFAGB(XR){{LOAD ARGUMENT VRBLK POINTER{11883
{{BRN{6,EXVNM{{{EXIT TO BUILD NMBLK{11884
*
*      HERE IF 1ST ARGUMENT IS BAD
*
{SARG1{ERB{1,063{26,ARG first argument is not program function name{{{11888
{{EJC{{{{{11889
*
*      ARRAY
*
{S_ARR{ENT{{{{ENTRY POINT{11893
{{MOV{7,XL{10,(XS)+{{LOAD INITIAL ELEMENT VALUE{11894
{{MOV{7,XR{10,(XS)+{{LOAD FIRST ARGUMENT{11895
{{JSR{6,GTINT{{{CONVERT FIRST ARG TO INTEGER{11896
{{PPM{6,SAR02{{{JUMP IF NOT INTEGER{11897
*
*      HERE FOR INTEGER FIRST ARGUMENT, BUILD VCBLK
*
{{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{11901
{{ILE{6,SAR10{{{JUMP IF ZERO OR NEG (BAD DIMENSION){11902
{{MFI{8,WA{6,SAR11{{ELSE CONVERT TO ONE WORD, TEST OVFL{11903
{{JSR{6,VMAKE{{{CREATE VECTOR{11904
{{PPM{6,SAR11{{{FAIL IF TOO LARGE{11905
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{11906
{{EJC{{{{{11907
*
*      ARRAY (CONTINUED)
*
*      HERE IF FIRST ARGUMENT IS NOT AN INTEGER
*
{SAR02{MOV{11,-(XS){7,XR{{REPLACE ARGUMENT ON STACK{11913
{{JSR{6,XSCNI{{{INITIALIZE SCAN OF FIRST ARGUMENT{11914
{{ERR{1,064{26,ARRAY first argument is not integer or string{{{11915
{{PPM{6,EXNUL{{{DUMMY (UNUSED) NULL STRING EXIT{11916
{{MOV{11,-(XS){3,R_XSC{{SAVE PROTOTYPE POINTER{11917
{{MOV{11,-(XS){7,XL{{SAVE DEFAULT VALUE{11918
{{ZER{3,ARCDM{{{ZERO COUNT OF DIMENSIONS{11919
{{ZER{3,ARPTR{{{ZERO OFFSET TO INDICATE PASS ONE{11920
{{LDI{4,INTV1{{{LOAD INTEGER ONE{11921
{{STI{3,ARNEL{{{INITIALIZE ELEMENT COUNT{11922
*
*      THE FOLLOWING CODE IS EXECUTED TWICE. THE FIRST TIME
*      (ARPTR EQ 0), IT IS USED TO COUNT THE NUMBER OF ELEMENTS
*      AND NUMBER OF DIMENSIONS. THE SECOND TIME (ARPTR GT 0) IS
*      USED TO ACTUALLY FILL IN THE DIM,LBD FIELDS OF THE ARBLK.
*
{SAR03{LDI{4,INTV1{{{LOAD ONE AS DEFAULT LOW BOUND{11929
{{STI{3,ARSVL{{{SAVE AS LOW BOUND{11930
{{MOV{8,WC{18,=CH_CL{{SET DELIMITER ONE = COLON{11931
{{MOV{7,XL{18,=CH_CM{{SET DELIMITER TWO = COMMA{11932
{{ZER{8,WA{{{RETAIN BLANKS IN PROTOTYPE{11933
{{JSR{6,XSCAN{{{SCAN NEXT BOUND{11934
{{BNE{8,WA{18,=NUM01{6,SAR04{JUMP IF NOT COLON{11935
*
*      HERE WE HAVE A COLON ENDING A LOW BOUND
*
{{JSR{6,GTINT{{{CONVERT LOW BOUND{11939
{{ERR{1,065{26,ARRAY first argument lower bound is not integer{{{11940
{{LDI{13,ICVAL(XR){{{LOAD VALUE OF LOW BOUND{11941
{{STI{3,ARSVL{{{STORE LOW BOUND VALUE{11942
{{MOV{8,WC{18,=CH_CM{{SET DELIMITER ONE = COMMA{11943
{{MOV{7,XL{8,WC{{AND DELIMITER TWO = COMMA{11944
{{ZER{8,WA{{{RETAIN BLANKS IN PROTOTYPE{11945
{{JSR{6,XSCAN{{{SCAN HIGH BOUND{11946
{{EJC{{{{{11947
*
*      ARRAY (CONTINUED)
*
*      MERGE HERE TO PROCESS UPPER BOUND
*
{SAR04{JSR{6,GTINT{{{CONVERT HIGH BOUND TO INTEGER{11953
{{ERR{1,066{26,ARRAY first argument upper bound is not integer{{{11954
{{LDI{13,ICVAL(XR){{{GET HIGH BOUND{11955
{{SBI{3,ARSVL{{{SUBTRACT LOWER BOUND{11956
{{IOV{6,SAR10{{{BAD DIMENSION IF OVERFLOW{11957
{{ILT{6,SAR10{{{BAD DIMENSION IF NEGATIVE{11958
{{ADI{4,INTV1{{{ADD 1 TO GET DIMENSION{11959
{{IOV{6,SAR10{{{BAD DIMENSION IF OVERFLOW{11960
{{MOV{7,XL{3,ARPTR{{LOAD OFFSET (ALSO PASS INDICATOR){11961
{{BZE{7,XL{6,SAR05{{JUMP IF FIRST PASS{11962
*
*      HERE IN SECOND PASS TO STORE LBD AND DIM IN ARBLK
*
{{ADD{7,XL{9,(XS){{POINT TO CURRENT LOCATION IN ARBLK{11966
{{STI{13,CFP_I(XL){{{STORE DIMENSION{11967
{{LDI{3,ARSVL{{{LOAD LOW BOUND{11968
{{STI{9,(XL){{{STORE LOW BOUND{11969
{{ADD{3,ARPTR{19,*ARDMS{{BUMP OFFSET TO NEXT BOUNDS{11970
{{BRN{6,SAR06{{{JUMP TO CHECK FOR END OF BOUNDS{11971
*
*      HERE IN PASS 1
*
{SAR05{ICV{3,ARCDM{{{BUMP DIMENSION COUNT{11975
{{MLI{3,ARNEL{{{MULTIPLY DIMENSION BY COUNT SO FAR{11976
{{IOV{6,SAR11{{{TOO LARGE IF OVERFLOW{11977
{{STI{3,ARNEL{{{ELSE STORE UPDATED ELEMENT COUNT{11978
*
*      MERGE HERE AFTER PROCESSING ONE SET OF BOUNDS
*
{SAR06{BNZ{8,WA{6,SAR03{{LOOP BACK UNLESS END OF BOUNDS{11982
{{BNZ{3,ARPTR{6,SAR09{{JUMP IF END OF PASS 2{11983
{{EJC{{{{{11984
*
*      ARRAY (CONTINUED)
*
*      HERE AT END OF PASS ONE, BUILD ARBLK
*
{{LDI{3,ARNEL{{{GET NUMBER OF ELEMENTS{11990
{{MFI{8,WB{6,SAR11{{GET AS ADDR INTEGER, TEST OVFLO{11991
{{WTB{8,WB{{{ELSE CONVERT TO LENGTH IN BYTES{11992
{{MOV{8,WA{19,*ARSI_{{SET SIZE OF STANDARD FIELDS{11993
{{LCT{8,WC{3,ARCDM{{SET DIMENSION COUNT TO CONTROL LOOP{11994
*
*      LOOP TO ALLOW SPACE FOR DIMENSIONS
*
{SAR07{ADD{8,WA{19,*ARDMS{{ALLOW SPACE FOR ONE SET OF BOUNDS{11998
{{BCT{8,WC{6,SAR07{{LOOP BACK TILL ALL ACCOUNTED FOR{11999
{{MOV{7,XL{8,WA{{SAVE SIZE (=AROFS){12000
*
*      NOW ALLOCATE SPACE FOR ARBLK
*
{{ADD{8,WA{8,WB{{ADD SPACE FOR ELEMENTS{12004
{{ICA{8,WA{{{ALLOW FOR ARPRO PROTOTYPE FIELD{12005
{{BGT{8,WA{3,MXLEN{6,SAR11{FAIL IF TOO LARGE{12006
{{JSR{6,ALLOC{{{ELSE ALLOCATE ARBLK{12007
{{MOV{8,WB{9,(XS){{LOAD DEFAULT VALUE{12008
{{MOV{9,(XS){7,XR{{SAVE ARBLK POINTER{12009
{{MOV{8,WC{8,WA{{SAVE LENGTH IN BYTES{12010
{{BTW{8,WA{{{CONVERT LENGTH BACK TO WORDS{12011
{{LCT{8,WA{8,WA{{SET COUNTER TO CONTROL LOOP{12012
*
*      LOOP TO CLEAR ENTIRE ARBLK TO DEFAULT VALUE
*
{SAR08{MOV{10,(XR)+{8,WB{{SET ONE WORD{12016
{{BCT{8,WA{6,SAR08{{LOOP TILL ALL SET{12017
{{EJC{{{{{12018
*
*      ARRAY (CONTINUED)
*
*      NOW SET INITIAL FIELDS OF ARBLK
*
{{MOV{7,XR{10,(XS)+{{RELOAD ARBLK POINTER{12024
{{MOV{8,WB{9,(XS){{LOAD PROTOTYPE{12025
{{MOV{9,(XR){22,=B_ART{{SET TYPE WORD{12026
{{MOV{13,ARLEN(XR){8,WC{{STORE LENGTH IN BYTES{12027
{{ZER{13,IDVAL(XR){{{ZERO ID TILL WE GET IT BUILT{12028
{{MOV{13,AROFS(XR){7,XL{{SET PROTOTYPE FIELD PTR{12029
{{MOV{13,ARNDM(XR){3,ARCDM{{SET NUMBER OF DIMENSIONS{12030
{{MOV{8,WC{7,XR{{SAVE ARBLK POINTER{12031
{{ADD{7,XR{7,XL{{POINT TO PROTOTYPE FIELD{12032
{{MOV{9,(XR){8,WB{{STORE PROTOTYPE PTR IN ARBLK{12033
{{MOV{3,ARPTR{19,*ARLBD{{SET OFFSET FOR PASS 2 BOUNDS SCAN{12034
{{MOV{3,R_XSC{8,WB{{RESET STRING POINTER FOR XSCAN{12035
{{MOV{9,(XS){8,WC{{STORE ARBLK POINTER ON STACK{12036
{{ZER{3,XSOFS{{{RESET OFFSET PTR TO START OF STRING{12037
{{BRN{6,SAR03{{{JUMP BACK TO RESCAN BOUNDS{12038
*
*      HERE AFTER FILLING IN BOUNDS INFORMATION (END PASS TWO)
*
{SAR09{MOV{7,XR{10,(XS)+{{RELOAD POINTER TO ARBLK{12042
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{12043
*
*      HERE FOR BAD DIMENSION
*
{SAR10{ERB{1,067{26,ARRAY dimension is zero, negative or out of range{{{12047
*
*      HERE IF ARRAY IS TOO LARGE
*
{SAR11{ERB{1,068{26,ARRAY size exceeds maximum permitted{{{12051
{{EJC{{{{{12052
*
*      ATAN
*
{S_ATN{ENT{{{{ENTRY POINT{12057
{{MOV{7,XR{10,(XS)+{{GET ARGUMENT{12058
{{JSR{6,GTREA{{{CONVERT TO REAL{12059
{{ERR{1,301{26,ATAN argument not numeric{{{12060
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{12061
{{ATN{{{{TAKE ARCTANGENT{12062
{{BRN{6,EXREA{{{OVERFLOW, OUT OF RANGE NOT POSSIBLE{12063
{{EJC{{{{{12064
{{EJC{{{{{12067
*
*      BACKSPACE
*
{S_BSP{ENT{{{{ENTRY POINT{12071
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{12072
{{ERR{1,316{26,BACKSPACE argument is not a suitable name{{{12073
{{ERR{1,316{26,BACKSPACE argument is not a suitable name{{{12074
{{ERR{1,317{26,BACKSPACE file does not exist{{{12075
{{JSR{6,SYSBS{{{CALL BACKSPACE FILE FUNCTION{12076
{{ERR{1,317{26,BACKSPACE file does not exist{{{12077
{{ERR{1,318{26,BACKSPACE file does not permit backspace{{{12078
{{ERR{1,319{26,BACKSPACE caused non-recoverable error{{{12079
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{12080
{{EJC{{{{{12081
*
*      BREAK
*
{S_BRK{ENT{{{{ENTRY POINT{12114
{{MOV{8,WB{22,=P_BKS{{SET PCODE FOR SINGLE CHAR CASE{12115
{{MOV{7,XL{22,=P_BRK{{PCODE FOR MULTI-CHAR CASE{12116
{{MOV{8,WC{22,=P_BKD{{PCODE FOR EXPRESSION CASE{12117
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{12118
{{ERR{1,069{26,BREAK argument is not a string or expression{{{12119
{{MOV{11,-(XS){7,XR{{STACK RESULT{12120
{{LCW{7,XR{{{GET NEXT CODE WORD{12121
{{BRI{9,(XR){{{EXECUTE IT{12122
{{EJC{{{{{12123
*
*      BREAKX
*
*      BREAKX IS A COMPOUND PATTERN. SEE DESCRIPTION AT START
*      OF PATTERN MATCHING SECTION FOR STRUCTURE FORMED.
*
{S_BKX{ENT{{{{ENTRY POINT{12130
{{MOV{8,WB{22,=P_BKS{{PCODE FOR SINGLE CHAR ARGUMENT{12131
{{MOV{7,XL{22,=P_BRK{{PCODE FOR MULTI-CHAR ARGUMENT{12132
{{MOV{8,WC{22,=P_BXD{{PCODE FOR EXPRESSION CASE{12133
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{12134
{{ERR{1,070{26,BREAKX argument is not a string or expression{{{12135
*
*      NOW HOOK BREAKX NODE ON AT FRONT END
*
{{MOV{11,-(XS){7,XR{{SAVE PTR TO BREAK NODE{12139
{{MOV{8,WB{22,=P_BKX{{SET PCODE FOR BREAKX NODE{12140
{{JSR{6,PBILD{{{BUILD IT{12141
{{MOV{13,PTHEN(XR){9,(XS){{SET BREAK NODE AS SUCCESSOR{12142
{{MOV{8,WB{22,=P_ALT{{SET PCODE FOR ALTERNATION NODE{12143
{{JSR{6,PBILD{{{BUILD (PARM1=ALT=BREAKX NODE){12144
{{MOV{8,WA{7,XR{{SAVE PTR TO ALTERNATION NODE{12145
{{MOV{7,XR{9,(XS){{POINT TO BREAK NODE{12146
{{MOV{13,PTHEN(XR){8,WA{{SET ALTERNATE NODE AS SUCCESSOR{12147
{{LCW{7,XR{{{RESULT ON STACK{12148
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12149
{{EJC{{{{{12150
*
*      CHAR
*
{S_CHR{ENT{{{{ENTRY POINT{12154
{{JSR{6,GTSMI{{{CONVERT ARG TO INTEGER{12155
{{ERR{1,281{26,CHAR argument not integer{{{12156
{{PPM{6,SCHR1{{{TOO BIG ERROR EXIT{12157
{{BGE{8,WC{18,=CFP_A{6,SCHR1{SEE IF OUT OF RANGE OF HOST SET{12158
{{MOV{8,WA{18,=NUM01{{IF NOT SET SCBLK ALLOCATION{12159
{{MOV{8,WB{8,WC{{SAVE CHAR CODE{12160
{{JSR{6,ALOCS{{{ALLOCATE 1 BAU SCBLK{12161
{{MOV{7,XL{7,XR{{COPY SCBLK POINTER{12162
{{PSC{7,XL{{{GET SET TO STUFF CHAR{12163
{{SCH{8,WB{9,(XL){{STUFF IT{12164
{{CSC{7,XL{{{COMPLETE STORE CHARACTER{12165
{{ZER{7,XL{{{CLEAR SLOP IN XL{12166
{{MOV{11,-(XS){7,XR{{STACK RESULT{12167
{{LCW{7,XR{{{GET NEXT CODE WORD{12168
{{BRI{9,(XR){{{EXECUTE IT{12169
*
*      HERE IF CHAR ARGUMENT IS OUT OF RANGE
*
{SCHR1{ERB{1,282{26,CHAR argument not in range{{{12173
{{EJC{{{{{12174
*
*      CHOP
*
{S_CHP{ENT{{{{ENTRY POINT{12179
{{MOV{7,XR{10,(XS)+{{GET ARGUMENT{12180
{{JSR{6,GTREA{{{CONVERT TO REAL{12181
{{ERR{1,302{26,CHOP argument not numeric{{{12182
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{12183
{{CHP{{{{TRUNCATE TO INTEGER VALUED REAL{12184
{{BRN{6,EXREA{{{NO OVERFLOW POSSIBLE{12185
{{EJC{{{{{12186
*
*      CLEAR
*
{S_CLR{ENT{{{{ENTRY POINT{12191
{{JSR{6,XSCNI{{{INITIALIZE TO SCAN ARGUMENT{12192
{{ERR{1,071{26,CLEAR argument is not a string{{{12193
{{PPM{6,SCLR2{{{JUMP IF NULL{12194
*
*      LOOP TO SCAN OUT NAMES IN FIRST ARGUMENT. VARIABLES IN
*      THE LIST ARE FLAGGED BY SETTING VRGET OF VRBLK TO ZERO.
*
{SCLR1{MOV{8,WC{18,=CH_CM{{SET DELIMITER ONE = COMMA{12199
{{MOV{7,XL{8,WC{{DELIMITER TWO = COMMA{12200
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{12201
{{JSR{6,XSCAN{{{SCAN NEXT VARIABLE NAME{12202
{{JSR{6,GTNVR{{{LOCATE VRBLK{12203
{{ERR{1,072{26,CLEAR argument has null variable name{{{12204
{{ZER{13,VRGET(XR){{{ELSE FLAG BY ZEROING VRGET FIELD{12205
{{BNZ{8,WA{6,SCLR1{{LOOP BACK IF STOPPED BY COMMA{12206
*
*      HERE AFTER FLAGGING VARIABLES IN ARGUMENT LIST
*
{SCLR2{MOV{8,WB{3,HSHTB{{POINT TO START OF HASH TABLE{12210
*
*      LOOP THROUGH SLOTS IN HASH TABLE
*
{SCLR3{BEQ{8,WB{3,HSHTE{6,EXNUL{EXIT RETURNING NULL IF NONE LEFT{12214
{{MOV{7,XR{8,WB{{ELSE COPY SLOT POINTER{12215
{{ICA{8,WB{{{BUMP SLOT POINTER{12216
{{SUB{7,XR{19,*VRNXT{{SET OFFSET TO MERGE INTO LOOP{12217
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
{SCLR4{MOV{7,XR{13,VRNXT(XR){{POINT TO NEXT VRBLK ON CHAIN{12221
{{BZE{7,XR{6,SCLR3{{JUMP FOR NEXT BUCKET IF CHAIN END{12222
{{BNZ{13,VRGET(XR){6,SCLR5{{JUMP IF NOT FLAGGED{12223
{{EJC{{{{{12224
*
*      CLEAR (CONTINUED)
*
*      HERE FOR FLAGGED VARIABLE, DO NOT SET VALUE TO NULL
*
{{JSR{6,SETVR{{{FOR FLAGGED VAR, RESTORE VRGET{12230
{{BRN{6,SCLR4{{{AND LOOP BACK FOR NEXT VRBLK{12231
*
*      HERE TO SET VALUE OF A VARIABLE TO NULL
*      PROTECTED VARIABLES (ARB, ETC) ARE EXEMPT
*
{SCLR5{BEQ{13,VRSTO(XR){22,=B_VRE{6,SCLR4{CHECK FOR PROTECTED VARIABLE{12236
{{MOV{7,XL{7,XR{{COPY VRBLK POINTER{12237
*
*      LOOP TO LOCATE VALUE AT END OF POSSIBLE TRBLK CHAIN
*
{SCLR6{MOV{8,WA{7,XL{{SAVE BLOCK POINTER{12241
{{MOV{7,XL{13,VRVAL(XL){{LOAD NEXT VALUE FIELD{12242
{{BEQ{9,(XL){22,=B_TRT{6,SCLR6{LOOP BACK IF TRAPPED{12243
*
*      NOW STORE THE NULL VALUE
*
{{MOV{7,XL{8,WA{{RESTORE BLOCK POINTER{12247
{{MOV{13,VRVAL(XL){21,=NULLS{{STORE NULL CONSTANT VALUE{12248
{{BRN{6,SCLR4{{{LOOP BACK FOR NEXT VRBLK{12249
{{EJC{{{{{12250
*
*      CODE
*
{S_COD{ENT{{{{ENTRY POINT{12254
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{12255
{{JSR{6,GTCOD{{{CONVERT TO CODE{12256
{{PPM{6,EXFAL{{{FAIL IF CONVERSION IS IMPOSSIBLE{12257
{{MOV{11,-(XS){7,XR{{STACK RESULT{12258
{{ZER{3,R_CCB{{{FORGET INTERIM CODE BLOCK{12259
{{LCW{7,XR{{{GET NEXT CODE WORD{12260
{{BRI{9,(XR){{{EXECUTE IT{12261
{{EJC{{{{{12262
*
*      COLLECT
*
{S_COL{ENT{{{{ENTRY POINT{12266
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{12267
{{JSR{6,GTINT{{{CONVERT TO INTEGER{12268
{{ERR{1,073{26,COLLECT argument is not integer{{{12269
{{LDI{13,ICVAL(XR){{{LOAD COLLECT ARGUMENT{12270
{{STI{3,CLSVI{{{SAVE COLLECT ARGUMENT{12271
{{ZER{8,WB{{{SET NO MOVE UP{12272
{{ZER{3,R_CCB{{{FORGET INTERIM CODE BLOCK{12273
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{12275
{{JSR{6,GBCOL{{{PERFORM GARBAGE COLLECTION{12276
{{MOV{3,DNAMS{7,XR{{RECORD NEW SEDIMENT SIZE{12277
{{MOV{8,WA{3,DNAME{{POINT TO END OF MEMORY{12281
{{SUB{8,WA{3,DNAMP{{SUBTRACT NEXT LOCATION{12282
{{BTW{8,WA{{{CONVERT BYTES TO WORDS{12283
{{MTI{8,WA{{{CONVERT WORDS AVAILABLE AS INTEGER{12284
{{SBI{3,CLSVI{{{SUBTRACT ARGUMENT{12285
{{IOV{6,EXFAL{{{FAIL IF OVERFLOW{12286
{{ILT{6,EXFAL{{{FAIL IF NOT ENOUGH{12287
{{ADI{3,CLSVI{{{ELSE RECOMPUTE AVAILABLE{12288
{{BRN{6,EXINT{{{AND EXIT WITH INTEGER RESULT{12289
{{EJC{{{{{12290
*
*      CONVERT
*
{S_CNV{ENT{{{{ENTRY POINT{12319
{{JSR{6,GTSTG{{{CONVERT SECOND ARGUMENT TO STRING{12320
{{PPM{6,SCV29{{{ERROR IF SECOND ARGUMENT NOT STRING{12321
{{BZE{8,WA{6,SCV29{{OR IF NULL STRING{12322
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{12324
{{MOV{7,XL{9,(XS){{LOAD FIRST ARGUMENT{12326
{{BNE{9,(XL){22,=B_PDT{6,SCV01{JUMP IF NOT PROGRAM DEFINED{12327
*
*      HERE FOR PROGRAM DEFINED DATATYPE
*
{{MOV{7,XL{13,PDDFP(XL){{POINT TO DFBLK{12331
{{MOV{7,XL{13,DFNAM(XL){{LOAD DATATYPE NAME{12332
{{JSR{6,IDENT{{{COMPARE WITH SECOND ARG{12333
{{PPM{6,EXITS{{{EXIT IF IDENT WITH ARG AS RESULT{12334
{{BRN{6,EXFAL{{{ELSE FAIL{12335
*
*      HERE IF NOT PROGRAM DEFINED DATATYPE
*
{SCV01{MOV{11,-(XS){7,XR{{SAVE STRING ARGUMENT{12339
{{MOV{7,XL{21,=SVCTB{{POINT TO TABLE OF NAMES TO COMPARE{12340
{{ZER{8,WB{{{INITIALIZE COUNTER{12341
{{MOV{8,WC{8,WA{{SAVE LENGTH OF ARGUMENT STRING{12342
*
*      LOOP THROUGH TABLE ENTRIES
*
{SCV02{MOV{7,XR{10,(XL)+{{LOAD NEXT TABLE ENTRY, BUMP POINTER{12346
{{BZE{7,XR{6,EXFAL{{FAIL IF ZERO MARKING END OF LIST{12347
{{BNE{8,WC{13,SCLEN(XR){6,SCV05{JUMP IF WRONG LENGTH{12348
{{MOV{3,CNVTP{7,XL{{ELSE STORE TABLE POINTER{12349
{{PLC{7,XR{{{POINT TO CHARS OF TABLE ENTRY{12350
{{MOV{7,XL{9,(XS){{LOAD POINTER TO STRING ARGUMENT{12351
{{PLC{7,XL{{{POINT TO CHARS OF STRING ARG{12352
{{MOV{8,WA{8,WC{{SET NUMBER OF CHARS TO COMPARE{12353
{{CMC{6,SCV04{6,SCV04{{COMPARE, JUMP IF NO MATCH{12354
{{EJC{{{{{12355
*
*      CONVERT (CONTINUED)
*
*      HERE WE HAVE A MATCH
*
{SCV03{MOV{7,XL{8,WB{{COPY ENTRY NUMBER{12361
{{ICA{7,XS{{{POP STRING ARG OFF STACK{12362
{{MOV{7,XR{10,(XS)+{{LOAD FIRST ARGUMENT{12363
{{BSW{7,XL{2,CNVTT{{JUMP TO APPROPRIATE ROUTINE{12364
{{IFF{1,0{6,SCV06{{STRING{12382
{{IFF{1,1{6,SCV07{{INTEGER{12382
{{IFF{1,2{6,SCV09{{NAME{12382
{{IFF{1,3{6,SCV10{{PATTERN{12382
{{IFF{1,4{6,SCV11{{ARRAY{12382
{{IFF{1,5{6,SCV19{{TABLE{12382
{{IFF{1,6{6,SCV25{{EXPRESSION{12382
{{IFF{1,7{6,SCV26{{CODE{12382
{{IFF{1,8{6,SCV27{{NUMERIC{12382
{{IFF{2,CNVRT{6,SCV08{{REAL{12382
{{ESW{{{{END OF SWITCH TABLE{12382
*
*      HERE IF NO MATCH WITH TABLE ENTRY
*
{SCV04{MOV{7,XL{3,CNVTP{{RESTORE TABLE POINTER, MERGE{12386
*
*      MERGE HERE IF LENGTHS DID NOT MATCH
*
{SCV05{ICV{8,WB{{{BUMP ENTRY NUMBER{12390
{{BRN{6,SCV02{{{LOOP BACK TO CHECK NEXT ENTRY{12391
*
*      HERE TO CONVERT TO STRING
*
{SCV06{MOV{11,-(XS){7,XR{{REPLACE STRING ARGUMENT ON STACK{12395
{{JSR{6,GTSTG{{{CONVERT TO STRING{12396
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{12397
{{MOV{11,-(XS){7,XR{{STACK RESULT{12398
{{LCW{7,XR{{{GET NEXT CODE WORD{12399
{{BRI{9,(XR){{{EXECUTE IT{12400
{{EJC{{{{{12401
*
*      CONVERT (CONTINUED)
*
*      HERE TO CONVERT TO INTEGER
*
{SCV07{JSR{6,GTINT{{{CONVERT TO INTEGER{12407
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{12408
{{MOV{11,-(XS){7,XR{{STACK RESULT{12409
{{LCW{7,XR{{{GET NEXT CODE WORD{12410
{{BRI{9,(XR){{{EXECUTE IT{12411
*
*      HERE TO CONVERT TO REAL
*
{SCV08{JSR{6,GTREA{{{CONVERT TO REAL{12417
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{12418
{{MOV{11,-(XS){7,XR{{STACK RESULT{12419
{{LCW{7,XR{{{GET NEXT CODE WORD{12420
{{BRI{9,(XR){{{EXECUTE IT{12421
*
*      HERE TO CONVERT TO NAME
*
{SCV09{BEQ{9,(XR){22,=B_NML{6,EXIXR{RETURN IF ALREADY A NAME{12426
{{JSR{6,GTNVR{{{ELSE TRY STRING TO NAME CONVERT{12427
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{12428
{{BRN{6,EXVNM{{{ELSE EXIT BUILDING NMBLK FOR VRBLK{12429
*
*      HERE TO CONVERT TO PATTERN
*
{SCV10{JSR{6,GTPAT{{{CONVERT TO PATTERN{12433
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{12434
{{MOV{11,-(XS){7,XR{{STACK RESULT{12435
{{LCW{7,XR{{{GET NEXT CODE WORD{12436
{{BRI{9,(XR){{{EXECUTE IT{12437
*
*      CONVERT TO ARRAY
*
*      IF THE FIRST ARGUMENT IS A TABLE, THEN WE GO THROUGH
*      AN INTERMEDIATE ARRAY OF ADDRESSES THAT IS SORTED TO
*      PROVIDE A RESULT ORDERED BY TIME OF ENTRY IN THE
*      ORIGINAL TABLE.  SEE C3.762.
*
{SCV11{MOV{11,-(XS){7,XR{{SAVE ARGUMENT ON STACK{12446
{{ZER{8,WA{{{USE TABLE CHAIN BLOCK ADDRESSES{12447
{{JSR{6,GTARR{{{GET AN ARRAY{12448
{{PPM{6,EXFAL{{{FAIL IF EMPTY TABLE{12449
{{PPM{6,EXFAL{{{FAIL IF NOT CONVERTIBLE{12450
{{MOV{7,XL{10,(XS)+{{RELOAD ORIGINAL ARG{12451
{{BNE{9,(XL){22,=B_TBT{6,EXSID{EXIT IF ORIGINAL NOT A TABLE{12452
{{MOV{11,-(XS){7,XR{{SORT THE INTERMEDIATE ARRAY{12453
{{MOV{11,-(XS){21,=NULLS{{ON FIRST COLUMN{12454
{{ZER{8,WA{{{SORT ASCENDING{12455
{{JSR{6,SORTA{{{DO SORT{12456
{{PPM{6,EXFAL{{{IF SORT FAILS, SO SHALL WE{12457
{{MOV{8,WB{7,XR{{SAVE ARRAY RESULT{12458
{{LDI{13,ARDIM(XR){{{LOAD DIM 1 (NUMBER OF ELEMENTS){12459
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{12460
{{LCT{8,WA{8,WA{{COPY TO CONTROL LOOP{12461
{{ADD{7,XR{19,*ARVL2{{POINT TO FIRST ELEMENT IN ARRAY{12462
*
*      HERE FOR EACH ROW OF THIS 2-COLUMN ARRAY
*
{SCV12{MOV{7,XL{9,(XR){{GET TEBLK ADDRESS{12466
{{MOV{10,(XR)+{13,TESUB(XL){{REPLACE WITH SUBSCRIPT{12467
{{MOV{10,(XR)+{13,TEVAL(XL){{REPLACE WITH VALUE{12468
{{BCT{8,WA{6,SCV12{{LOOP TILL ALL COPIED OVER{12469
{{MOV{7,XR{8,WB{{RETRIEVE ARRAY ADDRESS{12470
{{BRN{6,EXSID{{{EXIT SETTING ID FIELD{12471
*
*      CONVERT TO TABLE
*
{SCV19{MOV{8,WA{9,(XR){{LOAD FIRST WORD OF BLOCK{12475
{{MOV{11,-(XS){7,XR{{REPLACE ARBLK POINTER ON STACK{12476
{{BEQ{8,WA{22,=B_TBT{6,EXITS{RETURN ARG IF ALREADY A TABLE{12477
{{BNE{8,WA{22,=B_ART{6,EXFAL{ELSE FAIL IF NOT AN ARRAY{12478
{{EJC{{{{{12479
*
*      CONVERT (CONTINUED)
*
*      HERE TO CONVERT AN ARRAY TO TABLE
*
{{BNE{13,ARNDM(XR){18,=NUM02{6,EXFAL{FAIL IF NOT 2-DIM ARRAY{12485
{{LDI{13,ARDM2(XR){{{LOAD DIM 2{12486
{{SBI{4,INTV2{{{SUBTRACT 2 TO COMPARE{12487
{{INE{6,EXFAL{{{FAIL IF DIM2 NOT 2{12488
*
*      HERE WE HAVE AN ARBLK OF THE RIGHT SHAPE
*
{{LDI{13,ARDIM(XR){{{LOAD DIM 1 (NUMBER OF ELEMENTS){12492
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{12493
{{LCT{8,WB{8,WA{{COPY TO CONTROL LOOP{12494
{{ADD{8,WA{18,=TBSI_{{ADD SPACE FOR STANDARD FIELDS{12495
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{12496
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR TBBLK{12497
{{MOV{8,WC{7,XR{{COPY TBBLK POINTER{12498
{{MOV{11,-(XS){7,XR{{SAVE TBBLK POINTER{12499
{{MOV{10,(XR)+{22,=B_TBT{{STORE TYPE WORD{12500
{{ZER{10,(XR)+{{{STORE ZERO FOR IDVAL FOR NOW{12501
{{MOV{10,(XR)+{8,WA{{STORE LENGTH{12502
{{MOV{10,(XR)+{21,=NULLS{{NULL INITIAL LOOKUP VALUE{12503
*
*      LOOP TO INITIALIZE BUCKET PTRS TO POINT TO TABLE
*
{SCV20{MOV{10,(XR)+{8,WC{{SET BUCKET PTR TO POINT TO TBBLK{12507
{{BCT{8,WB{6,SCV20{{LOOP TILL ALL INITIALIZED{12508
{{MOV{8,WB{19,*ARVL2{{SET OFFSET TO FIRST ARBLK ELEMENT{12509
*
*      LOOP TO COPY ELEMENTS FROM ARRAY TO TABLE
*
{SCV21{MOV{7,XL{13,NUM01(XS){{POINT TO ARBLK{12513
{{BEQ{8,WB{13,ARLEN(XL){6,SCV24{JUMP IF ALL MOVED{12514
{{ADD{7,XL{8,WB{{ELSE POINT TO CURRENT LOCATION{12515
{{ADD{8,WB{19,*NUM02{{BUMP OFFSET{12516
{{MOV{7,XR{9,(XL){{LOAD SUBSCRIPT NAME{12517
{{DCA{7,XL{{{ADJUST PTR TO MERGE (TRVAL=1+1){12518
{{EJC{{{{{12519
*
*      CONVERT (CONTINUED)
*
*      LOOP TO CHASE DOWN TRBLK CHAIN FOR VALUE
*
{SCV22{MOV{7,XL{13,TRVAL(XL){{POINT TO NEXT VALUE{12525
{{BEQ{9,(XL){22,=B_TRT{6,SCV22{LOOP BACK IF TRAPPED{12526
*
*      HERE WITH NAME IN XR, VALUE IN XL
*
{SCV23{MOV{11,-(XS){7,XL{{STACK VALUE{12530
{{MOV{7,XL{13,NUM01(XS){{LOAD TBBLK POINTER{12531
{{JSR{6,TFIND{{{BUILD TEBLK (NOTE WB GT 0 BY NAME){12532
{{PPM{6,EXFAL{{{FAIL IF ACESS FAILS{12533
{{MOV{13,TEVAL(XL){10,(XS)+{{STORE VALUE IN TEBLK{12534
{{BRN{6,SCV21{{{LOOP BACK FOR NEXT ELEMENT{12535
*
*      HERE AFTER MOVING ALL ELEMENTS TO TBBLK
*
{SCV24{MOV{7,XR{10,(XS)+{{LOAD TBBLK POINTER{12539
{{ICA{7,XS{{{POP ARBLK POINTER{12540
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{12541
*
*      CONVERT TO EXPRESSION
*
{SCV25{ZER{8,WB{{{BY VALUE{12546
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{12547
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{12551
{{ZER{3,R_CCB{{{FORGET INTERIM CODE BLOCK{12552
{{MOV{11,-(XS){7,XR{{STACK RESULT{12553
{{LCW{7,XR{{{GET NEXT CODE WORD{12554
{{BRI{9,(XR){{{EXECUTE IT{12555
*
*      CONVERT TO CODE
*
{SCV26{JSR{6,GTCOD{{{CONVERT TO CODE{12559
{{PPM{6,EXFAL{{{FAIL IF CONVERSION IS NOT POSSIBLE{12560
{{ZER{3,R_CCB{{{FORGET INTERIM CODE BLOCK{12561
{{MOV{11,-(XS){7,XR{{STACK RESULT{12562
{{LCW{7,XR{{{GET NEXT CODE WORD{12563
{{BRI{9,(XR){{{EXECUTE IT{12564
*
*      CONVERT TO NUMERIC
*
{SCV27{JSR{6,GTNUM{{{CONVERT TO NUMERIC{12568
{{PPM{6,EXFAL{{{FAIL IF UNCONVERTIBLE{12569
{SCV31{MOV{11,-(XS){7,XR{{STACK RESULT{12570
{{LCW{7,XR{{{GET NEXT CODE WORD{12571
{{BRI{9,(XR){{{EXECUTE IT{12572
{{EJC{{{{{12573
*
*      SECOND ARGUMENT NOT STRING OR NULL
*
{SCV29{ERB{1,074{26,CONVERT second argument is not a string{{{12599
*
*      COPY
*
{S_COP{ENT{{{{ENTRY POINT{12603
{{JSR{6,COPYB{{{COPY THE BLOCK{12604
{{PPM{6,EXITS{{{RETURN IF NO IDVAL FIELD{12605
{{BRN{6,EXSID{{{EXIT SETTING ID VALUE{12606
{{EJC{{{{{12607
*
*      COS
*
{S_COS{ENT{{{{ENTRY POINT{12612
{{MOV{7,XR{10,(XS)+{{GET ARGUMENT{12613
{{JSR{6,GTREA{{{CONVERT TO REAL{12614
{{ERR{1,303{26,COS argument not numeric{{{12615
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{12616
{{COS{{{{TAKE COSINE{12617
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{12618
{{ERB{1,322{26,COS argument is out of range{{{12619
{{EJC{{{{{12620
*
*      DATA
*
{S_DAT{ENT{{{{ENTRY POINT{12625
{{JSR{6,XSCNI{{{PREPARE TO SCAN ARGUMENT{12626
{{ERR{1,075{26,DATA argument is not a string{{{12627
{{ERR{1,076{26,DATA argument is null{{{12628
*
*      SCAN OUT DATATYPE NAME
*
{{MOV{8,WC{18,=CH_PP{{DELIMITER ONE = LEFT PAREN{12632
{{MOV{7,XL{8,WC{{DELIMITER TWO = LEFT PAREN{12633
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{12634
{{JSR{6,XSCAN{{{SCAN DATATYPE NAME{12635
{{BNZ{8,WA{6,SDAT1{{SKIP IF LEFT PAREN FOUND{12636
{{ERB{1,077{26,DATA argument is missing a left paren{{{12637
*
*      HERE AFTER SCANNING DATATYPE NAME
*
{SDAT1{MOV{8,WA{13,SCLEN(XR){{GET LENGTH{12642
{{BZE{8,WA{6,SDT1A{{AVOID FOLDING IF NULL STRING{12643
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{12644
{SDT1A{MOV{7,XL{7,XR{{SAVE NAME PTR{12645
{{MOV{8,WA{13,SCLEN(XR){{GET LENGTH{12649
{{CTB{8,WA{2,SCSI_{{COMPUTE SPACE NEEDED{12650
{{JSR{6,ALOST{{{REQUEST STATIC STORE FOR NAME{12651
{{MOV{11,-(XS){7,XR{{SAVE DATATYPE NAME{12652
{{MVW{{{{COPY NAME TO STATIC{12653
{{MOV{7,XR{9,(XS){{GET NAME PTR{12654
{{ZER{7,XL{{{SCRUB DUD REGISTER{12655
{{JSR{6,GTNVR{{{LOCATE VRBLK FOR DATATYPE NAME{12656
{{ERR{1,078{26,DATA argument has null datatype name{{{12657
{{MOV{3,DATDV{7,XR{{SAVE VRBLK POINTER FOR DATATYPE{12658
{{MOV{3,DATXS{7,XS{{STORE STARTING STACK VALUE{12659
{{ZER{8,WB{{{ZERO COUNT OF FIELD NAMES{12660
*
*      LOOP TO SCAN FIELD NAMES AND STACK VRBLK POINTERS
*
{SDAT2{MOV{8,WC{18,=CH_RP{{DELIMITER ONE = RIGHT PAREN{12664
{{MOV{7,XL{18,=CH_CM{{DELIMITER TWO = COMMA{12665
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{12666
{{JSR{6,XSCAN{{{SCAN NEXT FIELD NAME{12667
{{BNZ{8,WA{6,SDAT3{{JUMP IF DELIMITER FOUND{12668
{{ERB{1,079{26,DATA argument is missing a right paren{{{12669
*
*      HERE AFTER SCANNING OUT ONE FIELD NAME
*
{SDAT3{JSR{6,GTNVR{{{LOCATE VRBLK FOR FIELD NAME{12673
{{ERR{1,080{26,DATA argument has null field name{{{12674
{{MOV{11,-(XS){7,XR{{STACK VRBLK POINTER{12675
{{ICV{8,WB{{{INCREMENT COUNTER{12676
{{BEQ{8,WA{18,=NUM02{6,SDAT2{LOOP BACK IF STOPPED BY COMMA{12677
{{EJC{{{{{12678
*
*      DATA (CONTINUED)
*
*      NOW BUILD THE DFBLK
*
{{MOV{8,WA{18,=DFSI_{{SET SIZE OF DFBLK STANDARD FIELDS{12684
{{ADD{8,WA{8,WB{{ADD NUMBER OF FIELDS{12685
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{12686
{{MOV{8,WC{8,WB{{PRESERVE NO. OF FIELDS{12687
{{JSR{6,ALOST{{{ALLOCATE SPACE FOR DFBLK{12688
{{MOV{8,WB{8,WC{{GET NO OF FIELDS{12689
{{MOV{7,XT{3,DATXS{{POINT TO START OF STACK{12690
{{MOV{8,WC{9,(XT){{LOAD DATATYPE NAME{12691
{{MOV{9,(XT){7,XR{{SAVE DFBLK POINTER ON STACK{12692
{{MOV{10,(XR)+{22,=B_DFC{{STORE TYPE WORD{12693
{{MOV{10,(XR)+{8,WB{{STORE NUMBER OF FIELDS (FARGS){12694
{{MOV{10,(XR)+{8,WA{{STORE LENGTH (DFLEN){12695
{{SUB{8,WA{19,*PDDFS{{COMPUTE PDBLK LENGTH (FOR DFPDL){12696
{{MOV{10,(XR)+{8,WA{{STORE PDBLK LENGTH (DFPDL){12697
{{MOV{10,(XR)+{8,WC{{STORE DATATYPE NAME (DFNAM){12698
{{LCT{8,WC{8,WB{{COPY NUMBER OF FIELDS{12699
*
*      LOOP TO MOVE FIELD NAME VRBLK POINTERS TO DFBLK
*
{SDAT4{MOV{10,(XR)+{11,-(XT){{MOVE ONE FIELD NAME VRBLK POINTER{12703
{{BCT{8,WC{6,SDAT4{{LOOP TILL ALL MOVED{12704
*
*      NOW DEFINE THE DATATYPE FUNCTION
*
{{MOV{8,WC{8,WA{{COPY LENGTH OF PDBLK FOR LATER LOOP{12708
{{MOV{7,XR{3,DATDV{{POINT TO VRBLK{12709
{{MOV{7,XT{3,DATXS{{POINT BACK ON STACK{12710
{{MOV{7,XL{9,(XT){{LOAD DFBLK POINTER{12711
{{JSR{6,DFFNC{{{DEFINE FUNCTION{12712
{{EJC{{{{{12713
*
*      DATA (CONTINUED)
*
*      LOOP TO BUILD FFBLKS
*
*
*      NOTICE THAT THE FFBLKS ARE CONSTRUCTED IN REVERSE ORDER
*      SO THAT THE REQUIRED OFFSETS CAN BE OBTAINED FROM
*      SUCCESSIVE DECREMENTATION OF THE PDBLK LENGTH (IN WC).
*
{SDAT5{MOV{8,WA{19,*FFSI_{{SET LENGTH OF FFBLK{12724
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR FFBLK{12725
{{MOV{9,(XR){22,=B_FFC{{SET TYPE WORD{12726
{{MOV{13,FARGS(XR){18,=NUM01{{STORE FARGS (ALWAYS ONE){12727
{{MOV{7,XT{3,DATXS{{POINT BACK ON STACK{12728
{{MOV{13,FFDFP(XR){9,(XT){{COPY DFBLK PTR TO FFBLK{12729
{{DCA{8,WC{{{DECREMENT OLD DFPDL TO GET NEXT OFS{12730
{{MOV{13,FFOFS(XR){8,WC{{SET OFFSET TO THIS FIELD{12731
{{ZER{13,FFNXT(XR){{{TENTATIVELY SET ZERO FORWARD PTR{12732
{{MOV{7,XL{7,XR{{COPY FFBLK POINTER FOR DFFNC{12733
{{MOV{7,XR{9,(XS){{LOAD VRBLK POINTER FOR FIELD{12734
{{MOV{7,XR{13,VRFNC(XR){{LOAD CURRENT FUNCTION POINTER{12735
{{BNE{9,(XR){22,=B_FFC{6,SDAT6{SKIP IF NOT CURRENTLY A FIELD FUNC{12736
*
*      HERE WE MUST CHAIN AN OLD FFBLK PTR TO PRESERVE IT IN THE
*      CASE OF MULTIPLE FIELD FUNCTIONS WITH THE SAME NAME
*
{{MOV{13,FFNXT(XL){7,XR{{LINK NEW FFBLK TO PREVIOUS CHAIN{12741
*
*      MERGE HERE TO DEFINE FIELD FUNCTION
*
{SDAT6{MOV{7,XR{10,(XS)+{{LOAD VRBLK POINTER{12745
{{JSR{6,DFFNC{{{DEFINE FIELD FUNCTION{12746
{{BNE{7,XS{3,DATXS{6,SDAT5{LOOP BACK TILL ALL DONE{12747
{{ICA{7,XS{{{POP DFBLK POINTER{12748
{{BRN{6,EXNUL{{{RETURN WITH NULL RESULT{12749
{{EJC{{{{{12750
*
*      DATATYPE
*
{S_DTP{ENT{{{{ENTRY POINT{12754
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{12755
{{JSR{6,DTYPE{{{GET DATATYPE{12756
{{MOV{11,-(XS){7,XR{{STACK RESULT{12757
{{LCW{7,XR{{{GET NEXT CODE WORD{12758
{{BRI{9,(XR){{{EXECUTE IT{12759
{{EJC{{{{{12760
*
*      DATE
*
{S_DTE{ENT{{{{ENTRY POINT{12764
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{12765
{{JSR{6,GTINT{{{CONVERT TO AN INTEGER{12766
{{ERR{1,330{26,DATE argument is not integer{{{12767
{{JSR{6,SYSDT{{{CALL SYSTEM DATE ROUTINE{12768
{{MOV{8,WA{13,NUM01(XL){{LOAD LENGTH FOR SBSTR{12769
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF LENGTH IS ZERO{12770
{{ZER{8,WB{{{SET ZERO OFFSET{12771
{{JSR{6,SBSTR{{{USE SBSTR TO BUILD SCBLK{12772
{{MOV{11,-(XS){7,XR{{STACK RESULT{12773
{{LCW{7,XR{{{GET NEXT CODE WORD{12774
{{BRI{9,(XR){{{EXECUTE IT{12775
{{EJC{{{{{12776
*
*      DEFINE
*
{S_DEF{ENT{{{{ENTRY POINT{12780
{{MOV{7,XR{10,(XS)+{{LOAD SECOND ARGUMENT{12781
{{ZER{3,DEFLB{{{ZERO LABEL POINTER IN CASE NULL{12782
{{BEQ{7,XR{21,=NULLS{6,SDF01{JUMP IF NULL SECOND ARGUMENT{12783
{{JSR{6,GTNVR{{{ELSE FIND VRBLK FOR LABEL{12784
{{PPM{6,SDF12{{{JUMP IF NOT A VARIABLE NAME{12785
{{MOV{3,DEFLB{7,XR{{ELSE SET SPECIFIED ENTRY{12786
*
*      SCAN FUNCTION NAME
*
{SDF01{JSR{6,XSCNI{{{PREPARE TO SCAN FIRST ARGUMENT{12790
{{ERR{1,081{26,DEFINE first argument is not a string{{{12791
{{ERR{1,082{26,DEFINE first argument is null{{{12792
{{MOV{8,WC{18,=CH_PP{{DELIMITER ONE = LEFT PAREN{12793
{{MOV{7,XL{8,WC{{DELIMITER TWO = LEFT PAREN{12794
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{12795
{{JSR{6,XSCAN{{{SCAN OUT FUNCTION NAME{12796
{{BNZ{8,WA{6,SDF02{{JUMP IF LEFT PAREN FOUND{12797
{{ERB{1,083{26,DEFINE first argument is missing a left paren{{{12798
*
*      HERE AFTER SCANNING OUT FUNCTION NAME
*
{SDF02{JSR{6,GTNVR{{{GET VARIABLE NAME{12802
{{ERR{1,084{26,DEFINE first argument has null function name{{{12803
{{MOV{3,DEFVR{7,XR{{SAVE VRBLK POINTER FOR FUNCTION NAM{12804
{{ZER{8,WB{{{ZERO COUNT OF ARGUMENTS{12805
{{MOV{3,DEFXS{7,XS{{SAVE INITIAL STACK POINTER{12806
{{BNZ{3,DEFLB{6,SDF03{{JUMP IF SECOND ARGUMENT GIVEN{12807
{{MOV{3,DEFLB{7,XR{{ELSE DEFAULT IS FUNCTION NAME{12808
*
*      LOOP TO SCAN ARGUMENT NAMES AND STACK VRBLK POINTERS
*
{SDF03{MOV{8,WC{18,=CH_RP{{DELIMITER ONE = RIGHT PAREN{12812
{{MOV{7,XL{18,=CH_CM{{DELIMITER TWO = COMMA{12813
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{12814
{{JSR{6,XSCAN{{{SCAN OUT NEXT ARGUMENT NAME{12815
{{BNZ{8,WA{6,SDF04{{SKIP IF DELIMITER FOUND{12816
{{ERB{1,085{26,Null arg name or missing ) in DEFINE first arg.{{{12817
{{EJC{{{{{12818
*
*      DEFINE (CONTINUED)
*
*      HERE AFTER SCANNING AN ARGUMENT NAME
*
{SDF04{BNE{7,XR{21,=NULLS{6,SDF05{SKIP IF NON-NULL{12824
{{BZE{8,WB{6,SDF06{{IGNORE NULL IF CASE OF NO ARGUMENTS{12825
*
*      HERE AFTER DEALING WITH THE CASE OF NO ARGUMENTS
*
{SDF05{JSR{6,GTNVR{{{GET VRBLK POINTER{12829
{{PPM{6,SDF03{{{LOOP BACK TO IGNORE NULL NAME{12830
{{MOV{11,-(XS){7,XR{{STACK ARGUMENT VRBLK POINTER{12831
{{ICV{8,WB{{{INCREMENT COUNTER{12832
{{BEQ{8,WA{18,=NUM02{6,SDF03{LOOP BACK IF STOPPED BY A COMMA{12833
*
*      HERE AFTER SCANNING OUT FUNCTION ARGUMENT NAMES
*
{SDF06{MOV{3,DEFNA{8,WB{{SAVE NUMBER OF ARGUMENTS{12837
{{ZER{8,WB{{{ZERO COUNT OF LOCALS{12838
*
*      LOOP TO SCAN LOCAL NAMES AND STACK VRBLK POINTERS
*
{SDF07{MOV{8,WC{18,=CH_CM{{SET DELIMITER ONE = COMMA{12842
{{MOV{7,XL{8,WC{{SET DELIMITER TWO = COMMA{12843
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{12844
{{JSR{6,XSCAN{{{SCAN OUT NEXT LOCAL NAME{12845
{{BNE{7,XR{21,=NULLS{6,SDF08{SKIP IF NON-NULL{12846
{{BZE{8,WA{6,SDF09{{EXIT SCAN IF END OF STRING{12847
*
*      HERE AFTER SCANNING OUT A LOCAL NAME
*
{SDF08{JSR{6,GTNVR{{{GET VRBLK POINTER{12851
{{PPM{6,SDF07{{{LOOP BACK TO IGNORE NULL NAME{12852
{{ICV{8,WB{{{IF OK, INCREMENT COUNT{12853
{{MOV{11,-(XS){7,XR{{STACK VRBLK POINTER{12854
{{BNZ{8,WA{6,SDF07{{LOOP BACK IF STOPPED BY A COMMA{12855
{{EJC{{{{{12856
*
*      DEFINE (CONTINUED)
*
*      HERE AFTER SCANNING LOCALS, BUILD PFBLK
*
{SDF09{MOV{8,WA{8,WB{{COPY COUNT OF LOCALS{12862
{{ADD{8,WA{3,DEFNA{{ADD NUMBER OF ARGUMENTS{12863
{{MOV{8,WC{8,WA{{SET SUM ARGS+LOCALS AS LOOP COUNT{12864
{{ADD{8,WA{18,=PFSI_{{ADD SPACE FOR STANDARD FIELDS{12865
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{12866
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR PFBLK{12867
{{MOV{7,XL{7,XR{{SAVE POINTER TO PFBLK{12868
{{MOV{10,(XR)+{22,=B_PFC{{STORE FIRST WORD{12869
{{MOV{10,(XR)+{3,DEFNA{{STORE NUMBER OF ARGUMENTS{12870
{{MOV{10,(XR)+{8,WA{{STORE LENGTH (PFLEN){12871
{{MOV{10,(XR)+{3,DEFVR{{STORE VRBLK PTR FOR FUNCTION NAME{12872
{{MOV{10,(XR)+{8,WB{{STORE NUMBER OF LOCALS{12873
{{ZER{10,(XR)+{{{DEAL WITH LABEL LATER{12874
{{ZER{10,(XR)+{{{ZERO PFCTR{12875
{{ZER{10,(XR)+{{{ZERO PFRTR{12876
{{BZE{8,WC{6,SDF11{{SKIP IF NO ARGS OR LOCALS{12877
{{MOV{8,WA{7,XL{{KEEP PFBLK POINTER{12878
{{MOV{7,XT{3,DEFXS{{POINT BEFORE ARGUMENTS{12879
{{LCT{8,WC{8,WC{{GET COUNT OF ARGS+LOCALS FOR LOOP{12880
*
*      LOOP TO MOVE LOCALS AND ARGS TO PFBLK
*
{SDF10{MOV{10,(XR)+{11,-(XT){{STORE ONE ENTRY AND BUMP POINTERS{12884
{{BCT{8,WC{6,SDF10{{LOOP TILL ALL STORED{12885
{{MOV{7,XL{8,WA{{RECOVER PFBLK POINTER{12886
{{EJC{{{{{12887
*
*      DEFINE (CONTINUED)
*
*      NOW DEAL WITH LABEL
*
{SDF11{MOV{7,XS{3,DEFXS{{POP STACK{12893
{{MOV{13,PFCOD(XL){3,DEFLB{{STORE LABEL VRBLK IN PFBLK{12894
{{MOV{7,XR{3,DEFVR{{POINT BACK TO VRBLK FOR FUNCTION{12895
{{JSR{6,DFFNC{{{DEFINE FUNCTION{12896
{{BRN{6,EXNUL{{{AND EXIT RETURNING NULL{12897
*
*      HERE FOR ERRONEOUS LABEL
*
{SDF12{ERB{1,086{26,DEFINE function entry point is not defined label{{{12901
{{EJC{{{{{12902
*
*      DETACH
*
{S_DET{ENT{{{{ENTRY POINT{12906
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{12907
{{JSR{6,GTVAR{{{LOCATE VARIABLE{12908
{{ERR{1,087{26,DETACH argument is not appropriate name{{{12909
{{JSR{6,DTACH{{{DETACH I/O ASSOCIATION FROM NAME{12910
{{BRN{6,EXNUL{{{RETURN NULL RESULT{12911
{{EJC{{{{{12912
*
*      DIFFER
*
{S_DIF{ENT{{{{ENTRY POINT{12916
{{MOV{7,XR{10,(XS)+{{LOAD SECOND ARGUMENT{12917
{{MOV{7,XL{10,(XS)+{{LOAD FIRST ARGUMENT{12918
{{JSR{6,IDENT{{{CALL IDENT COMPARISON ROUTINE{12919
{{PPM{6,EXFAL{{{FAIL IF IDENT{12920
{{BRN{6,EXNUL{{{RETURN NULL IF DIFFER{12921
{{EJC{{{{{12922
*
*      DUMP
*
{S_DMP{ENT{{{{ENTRY POINT{12926
{{JSR{6,GTSMI{{{LOAD DUMP ARG AS SMALL INTEGER{12927
{{ERR{1,088{26,DUMP argument is not integer{{{12928
{{ERR{1,089{26,DUMP argument is negative or too large{{{12929
{{JSR{6,DUMPR{{{ELSE CALL DUMP ROUTINE{12930
{{BRN{6,EXNUL{{{AND RETURN NULL AS RESULT{12931
{{EJC{{{{{12932
*
*      DUPL
*
{S_DUP{ENT{{{{ENTRY POINT{12936
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT AS SMALL INTEGR{12937
{{ERR{1,090{26,DUPL second argument is not integer{{{12938
{{PPM{6,SDUP7{{{JUMP IF NEGATIVE OR TOO BIG{12939
{{MOV{8,WB{7,XR{{SAVE DUPLICATION FACTOR{12940
{{JSR{6,GTSTG{{{GET FIRST ARG AS STRING{12941
{{PPM{6,SDUP4{{{JUMP IF NOT A STRING{12942
*
*      HERE FOR CASE OF DUPLICATION OF A STRING
*
{{MTI{8,WA{{{ACQUIRE LENGTH AS INTEGER{12946
{{STI{3,DUPSI{{{SAVE FOR THE MOMENT{12947
{{MTI{8,WB{{{GET DUPLICATION FACTOR AS INTEGER{12948
{{MLI{3,DUPSI{{{FORM PRODUCT{12949
{{IOV{6,SDUP3{{{JUMP IF OVERFLOW{12950
{{IEQ{6,EXNUL{{{RETURN NULL IF RESULT LENGTH = 0{12951
{{MFI{8,WA{6,SDUP3{{GET AS ADDR INTEGER, CHECK OVFLO{12952
*
*      MERGE HERE WITH RESULT LENGTH IN WA
*
{SDUP1{MOV{7,XL{7,XR{{SAVE STRING POINTER{12956
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR STRING{12957
{{MOV{11,-(XS){7,XR{{SAVE AS RESULT POINTER{12958
{{MOV{8,WC{7,XL{{SAVE POINTER TO ARGUMENT STRING{12959
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{12960
{{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{12961
*
*      LOOP THROUGH DUPLICATIONS
*
{SDUP2{MOV{7,XL{8,WC{{POINT BACK TO ARGUMENT STRING{12965
{{MOV{8,WA{13,SCLEN(XL){{GET NUMBER OF CHARACTERS{12966
{{PLC{7,XL{{{POINT TO CHARS IN ARGUMENT STRING{12967
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{12968
{{BCT{8,WB{6,SDUP2{{LOOP TILL ALL DUPLICATIONS DONE{12969
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{12970
{{LCW{7,XR{{{GET NEXT CODE WORD{12971
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12972
{{EJC{{{{{12973
*
*      DUPL (CONTINUED)
*
*      HERE IF TOO LARGE, SET MAX LENGTH AND LET ALOCS CATCH IT
*
{SDUP3{MOV{8,WA{3,DNAME{{SET IMPOSSIBLE LENGTH FOR ALOCS{12979
{{BRN{6,SDUP1{{{MERGE BACK{12980
*
*      HERE IF NOT A STRING
*
{SDUP4{JSR{6,GTPAT{{{CONVERT ARGUMENT TO PATTERN{12984
{{ERR{1,091{26,DUPL first argument is not a string or pattern{{{12985
*
*      HERE TO DUPLICATE A PATTERN ARGUMENT
*
{{MOV{11,-(XS){7,XR{{STORE PATTERN ON STACK{12989
{{MOV{7,XR{21,=NDNTH{{START OFF WITH NULL PATTERN{12990
{{BZE{8,WB{6,SDUP6{{NULL PATTERN IS RESULT IF DUPFAC=0{12991
{{MOV{11,-(XS){8,WB{{PRESERVE LOOP COUNT{12992
*
*      LOOP TO DUPLICATE BY SUCCESSIVE CONCATENATION
*
{SDUP5{MOV{7,XL{7,XR{{COPY CURRENT VALUE AS RIGHT ARGUMNT{12996
{{MOV{7,XR{13,NUM01(XS){{GET A NEW COPY OF LEFT{12997
{{JSR{6,PCONC{{{CONCATENATE{12998
{{DCV{9,(XS){{{COUNT DOWN{12999
{{BNZ{9,(XS){6,SDUP5{{LOOP{13000
{{ICA{7,XS{{{POP LOOP COUNT{13001
*
*      HERE TO EXIT AFTER CONSTRUCTING PATTERN
*
{SDUP6{MOV{9,(XS){7,XR{{STORE RESULT ON STACK{13005
{{LCW{7,XR{{{GET NEXT CODE WORD{13006
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{13007
*
*      FAIL IF SECOND ARG IS OUT OF RANGE
*
{SDUP7{ICA{7,XS{{{POP FIRST ARGUMENT{13011
{{BRN{6,EXFAL{{{FAIL{13012
{{EJC{{{{{13013
*
*      EJECT
*
{S_EJC{ENT{{{{ENTRY POINT{13017
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{13018
{{ERR{1,092{26,EJECT argument is not a suitable name{{{13019
{{PPM{6,SEJC1{{{NULL ARGUMENT{13020
{{ERR{1,093{26,EJECT file does not exist{{{13021
{{JSR{6,SYSEF{{{CALL EJECT FILE FUNCTION{13022
{{ERR{1,093{26,EJECT file does not exist{{{13023
{{ERR{1,094{26,EJECT file does not permit page eject{{{13024
{{ERR{1,095{26,EJECT caused non-recoverable output error{{{13025
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{13026
*
*      HERE TO EJECT STANDARD OUTPUT FILE
*
{SEJC1{JSR{6,SYSEP{{{CALL ROUTINE TO EJECT PRINTER{13030
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT{13031
{{EJC{{{{{13032
*
*      ENDFILE
*
{S_ENF{ENT{{{{ENTRY POINT{13036
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{13037
{{ERR{1,096{26,ENDFILE argument is not a suitable name{{{13038
{{ERR{1,097{26,ENDFILE argument is null{{{13039
{{ERR{1,098{26,ENDFILE file does not exist{{{13040
{{JSR{6,SYSEN{{{CALL ENDFILE ROUTINE{13041
{{ERR{1,098{26,ENDFILE file does not exist{{{13042
{{ERR{1,099{26,ENDFILE file does not permit endfile{{{13043
{{ERR{1,100{26,ENDFILE caused non-recoverable output error{{{13044
{{MOV{8,WB{7,XL{{REMEMBER VRBLK PTR FROM IOFCB CALL{13045
{{MOV{7,XR{7,XL{{COPY POINTER{13046
*
*      LOOP TO FIND TRTRF BLOCK
*
{SENF1{MOV{7,XL{7,XR{{REMEMBER PREVIOUS ENTRY{13050
{{MOV{7,XR{13,TRVAL(XR){{CHAIN ALONG{13051
{{BNE{9,(XR){22,=B_TRT{6,EXNUL{SKIP OUT IF CHAIN END{13052
{{BNE{13,TRTYP(XR){18,=TRTFC{6,SENF1{LOOP IF NOT FOUND{13053
{{MOV{13,TRVAL(XL){13,TRVAL(XR){{REMOVE TRTRF{13054
{{MOV{3,ENFCH{13,TRTRF(XR){{POINT TO HEAD OF IOCHN{13055
{{MOV{8,WC{13,TRFPT(XR){{POINT TO FCBLK{13056
{{MOV{7,XR{8,WB{{FILEARG1 VRBLK FROM IOFCB{13057
{{JSR{6,SETVR{{{RESET IT{13058
{{MOV{7,XL{20,=R_FCB{{PTR TO HEAD OF FCBLK CHAIN{13059
{{SUB{7,XL{19,*NUM02{{ADJUST READY TO ENTER LOOP{13060
*
*      FIND FCBLK
*
{SENF2{MOV{7,XR{7,XL{{COPY PTR{13064
{{MOV{7,XL{13,NUM02(XL){{GET NEXT LINK{13065
{{BZE{7,XL{6,SENF4{{STOP IF CHAIN END{13066
{{BEQ{13,NUM03(XL){8,WC{6,SENF3{JUMP IF FCBLK FOUND{13067
{{BRN{6,SENF2{{{LOOP{13068
*
*      REMOVE FCBLK
*
{SENF3{MOV{13,NUM02(XR){13,NUM02(XL){{DELETE FCBLK FROM CHAIN{13072
*
*      LOOP WHICH DETACHES ALL VBLS ON IOCHN CHAIN
*
{SENF4{MOV{7,XL{3,ENFCH{{GET CHAIN HEAD{13076
{{BZE{7,XL{6,EXNUL{{FINISHED IF CHAIN END{13077
{{MOV{3,ENFCH{13,TRTRF(XL){{CHAIN ALONG{13078
{{MOV{8,WA{13,IONMO(XL){{NAME OFFSET{13079
{{MOV{7,XL{13,IONMB(XL){{NAME BASE{13080
{{JSR{6,DTACH{{{DETACH NAME{13081
{{BRN{6,SENF4{{{LOOP TILL DONE{13082
{{EJC{{{{{13083
*
*      EQ
*
{S_EQF{ENT{{{{ENTRY POINT{13087
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{13088
{{ERR{1,101{26,EQ first argument is not numeric{{{13089
{{ERR{1,102{26,EQ second argument is not numeric{{{13090
{{PPM{6,EXFAL{{{FAIL IF LT{13091
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{13092
{{PPM{6,EXFAL{{{FAIL IF GT{13093
{{EJC{{{{{13094
*
*      EVAL
*
{S_EVL{ENT{{{{ENTRY POINT{13098
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{13099
{{LCW{8,WC{{{LOAD NEXT CODE WORD{13105
{{BNE{8,WC{21,=OFNE_{6,SEVL1{JUMP IF CALLED BY VALUE{13106
{{SCP{7,XL{{{COPY CODE POINTER{13107
{{MOV{8,WA{9,(XL){{GET NEXT CODE WORD{13108
{{BNE{8,WA{21,=ORNM_{6,SEVL2{BY NAME UNLESS EXPRESSION{13109
{{BNZ{13,NUM01(XS){6,SEVL2{{JUMP IF BY NAME{13110
*
*      HERE IF CALLED BY VALUE
*
{SEVL1{ZER{8,WB{{{SET FLAG FOR BY VALUE{13114
{{MOV{11,-(XS){8,WC{{SAVE CODE WORD{13116
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{13117
{{ERR{1,103{26,EVAL argument is not expression{{{13118
{{ZER{3,R_CCB{{{FORGET INTERIM CODE BLOCK{13119
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{13120
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY VALUE{13124
{{PPM{6,EXFAL{{{FAIL IF EVALUATION FAILS{13125
{{MOV{7,XL{7,XR{{COPY RESULT{13126
{{MOV{7,XR{9,(XS){{RELOAD NEXT CODE WORD{13127
{{MOV{9,(XS){7,XL{{STACK RESULT{13128
{{BRI{9,(XR){{{JUMP TO EXECUTE NEXT CODE WORD{13129
*
*      HERE IF CALLED BY NAME
*
{SEVL2{MOV{8,WB{18,=NUM01{{SET FLAG FOR BY NAME{13133
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{13135
{{ERR{1,103{26,EVAL argument is not expression{{{13136
{{ZER{3,R_CCB{{{FORGET INTERIM CODE BLOCK{13137
{{MOV{8,WB{18,=NUM01{{SET FLAG FOR BY NAME{13138
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY NAME{13140
{{PPM{6,EXFAL{{{FAIL IF EVALUATION FAILS{13141
{{BRN{6,EXNAM{{{EXIT WITH NAME{13142
{{EJC{{{{{13145
*
*      EXIT
*
{S_EXT{ENT{{{{ENTRY POINT{13149
{{ZER{8,WB{{{CLEAR AMOUNT OF STATIC SHIFT{13150
{{ZER{3,R_CCB{{{FORGET INTERIM CODE BLOCK{13151
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{13153
{{JSR{6,GBCOL{{{COMPACT MEMORY BY COLLECTING{13154
{{MOV{3,DNAMS{7,XR{{RECORD NEW SEDIMENT SIZE{13155
{{JSR{6,GTSTG{{{{13159
{{ERR{1,288{26,EXIT second argument is not a string{{{13160
{{MOV{7,XL{7,XR{{COPY SECOND ARG STRING POINTER{13161
{{JSR{6,GTSTG{{{CONVERT ARG TO STRING{13162
{{ERR{1,104{26,EXIT first argument is not suitable integer or string{{{13163
{{MOV{11,-(XS){7,XL{{SAVE SECOND ARGUMENT{13164
{{MOV{7,XL{7,XR{{COPY FIRST ARG STRING PTR{13165
{{JSR{6,GTINT{{{CHECK IT IS INTEGER{13166
{{PPM{6,SEXT1{{{SKIP IF UNCONVERTIBLE{13167
{{ZER{7,XL{{{NOTE IT IS INTEGER{13168
{{LDI{13,ICVAL(XR){{{GET INTEGER ARG{13169
*
*      MERGE TO CALL OSINT EXIT ROUTINE
*
{SEXT1{MOV{8,WB{3,R_FCB{{GET FCBLK CHAIN HEADER{13173
{{MOV{7,XR{21,=HEADV{{POINT TO V.V STRING{13174
{{MOV{8,WA{10,(XS)+{{PROVIDE SECOND ARGUMENT SCBLK{13175
{{JSR{6,SYSXI{{{CALL EXTERNAL ROUTINE{13176
{{ERR{1,105{26,EXIT action not available in this implementation{{{13177
{{ERR{1,106{26,EXIT action caused irrecoverable error{{{13178
{{IEQ{6,EXNUL{{{RETURN IF ARGUMENT 0{13179
{{IGT{6,SEXT2{{{SKIP IF POSITIVE{13180
{{NGI{{{{MAKE POSITIVE{13181
*
*      CHECK FOR OPTION RESPECIFICATION
*
*      SYSXI RETURNS 0 IN WA WHEN A FILE HAS BEEN RESUMED,
*      1 WHEN THIS IS A CONTINUATION OF AN EXIT(4) OR EXIT(-4)
*      ACTION.
*
{SEXT2{MFI{8,WC{{{GET VALUE IN WORK REG{13189
{{ADD{8,WA{8,WC{{PREPARE TO TEST FOR CONTINUE{13190
{{BEQ{8,WA{18,=NUM05{6,SEXT5{CONTINUED EXECUTION IF 4 PLUS 1{13191
{{ZER{3,GBCNT{{{RESUMING EXECUTION SO RESET{13192
{{BGE{8,WC{18,=NUM03{6,SEXT3{SKIP IF WAS 3 OR 4{13193
{{MOV{11,-(XS){8,WC{{SAVE VALUE{13194
{{ZER{8,WC{{{SET TO READ OPTIONS{13195
{{JSR{6,PRPAR{{{READ SYSPP OPTIONS{13196
{{MOV{8,WC{10,(XS)+{{RESTORE VALUE{13197
*
*      DEAL WITH HEADER OPTION (FIDDLED BY PRPAR)
*
{SEXT3{MNZ{3,HEADP{{{ASSUME NO HEADERS{13201
{{BNE{8,WC{18,=NUM01{6,SEXT4{SKIP IF NOT 1{13202
{{ZER{3,HEADP{{{REQUEST HEADER PRINTING{13203
*
*      ALMOST READY TO RESUME RUNNING
*
{SEXT4{JSR{6,SYSTM{{{GET EXECUTION TIME START (SGD11){13207
{{STI{3,TIMSX{{{SAVE AS INITIAL TIME{13208
{{LDI{3,KVSTC{{{RESET TO ENSURE ...{13209
{{STI{3,KVSTL{{{... CORRECT EXECUTION STATS{13210
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{13211
{{BRN{6,EXNUL{{{RESUME EXECUTION{13212
*
*      HERE AFTER EXIT(4) OR EXIT(-4) -- CREATE SAVE FILE
*      OR LOAD MODULE AND CONTINUE EXECUTION.
*
*      RETURN INTEGER 1 TO SIGNAL THE CONTINUATION OF THE
*      ORIGINAL EXECUTION.
*
{SEXT5{MOV{7,XR{21,=INTON{{INTEGER ONE{13220
{{BRN{6,EXIXR{{{RETURN AS RESULT{13221
{{EJC{{{{{13223
*
*      EXP
*
{S_EXP{ENT{{{{ENTRY POINT{13228
{{MOV{7,XR{10,(XS)+{{GET ARGUMENT{13229
{{JSR{6,GTREA{{{CONVERT TO REAL{13230
{{ERR{1,304{26,EXP argument not numeric{{{13231
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{13232
{{ETX{{{{TAKE EXPONENTIAL{13233
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{13234
{{ERB{1,305{26,EXP produced real overflow{{{13235
{{EJC{{{{{13236
*
*      FIELD
*
{S_FLD{ENT{{{{ENTRY POINT{13241
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT (FIELD NUMBER){13242
{{ERR{1,107{26,FIELD second argument is not integer{{{13243
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE{13244
{{MOV{8,WB{7,XR{{ELSE SAVE INTEGER VALUE{13245
{{MOV{7,XR{10,(XS)+{{LOAD FIRST ARGUMENT{13246
{{JSR{6,GTNVR{{{POINT TO VRBLK{13247
{{PPM{6,SFLD1{{{JUMP (ERROR) IF NOT VARIABLE NAME{13248
{{MOV{7,XR{13,VRFNC(XR){{ELSE POINT TO FUNCTION BLOCK{13249
{{BNE{9,(XR){22,=B_DFC{6,SFLD1{ERROR IF NOT DATATYPE FUNCTION{13250
*
*      HERE IF FIRST ARGUMENT IS A DATATYPE FUNCTION NAME
*
{{BZE{8,WB{6,EXFAL{{FAIL IF ARGUMENT NUMBER IS ZERO{13254
{{BGT{8,WB{13,FARGS(XR){6,EXFAL{FAIL IF TOO LARGE{13255
{{WTB{8,WB{{{ELSE CONVERT TO BYTE OFFSET{13256
{{ADD{7,XR{8,WB{{POINT TO FIELD NAME{13257
{{MOV{7,XR{13,DFFLB(XR){{LOAD VRBLK POINTER{13258
{{BRN{6,EXVNM{{{EXIT TO BUILD NMBLK{13259
*
*      HERE FOR BAD FIRST ARGUMENT
*
{SFLD1{ERB{1,108{26,FIELD first argument is not datatype name{{{13263
{{EJC{{{{{13264
*
*      FENCE
*
{S_FNC{ENT{{{{ENTRY POINT{13268
{{MOV{8,WB{22,=P_FNC{{SET PCODE FOR P_FNC{13269
{{ZER{7,XR{{{P0BLK{13270
{{JSR{6,PBILD{{{BUILD P_FNC NODE{13271
{{MOV{7,XL{7,XR{{SAVE POINTER TO IT{13272
{{MOV{7,XR{10,(XS)+{{GET ARGUMENT{13273
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{13274
{{ERR{1,259{26,FENCE argument is not pattern{{{13275
{{JSR{6,PCONC{{{CONCATENATE TO P_FNC NODE{13276
{{MOV{7,XL{7,XR{{SAVE PTR TO CONCATENATED PATTERN{13277
{{MOV{8,WB{22,=P_FNA{{SET FOR P_FNA PCODE{13278
{{ZER{7,XR{{{P0BLK{13279
{{JSR{6,PBILD{{{CONSTRUCT P_FNA NODE{13280
{{MOV{13,PTHEN(XR){7,XL{{SET PATTERN AS PTHEN{13281
{{MOV{11,-(XS){7,XR{{SET AS RESULT{13282
{{LCW{7,XR{{{GET NEXT CODE WORD{13283
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{13284
{{EJC{{{{{13285
*
*      GE
*
{S_GEF{ENT{{{{ENTRY POINT{13289
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{13290
{{ERR{1,109{26,GE first argument is not numeric{{{13291
{{ERR{1,110{26,GE second argument is not numeric{{{13292
{{PPM{6,EXFAL{{{FAIL IF LT{13293
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{13294
{{PPM{6,EXNUL{{{RETURN NULL IF GT{13295
{{EJC{{{{{13296
*
*      GT
*
{S_GTF{ENT{{{{ENTRY POINT{13300
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{13301
{{ERR{1,111{26,GT first argument is not numeric{{{13302
{{ERR{1,112{26,GT second argument is not numeric{{{13303
{{PPM{6,EXFAL{{{FAIL IF LT{13304
{{PPM{6,EXFAL{{{FAIL IF EQ{13305
{{PPM{6,EXNUL{{{RETURN NULL IF GT{13306
{{EJC{{{{{13307
*
*      HOST
*
{S_HST{ENT{{{{ENTRY POINT{13311
{{MOV{8,WC{10,(XS)+{{GET FIFTH ARG{13312
{{MOV{8,WB{10,(XS)+{{GET FOURTH ARG{13313
{{MOV{7,XR{10,(XS)+{{GET THIRD ARG{13314
{{MOV{7,XL{10,(XS)+{{GET SECOND ARG{13315
{{MOV{8,WA{10,(XS)+{{GET FIRST ARG{13316
{{JSR{6,SYSHS{{{ENTER SYSHS ROUTINE{13317
{{ERR{1,254{26,Erroneous argument for HOST{{{13318
{{ERR{1,255{26,Error during execution of HOST{{{13319
{{PPM{6,SHST1{{{STORE HOST STRING{13320
{{PPM{6,EXNUL{{{RETURN NULL RESULT{13321
{{PPM{6,EXIXR{{{RETURN XR{13322
{{PPM{6,EXFAL{{{FAIL RETURN{13323
{{PPM{6,SHST3{{{STORE ACTUAL STRING{13324
{{PPM{6,SHST4{{{RETURN COPY OF XR{13325
*
*      RETURN HOST STRING
*
{SHST1{BZE{7,XL{6,EXNUL{{NULL STRING IF SYSHS UNCOOPERATIVE{13329
{{MOV{8,WA{13,SCLEN(XL){{LENGTH{13330
{{ZER{8,WB{{{ZERO OFFSET{13331
*
*      COPY STRING AND RETURN
*
{SHST2{JSR{6,SBSTR{{{BUILD COPY OF STRING{13335
{{MOV{11,-(XS){7,XR{{STACK THE RESULT{13336
{{LCW{7,XR{{{LOAD NEXT CODE WORD{13337
{{BRI{9,(XR){{{EXECUTE IT{13338
*
*      RETURN ACTUAL STRING POINTED TO BY XL
*
{SHST3{ZER{8,WB{{{TREAT XL LIKE AN SCBLK PTR{13342
{{SUB{8,WB{18,=CFP_F{{BY CREATING A NEGATIVE OFFSET{13343
{{BRN{6,SHST2{{{JOIN TO COPY STRING{13344
*
*      RETURN COPY OF BLOCK POINTED TO BY XR
*
{SHST4{MOV{11,-(XS){7,XR{{STACK RESULTS{13348
{{JSR{6,COPYB{{{MAKE COPY OF BLOCK{13349
{{PPM{6,EXITS{{{IF NOT AN AGGREGATE STRUCTURE{13350
{{BRN{6,EXSID{{{SET CURRENT ID VALUE OTHERWISE{13351
{{EJC{{{{{13352
*
*      IDENT
*
{S_IDN{ENT{{{{ENTRY POINT{13356
{{MOV{7,XR{10,(XS)+{{LOAD SECOND ARGUMENT{13357
{{MOV{7,XL{10,(XS)+{{LOAD FIRST ARGUMENT{13358
{{JSR{6,IDENT{{{CALL IDENT COMPARISON ROUTINE{13359
{{PPM{6,EXNUL{{{RETURN NULL IF IDENT{13360
{{BRN{6,EXFAL{{{FAIL IF DIFFER{13361
{{EJC{{{{{13362
*
*      INPUT
*
{S_INP{ENT{{{{ENTRY POINT{13366
{{ZER{8,WB{{{INPUT FLAG{13367
{{JSR{6,IOPUT{{{CALL INPUT/OUTPUT ASSOC. ROUTINE{13368
{{ERR{1,113{26,INPUT third argument is not a string{{{13369
{{ERR{1,114{26,Inappropriate second argument for INPUT{{{13370
{{ERR{1,115{26,Inappropriate first argument for INPUT{{{13371
{{ERR{1,116{26,Inappropriate file specification for INPUT{{{13372
{{PPM{6,EXFAL{{{FAIL IF FILE DOES NOT EXIST{13373
{{ERR{1,117{26,INPUT file cannot be read{{{13374
{{ERR{1,289{26,INPUT channel currently in use{{{13375
{{BRN{6,EXNUL{{{RETURN NULL STRING{13376
{{EJC{{{{{13377
*
*      INTEGER
*
{S_INT{ENT{{{{ENTRY POINT{13410
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{13411
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{13412
{{PPM{6,EXFAL{{{FAIL IF NON-NUMERIC{13413
{{BEQ{8,WA{22,=B_ICL{6,EXNUL{RETURN NULL IF INTEGER{13414
{{BRN{6,EXFAL{{{FAIL IF REAL{13415
{{EJC{{{{{13416
*
*      ITEM
*
*      ITEM DOES NOT PERMIT THE DIRECT (FAST) CALL SO THAT
*      WA CONTAINS THE ACTUAL NUMBER OF ARGUMENTS PASSED.
*
{S_ITM{ENT{{{{ENTRY POINT{13423
*
*      DEAL WITH CASE OF NO ARGS
*
{{BNZ{8,WA{6,SITM1{{JUMP IF AT LEAST ONE ARG{13427
{{MOV{11,-(XS){21,=NULLS{{ELSE SUPPLY GARBAGE NULL ARG{13428
{{MOV{8,WA{18,=NUM01{{AND FIX ARGUMENT COUNT{13429
*
*      CHECK FOR NAME/VALUE CASES
*
{SITM1{SCP{7,XR{{{GET CURRENT CODE POINTER{13433
{{MOV{7,XL{9,(XR){{LOAD NEXT CODE WORD{13434
{{DCV{8,WA{{{GET NUMBER OF SUBSCRIPTS{13435
{{MOV{7,XR{8,WA{{COPY FOR ARREF{13436
{{BEQ{7,XL{21,=OFNE_{6,SITM2{JUMP IF CALLED BY NAME{13437
*
*      HERE IF CALLED BY VALUE
*
{{ZER{8,WB{{{SET CODE FOR CALL BY VALUE{13441
{{BRN{6,ARREF{{{OFF TO ARRAY REFERENCE ROUTINE{13442
*
*      HERE FOR CALL BY NAME
*
{SITM2{MNZ{8,WB{{{SET CODE FOR CALL BY NAME{13446
{{LCW{8,WA{{{LOAD AND IGNORE OFNE_ CALL{13447
{{BRN{6,ARREF{{{OFF TO ARRAY REFERENCE ROUTINE{13448
{{EJC{{{{{13449
*
*      LE
*
{S_LEF{ENT{{{{ENTRY POINT{13453
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{13454
{{ERR{1,118{26,LE first argument is not numeric{{{13455
{{ERR{1,119{26,LE second argument is not numeric{{{13456
{{PPM{6,EXNUL{{{RETURN NULL IF LT{13457
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{13458
{{PPM{6,EXFAL{{{FAIL IF GT{13459
{{EJC{{{{{13460
*
*      LEN
*
{S_LEN{ENT{{{{ENTRY POINT{13464
{{MOV{8,WB{22,=P_LEN{{SET PCODE FOR INTEGER ARG CASE{13465
{{MOV{8,WA{22,=P_LND{{SET PCODE FOR EXPR ARG CASE{13466
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{13467
{{ERR{1,120{26,LEN argument is not integer or expression{{{13468
{{ERR{1,121{26,LEN argument is negative or too large{{{13469
{{MOV{11,-(XS){7,XR{{STACK RESULT{13470
{{LCW{7,XR{{{GET NEXT CODE WORD{13471
{{BRI{9,(XR){{{EXECUTE IT{13472
{{EJC{{{{{13473
*
*      LEQ
*
{S_LEQ{ENT{{{{ENTRY POINT{13477
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{13478
{{ERR{1,122{26,LEQ first argument is not a string{{{13479
{{ERR{1,123{26,LEQ second argument is not a string{{{13480
{{PPM{6,EXFAL{{{FAIL IF LLT{13481
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{13482
{{PPM{6,EXFAL{{{FAIL IF LGT{13483
{{EJC{{{{{13484
*
*      LGE
*
{S_LGE{ENT{{{{ENTRY POINT{13488
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{13489
{{ERR{1,124{26,LGE first argument is not a string{{{13490
{{ERR{1,125{26,LGE second argument is not a string{{{13491
{{PPM{6,EXFAL{{{FAIL IF LLT{13492
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{13493
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{13494
{{EJC{{{{{13495
*
*      LGT
*
{S_LGT{ENT{{{{ENTRY POINT{13499
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{13500
{{ERR{1,126{26,LGT first argument is not a string{{{13501
{{ERR{1,127{26,LGT second argument is not a string{{{13502
{{PPM{6,EXFAL{{{FAIL IF LLT{13503
{{PPM{6,EXFAL{{{FAIL IF LEQ{13504
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{13505
{{EJC{{{{{13506
*
*      LLE
*
{S_LLE{ENT{{{{ENTRY POINT{13510
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{13511
{{ERR{1,128{26,LLE first argument is not a string{{{13512
{{ERR{1,129{26,LLE second argument is not a string{{{13513
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{13514
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{13515
{{PPM{6,EXFAL{{{FAIL IF LGT{13516
{{EJC{{{{{13517
*
*      LLT
*
{S_LLT{ENT{{{{ENTRY POINT{13521
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{13522
{{ERR{1,130{26,LLT first argument is not a string{{{13523
{{ERR{1,131{26,LLT second argument is not a string{{{13524
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{13525
{{PPM{6,EXFAL{{{FAIL IF LEQ{13526
{{PPM{6,EXFAL{{{FAIL IF LGT{13527
{{EJC{{{{{13528
*
*      LNE
*
{S_LNE{ENT{{{{ENTRY POINT{13532
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{13533
{{ERR{1,132{26,LNE first argument is not a string{{{13534
{{ERR{1,133{26,LNE second argument is not a string{{{13535
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{13536
{{PPM{6,EXFAL{{{FAIL IF LEQ{13537
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{13538
{{EJC{{{{{13539
*
*      LN
*
{S_LNF{ENT{{{{ENTRY POINT{13544
{{MOV{7,XR{10,(XS)+{{GET ARGUMENT{13545
{{JSR{6,GTREA{{{CONVERT TO REAL{13546
{{ERR{1,306{26,LN argument not numeric{{{13547
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{13548
{{REQ{6,SLNF1{{{OVERFLOW IF ARGUMENT IS 0{13549
{{RLT{6,SLNF2{{{ERROR IF ARGUMENT LESS THAN 0{13550
{{LNF{{{{TAKE NATURAL LOGARITHM{13551
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{13552
{SLNF1{ERB{1,307{26,LN produced real overflow{{{13553
*
*      HERE FOR BAD ARGUMENT
*
{SLNF2{ERB{1,315{26,LN argument negative{{{13557
{{EJC{{{{{13558
*
*      LOCAL
*
{S_LOC{ENT{{{{ENTRY POINT{13563
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT (LOCAL NUMBER){13564
{{ERR{1,134{26,LOCAL second argument is not integer{{{13565
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE{13566
{{MOV{8,WB{7,XR{{SAVE LOCAL NUMBER{13567
{{MOV{7,XR{10,(XS)+{{LOAD FIRST ARGUMENT{13568
{{JSR{6,GTNVR{{{POINT TO VRBLK{13569
{{PPM{6,SLOC1{{{JUMP IF NOT VARIABLE NAME{13570
{{MOV{7,XR{13,VRFNC(XR){{ELSE LOAD FUNCTION POINTER{13571
{{BNE{9,(XR){22,=B_PFC{6,SLOC1{JUMP IF NOT PROGRAM DEFINED{13572
*
*      HERE IF WE HAVE A PROGRAM DEFINED FUNCTION NAME
*
{{BZE{8,WB{6,EXFAL{{FAIL IF SECOND ARG IS ZERO{13576
{{BGT{8,WB{13,PFNLO(XR){6,EXFAL{OR TOO LARGE{13577
{{ADD{8,WB{13,FARGS(XR){{ELSE ADJUST OFFSET TO INCLUDE ARGS{13578
{{WTB{8,WB{{{CONVERT TO BYTES{13579
{{ADD{7,XR{8,WB{{POINT TO LOCAL POINTER{13580
{{MOV{7,XR{13,PFAGB(XR){{LOAD VRBLK POINTER{13581
{{BRN{6,EXVNM{{{EXIT BUILDING NMBLK{13582
*
*      HERE IF FIRST ARGUMENT IS NO GOOD
*
{SLOC1{ERB{1,135{26,LOCAL first arg is not a program function name{{{13586
{{EJC{{{{{13589
*
*      LOAD
*
{S_LOD{ENT{{{{ENTRY POINT{13593
{{JSR{6,GTSTG{{{LOAD LIBRARY NAME{13594
{{ERR{1,136{26,LOAD second argument is not a string{{{13595
{{MOV{7,XL{7,XR{{SAVE LIBRARY NAME{13596
{{JSR{6,XSCNI{{{PREPARE TO SCAN FIRST ARGUMENT{13597
{{ERR{1,137{26,LOAD first argument is not a string{{{13598
{{ERR{1,138{26,LOAD first argument is null{{{13599
{{MOV{11,-(XS){7,XL{{STACK LIBRARY NAME{13600
{{MOV{8,WC{18,=CH_PP{{SET DELIMITER ONE = LEFT PAREN{13601
{{MOV{7,XL{8,WC{{SET DELIMITER TWO = LEFT PAREN{13602
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{13603
{{JSR{6,XSCAN{{{SCAN FUNCTION NAME{13604
{{MOV{11,-(XS){7,XR{{SAVE PTR TO FUNCTION NAME{13605
{{BNZ{8,WA{6,SLOD1{{JUMP IF LEFT PAREN FOUND{13606
{{ERB{1,139{26,LOAD first argument is missing a left paren{{{13607
*
*      HERE AFTER SUCCESSFULLY SCANNING FUNCTION NAME
*
{SLOD1{JSR{6,GTNVR{{{LOCATE VRBLK{13611
{{ERR{1,140{26,LOAD first argument has null function name{{{13612
{{MOV{3,LODFN{7,XR{{SAVE VRBLK POINTER{13613
{{ZER{3,LODNA{{{ZERO COUNT OF ARGUMENTS{13614
*
*      LOOP TO SCAN ARGUMENT DATATYPE NAMES
*
{SLOD2{MOV{8,WC{18,=CH_RP{{DELIMITER ONE IS RIGHT PAREN{13618
{{MOV{7,XL{18,=CH_CM{{DELIMITER TWO IS COMMA{13619
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{13620
{{JSR{6,XSCAN{{{SCAN NEXT ARGUMENT NAME{13621
{{ICV{3,LODNA{{{BUMP ARGUMENT COUNT{13622
{{BNZ{8,WA{6,SLOD3{{JUMP IF OK DELIMITER WAS FOUND{13623
{{ERB{1,141{26,LOAD first argument is missing a right paren{{{13624
{{EJC{{{{{13625
*
*      LOAD (CONTINUED)
*
*      COME HERE TO ANALYZE THE DATATYPE POINTER IN (XR). THIS
*      CODE IS USED BOTH FOR ARGUMENTS (WA=1,2) AND FOR THE
*      RESULT DATATYPE (WITH WA SET TO ZERO).
*
{SLOD3{MOV{8,WB{8,WA{{SAVE SCAN MODE{13634
{{MOV{8,WA{13,SCLEN(XR){{DATATYPE LENGTH{13635
{{BZE{8,WA{6,SLD3A{{BYPASS IF NULL STRING{13636
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{13637
{SLD3A{MOV{8,WA{8,WB{{RESTORE SCAN MODE{13638
{{MOV{11,-(XS){7,XR{{STACK DATATYPE NAME POINTER{13639
{{MOV{8,WB{18,=NUM01{{SET STRING CODE IN CASE{13643
{{MOV{7,XL{21,=SCSTR{{POINT TO /STRING/{13644
{{JSR{6,IDENT{{{CHECK FOR MATCH{13645
{{PPM{6,SLOD4{{{JUMP IF MATCH{13646
{{MOV{7,XR{9,(XS){{ELSE RELOAD NAME{13647
{{ADD{8,WB{8,WB{{SET CODE FOR INTEGER (2){13648
{{MOV{7,XL{21,=SCINT{{POINT TO /INTEGER/{13649
{{JSR{6,IDENT{{{CHECK FOR MATCH{13650
{{PPM{6,SLOD4{{{JUMP IF MATCH{13651
{{MOV{7,XR{9,(XS){{ELSE RELOAD STRING POINTER{13654
{{ICV{8,WB{{{SET CODE FOR REAL (3){13655
{{MOV{7,XL{21,=SCREA{{POINT TO /REAL/{13656
{{JSR{6,IDENT{{{CHECK FOR MATCH{13657
{{PPM{6,SLOD4{{{JUMP IF MATCH{13658
{{MOV{7,XR{9,(XS){{RELOAD STRING POINTER{13661
{{ICV{8,WB{{{CODE FOR FILE (4, OR 3 IF NO REALS){13662
{{MOV{7,XL{21,=SCFIL{{POINT TO /FILE/{13663
{{JSR{6,IDENT{{{CHECK FOR MATCH{13664
{{PPM{6,SLOD4{{{JUMP IF MATCH{13665
{{ZER{8,WB{{{ELSE GET CODE FOR NO CONVERT{13667
*
*      MERGE HERE WITH PROPER DATATYPE CODE IN WB
*
{SLOD4{MOV{9,(XS){8,WB{{STORE CODE ON STACK{13671
{{BEQ{8,WA{18,=NUM02{6,SLOD2{LOOP BACK IF ARG STOPPED BY COMMA{13672
{{BZE{8,WA{6,SLOD5{{JUMP IF THAT WAS THE RESULT TYPE{13673
*
*      HERE WE SCAN OUT THE RESULT TYPE (ARG STOPPED BY ) )
*
{{MOV{8,WC{3,MXLEN{{SET DUMMY (IMPOSSIBLE) DELIMITER 1{13677
{{MOV{7,XL{8,WC{{AND DELIMITER TWO{13678
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{13679
{{JSR{6,XSCAN{{{SCAN RESULT NAME{13680
{{ZER{8,WA{{{SET CODE FOR PROCESSING RESULT{13681
{{BRN{6,SLOD3{{{JUMP BACK TO PROCESS RESULT NAME{13682
{{EJC{{{{{13683
*
*      LOAD (CONTINUED)
*
*      HERE AFTER PROCESSING ALL ARGS AND RESULT
*
{SLOD5{MOV{8,WA{3,LODNA{{GET NUMBER OF ARGUMENTS{13689
{{MOV{8,WC{8,WA{{COPY FOR LATER{13690
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{13691
{{ADD{8,WA{19,*EFSI_{{ADD SPACE FOR STANDARD FIELDS{13692
{{JSR{6,ALLOC{{{ALLOCATE EFBLK{13693
{{MOV{9,(XR){22,=B_EFC{{SET TYPE WORD{13694
{{MOV{13,FARGS(XR){8,WC{{SET NUMBER OF ARGUMENTS{13695
{{ZER{13,EFUSE(XR){{{SET USE COUNT (DFFNC WILL SET TO 1){13696
{{ZER{13,EFCOD(XR){{{ZERO CODE POINTER FOR NOW{13697
{{MOV{13,EFRSL(XR){10,(XS)+{{STORE RESULT TYPE CODE{13698
{{MOV{13,EFVAR(XR){3,LODFN{{STORE FUNCTION VRBLK POINTER{13699
{{MOV{13,EFLEN(XR){8,WA{{STORE EFBLK LENGTH{13700
{{MOV{8,WB{7,XR{{SAVE EFBLK POINTER{13701
{{ADD{7,XR{8,WA{{POINT PAST END OF EFBLK{13702
{{LCT{8,WC{8,WC{{SET NUMBER OF ARGUMENTS FOR LOOP{13703
*
*      LOOP TO SET ARGUMENT TYPE CODES FROM STACK
*
{SLOD6{MOV{11,-(XR){10,(XS)+{{STORE ONE TYPE CODE FROM STACK{13707
{{BCT{8,WC{6,SLOD6{{LOOP TILL ALL STORED{13708
*
*      NOW LOAD THE EXTERNAL FUNCTION AND PERFORM DEFINITION
*
{{MOV{7,XR{10,(XS)+{{LOAD FUNCTION STRING NAME{13712
{{MOV{8,WA{13,SCLEN(XR){{FUNCTION NAME LENGTH{13714
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{13715
{{MOV{7,XL{9,(XS){{LOAD LIBRARY NAME{13717
{{MOV{9,(XS){8,WB{{STORE EFBLK POINTER{13718
{{JSR{6,SYSLD{{{CALL FUNCTION TO LOAD EXTERNAL FUNC{13719
{{ERR{1,142{26,LOAD function does not exist{{{13720
{{ERR{1,143{26,LOAD function caused input error during load{{{13721
{{ERR{1,328{26,LOAD function - insufficient memory{{{13722
{{MOV{7,XL{10,(XS)+{{RECALL EFBLK POINTER{13723
{{MOV{13,EFCOD(XL){7,XR{{STORE CODE POINTER{13724
{{MOV{7,XR{3,LODFN{{POINT TO VRBLK FOR FUNCTION{13725
{{JSR{6,DFFNC{{{PERFORM FUNCTION DEFINITION{13726
{{BRN{6,EXNUL{{{RETURN NULL RESULT{13727
{{EJC{{{{{13729
*
*      LPAD
*
{S_LPD{ENT{{{{ENTRY POINT{13733
{{JSR{6,GTSTG{{{GET PAD CHARACTER{13734
{{ERR{1,144{26,LPAD third argument is not a string{{{13735
{{PLC{7,XR{{{POINT TO CHARACTER (NULL IS BLANK){13736
{{LCH{8,WB{9,(XR){{LOAD PAD CHARACTER{13737
{{JSR{6,GTSMI{{{GET PAD LENGTH{13738
{{ERR{1,145{26,LPAD second argument is not integer{{{13739
{{PPM{6,SLPD4{{{SKIP IF NEGATIVE OR LARGE{13740
*
*      MERGE TO CHECK FIRST ARG
*
{SLPD1{JSR{6,GTSTG{{{GET FIRST ARGUMENT (STRING TO PAD){13744
{{ERR{1,146{26,LPAD first argument is not a string{{{13745
{{BGE{8,WA{8,WC{6,EXIXR{RETURN 1ST ARG IF TOO LONG TO PAD{13746
{{MOV{7,XL{7,XR{{ELSE MOVE PTR TO STRING TO PAD{13747
*
*      NOW WE ARE READY FOR THE PAD
*
*      (XL)                  POINTER TO STRING TO PAD
*      (WB)                  PAD CHARACTER
*      (WC)                  LENGTH TO PAD STRING TO
*
{{MOV{8,WA{8,WC{{COPY LENGTH{13755
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR NEW STRING{13756
{{MOV{11,-(XS){7,XR{{SAVE AS RESULT{13757
{{MOV{8,WA{13,SCLEN(XL){{LOAD LENGTH OF ARGUMENT{13758
{{SUB{8,WC{8,WA{{CALCULATE NUMBER OF PAD CHARACTERS{13759
{{PSC{7,XR{{{POINT TO CHARS IN RESULT STRING{13760
{{LCT{8,WC{8,WC{{SET COUNTER FOR PAD LOOP{13761
*
*      LOOP TO PERFORM PAD
*
{SLPD2{SCH{8,WB{10,(XR)+{{STORE PAD CHARACTER, BUMP PTR{13765
{{BCT{8,WC{6,SLPD2{{LOOP TILL ALL PAD CHARS STORED{13766
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{13767
*
*      NOW COPY STRING
*
{{BZE{8,WA{6,SLPD3{{EXIT IF NULL STRING{13771
{{PLC{7,XL{{{ELSE POINT TO CHARS IN ARGUMENT{13772
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{13773
{{ZER{7,XL{{{CLEAR GARBAGE XL{13774
*
*      HERE TO EXIT WITH RESULT ON STACK
*
{SLPD3{LCW{7,XR{{{LOAD NEXT CODE WORD{13778
{{BRI{9,(XR){{{EXECUTE IT{13779
*
*      HERE IF 2ND ARG IS NEGATIVE OR LARGE
*
{SLPD4{ZER{8,WC{{{ZERO PAD COUNT{13783
{{BRN{6,SLPD1{{{MERGE{13784
{{EJC{{{{{13785
*
*      LT
*
{S_LTF{ENT{{{{ENTRY POINT{13789
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{13790
{{ERR{1,147{26,LT first argument is not numeric{{{13791
{{ERR{1,148{26,LT second argument is not numeric{{{13792
{{PPM{6,EXNUL{{{RETURN NULL IF LT{13793
{{PPM{6,EXFAL{{{FAIL IF EQ{13794
{{PPM{6,EXFAL{{{FAIL IF GT{13795
{{EJC{{{{{13796
*
*      NE
*
{S_NEF{ENT{{{{ENTRY POINT{13800
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{13801
{{ERR{1,149{26,NE first argument is not numeric{{{13802
{{ERR{1,150{26,NE second argument is not numeric{{{13803
{{PPM{6,EXNUL{{{RETURN NULL IF LT{13804
{{PPM{6,EXFAL{{{FAIL IF EQ{13805
{{PPM{6,EXNUL{{{RETURN NULL IF GT{13806
{{EJC{{{{{13807
*
*      NOTANY
*
{S_NAY{ENT{{{{ENTRY POINT{13811
{{MOV{8,WB{22,=P_NAS{{SET PCODE FOR SINGLE CHAR ARG{13812
{{MOV{7,XL{22,=P_NAY{{PCODE FOR MULTI-CHAR ARG{13813
{{MOV{8,WC{22,=P_NAD{{SET PCODE FOR EXPR ARG{13814
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{13815
{{ERR{1,151{26,NOTANY argument is not a string or expression{{{13816
{{MOV{11,-(XS){7,XR{{STACK RESULT{13817
{{LCW{7,XR{{{GET NEXT CODE WORD{13818
{{BRI{9,(XR){{{EXECUTE IT{13819
{{EJC{{{{{13820
*
*      OPSYN
*
{S_OPS{ENT{{{{ENTRY POINT{13824
{{JSR{6,GTSMI{{{LOAD THIRD ARGUMENT{13825
{{ERR{1,152{26,OPSYN third argument is not integer{{{13826
{{ERR{1,153{26,OPSYN third argument is negative or too large{{{13827
{{MOV{8,WB{8,WC{{IF OK, SAVE THIRD ARGUMNET{13828
{{MOV{7,XR{10,(XS)+{{LOAD SECOND ARGUMENT{13829
{{JSR{6,GTNVR{{{LOCATE VARIABLE BLOCK{13830
{{ERR{1,154{26,OPSYN second arg is not natural variable name{{{13831
{{MOV{7,XL{13,VRFNC(XR){{IF OK, LOAD FUNCTION BLOCK POINTER{13832
{{BNZ{8,WB{6,SOPS2{{JUMP IF OPERATOR OPSYN CASE{13833
*
*      HERE FOR FUNCTION OPSYN (THIRD ARG ZERO)
*
{{MOV{7,XR{10,(XS)+{{LOAD FIRST ARGUMENT{13837
{{JSR{6,GTNVR{{{GET VRBLK POINTER{13838
{{ERR{1,155{26,OPSYN first arg is not natural variable name{{{13839
*
*      MERGE HERE TO PERFORM FUNCTION DEFINITION
*
{SOPS1{JSR{6,DFFNC{{{CALL FUNCTION DEFINER{13843
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT{13844
*
*      HERE FOR OPERATOR OPSYN (THIRD ARG NON-ZERO)
*
{SOPS2{JSR{6,GTSTG{{{GET OPERATOR NAME{13848
{{PPM{6,SOPS5{{{JUMP IF NOT STRING{13849
{{BNE{8,WA{18,=NUM01{6,SOPS5{ERROR IF NOT ONE CHAR LONG{13850
{{PLC{7,XR{{{ELSE POINT TO CHARACTER{13851
{{LCH{8,WC{9,(XR){{LOAD CHARACTER NAME{13852
{{EJC{{{{{13853
*
*      OPSYN (CONTINUED)
*
*      NOW SET TO SEARCH FOR MATCHING UNARY OR BINARY OPERATOR
*      NAME AS APPROPRIATE. NOTE THAT THERE ARE =OPBUN UNDEFINED
*      BINARY OPERATORS AND =OPUUN UNDEFINED UNARY OPERATORS.
*
{{MOV{8,WA{20,=R_UUB{{POINT TO UNOP POINTERS IN CASE{13861
{{MOV{7,XR{21,=OPNSU{{POINT TO NAMES OF UNARY OPERATORS{13862
{{ADD{8,WB{18,=OPBUN{{ADD NO. OF UNDEFINED BINARY OPS{13863
{{BEQ{8,WB{18,=OPUUN{6,SOPS3{JUMP IF UNOP (THIRD ARG WAS 1){13864
{{MOV{8,WA{20,=R_UBA{{ELSE POINT TO BINARY OPERATOR PTRS{13865
{{MOV{7,XR{21,=OPSNB{{POINT TO NAMES OF BINARY OPERATORS{13866
{{MOV{8,WB{18,=OPBUN{{SET NUMBER OF UNDEFINED BINOPS{13867
*
*      MERGE HERE TO CHECK LIST (WB = NUMBER TO CHECK)
*
{SOPS3{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{13871
*
*      LOOP TO SEARCH FOR NAME MATCH
*
{SOPS4{BEQ{8,WC{9,(XR){6,SOPS6{JUMP IF NAMES MATCH{13875
{{ICA{8,WA{{{ELSE PUSH POINTER TO FUNCTION PTR{13876
{{ICA{7,XR{{{BUMP POINTER{13877
{{BCT{8,WB{6,SOPS4{{LOOP BACK TILL ALL CHECKED{13878
*
*      HERE IF BAD OPERATOR NAME
*
{SOPS5{ERB{1,156{26,OPSYN first arg is not correct operator name{{{13882
*
*      COME HERE ON FINDING A MATCH IN THE OPERATOR NAME TABLE
*
{SOPS6{MOV{7,XR{8,WA{{COPY POINTER TO FUNCTION BLOCK PTR{13886
{{SUB{7,XR{19,*VRFNC{{MAKE IT LOOK LIKE DUMMY VRBLK{13887
{{BRN{6,SOPS1{{{MERGE BACK TO DEFINE OPERATOR{13888
{{EJC{{{{{13889
*
*      OUTPUT
*
{S_OUP{ENT{{{{ENTRY POINT{13914
{{MOV{8,WB{18,=NUM03{{OUTPUT FLAG{13915
{{JSR{6,IOPUT{{{CALL INPUT/OUTPUT ASSOC. ROUTINE{13916
{{ERR{1,157{26,OUTPUT third argument is not a string{{{13917
{{ERR{1,158{26,Inappropriate second argument for OUTPUT{{{13918
{{ERR{1,159{26,Inappropriate first argument for OUTPUT{{{13919
{{ERR{1,160{26,Inappropriate file specification for OUTPUT{{{13920
{{PPM{6,EXFAL{{{FAIL IF FILE DOES NOT EXIST{13921
{{ERR{1,161{26,OUTPUT file cannot be written to{{{13922
{{ERR{1,290{26,OUTPUT channel currently in use{{{13923
{{BRN{6,EXNUL{{{RETURN NULL STRING{13924
{{EJC{{{{{13925
*
*      POS
*
{S_POS{ENT{{{{ENTRY POINT{13929
{{MOV{8,WB{22,=P_POS{{SET PCODE FOR INTEGER ARG CASE{13930
{{MOV{8,WA{22,=P_PSD{{SET PCODE FOR EXPRESSION ARG CASE{13931
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{13932
{{ERR{1,162{26,POS argument is not integer or expression{{{13933
{{ERR{1,163{26,POS argument is negative or too large{{{13934
{{MOV{11,-(XS){7,XR{{STACK RESULT{13935
{{LCW{7,XR{{{GET NEXT CODE WORD{13936
{{BRI{9,(XR){{{EXECUTE IT{13937
{{EJC{{{{{13938
*
*      PROTOTYPE
*
{S_PRO{ENT{{{{ENTRY POINT{13942
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{13943
{{MOV{8,WB{13,TBLEN(XR){{LENGTH IF TABLE, VECTOR (=VCLEN){13944
{{BTW{8,WB{{{CONVERT TO WORDS{13945
{{MOV{8,WA{9,(XR){{LOAD TYPE WORD OF ARGUMENT BLOCK{13946
{{BEQ{8,WA{22,=B_ART{6,SPRO4{JUMP IF ARRAY{13947
{{BEQ{8,WA{22,=B_TBT{6,SPRO1{JUMP IF TABLE{13948
{{BEQ{8,WA{22,=B_VCT{6,SPRO3{JUMP IF VECTOR{13949
{{ERB{1,164{26,PROTOTYPE argument is not valid object{{{13954
*
*      HERE FOR TABLE
*
{SPRO1{SUB{8,WB{18,=TBSI_{{SUBTRACT STANDARD FIELDS{13958
*
*      MERGE FOR VECTOR
*
{SPRO2{MTI{8,WB{{{CONVERT TO INTEGER{13962
{{BRN{6,EXINT{{{EXIT WITH INTEGER RESULT{13963
*
*      HERE FOR VECTOR
*
{SPRO3{SUB{8,WB{18,=VCSI_{{SUBTRACT STANDARD FIELDS{13967
{{BRN{6,SPRO2{{{MERGE{13968
*
*      HERE FOR ARRAY
*
{SPRO4{ADD{7,XR{13,AROFS(XR){{POINT TO PROTOTYPE FIELD{13972
{{MOV{7,XR{9,(XR){{LOAD PROTOTYPE{13973
{{MOV{11,-(XS){7,XR{{STACK RESULT{13974
{{LCW{7,XR{{{GET NEXT CODE WORD{13975
{{BRI{9,(XR){{{EXECUTE IT{13976
{{EJC{{{{{13986
*
*      REMDR
*
{S_RMD{ENT{{{{ENTRY POINT{13990
{{JSR{6,ARITH{{{GET TWO INTEGERS OR TWO REALS{13992
{{ERR{1,166{26,REMDR first argument is not numeric{{{13993
{{ERR{1,165{26,REMDR second argument is not numeric{{{13994
{{PPM{6,SRM06{{{IF REAL{13995
*
*      BOTH ARGUMENTS INTEGER
*
{{ZER{8,WB{{{SET POSITIVE FLAG{14012
{{LDI{13,ICVAL(XR){{{LOAD LEFT ARGUMENT VALUE{14013
{{IGE{6,SRM01{{{JUMP IF POSITIVE{14014
{{MNZ{8,WB{{{SET NEGATIVE FLAG{14015
{SRM01{RMI{13,ICVAL(XL){{{GET REMAINDER{14016
{{IOV{6,SRM05{{{ERROR IF OVERFLOW{14017
*
*      MAKE SIGN OF RESULT MATCH SIGN OF FIRST ARGUMENT
*
{{BZE{8,WB{6,SRM03{{IF RESULT SHOULD BE POSITIVE{14021
{{ILE{6,EXINT{{{IF SHOULD BE NEGATIVE, AND IS{14022
{SRM02{NGI{{{{ADJUST SIGN OF RESULT{14023
{{BRN{6,EXINT{{{RETURN RESULT{14024
{SRM03{ILT{6,SRM02{{{SHOULD BE POS, AND RESULT NEGATIVE{14025
{{BRN{6,EXINT{{{SHOULD BE POSITIVE, AND IS{14026
*
*      FAIL FIRST ARGUMENT
*
{SRM04{ERB{1,166{26,REMDR first argument is not numeric{{{14030
*
*      FAIL IF OVERFLOW
*
{SRM05{ERB{1,167{26,REMDR caused integer overflow{{{14034
*
*      HERE WITH 1ST ARGUMENT IN (XR), 2ND IN (XL), BOTH REAL
*
*      RESULT = N1 - CHOP(N1/N2)*N2
*
{SRM06{ZER{8,WB{{{SET POSITIVE FLAG{14041
{{LDR{13,RCVAL(XR){{{LOAD LEFT ARGUMENT VALUE{14042
{{RGE{6,SRM07{{{JUMP IF POSITIVE{14043
{{MNZ{8,WB{{{SET NEGATIVE FLAG{14044
{SRM07{DVR{13,RCVAL(XL){{{COMPUTE N1/N2{14045
{{ROV{6,SRM10{{{JUMP IF OVERFLOW{14046
{{CHP{{{{CHOP RESULT{14047
{{MLR{13,RCVAL(XL){{{TIMES N2{14048
{{SBR{13,RCVAL(XR){{{COMPUTE DIFFERENCE{14049
*
*      MAKE SIGN OF RESULT MATCH SIGN OF FIRST ARGUMENT
*      -RESULT IS IN RA AT THIS POINT
*
{{BZE{8,WB{6,SRM09{{IF RESULT SHOULD BE POSITIVE{14054
{{RLE{6,EXREA{{{IF SHOULD BE NEGATIVE, AND IS{14055
{SRM08{NGR{{{{ADJUST SIGN OF RESULT{14056
{{BRN{6,EXREA{{{RETURN RESULT{14057
{SRM09{RLT{6,SRM08{{{SHOULD BE POS, AND RESULT NEGATIVE{14058
{{BRN{6,EXREA{{{SHOULD BE POSITIVE, AND IS{14059
*
*      FAIL IF OVERFLOW
*
{SRM10{ERB{1,312{26,REMDR caused real overflow{{{14063
{{EJC{{{{{14065
*
*      REPLACE
*
*      THE ACTUAL REPLACE OPERATION USES AN SCBLK WHOSE CFP_A
*      CHARS CONTAIN THE TRANSLATED VERSIONS OF ALL THE CHARS.
*      THE TABLE POINTER IS REMEMBERED FROM CALL TO CALL AND
*      THE TABLE IS ONLY BUILT WHEN THE ARGUMENTS CHANGE.
*
*      WE ALSO PERFORM AN OPTIMIZATION GLEANED FROM SPITBOL 370.
*      IF THE SECOND ARGUMENT IS &ALPHABET, THERE IS NO NEED TO
*      TO BUILD A REPLACE TABLE.  THE THIRD ARGUMENT CAN BE
*      USED DIRECTLY AS THE REPLACE TABLE.
*
{S_RPL{ENT{{{{ENTRY POINT{14079
{{JSR{6,GTSTG{{{LOAD THIRD ARGUMENT AS STRING{14080
{{ERR{1,168{26,REPLACE third argument is not a string{{{14081
{{MOV{7,XL{7,XR{{SAVE THIRD ARG PTR{14082
{{JSR{6,GTSTG{{{GET SECOND ARGUMENT{14083
{{ERR{1,169{26,REPLACE second argument is not a string{{{14084
*
*      CHECK TO SEE IF THIS IS THE SAME TABLE AS LAST TIME
*
{{BNE{7,XR{3,R_RA2{6,SRPL1{JUMP IF 2ND ARGUMENT DIFFERENT{14088
{{BEQ{7,XL{3,R_RA3{6,SRPL4{JUMP IF ARGS SAME AS LAST TIME{14089
*
*      HERE WE BUILD A NEW REPLACE TABLE (NOTE WA = 2ND ARG LEN)
*
{SRPL1{MOV{8,WB{13,SCLEN(XL){{LOAD 3RD ARGUMENT LENGTH{14093
{{BNE{8,WA{8,WB{6,SRPL6{JUMP IF ARGUMENTS NOT SAME LENGTH{14094
{{BEQ{7,XR{3,KVALP{6,SRPL5{JUMP IF 2ND ARG IS ALPHABET STRING{14095
{{BZE{8,WB{6,SRPL6{{JUMP IF NULL 2ND ARGUMENT{14096
{{MOV{3,R_RA3{7,XL{{SAVE THIRD ARG FOR NEXT TIME IN{14097
{{MOV{3,R_RA2{7,XR{{SAVE SECOND ARG FOR NEXT TIME IN{14098
{{MOV{7,XL{3,KVALP{{POINT TO ALPHABET STRING{14099
{{MOV{8,WA{13,SCLEN(XL){{LOAD ALPHABET SCBLK LENGTH{14100
{{MOV{7,XR{3,R_RPT{{POINT TO CURRENT TABLE (IF ANY){14101
{{BNZ{7,XR{6,SRPL2{{JUMP IF WE ALREADY HAVE A TABLE{14102
*
*      HERE WE ALLOCATE A NEW TABLE
*
{{JSR{6,ALOCS{{{ALLOCATE NEW TABLE{14106
{{MOV{8,WA{8,WC{{KEEP SCBLK LENGTH{14107
{{MOV{3,R_RPT{7,XR{{SAVE TABLE POINTER FOR NEXT TIME{14108
*
*      MERGE HERE WITH POINTER TO NEW TABLE BLOCK IN (XR)
*
{SRPL2{CTB{8,WA{2,SCSI_{{COMPUTE LENGTH OF SCBLK{14112
{{MVW{{{{COPY TO GET INITIAL TABLE VALUES{14113
{{EJC{{{{{14114
*
*      REPLACE (CONTINUED)
*
*      NOW WE MUST PLUG SELECTED ENTRIES AS REQUIRED. NOTE THAT
*      WE ARE SHORT OF INDEX REGISTERS FOR THE FOLLOWING LOOP.
*      HENCE THE NEED TO REPEATEDLY RE-INITIALISE CHAR PTR XL
*
{{MOV{7,XL{3,R_RA2{{POINT TO SECOND ARGUMENT{14122
{{LCT{8,WB{8,WB{{NUMBER OF CHARS TO PLUG{14123
{{ZER{8,WC{{{ZERO CHAR OFFSET{14124
{{MOV{7,XR{3,R_RA3{{POINT TO 3RD ARG{14125
{{PLC{7,XR{{{GET CHAR PTR FOR 3RD ARG{14126
*
*      LOOP TO PLUG CHARS
*
{SRPL3{MOV{7,XL{3,R_RA2{{POINT TO 2ND ARG{14130
{{PLC{7,XL{8,WC{{POINT TO NEXT CHAR{14131
{{ICV{8,WC{{{INCREMENT OFFSET{14132
{{LCH{8,WA{9,(XL){{GET NEXT CHAR{14133
{{MOV{7,XL{3,R_RPT{{POINT TO TRANSLATE TABLE{14134
{{PSC{7,XL{8,WA{{CONVERT CHAR TO OFFSET INTO TABLE{14135
{{LCH{8,WA{10,(XR)+{{GET TRANSLATED CHAR{14136
{{SCH{8,WA{9,(XL){{STORE IN TABLE{14137
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{14138
{{BCT{8,WB{6,SRPL3{{LOOP TILL DONE{14139
{{EJC{{{{{14140
*
*      REPLACE (CONTINUED)
*
*      HERE TO USE R_RPT AS REPLACE TABLE.
*
{SRPL4{MOV{7,XL{3,R_RPT{{REPLACE TABLE TO USE{14146
*
*      HERE TO PERFORM TRANSLATE USING TABLE IN XL.
*
{SRPL5{JSR{6,GTSTG{{{GET FIRST ARGUMENT{14151
{{ERR{1,170{26,REPLACE first argument is not a string{{{14152
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF NULL ARGUMENT{14161
{{MOV{11,-(XS){7,XL{{STACK REPLACE TABLE TO USE{14162
{{MOV{7,XL{7,XR{{COPY POINTER{14163
{{MOV{8,WC{8,WA{{SAVE LENGTH{14164
{{CTB{8,WA{2,SCHAR{{GET SCBLK LENGTH{14165
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR COPY{14166
{{MOV{8,WB{7,XR{{SAVE ADDRESS OF COPY{14167
{{MVW{{{{MOVE SCBLK CONTENTS TO COPY{14168
{{MOV{7,XR{10,(XS)+{{UNSTACK REPLACE TABLE{14169
{{PLC{7,XR{{{POINT TO CHARS OF TABLE{14170
{{MOV{7,XL{8,WB{{POINT TO STRING TO TRANSLATE{14171
{{PLC{7,XL{{{POINT TO CHARS OF STRING{14172
{{MOV{8,WA{8,WC{{SET NUMBER OF CHARS TO TRANSLATE{14173
{{TRC{{{{PERFORM TRANSLATION{14174
{SRPL8{MOV{11,-(XS){8,WB{{STACK RESULT{14175
{{LCW{7,XR{{{LOAD NEXT CODE WORD{14176
{{BRI{9,(XR){{{EXECUTE IT{14177
*
*      ERROR POINT
*
{SRPL6{ERB{1,171{26,Null or unequally long 2nd, 3rd args to REPLACE{{{14181
{{EJC{{{{{14196
*
*      REWIND
*
{S_REW{ENT{{{{ENTRY POINT{14200
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{14201
{{ERR{1,172{26,REWIND argument is not a suitable name{{{14202
{{ERR{1,173{26,REWIND argument is null{{{14203
{{ERR{1,174{26,REWIND file does not exist{{{14204
{{JSR{6,SYSRW{{{CALL SYSTEM REWIND FUNCTION{14205
{{ERR{1,174{26,REWIND file does not exist{{{14206
{{ERR{1,175{26,REWIND file does not permit rewind{{{14207
{{ERR{1,176{26,REWIND caused non-recoverable error{{{14208
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT IF NO ERROR{14209
{{EJC{{{{{14210
*
*      REVERSE
*
{S_RVS{ENT{{{{ENTRY POINT{14214
{{JSR{6,GTSTG{{{LOAD STRING ARGUMENT{14216
{{ERR{1,177{26,REVERSE argument is not a string{{{14217
{{BZE{8,WA{6,EXIXR{{RETURN ARGUMENT IF NULL{14223
{{MOV{7,XL{7,XR{{ELSE SAVE POINTER TO STRING ARG{14224
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR NEW SCBLK{14225
{{MOV{11,-(XS){7,XR{{STORE SCBLK PTR ON STACK AS RESULT{14226
{{PSC{7,XR{{{PREPARE TO STORE IN NEW SCBLK{14227
{{PLC{7,XL{8,WC{{POINT PAST LAST CHAR IN ARGUMENT{14228
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{14229
*
*      LOOP TO MOVE CHARS IN REVERSE ORDER
*
{SRVS1{LCH{8,WB{11,-(XL){{LOAD NEXT CHAR FROM ARGUMENT{14233
{{SCH{8,WB{10,(XR)+{{STORE IN RESULT{14234
{{BCT{8,WC{6,SRVS1{{LOOP TILL ALL MOVED{14235
*
*      HERE WHEN COMPLETE TO EXECUTE NEXT CODE WORD
*
{SRVS4{CSC{7,XR{{{COMPLETE STORE CHARACTERS{14239
{{ZER{7,XL{{{CLEAR GARBAGE XL{14240
{SRVS2{LCW{7,XR{{{LOAD NEXT CODE WORD{14241
{{BRI{9,(XR){{{EXECUTE IT{14242
{{EJC{{{{{14266
*
*      RPAD
*
{S_RPD{ENT{{{{ENTRY POINT{14270
{{JSR{6,GTSTG{{{GET PAD CHARACTER{14271
{{ERR{1,178{26,RPAD third argument is not a string{{{14272
{{PLC{7,XR{{{POINT TO CHARACTER (NULL IS BLANK){14273
{{LCH{8,WB{9,(XR){{LOAD PAD CHARACTER{14274
{{JSR{6,GTSMI{{{GET PAD LENGTH{14275
{{ERR{1,179{26,RPAD second argument is not integer{{{14276
{{PPM{6,SRPD3{{{SKIP IF NEGATIVE OR LARGE{14277
*
*      MERGE TO CHECK FIRST ARG.
*
{SRPD1{JSR{6,GTSTG{{{GET FIRST ARGUMENT (STRING TO PAD){14281
{{ERR{1,180{26,RPAD first argument is not a string{{{14282
{{BGE{8,WA{8,WC{6,EXIXR{RETURN 1ST ARG IF TOO LONG TO PAD{14283
{{MOV{7,XL{7,XR{{ELSE MOVE PTR TO STRING TO PAD{14284
*
*      NOW WE ARE READY FOR THE PAD
*
*      (XL)                  POINTER TO STRING TO PAD
*      (WB)                  PAD CHARACTER
*      (WC)                  LENGTH TO PAD STRING TO
*
{{MOV{8,WA{8,WC{{COPY LENGTH{14292
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR NEW STRING{14293
{{MOV{11,-(XS){7,XR{{SAVE AS RESULT{14294
{{MOV{8,WA{13,SCLEN(XL){{LOAD LENGTH OF ARGUMENT{14295
{{SUB{8,WC{8,WA{{CALCULATE NUMBER OF PAD CHARACTERS{14296
{{PSC{7,XR{{{POINT TO CHARS IN RESULT STRING{14297
{{LCT{8,WC{8,WC{{SET COUNTER FOR PAD LOOP{14298
*
*      COPY ARGUMENT STRING
*
{{BZE{8,WA{6,SRPD2{{JUMP IF ARGUMENT IS NULL{14302
{{PLC{7,XL{{{ELSE POINT TO ARGUMENT CHARS{14303
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{14304
{{ZER{7,XL{{{CLEAR GARBAGE XL{14305
*
*      LOOP TO SUPPLY PAD CHARACTERS
*
{SRPD2{SCH{8,WB{10,(XR)+{{STORE PAD CHARACTER, BUMP PTR{14309
{{BCT{8,WC{6,SRPD2{{LOOP TILL ALL PAD CHARS STORED{14310
{{CSC{7,XR{{{COMPLETE CHARACTER STORING{14311
{{LCW{7,XR{{{LOAD NEXT CODE WORD{14312
{{BRI{9,(XR){{{EXECUTE IT{14313
*
*      HERE IF 2ND ARG IS NEGATIVE OR LARGE
*
{SRPD3{ZER{8,WC{{{ZERO PAD COUNT{14317
{{BRN{6,SRPD1{{{MERGE{14318
{{EJC{{{{{14319
*
*      RTAB
*
{S_RTB{ENT{{{{ENTRY POINT{14323
{{MOV{8,WB{22,=P_RTB{{SET PCODE FOR INTEGER ARG CASE{14324
{{MOV{8,WA{22,=P_RTD{{SET PCODE FOR EXPRESSION ARG CASE{14325
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{14326
{{ERR{1,181{26,RTAB argument is not integer or expression{{{14327
{{ERR{1,182{26,RTAB argument is negative or too large{{{14328
{{MOV{11,-(XS){7,XR{{STACK RESULT{14329
{{LCW{7,XR{{{GET NEXT CODE WORD{14330
{{BRI{9,(XR){{{EXECUTE IT{14331
{{EJC{{{{{14332
*
*      SET
*
{S_SET{ENT{{{{ENTRY POINT{14337
{{MOV{3,R_IO2{10,(XS)+{{SAVE THIRD ARG (WHENCE){14338
{{MOV{3,R_IO1{10,(XS)+{{SAVE SECOND ARG (OFFSET){14345
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{14347
{{ERR{1,291{26,SET first argument is not a suitable name{{{14348
{{ERR{1,292{26,SET first argument is null{{{14349
{{ERR{1,295{26,SET file does not exist{{{14350
{{MOV{8,WB{3,R_IO1{{LOAD SECOND ARG{14353
{{MOV{8,WC{3,R_IO2{{LOAD THIRD ARG{14355
{{JSR{6,SYSST{{{CALL SYSTEM SET ROUTINE{14356
{{ERR{1,293{26,Inappropriate second argument to SET{{{14357
{{ERR{1,294{26,Inappropriate third argument to SET{{{14358
{{ERR{1,295{26,SET file does not exist{{{14359
{{ERR{1,296{26,SET file does not permit setting file pointer{{{14360
{{ERR{1,297{26,SET caused non-recoverable I/O error{{{14361
{{BRN{6,EXINT{{{OTHERWISE RETURN POSITION{14366
{{EJC{{{{{14368
*
*      TAB
*
{S_TAB{ENT{{{{ENTRY POINT{14373
{{MOV{8,WB{22,=P_TAB{{SET PCODE FOR INTEGER ARG CASE{14374
{{MOV{8,WA{22,=P_TBD{{SET PCODE FOR EXPRESSION ARG CASE{14375
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{14376
{{ERR{1,183{26,TAB argument is not integer or expression{{{14377
{{ERR{1,184{26,TAB argument is negative or too large{{{14378
{{MOV{11,-(XS){7,XR{{STACK RESULT{14379
{{LCW{7,XR{{{GET NEXT CODE WORD{14380
{{BRI{9,(XR){{{EXECUTE IT{14381
{{EJC{{{{{14382
*
*      RPOS
*
{S_RPS{ENT{{{{ENTRY POINT{14386
{{MOV{8,WB{22,=P_RPS{{SET PCODE FOR INTEGER ARG CASE{14387
{{MOV{8,WA{22,=P_RPD{{SET PCODE FOR EXPRESSION ARG CASE{14388
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{14389
{{ERR{1,185{26,RPOS argument is not integer or expression{{{14390
{{ERR{1,186{26,RPOS argument is negative or too large{{{14391
{{MOV{11,-(XS){7,XR{{STACK RESULT{14392
{{LCW{7,XR{{{GET NEXT CODE WORD{14393
{{BRI{9,(XR){{{EXECUTE IT{14394
{{EJC{{{{{14397
*
*      RSORT
*
{S_RSR{ENT{{{{ENTRY POINT{14401
{{MNZ{8,WA{{{MARK AS RSORT{14402
{{JSR{6,SORTA{{{CALL SORT ROUTINE{14403
{{PPM{6,EXFAL{{{IF CONVERSION FAILS, SO SHALL WE{14404
{{BRN{6,EXSID{{{RETURN, SETTING IDVAL{14405
{{EJC{{{{{14407
*
*      SETEXIT
*
{S_STX{ENT{{{{ENTRY POINT{14411
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{14412
{{MOV{8,WA{3,STXVR{{LOAD OLD VRBLK POINTER{14413
{{ZER{7,XL{{{LOAD ZERO IN CASE NULL ARG{14414
{{BEQ{7,XR{21,=NULLS{6,SSTX1{JUMP IF NULL ARGUMENT (RESET CALL){14415
{{JSR{6,GTNVR{{{ELSE GET SPECIFIED VRBLK{14416
{{PPM{6,SSTX2{{{JUMP IF NOT NATURAL VARIABLE{14417
{{MOV{7,XL{13,VRLBL(XR){{ELSE LOAD LABEL{14418
{{BEQ{7,XL{21,=STNDL{6,SSTX2{JUMP IF LABEL IS NOT DEFINED{14419
{{BNE{9,(XL){22,=B_TRT{6,SSTX1{JUMP IF NOT TRAPPED{14420
{{MOV{7,XL{13,TRLBL(XL){{ELSE LOAD PTR TO REAL LABEL CODE{14421
*
*      HERE TO SET/RESET SETEXIT TRAP
*
{SSTX1{MOV{3,STXVR{7,XR{{STORE NEW VRBLK POINTER (OR NULL){14425
{{MOV{3,R_SXC{7,XL{{STORE NEW CODE PTR (OR ZERO){14426
{{BEQ{8,WA{21,=NULLS{6,EXNUL{RETURN NULL IF NULL RESULT{14427
{{MOV{7,XR{8,WA{{ELSE COPY VRBLK POINTER{14428
{{BRN{6,EXVNM{{{AND RETURN BUILDING NMBLK{14429
*
*      HERE IF BAD ARGUMENT
*
{SSTX2{ERB{1,187{26,SETEXIT argument is not label name or null{{{14433
*
*      SIN
*
{S_SIN{ENT{{{{ENTRY POINT{14438
{{MOV{7,XR{10,(XS)+{{GET ARGUMENT{14439
{{JSR{6,GTREA{{{CONVERT TO REAL{14440
{{ERR{1,308{26,SIN argument not numeric{{{14441
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{14442
{{SIN{{{{TAKE SINE{14443
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{14444
{{ERB{1,323{26,SIN argument is out of range{{{14445
{{EJC{{{{{14446
*
*      SQRT
*
{S_SQR{ENT{{{{ENTRY POINT{14452
{{MOV{7,XR{10,(XS)+{{GET ARGUMENT{14453
{{JSR{6,GTREA{{{CONVERT TO REAL{14454
{{ERR{1,313{26,SQRT argument not numeric{{{14455
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{14456
{{RLT{6,SSQR1{{{NEGATIVE NUMBER{14457
{{SQR{{{{TAKE SQUARE ROOT{14458
{{BRN{6,EXREA{{{NO OVERFLOW POSSIBLE, RESULT IN RA{14459
*
*      HERE IF BAD ARGUMENT
*
{SSQR1{ERB{1,314{26,SQRT argument negative{{{14463
{{EJC{{{{{14464
{{EJC{{{{{14468
*
*      SORT
*
{S_SRT{ENT{{{{ENTRY POINT{14472
{{ZER{8,WA{{{MARK AS SORT{14473
{{JSR{6,SORTA{{{CALL SORT ROUTINE{14474
{{PPM{6,EXFAL{{{IF CONVERSION FAILS, SO SHALL WE{14475
{{BRN{6,EXSID{{{RETURN, SETTING IDVAL{14476
{{EJC{{{{{14478
*
*      SPAN
*
{S_SPN{ENT{{{{ENTRY POINT{14482
{{MOV{8,WB{22,=P_SPS{{SET PCODE FOR SINGLE CHAR ARG{14483
{{MOV{7,XL{22,=P_SPN{{SET PCODE FOR MULTI-CHAR ARG{14484
{{MOV{8,WC{22,=P_SPD{{SET PCODE FOR EXPRESSION ARG{14485
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{14486
{{ERR{1,188{26,SPAN argument is not a string or expression{{{14487
{{MOV{11,-(XS){7,XR{{STACK RESULT{14488
{{LCW{7,XR{{{GET NEXT CODE WORD{14489
{{BRI{9,(XR){{{EXECUTE IT{14490
{{EJC{{{{{14491
*
*      SIZE
*
{S_SI_{ENT{{{{ENTRY POINT{14495
{{JSR{6,GTSTG{{{LOAD STRING ARGUMENT{14497
{{ERR{1,189{26,SIZE argument is not a string{{{14498
*
*      MERGE WITH BFBLK OR SCBLK PTR IN XR.  WA HAS LENGTH.
*
{{MTI{8,WA{{{LOAD LENGTH AS INTEGER{14506
{{BRN{6,EXINT{{{EXIT WITH INTEGER RESULT{14507
{{EJC{{{{{14508
*
*      STOPTR
*
{S_STT{ENT{{{{ENTRY POINT{14512
{{ZER{7,XL{{{INDICATE STOPTR CASE{14513
{{JSR{6,TRACE{{{CALL TRACE PROCEDURE{14514
{{ERR{1,190{26,STOPTR first argument is not appropriate name{{{14515
{{ERR{1,191{26,STOPTR second argument is not trace type{{{14516
{{BRN{6,EXNUL{{{RETURN NULL{14517
{{EJC{{{{{14518
*
*      SUBSTR
*
{S_SUB{ENT{{{{ENTRY POINT{14522
{{JSR{6,GTSMI{{{LOAD THIRD ARGUMENT{14523
{{ERR{1,192{26,SUBSTR third argument is not integer{{{14524
{{PPM{6,EXFAL{{{JUMP IF NEGATIVE OR TOO LARGE{14525
{{MOV{3,SBSSV{7,XR{{SAVE THIRD ARGUMENT{14526
{{JSR{6,GTSMI{{{LOAD SECOND ARGUMENT{14527
{{ERR{1,193{26,SUBSTR second argument is not integer{{{14528
{{PPM{6,EXFAL{{{JUMP IF OUT OF RANGE{14529
{{MOV{8,WC{7,XR{{SAVE SECOND ARGUMENT{14530
{{BZE{8,WC{6,EXFAL{{JUMP IF SECOND ARGUMENT ZERO{14531
{{DCV{8,WC{{{ELSE DECREMENT FOR ONES ORIGIN{14532
{{JSR{6,GTSTG{{{LOAD FIRST ARGUMENT{14534
{{ERR{1,194{26,SUBSTR first argument is not a string{{{14535
*
*      MERGE WITH BFBLK OR SCBLK PTR IN XR.  WA HAS LENGTH
*
{{MOV{8,WB{8,WC{{COPY SECOND ARG TO WB{14543
{{MOV{8,WC{3,SBSSV{{RELOAD THIRD ARGUMENT{14544
{{BNZ{8,WC{6,SSUB2{{SKIP IF THIRD ARG GIVEN{14545
{{MOV{8,WC{8,WA{{ELSE GET STRING LENGTH{14546
{{BGT{8,WB{8,WC{6,EXFAL{FAIL IF IMPROPER{14547
{{SUB{8,WC{8,WB{{REDUCE BY OFFSET TO START{14548
*
*      MERGE
*
{SSUB2{MOV{7,XL{8,WA{{SAVE STRING LENGTH{14552
{{MOV{8,WA{8,WC{{SET LENGTH OF SUBSTRING{14553
{{ADD{8,WC{8,WB{{ADD 2ND ARG TO 3RD ARG{14554
{{BGT{8,WC{7,XL{6,EXFAL{JUMP IF IMPROPER SUBSTRING{14555
{{MOV{7,XL{7,XR{{COPY POINTER TO FIRST ARG{14556
{{JSR{6,SBSTR{{{BUILD SUBSTRING{14557
{{MOV{11,-(XS){7,XR{{STACK RESULT{14558
{{LCW{7,XR{{{GET NEXT CODE WORD{14559
{{BRI{9,(XR){{{EXECUTE IT{14560
{{EJC{{{{{14561
*
*      TABLE
*
{S_TBL{ENT{{{{ENTRY POINT{14565
{{MOV{7,XL{10,(XS)+{{GET INITIAL LOOKUP VALUE{14566
{{ICA{7,XS{{{POP SECOND ARGUMENT{14567
{{JSR{6,GTSMI{{{LOAD ARGUMENT{14568
{{ERR{1,195{26,TABLE argument is not integer{{{14569
{{ERR{1,196{26,TABLE argument is out of range{{{14570
{{BNZ{8,WC{6,STBL1{{JUMP IF NON-ZERO{14571
{{MOV{8,WC{18,=TBNBK{{ELSE SUPPLY DEFAULT VALUE{14572
*
*      MERGE HERE WITH NUMBER OF HEADERS IN WC
*
{STBL1{JSR{6,TMAKE{{{MAKE TABLE{14576
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{14577
{{EJC{{{{{14578
*
*      TAN
*
{S_TAN{ENT{{{{ENTRY POINT{14583
{{MOV{7,XR{10,(XS)+{{GET ARGUMENT{14584
{{JSR{6,GTREA{{{CONVERT TO REAL{14585
{{ERR{1,309{26,TAN argument not numeric{{{14586
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{14587
{{TAN{{{{TAKE TANGENT{14588
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{14589
{{ERB{1,310{26,TAN produced real overflow or argument is out of range{{{14590
{{EJC{{{{{14591
*
*      TIME
*
{S_TIM{ENT{{{{ENTRY POINT{14596
{{JSR{6,SYSTM{{{GET TIMER VALUE{14597
{{SBI{3,TIMSX{{{SUBTRACT STARTING TIME{14598
{{BRN{6,EXINT{{{EXIT WITH INTEGER VALUE{14599
{{EJC{{{{{14600
*
*      TRACE
*
{S_TRA{ENT{{{{ENTRY POINT{14604
{{BEQ{13,NUM03(XS){21,=NULLS{6,STR02{JUMP IF FIRST ARGUMENT IS NULL{14605
{{MOV{7,XR{10,(XS)+{{LOAD FOURTH ARGUMENT{14606
{{ZER{7,XL{{{TENTATIVELY SET ZERO POINTER{14607
{{BEQ{7,XR{21,=NULLS{6,STR01{JUMP IF 4TH ARGUMENT IS NULL{14608
{{JSR{6,GTNVR{{{ELSE POINT TO VRBLK{14609
{{PPM{6,STR03{{{JUMP IF NOT VARIABLE NAME{14610
{{MOV{7,XL{7,XR{{ELSE SAVE VRBLK IN TRFNC{14611
*
*      HERE WITH VRBLK OR ZERO IN XL
*
{STR01{MOV{7,XR{10,(XS)+{{LOAD THIRD ARGUMENT (TAG){14615
{{ZER{8,WB{{{SET ZERO AS TRTYP VALUE FOR NOW{14616
{{JSR{6,TRBLD{{{BUILD TRBLK FOR TRACE CALL{14617
{{MOV{7,XL{7,XR{{MOVE TRBLK POINTER FOR TRACE{14618
{{JSR{6,TRACE{{{CALL TRACE PROCEDURE{14619
{{ERR{1,198{26,TRACE first argument is not appropriate name{{{14620
{{ERR{1,199{26,TRACE second argument is not trace type{{{14621
{{BRN{6,EXNUL{{{RETURN NULL{14622
*
*      HERE TO CALL SYSTEM TRACE TOGGLE ROUTINE
*
{STR02{JSR{6,SYSTT{{{CALL IT{14626
{{ADD{7,XS{19,*NUM04{{POP TRACE ARGUMENTS{14627
{{BRN{6,EXNUL{{{RETURN{14628
*
*      HERE FOR BAD FOURTH ARGUMENT
*
{STR03{ERB{1,197{26,TRACE fourth arg is not function name or null{{{14632
{{EJC{{{{{14633
*
*      TRIM
*
{S_TRM{ENT{{{{ENTRY POINT{14637
{{JSR{6,GTSTG{{{LOAD ARGUMENT AS STRING{14639
{{ERR{1,200{26,TRIM argument is not a string{{{14640
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF ARGUMENT IS NULL{14646
{{MOV{7,XL{7,XR{{COPY STRING POINTER{14647
{{CTB{8,WA{2,SCHAR{{GET BLOCK LENGTH{14648
{{JSR{6,ALLOC{{{ALLOCATE COPY SAME SIZE{14649
{{MOV{8,WB{7,XR{{SAVE POINTER TO COPY{14650
{{MVW{{{{COPY OLD STRING BLOCK TO NEW{14651
{{MOV{7,XR{8,WB{{RESTORE PTR TO NEW BLOCK{14652
{{JSR{6,TRIMR{{{TRIM BLANKS (WB IS NON-ZERO){14653
{{MOV{11,-(XS){7,XR{{STACK RESULT{14654
{{LCW{7,XR{{{GET NEXT CODE WORD{14655
{{BRI{9,(XR){{{EXECUTE IT{14656
{{EJC{{{{{14699
*
*      UNLOAD
*
{S_UNL{ENT{{{{ENTRY POINT{14703
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{14704
{{JSR{6,GTNVR{{{POINT TO VRBLK{14705
{{ERR{1,201{26,UNLOAD argument is not natural variable name{{{14706
{{MOV{7,XL{21,=STNDF{{GET PTR TO UNDEFINED FUNCTION{14707
{{JSR{6,DFFNC{{{UNDEFINE NAMED FUNCTION{14708
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{14709
{{TTL{27,S P I T B O L -- UTILITY ROUTINES{{{{14731
*
*      THE FOLLOWING SECTION CONTAINS UTILITY ROUTINES USED FOR
*      VARIOUS PURPOSES THROUGHOUT THE SYSTEM. THESE DIFFER
*      FROM THE PROCEDURES IN THE UTILITY PROCEDURES SECTION IN
*      THEY ARE NOT IN PROCEDURE FORM AND THEY DO NOT RETURN
*      TO THEIR CALLERS. THEY ARE ACCESSED WITH A BRANCH TYPE
*      INSTRUCTION AFTER SETTING THE REGISTERS TO APPROPRIATE
*      PARAMETER VALUES.
*
*      THE REGISTER VALUES REQUIRED FOR EACH ROUTINE ARE
*      DOCUMENTED AT THE START OF EACH ROUTINE. REGISTERS NOT
*      MENTIONED MAY CONTAIN ANY VALUES EXCEPT THAT XR,XL
*      CAN ONLY CONTAIN PROPER COLLECTABLE POINTERS.
*
*      SOME OF THESE ROUTINES WILL TOLERATE GARBAGE POINTERS
*      IN XL,XR ON ENTRY. THIS IS ALWAYS DOCUMENTED AND IN
*      EACH CASE, THE ROUTINE CLEARS THESE GARBAGE VALUES BEFORE
*      EXITING AFTER COMPLETING ITS TASK.
*
*      THE ROUTINES HAVE NAMES CONSISTING OF FIVE LETTERS
*      AND ARE ASSEMBLED IN ALPHABETICAL ORDER.
{{EJC{{{{{14753
*      ARREF -- ARRAY REFERENCE
*
*      (XL)                  MAY BE NON-COLLECTABLE
*      (XR)                  NUMBER OF SUBSCRIPTS
*      (WB)                  SET ZERO/NONZERO FOR VALUE/NAME
*                            THE VALUE IN WB MUST BE COLLECTABLE
*      STACK                 SUBSCRIPTS AND ARRAY OPERAND
*      BRN  ARREF            JUMP TO CALL FUNCTION
*
*      ARREF CONTINUES BY EXECUTING THE NEXT CODE WORD WITH
*      THE RESULT NAME OR VALUE PLACED ON TOP OF THE STACK.
*      TO DEAL WITH THE PROBLEM OF ACCESSING SUBSCRIPTS IN THE
*      ORDER OF STACKING, XL IS USED AS A SUBSCRIPT POINTER
*      WORKING BELOW THE STACK POINTER.
*
{ARREF{RTN{{{{{14769
{{MOV{8,WA{7,XR{{COPY NUMBER OF SUBSCRIPTS{14770
{{MOV{7,XT{7,XS{{POINT TO STACK FRONT{14771
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{14772
{{ADD{7,XT{7,XR{{POINT TO ARRAY OPERAND ON STACK{14773
{{ICA{7,XT{{{FINAL VALUE FOR STACK POPPING{14774
{{MOV{3,ARFXS{7,XT{{KEEP FOR LATER{14775
{{MOV{7,XR{11,-(XT){{LOAD ARRAY OPERAND POINTER{14776
{{MOV{3,R_ARF{7,XR{{KEEP ARRAY POINTER{14777
{{MOV{7,XR{7,XT{{SAVE POINTER TO SUBSCRIPTS{14778
{{MOV{7,XL{3,R_ARF{{POINT XL TO POSSIBLE VCBLK OR TBBLK{14779
{{MOV{8,WC{9,(XL){{LOAD FIRST WORD{14780
{{BEQ{8,WC{22,=B_ART{6,ARF01{JUMP IF ARBLK{14781
{{BEQ{8,WC{22,=B_VCT{6,ARF07{JUMP IF VCBLK{14782
{{BEQ{8,WC{22,=B_TBT{6,ARF10{JUMP IF TBBLK{14783
{{ERB{1,235{26,Subscripted operand is not table or array{{{14784
*
*      HERE FOR ARRAY (ARBLK)
*
{ARF01{BNE{8,WA{13,ARNDM(XL){6,ARF09{JUMP IF WRONG NUMBER OF DIMS{14788
{{LDI{4,INTV0{{{GET INITIAL SUBSCRIPT OF ZERO{14789
{{MOV{7,XT{7,XR{{POINT BEFORE SUBSCRIPTS{14790
{{ZER{8,WA{{{INITIAL OFFSET TO BOUNDS{14791
{{BRN{6,ARF03{{{JUMP INTO LOOP{14792
*
*      LOOP TO COMPUTE SUBSCRIPTS BY MULTIPLICATIONS
*
{ARF02{MLI{13,ARDM2(XR){{{MULTIPLY TOTAL BY NEXT DIMENSION{14796
*
*      MERGE HERE FIRST TIME
*
{ARF03{MOV{7,XR{11,-(XT){{LOAD NEXT SUBSCRIPT{14800
{{STI{3,ARFSI{{{SAVE CURRENT SUBSCRIPT{14801
{{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE IN CASE{14802
{{BEQ{9,(XR){22,=B_ICL{6,ARF04{JUMP IF IT WAS AN INTEGER{14803
{{EJC{{{{{14804
*
*      ARREF (CONTINUED)
*
*
{{JSR{6,GTINT{{{CONVERT TO INTEGER{14809
{{PPM{6,ARF12{{{JUMP IF NOT INTEGER{14810
{{LDI{13,ICVAL(XR){{{IF OK, LOAD INTEGER VALUE{14811
*
*      HERE WITH INTEGER SUBSCRIPT IN (IA)
*
{ARF04{MOV{7,XR{3,R_ARF{{POINT TO ARRAY{14815
{{ADD{7,XR{8,WA{{OFFSET TO NEXT BOUNDS{14816
{{SBI{13,ARLBD(XR){{{SUBTRACT LOW BOUND TO COMPARE{14817
{{IOV{6,ARF13{{{OUT OF RANGE FAIL IF OVERFLOW{14818
{{ILT{6,ARF13{{{OUT OF RANGE FAIL IF TOO SMALL{14819
{{SBI{13,ARDIM(XR){{{SUBTRACT DIMENSION{14820
{{IGE{6,ARF13{{{OUT OF RANGE FAIL IF TOO LARGE{14821
{{ADI{13,ARDIM(XR){{{ELSE RESTORE SUBSCRIPT OFFSET{14822
{{ADI{3,ARFSI{{{ADD TO CURRENT TOTAL{14823
{{ADD{8,WA{19,*ARDMS{{POINT TO NEXT BOUNDS{14824
{{BNE{7,XT{7,XS{6,ARF02{LOOP BACK IF MORE TO GO{14825
*
*      HERE WITH INTEGER SUBSCRIPT COMPUTED
*
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{14829
{{WTB{8,WA{{{CONVERT TO OFFSET{14830
{{MOV{7,XL{3,R_ARF{{POINT TO ARBLK{14831
{{ADD{8,WA{13,AROFS(XL){{ADD OFFSET PAST BOUNDS{14832
{{ICA{8,WA{{{ADJUST FOR ARPRO FIELD{14833
{{BNZ{8,WB{6,ARF08{{EXIT WITH NAME IF NAME CALL{14834
*
*      MERGE HERE TO GET VALUE FOR VALUE CALL
*
{ARF05{JSR{6,ACESS{{{GET VALUE{14838
{{PPM{6,ARF13{{{FAIL IF ACESS FAILS{14839
*
*      RETURN VALUE
*
{ARF06{MOV{7,XS{3,ARFXS{{POP STACK ENTRIES{14843
{{ZER{3,R_ARF{{{FINISHED WITH ARRAY POINTER{14844
{{MOV{11,-(XS){7,XR{{STACK RESULT{14845
{{LCW{7,XR{{{GET NEXT CODE WORD{14846
{{BRI{9,(XR){{{EXECUTE IT{14847
{{EJC{{{{{14848
*
*      ARREF (CONTINUED)
*
*      HERE FOR VECTOR
*
{ARF07{BNE{8,WA{18,=NUM01{6,ARF09{ERROR IF MORE THAN 1 SUBSCRIPT{14854
{{MOV{7,XR{9,(XS){{ELSE LOAD SUBSCRIPT{14855
{{JSR{6,GTINT{{{CONVERT TO INTEGER{14856
{{PPM{6,ARF12{{{ERROR IF NOT INTEGER{14857
{{LDI{13,ICVAL(XR){{{ELSE LOAD INTEGER VALUE{14858
{{SBI{4,INTV1{{{SUBTRACT FOR ONES OFFSET{14859
{{MFI{8,WA{6,ARF13{{GET SUBSCRIPT AS ONE WORD{14860
{{ADD{8,WA{18,=VCVLS{{ADD OFFSET FOR STANDARD FIELDS{14861
{{WTB{8,WA{{{CONVERT OFFSET TO BYTES{14862
{{BGE{8,WA{13,VCLEN(XL){6,ARF13{FAIL IF OUT OF RANGE SUBSCRIPT{14863
{{BZE{8,WB{6,ARF05{{BACK TO GET VALUE IF VALUE CALL{14864
*
*      RETURN NAME
*
{ARF08{MOV{7,XS{3,ARFXS{{POP STACK ENTRIES{14868
{{ZER{3,R_ARF{{{FINISHED WITH ARRAY POINTER{14869
{{BRN{6,EXNAM{{{ELSE EXIT WITH NAME{14870
*
*      HERE IF SUBSCRIPT COUNT IS WRONG
*
{ARF09{ERB{1,236{26,Array referenced with wrong number of subscripts{{{14874
*
*      TABLE
*
{ARF10{BNE{8,WA{18,=NUM01{6,ARF11{ERROR IF MORE THAN 1 SUBSCRIPT{14878
{{MOV{7,XR{9,(XS){{ELSE LOAD SUBSCRIPT{14879
{{JSR{6,TFIND{{{CALL TABLE SEARCH ROUTINE{14880
{{PPM{6,ARF13{{{FAIL IF FAILED{14881
{{BNZ{8,WB{6,ARF08{{EXIT WITH NAME IF NAME CALL{14882
{{BRN{6,ARF06{{{ELSE EXIT WITH VALUE{14883
*
*      HERE FOR BAD TABLE REFERENCE
*
{ARF11{ERB{1,237{26,Table referenced with more than one subscript{{{14887
*
*      HERE FOR BAD SUBSCRIPT
*
{ARF12{ERB{1,238{26,Array subscript is not integer{{{14891
*
*      HERE TO SIGNAL FAILURE
*
{ARF13{ZER{3,R_ARF{{{FINISHED WITH ARRAY POINTER{14895
{{BRN{6,EXFAL{{{FAIL{14896
{{EJC{{{{{14897
*
*      CFUNC -- CALL A FUNCTION
*
*      CFUNC IS USED TO CALL A SNOBOL LEVEL FUNCTION. IT IS
*      USED BY THE APPLY FUNCTION (S_APP), THE FUNCTION
*      TRACE ROUTINE (TRXEQ) AND THE MAIN FUNCTION CALL ENTRY
*      (O_FNC, O_FNS). IN THE LATTER CASES, CFUNC IS USED ONLY
*      IF THE NUMBER OF ARGUMENTS IS INCORRECT.
*
*      (XL)                  POINTER TO FUNCTION BLOCK
*      (WA)                  ACTUAL NUMBER OF ARGUMENTS
*      (XS)                  POINTS TO STACKED ARGUMENTS
*      BRN  CFUNC            JUMP TO CALL FUNCTION
*
*      CFUNC CONTINUES BY EXECUTING THE FUNCTION
*
{CFUNC{RTN{{{{{14914
{{BLT{8,WA{13,FARGS(XL){6,CFNC1{JUMP IF TOO FEW ARGUMENTS{14915
{{BEQ{8,WA{13,FARGS(XL){6,CFNC3{JUMP IF CORRECT NUMBER OF ARGS{14916
*
*      HERE IF TOO MANY ARGUMENTS SUPPLIED, POP THEM OFF
*
{{MOV{8,WB{8,WA{{COPY ACTUAL NUMBER{14920
{{SUB{8,WB{13,FARGS(XL){{GET NUMBER OF EXTRA ARGS{14921
{{WTB{8,WB{{{CONVERT TO BYTES{14922
{{ADD{7,XS{8,WB{{POP OFF UNWANTED ARGUMENTS{14923
{{BRN{6,CFNC3{{{JUMP TO GO OFF TO FUNCTION{14924
*
*      HERE IF TOO FEW ARGUMENTS
*
{CFNC1{MOV{8,WB{13,FARGS(XL){{LOAD REQUIRED NUMBER OF ARGUMENTS{14928
{{BEQ{8,WB{18,=NINI9{6,CFNC3{JUMP IF CASE OF VAR NUM OF ARGS{14929
{{SUB{8,WB{8,WA{{CALCULATE NUMBER MISSING{14930
{{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{14931
*
*      LOOP TO SUPPLY EXTRA NULL ARGUMENTS
*
{CFNC2{MOV{11,-(XS){21,=NULLS{{STACK A NULL ARGUMENT{14935
{{BCT{8,WB{6,CFNC2{{LOOP TILL PROPER NUMBER STACKED{14936
*
*      MERGE HERE TO JUMP TO FUNCTION
*
{CFNC3{BRI{9,(XL){{{JUMP THROUGH FCODE FIELD{14940
{{EJC{{{{{14941
*
*      EXFAL -- EXIT SIGNALLING SNOBOL FAILURE
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  EXFAL            JUMP TO FAIL
*
*      EXFAL CONTINUES BY EXECUTING THE APPROPRIATE FAIL GOTO
*
{EXFAL{RTN{{{{{14950
{{MOV{7,XS{3,FLPTR{{POP STACK{14951
{{MOV{7,XR{9,(XS){{LOAD FAILURE OFFSET{14952
{{ADD{7,XR{3,R_COD{{POINT TO FAILURE CODE LOCATION{14953
{{LCP{7,XR{{{SET CODE POINTER{14954
{{LCW{7,XR{{{LOAD NEXT CODE WORD{14955
{{MOV{7,XL{9,(XR){{LOAD ENTRY ADDRESS{14956
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{14957
{{EJC{{{{{14958
*
*      EXINT -- EXIT WITH INTEGER RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      (IA)                  INTEGER VALUE
*      BRN  EXINT            JUMP TO EXIT WITH INTEGER
*
*      EXINT CONTINUES BY EXECUTING THE NEXT CODE WORD
*      WHICH IT DOES BY FALLING THROUGH TO EXIXR
*
{EXINT{RTN{{{{{14969
{{ZER{7,XL{{{CLEAR DUD VALUE{14970
{{JSR{6,ICBLD{{{BUILD ICBLK{14971
{{EJC{{{{{14972
*      EXIXR -- EXIT WITH RESULT IN (XR)
*
*      (XR)                  RESULT
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXIXR            JUMP TO EXIT WITH RESULT IN (XR)
*
*      EXIXR CONTINUES BY EXECUTING THE NEXT CODE WORD
*      WHICH IT DOES BY FALLING THROUGH TO EXITS.
{EXIXR{RTN{{{{{14981
*
{{MOV{11,-(XS){7,XR{{STACK RESULT{14983
*
*
*      EXITS -- EXIT WITH RESULT IF ANY STACKED
*
*      (XR,XL)               MAY BE NON-COLLECTABLE
*
*      BRN  EXITS            ENTER EXITS ROUTINE
*
{EXITS{RTN{{{{{14992
{{LCW{7,XR{{{LOAD NEXT CODE WORD{14993
{{MOV{7,XL{9,(XR){{LOAD ENTRY ADDRESS{14994
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{14995
{{EJC{{{{{14996
*
*      EXNAM -- EXIT WITH NAME IN (XL,WA)
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      (XR)                  MAY BE NON-COLLECTABLE
*      BRN  EXNAM            JUMP TO EXIT WITH NAME IN (XL,WA)
*
*      EXNAM CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXNAM{RTN{{{{{15007
{{MOV{11,-(XS){7,XL{{STACK NAME BASE{15008
{{MOV{11,-(XS){8,WA{{STACK NAME OFFSET{15009
{{LCW{7,XR{{{LOAD NEXT CODE WORD{15010
{{BRI{9,(XR){{{EXECUTE IT{15011
{{EJC{{{{{15012
*
*      EXNUL -- EXIT WITH NULL RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  EXNUL            JUMP TO EXIT WITH NULL VALUE
*
*      EXNUL CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXNUL{RTN{{{{{15021
{{MOV{11,-(XS){21,=NULLS{{STACK NULL VALUE{15022
{{LCW{7,XR{{{LOAD NEXT CODE WORD{15023
{{MOV{7,XL{9,(XR){{LOAD ENTRY ADDRESS{15024
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{15025
{{EJC{{{{{15026
*
*      EXREA -- EXIT WITH REAL RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      (RA)                  REAL VALUE
*      BRN  EXREA            JUMP TO EXIT WITH REAL VALUE
*
*      EXREA CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXREA{RTN{{{{{15038
{{ZER{7,XL{{{CLEAR DUD VALUE{15039
{{JSR{6,RCBLD{{{BUILD RCBLK{15040
{{BRN{6,EXIXR{{{JUMP TO EXIT WITH RESULT IN XR{15041
{{EJC{{{{{15043
*
*      EXSID -- EXIT SETTING ID FIELD
*
*      EXSID IS USED TO EXIT AFTER BUILDING ANY OF THE FOLLOWING
*      BLOCKS (ARBLK, TBBLK, PDBLK, VCBLK). IT SETS THE IDVAL.
*
*      (XR)                  PTR TO BLOCK WITH IDVAL FIELD
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXSID            JUMP TO EXIT AFTER SETTING ID FIELD
*
*      EXSID CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXSID{RTN{{{{{15056
{{MOV{8,WA{3,CURID{{LOAD CURRENT ID VALUE{15057
{{BNE{8,WA{18,=CFP_M{6,EXSI1{JUMP IF NO OVERFLOW{15058
{{ZER{8,WA{{{ELSE RESET FOR WRAPAROUND{15059
*
*      HERE WITH OLD IDVAL IN WA
*
{EXSI1{ICV{8,WA{{{BUMP ID VALUE{15063
{{MOV{3,CURID{8,WA{{STORE FOR NEXT TIME{15064
{{MOV{13,IDVAL(XR){8,WA{{STORE ID VALUE{15065
{{BRN{6,EXIXR{{{EXIT WITH RESULT IN (XR){15066
{{EJC{{{{{15067
*
*      EXVNM -- EXIT WITH NAME OF VARIABLE
*
*      EXVNM EXITS AFTER STACKING A VALUE WHICH IS A NMBLK
*      REFERENCING THE NAME OF A GIVEN NATURAL VARIABLE.
*
*      (XR)                  VRBLK POINTER
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXVNM            EXIT WITH VRBLK POINTER IN XR
*
{EXVNM{RTN{{{{{15078
{{MOV{7,XL{7,XR{{COPY NAME BASE POINTER{15079
{{MOV{8,WA{19,*NMSI_{{SET SIZE OF NMBLK{15080
{{JSR{6,ALLOC{{{ALLOCATE NMBLK{15081
{{MOV{9,(XR){22,=B_NML{{STORE TYPE WORD{15082
{{MOV{13,NMBAS(XR){7,XL{{STORE NAME BASE{15083
{{MOV{13,NMOFS(XR){19,*VRVAL{{STORE NAME OFFSET{15084
{{BRN{6,EXIXR{{{EXIT WITH RESULT IN XR{15085
{{EJC{{{{{15086
*
*      FLPOP -- FAIL AND POP IN PATTERN MATCHING
*
*      FLPOP POPS THE NODE AND CURSOR ON THE STACK AND THEN
*      DROPS THROUGH INTO FAILP TO CAUSE PATTERN FAILURE
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  FLPOP            JUMP TO FAIL AND POP STACK
*
{FLPOP{RTN{{{{{15096
{{ADD{7,XS{19,*NUM02{{POP TWO ENTRIES OFF STACK{15097
{{EJC{{{{{15098
*
*      FAILP -- FAILURE IN MATCHING PATTERN NODE
*
*      FAILP IS USED AFTER FAILING TO MATCH A PATTERN NODE.
*      SEE PATTERN MATCH ROUTINES FOR DETAILS OF USE.
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  FAILP            SIGNAL FAILURE TO MATCH
*
*      FAILP CONTINUES BY MATCHING AN ALTERNATIVE FROM THE STACK
*
{FAILP{RTN{{{{{15110
{{MOV{7,XR{10,(XS)+{{LOAD ALTERNATIVE NODE POINTER{15111
{{MOV{8,WB{10,(XS)+{{RESTORE OLD CURSOR{15112
{{MOV{7,XL{9,(XR){{LOAD PCODE ENTRY POINTER{15113
{{BRI{7,XL{{{JUMP TO EXECUTE CODE FOR NODE{15114
{{EJC{{{{{15115
*
*      INDIR -- COMPUTE INDIRECT REFERENCE
*
*      (WB)                  NONZERO/ZERO FOR BY NAME/VALUE
*      BRN  INDIR            JUMP TO GET INDIRECT REF ON STACK
*
*      INDIR CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{INDIR{RTN{{{{{15124
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{15125
{{BEQ{9,(XR){22,=B_NML{6,INDR2{JUMP IF A NAME{15126
{{JSR{6,GTNVR{{{ELSE CONVERT TO VARIABLE{15127
{{ERR{1,239{26,Indirection operand is not name{{{15128
{{BZE{8,WB{6,INDR1{{SKIP IF BY VALUE{15129
{{MOV{11,-(XS){7,XR{{ELSE STACK VRBLK PTR{15130
{{MOV{11,-(XS){19,*VRVAL{{STACK NAME OFFSET{15131
{{LCW{7,XR{{{LOAD NEXT CODE WORD{15132
{{MOV{7,XL{9,(XR){{LOAD ENTRY ADDRESS{15133
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{15134
*
*      HERE TO GET VALUE OF NATURAL VARIABLE
*
{INDR1{BRI{9,(XR){{{JUMP THROUGH VRGET FIELD OF VRBLK{15138
*
*      HERE IF OPERAND IS A NAME
*
{INDR2{MOV{7,XL{13,NMBAS(XR){{LOAD NAME BASE{15142
{{MOV{8,WA{13,NMOFS(XR){{LOAD NAME OFFSET{15143
{{BNZ{8,WB{6,EXNAM{{EXIT IF CALLED BY NAME{15144
{{JSR{6,ACESS{{{ELSE GET VALUE FIRST{15145
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{15146
{{BRN{6,EXIXR{{{ELSE RETURN WITH VALUE IN XR{15147
{{EJC{{{{{15148
*
*      MATCH -- INITIATE PATTERN MATCH
*
*      (WB)                  MATCH TYPE CODE
*      BRN  MATCH            JUMP TO INITIATE PATTERN MATCH
*
*      MATCH CONTINUES BY EXECUTING THE PATTERN MATCH. SEE
*      PATTERN MATCH ROUTINES (P_XXX) FOR FULL DETAILS.
*
{MATCH{RTN{{{{{15158
{{MOV{7,XR{10,(XS)+{{LOAD PATTERN OPERAND{15159
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{15160
{{ERR{1,240{26,Pattern match right operand is not pattern{{{15161
{{MOV{7,XL{7,XR{{IF OK, SAVE PATTERN POINTER{15162
{{BNZ{8,WB{6,MTCH1{{JUMP IF NOT MATCH BY NAME{15163
{{MOV{8,WA{9,(XS){{ELSE LOAD NAME OFFSET{15164
{{MOV{11,-(XS){7,XL{{SAVE PATTERN POINTER{15165
{{MOV{7,XL{13,NUM02(XS){{LOAD NAME BASE{15166
{{JSR{6,ACESS{{{ACCESS SUBJECT VALUE{15167
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{15168
{{MOV{7,XL{9,(XS){{RESTORE PATTERN POINTER{15169
{{MOV{9,(XS){7,XR{{STACK SUBJECT STRING VAL FOR MERGE{15170
{{ZER{8,WB{{{RESTORE TYPE CODE{15171
*
*      MERGE HERE WITH SUBJECT VALUE ON STACK
*
{MTCH1{JSR{6,GTSTG{{{CONVERT SUBJECT TO STRING{15176
{{ERR{1,241{26,Pattern match left operand is not a string{{{15177
{{MOV{11,-(XS){8,WB{{STACK MATCH TYPE CODE{15178
{{MOV{3,R_PMS{7,XR{{IF OK, STORE SUBJECT STRING POINTER{15186
{{MOV{3,PMSSL{8,WA{{AND LENGTH{15187
{{ZER{11,-(XS){{{STACK INITIAL CURSOR (ZERO){15188
{{ZER{8,WB{{{SET INITIAL CURSOR{15189
{{MOV{3,PMHBS{7,XS{{SET HISTORY STACK BASE PTR{15190
{{ZER{3,PMDFL{{{RESET PATTERN ASSIGNMENT FLAG{15191
{{MOV{7,XR{7,XL{{SET INITIAL NODE POINTER{15192
{{BNZ{3,KVANC{6,MTCH2{{JUMP IF ANCHORED{15193
*
*      HERE FOR UNANCHORED
*
{{MOV{11,-(XS){7,XR{{STACK INITIAL NODE POINTER{15197
{{MOV{11,-(XS){21,=NDUNA{{STACK POINTER TO ANCHOR MOVE NODE{15198
{{BRI{9,(XR){{{START MATCH OF FIRST NODE{15199
*
*      HERE IN ANCHORED MODE
*
{MTCH2{ZER{11,-(XS){{{DUMMY CURSOR VALUE{15203
{{MOV{11,-(XS){21,=NDABO{{STACK POINTER TO ABORT NODE{15204
{{BRI{9,(XR){{{START MATCH OF FIRST NODE{15205
{{EJC{{{{{15206
*
*      RETRN -- RETURN FROM FUNCTION
*
*      (WA)                  STRING POINTER FOR RETURN TYPE
*      BRN  RETRN            JUMP TO RETURN FROM (SNOBOL) FUNC
*
*      RETRN CONTINUES BY EXECUTING THE CODE AT THE RETURN POINT
*      THE STACK IS CLEANED OF ANY GARBAGE LEFT BY OTHER
*      ROUTINES WHICH MAY HAVE ALTERED FLPTR SINCE FUNCTION
*      ENTRY BY USING FLPRT, RESERVED FOR USE ONLY BY
*      FUNCTION CALL AND RETURN.
*
{RETRN{RTN{{{{{15219
{{BNZ{3,KVFNC{6,RTN01{{JUMP IF NOT LEVEL ZERO{15220
{{ERB{1,242{26,Function return from level zero{{{15221
*
*      HERE IF NOT LEVEL ZERO RETURN
*
{RTN01{MOV{7,XS{3,FLPRT{{POP STACK{15225
{{ICA{7,XS{{{REMOVE FAILURE OFFSET{15226
{{MOV{7,XR{10,(XS)+{{POP PFBLK POINTER{15227
{{MOV{3,FLPTR{10,(XS)+{{POP FAILURE POINTER{15228
{{MOV{3,FLPRT{10,(XS)+{{POP OLD FLPRT{15229
{{MOV{8,WB{10,(XS)+{{POP CODE POINTER OFFSET{15230
{{MOV{8,WC{10,(XS)+{{POP OLD CODE BLOCK POINTER{15231
{{ADD{8,WB{8,WC{{MAKE OLD CODE POINTER ABSOLUTE{15232
{{LCP{8,WB{{{RESTORE OLD CODE POINTER{15233
{{MOV{3,R_COD{8,WC{{RESTORE OLD CODE BLOCK POINTER{15234
{{DCV{3,KVFNC{{{DECREMENT FUNCTION LEVEL{15235
{{MOV{8,WB{3,KVTRA{{LOAD TRACE{15236
{{ADD{8,WB{3,KVFTR{{ADD FTRACE{15237
{{BZE{8,WB{6,RTN06{{JUMP IF NO TRACING POSSIBLE{15238
*
*      HERE IF THERE MAY BE A TRACE
*
{{MOV{11,-(XS){8,WA{{SAVE FUNCTION RETURN TYPE{15242
{{MOV{11,-(XS){7,XR{{SAVE PFBLK POINTER{15243
{{MOV{3,KVRTN{8,WA{{SET RTNTYPE FOR TRACE FUNCTION{15244
{{MOV{7,XL{3,R_FNC{{LOAD FNCLEVEL TRBLK PTR (IF ANY){15245
{{JSR{6,KTREX{{{EXECUTE POSSIBLE FNCLEVEL TRACE{15246
{{MOV{7,XL{13,PFVBL(XR){{LOAD VRBLK PTR (SGD13){15247
{{BZE{3,KVTRA{6,RTN02{{JUMP IF TRACE IS OFF{15248
{{MOV{7,XR{13,PFRTR(XR){{ELSE LOAD RETURN TRACE TRBLK PTR{15249
{{BZE{7,XR{6,RTN02{{JUMP IF NOT RETURN TRACED{15250
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{15251
{{BZE{13,TRFNC(XR){6,RTN03{{JUMP IF PRINT TRACE{15252
{{MOV{8,WA{19,*VRVAL{{ELSE SET NAME OFFSET{15253
{{MOV{3,KVRTN{13,NUM01(XS){{MAKE SURE RTNTYPE IS SET RIGHT{15254
{{JSR{6,TRXEQ{{{EXECUTE FULL TRACE{15255
{{EJC{{{{{15256
*
*      RETRN (CONTINUED)
*
*      HERE TO TEST FOR FTRACE
*
{RTN02{BZE{3,KVFTR{6,RTN05{{JUMP IF FTRACE IS OFF{15262
{{DCV{3,KVFTR{{{ELSE DECREMENT FTRACE{15263
*
*      HERE FOR PRINT TRACE OF FUNCTION RETURN
*
{RTN03{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{15267
{{MOV{7,XR{13,NUM01(XS){{LOAD RETURN TYPE{15268
{{JSR{6,PRTST{{{PRINT IT{15269
{{MOV{8,WA{18,=CH_BL{{LOAD BLANK{15270
{{JSR{6,PRTCH{{{PRINT IT{15271
{{MOV{7,XL{12,0(XS){{LOAD PFBLK PTR{15272
{{MOV{7,XL{13,PFVBL(XL){{LOAD FUNCTION VRBLK PTR{15273
{{MOV{8,WA{19,*VRVAL{{SET VRBLK NAME OFFSET{15274
{{BNE{7,XR{21,=SCFRT{6,RTN04{JUMP IF NOT FRETURN CASE{15275
*
*      FOR FRETURN, JUST PRINT FUNCTION NAME
*
{{JSR{6,PRTNM{{{PRINT NAME{15279
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{15280
{{BRN{6,RTN05{{{MERGE{15281
*
*      HERE FOR RETURN OR NRETURN, PRINT FUNCTION NAME = VALUE
*
{RTN04{JSR{6,PRTNV{{{PRINT NAME = VALUE{15285
*
*      HERE AFTER COMPLETING TRACE
*
{RTN05{MOV{7,XR{10,(XS)+{{POP PFBLK POINTER{15289
{{MOV{8,WA{10,(XS)+{{POP RETURN TYPE STRING{15290
*
*      MERGE HERE IF NO TRACE REQUIRED
*
{RTN06{MOV{3,KVRTN{8,WA{{SET RTNTYPE KEYWORD{15294
{{MOV{7,XL{13,PFVBL(XR){{LOAD POINTER TO FN VRBLK{15295
{{EJC{{{{{15296
*      RETRN (CONTINUED)
*
*      GET VALUE OF FUNCTION
*
{RTN07{MOV{3,RTNBP{7,XL{{SAVE BLOCK POINTER{15301
{{MOV{7,XL{13,VRVAL(XL){{LOAD VALUE{15302
{{BEQ{9,(XL){22,=B_TRT{6,RTN07{LOOP BACK IF TRAPPED{15303
{{MOV{3,RTNFV{7,XL{{ELSE SAVE FUNCTION RESULT VALUE{15304
{{MOV{3,RTNSV{10,(XS)+{{SAVE ORIGINAL FUNCTION VALUE{15305
{{MOV{7,XL{10,(XS)+{{POP SAVED POINTER{15309
{{BZE{7,XL{6,RTN7C{{NO ACTION IF NONE{15310
{{BZE{3,KVPFL{6,RTN7C{{JUMP IF NO PROFILING{15311
{{JSR{6,PRFLU{{{ELSE PROFILE LAST FUNC STMT{15312
{{BEQ{3,KVPFL{18,=NUM02{6,RTN7A{BRANCH ON VALUE OF PROFILE KEYWD{15313
*
*      HERE IF &PROFILE = 1. START TIME MUST BE FRIGGED TO
*      APPEAR EARLIER THAN IT ACTUALLY IS, BY AMOUNT USED BEFORE
*      THE CALL.
*
{{LDI{3,PFSTM{{{LOAD CURRENT TIME{15319
{{SBI{13,ICVAL(XL){{{FRIG BY SUBTRACTING SAVED AMOUNT{15320
{{BRN{6,RTN7B{{{AND MERGE{15321
*
*      HERE IF &PROFILE = 2
*
{RTN7A{LDI{13,ICVAL(XL){{{LOAD SAVED TIME{15325
*
*      BOTH PROFILE TYPES MERGE HERE
*
{RTN7B{STI{3,PFSTM{{{STORE BACK CORRECT START TIME{15329
*
*      MERGE HERE IF NO PROFILING
*
{RTN7C{MOV{8,WB{13,FARGS(XR){{GET NUMBER OF ARGS{15333
{{ADD{8,WB{13,PFNLO(XR){{ADD NUMBER OF LOCALS{15335
{{BZE{8,WB{6,RTN10{{JUMP IF NO ARGS/LOCALS{15336
{{LCT{8,WB{8,WB{{ELSE SET LOOP COUNTER{15337
{{ADD{7,XR{13,PFLEN(XR){{AND POINT TO END OF PFBLK{15338
*
*      LOOP TO RESTORE FUNCTIONS AND LOCALS
*
{RTN08{MOV{7,XL{11,-(XR){{LOAD NEXT VRBLK POINTER{15342
*
*      LOOP TO FIND VALUE BLOCK
*
{RTN09{MOV{8,WA{7,XL{{SAVE BLOCK POINTER{15346
{{MOV{7,XL{13,VRVAL(XL){{LOAD POINTER TO NEXT VALUE{15347
{{BEQ{9,(XL){22,=B_TRT{6,RTN09{LOOP BACK IF TRAPPED{15348
{{MOV{7,XL{8,WA{{ELSE RESTORE LAST BLOCK POINTER{15349
{{MOV{13,VRVAL(XL){10,(XS)+{{RESTORE OLD VARIABLE VALUE{15350
{{BCT{8,WB{6,RTN08{{LOOP TILL ALL PROCESSED{15351
*
*      NOW RESTORE FUNCTION VALUE AND EXIT
*
{RTN10{MOV{7,XL{3,RTNBP{{RESTORE PTR TO LAST FUNCTION BLOCK{15355
{{MOV{13,VRVAL(XL){3,RTNSV{{RESTORE OLD FUNCTION VALUE{15356
{{MOV{7,XR{3,RTNFV{{RELOAD FUNCTION RESULT{15357
{{MOV{7,XL{3,R_COD{{POINT TO NEW CODE BLOCK{15358
{{MOV{3,KVLST{3,KVSTN{{SET LASTNO FROM STNO{15359
{{MOV{3,KVSTN{13,CDSTM(XL){{RESET PROPER STNO VALUE{15360
{{MOV{3,KVLLN{3,KVLIN{{SET LASTLINE FROM LINE{15362
{{MOV{3,KVLIN{13,CDSLN(XL){{RESET PROPER LINE VALUE{15363
{{MOV{8,WA{3,KVRTN{{LOAD RETURN TYPE{15365
{{BEQ{8,WA{21,=SCRTN{6,EXIXR{EXIT WITH RESULT IN XR IF RETURN{15366
{{BEQ{8,WA{21,=SCFRT{6,EXFAL{FAIL IF FRETURN{15367
{{EJC{{{{{15368
*
*      RETRN (CONTINUED)
*
*      HERE FOR NRETURN
*
{{BEQ{9,(XR){22,=B_NML{6,RTN11{JUMP IF IS A NAME{15374
{{JSR{6,GTNVR{{{ELSE TRY CONVERT TO VARIABLE NAME{15375
{{ERR{1,243{26,Function result in NRETURN is not name{{{15376
{{MOV{7,XL{7,XR{{IF OK, COPY VRBLK (NAME BASE) PTR{15377
{{MOV{8,WA{19,*VRVAL{{SET NAME OFFSET{15378
{{BRN{6,RTN12{{{AND MERGE{15379
*
*      HERE IF RETURNED RESULT IS A NAME
*
{RTN11{MOV{7,XL{13,NMBAS(XR){{LOAD NAME BASE{15383
{{MOV{8,WA{13,NMOFS(XR){{LOAD NAME OFFSET{15384
*
*      MERGE HERE WITH RETURNED NAME IN (XL,WA)
*
{RTN12{MOV{7,XR{7,XL{{PRESERVE XL{15388
{{LCW{8,WB{{{LOAD NEXT WORD{15389
{{MOV{7,XL{7,XR{{RESTORE XL{15390
{{BEQ{8,WB{21,=OFNE_{6,EXNAM{EXIT IF CALLED BY NAME{15391
{{MOV{11,-(XS){8,WB{{ELSE SAVE CODE WORD{15392
{{JSR{6,ACESS{{{GET VALUE{15393
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{15394
{{MOV{7,XL{7,XR{{IF OK, COPY RESULT{15395
{{MOV{7,XR{9,(XS){{RELOAD NEXT CODE WORD{15396
{{MOV{9,(XS){7,XL{{STORE RESULT ON STACK{15397
{{MOV{7,XL{9,(XR){{LOAD ROUTINE ADDRESS{15398
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{15399
{{EJC{{{{{15400
*
*      STCOV -- SIGNAL STATEMENT COUNTER OVERFLOW
*
*      BRN  STCOV            JUMP TO SIGNAL STATEMENT COUNT OFLO
*
*      PERMIT UP TO 10 MORE STATEMENTS TO BE OBEYED SO THAT
*      SETEXIT TRAP CAN REGAIN CONTROL.
*      STCOV CONTINUES BY ISSUING THE ERROR MESSAGE
*
{STCOV{RTN{{{{{15410
{{ICV{3,ERRFT{{{FATAL ERROR{15411
{{LDI{4,INTVT{{{GET 10{15412
{{ADI{3,KVSTL{{{ADD TO FORMER LIMIT{15413
{{STI{3,KVSTL{{{STORE AS NEW STLIMIT{15414
{{LDI{4,INTVT{{{GET 10{15415
{{STI{3,KVSTC{{{SET AS NEW COUNT{15416
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{15417
{{ERB{1,244{26,Statement count exceeds value of STLIMIT keyword{{{15418
{{EJC{{{{{15419
*
*      STMGO -- START EXECUTION OF NEW STATEMENT
*
*      (XR)                  POINTER TO CDBLK FOR NEW STATEMENT
*      BRN  STMGO            JUMP TO EXECUTE NEW STATEMENT
*
*      STMGO CONTINUES BY EXECUTING THE NEXT STATEMENT
*
{STMGO{RTN{{{{{15428
{{MOV{3,R_COD{7,XR{{SET NEW CODE BLOCK POINTER{15429
{{DCV{3,STMCT{{{SEE IF TIME TO CHECK SOMETHING{15430
{{BZE{3,STMCT{6,STGO2{{JUMP IF SO{15431
{{MOV{3,KVLST{3,KVSTN{{SET LASTNO{15432
{{MOV{3,KVSTN{13,CDSTM(XR){{SET STNO{15433
{{MOV{3,KVLLN{3,KVLIN{{SET LASTLINE{15435
{{MOV{3,KVLIN{13,CDSLN(XR){{SET LINE{15436
{{ADD{7,XR{19,*CDCOD{{POINT TO FIRST CODE WORD{15438
{{LCP{7,XR{{{SET CODE POINTER{15439
*
*      HERE TO EXECUTE FIRST CODE WORD OF STATEMENT
*
{STGO1{LCW{7,XR{{{LOAD NEXT CODE WORD{15443
{{ZER{7,XL{{{CLEAR GARBAGE XL{15444
{{BRI{9,(XR){{{EXECUTE IT{15445
*
*      CHECK PROFILING, POLLING, STLIMIT, STATEMENT TRACING
*
{STGO2{BZE{3,KVPFL{6,STGO3{{SKIP IF NO PROFILING{15449
{{JSR{6,PRFLU{{{ELSE PROFILE THE STATEMENT IN KVSTN{15450
*
*      HERE WHEN FINISHED WITH PROFILING
*
{STGO3{MOV{3,KVLST{3,KVSTN{{SET LASTNO{15454
{{MOV{3,KVSTN{13,CDSTM(XR){{SET STNO{15455
{{MOV{3,KVLLN{3,KVLIN{{SET LASTLINE{15457
{{MOV{3,KVLIN{13,CDSLN(XR){{SET LINE{15458
{{ADD{7,XR{19,*CDCOD{{POINT TO FIRST CODE WORD{15460
{{LCP{7,XR{{{SET CODE POINTER{15461
*
*      HERE TO CHECK FOR POLLING
*
{{MOV{11,-(XS){3,STMCS{{SAVE PRESENT COUNT START ON STACK{15466
{{DCV{3,POLCT{{{POLL INTERVAL WITHIN STMCT{15467
{{BNZ{3,POLCT{6,STGO4{{JUMP IF NOT POLL TIME YET{15468
{{ZER{8,WA{{{=0 FOR POLL{15469
{{MOV{8,WB{3,KVSTN{{STATEMENT NUMBER{15470
{{MOV{7,XL{7,XR{{MAKE COLLECTABLE{15471
{{JSR{6,SYSPL{{{ALLOW INTERACTIVE ACCESS{15472
{{ERR{1,320{26,User interrupt{{{15473
{{PPM{{{{SINGLE STEP{15474
{{PPM{{{{EXPRESSION EVALUATION{15475
{{MOV{7,XR{7,XL{{RESTORE CODE BLOCK POINTER{15476
{{MOV{3,POLCS{8,WA{{POLL INTERVAL START VALUE{15477
{{JSR{6,STGCC{{{RECOMPUTE COUNTER VALUES{15478
*
*      CHECK STATEMENT LIMIT
*
{STGO4{LDI{3,KVSTC{{{GET STMT COUNT{15483
{{ILT{6,STGO5{{{OMIT COUNTING IF NEGATIVE{15484
{{MTI{10,(XS)+{{{RELOAD START VALUE OF COUNTER{15485
{{NGI{{{{NEGATE{15486
{{ADI{3,KVSTC{{{STMT COUNT MINUS COUNTER{15487
{{STI{3,KVSTC{{{REPLACE IT{15488
{{ILE{6,STCOV{{{FAIL IF STLIMIT REACHED{15489
{{BZE{3,R_STC{6,STGO5{{JUMP IF NO STATEMENT TRACE{15490
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{15491
{{MOV{7,XL{3,R_STC{{LOAD POINTER TO STCOUNT TRBLK{15492
{{JSR{6,KTREX{{{EXECUTE KEYWORD TRACE{15493
*
*      RESET STMGO COUNTER
*
{STGO5{MOV{3,STMCT{3,STMCS{{RESET COUNTER{15497
{{BRN{6,STGO1{{{FETCH NEXT CODE WORD{15498
{{EJC{{{{{15499
*
*      STOPR -- TERMINATE RUN
*
*      (XR)                  POINTS TO ENDING MESSAGE
*      BRN STOPR             JUMP TO TERMINATE RUN
*
*      TERMINATE RUN AND PRINT STATISTICS.  ON ENTRY XR POINTS
*      TO ENDING MESSAGE OR IS ZERO IF MESSAGE  PRINTED ALREADY.
*
{STOPR{RTN{{{{{15509
{{BZE{7,XR{6,STPRA{{SKIP IF SYSAX ALREADY CALLED{15511
{{JSR{6,SYSAX{{{CALL AFTER EXECUTION PROC{15512
{STPRA{ADD{3,DNAME{3,RSMEM{{USE THE RESERVE MEMORY{15513
{{BNE{7,XR{21,=ENDMS{6,STPR0{SKIP IF NOT NORMAL END MESSAGE{15517
{{BNZ{3,EXSTS{6,STPR3{{SKIP IF EXEC STATS SUPPRESSED{15518
{{ZER{3,ERICH{{{CLEAR ERRORS TO INT.CH. FLAG{15519
*
*      LOOK TO SEE IF AN ENDING MESSAGE IS SUPPLIED
*
{STPR0{JSR{6,PRTPG{{{EJECT PRINTER{15523
{{BZE{7,XR{6,STPR1{{SKIP IF NO MESSAGE{15524
{{JSR{6,PRTST{{{PRINT MESSAGE{15525
*
*      MERGE HERE IF NO MESSAGE TO PRINT
*
{STPR1{JSR{6,PRTIS{{{PRINT BLANK LINE{15529
{{BNZ{3,GBCFL{6,STPR5{{IF IN GARBAGE COLLECTION, SKIP{15531
{{MOV{7,XR{21,=STPM7{{POINT TO MESSAGE /IN FILE XXX/{15532
{{JSR{6,PRTST{{{PRINT IT{15533
{{MOV{3,PROFS{18,=PRTMF{{SET COLUMN OFFSET{15534
{{MOV{8,WC{3,KVSTN{{GET STATEMENT NUMBER{15535
{{JSR{6,FILNM{{{GET FILE NAME{15536
{{MOV{7,XR{7,XL{{PREPARE TO PRINT{15537
{{JSR{6,PRTST{{{PRINT FILE NAME{15538
{{JSR{6,PRTIS{{{PRINT TO INTERACTIVE CHANNEL{15539
{{MOV{7,XR{3,R_COD{{GET CODE POINTER{15546
{{MTI{13,CDSLN(XR){{{GET SOURCE LINE NUMBER{15547
{{MOV{7,XR{21,=STPM6{{POINT TO MESSAGE /IN LINE XXX/{15548
{{JSR{6,PRTMX{{{PRINT IT{15549
{STPR5{MTI{3,KVSTN{{{GET STATEMENT NUMBER{15551
{{MOV{7,XR{21,=STPM1{{POINT TO MESSAGE /IN STATEMENT XXX/{15552
{{JSR{6,PRTMX{{{PRINT IT{15553
{{JSR{6,SYSTM{{{GET CURRENT TIME{15554
{{SBI{3,TIMSX{{{MINUS START TIME = ELAPSED EXEC TIM{15555
{{STI{3,STPTI{{{SAVE FOR LATER{15556
{{MOV{7,XR{21,=STPM3{{POINT TO MSG /EXECUTION TIME MSEC /{15557
{{JSR{6,PRTMX{{{PRINT IT{15558
{{LDI{3,KVSTL{{{GET STATEMENT LIMIT{15559
{{ILT{6,STPR2{{{SKIP IF NEGATIVE{15560
{{SBI{3,KVSTC{{{MINUS COUNTER = COURSE COUNT{15561
{{STI{3,STPSI{{{SAVE{15562
{{MOV{8,WA{3,STMCS{{REFINE WITH COUNTER START VALUE{15563
{{SUB{8,WA{3,STMCT{{MINUS CURRENT COUNTER{15564
{{MTI{8,WA{{{CONVERT TO INTEGER{15565
{{ADI{3,STPSI{{{ADD IN COURSE COUNT{15566
{{STI{3,STPSI{{{SAVE{15567
{{MOV{7,XR{21,=STPM2{{POINT TO MESSAGE /STMTS EXECUTED/{15568
{{JSR{6,PRTMX{{{PRINT IT{15569
{{LDI{3,STPTI{{{RELOAD ELAPSED TIME{15572
{{MLI{4,INTTH{{{*1000 (MICROSECS){15573
{{IOV{6,STPR2{{{JUMP IF WE CANNOT COMPUTE{15574
{{DVI{3,STPSI{{{DIVIDE BY STATEMENT COUNT{15575
{{IOV{6,STPR2{{{JUMP IF OVERFLOW{15576
{{MOV{7,XR{21,=STPM4{{POINT TO MSG (MCSEC PER STATEMENT /{15577
{{JSR{6,PRTMX{{{PRINT IT{15578
{{EJC{{{{{15580
*
*      STOPR (CONTINUED)
*
*      MERGE TO SKIP MESSAGE (OVERFLOW OR NEGATIVE STLIMIT)
*
{STPR2{MTI{3,GBCNT{{{LOAD COUNT OF COLLECTIONS{15586
{{MOV{7,XR{21,=STPM5{{POINT TO MESSAGE /REGENERATIONS /{15587
{{JSR{6,PRTMX{{{PRINT IT{15588
{{JSR{6,PRTMM{{{PRINT MEMORY USAGE{15589
{{JSR{6,PRTIS{{{ONE MORE BLANK FOR LUCK{15590
*
*      CHECK IF DUMP REQUESTED
*
{STPR3{JSR{6,PRFLR{{{PRINT PROFILE IF WANTED{15597
*
{{MOV{7,XR{3,KVDMP{{LOAD DUMP KEYWORD{15599
{{JSR{6,DUMPR{{{EXECUTE DUMP IF REQUESTED{15601
{{MOV{7,XL{3,R_FCB{{GET FCBLK CHAIN HEAD{15602
{{MOV{8,WA{3,KVABE{{LOAD ABEND VALUE{15603
{{MOV{8,WB{3,KVCOD{{LOAD CODE VALUE{15604
{{JSR{6,SYSEJ{{{EXIT TO SYSTEM{15605
*
*      HERE AFTER SYSEA CALL AND SUPPRESSING ERROR MSG PRINT
*
{STPR4{RTN{{{{{15610
{{ADD{3,DNAME{3,RSMEM{{USE THE RESERVE MEMORY{15611
{{BZE{3,EXSTS{6,STPR1{{IF EXECUTION STATS REQUESTED{15612
{{BRN{6,STPR3{{{CHECK IF DUMP OR PROFILE NEEDED{15613
{{EJC{{{{{15616
*
*      SUCCP -- SIGNAL SUCCESSFUL MATCH OF A PATTERN NODE
*
*      SEE PATTERN MATCH ROUTINES FOR DETAILS
*
*      (XR)                  CURRENT NODE
*      (WB)                  CURRENT CURSOR
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  SUCCP            SIGNAL SUCCESSFUL PATTERN MATCH
*
*      SUCCP CONTINUES BY MATCHING THE SUCCESSOR NODE
*
{SUCCP{RTN{{{{{15629
{{MOV{7,XR{13,PTHEN(XR){{LOAD SUCCESSOR NODE{15630
{{MOV{7,XL{9,(XR){{LOAD NODE CODE ENTRY ADDRESS{15631
{{BRI{7,XL{{{JUMP TO MATCH SUCCESSOR NODE{15632
{{EJC{{{{{15633
*
*      SYSAB -- PRINT /ABNORMAL END/ AND TERMINATE
*
{SYSAB{RTN{{{{{15637
{{MOV{7,XR{21,=ENDAB{{POINT TO MESSAGE{15638
{{MOV{3,KVABE{18,=NUM01{{SET ABEND FLAG{15639
{{JSR{6,PRTNL{{{SKIP TO NEW LINE{15640
{{BRN{6,STOPR{{{JUMP TO PACK UP{15641
{{EJC{{{{{15642
*
*      SYSTU -- PRINT /TIME UP/ AND TERMINATE
*
{SYSTU{RTN{{{{{15646
{{MOV{7,XR{21,=ENDTU{{POINT TO MESSAGE{15647
{{MOV{8,WA{4,STRTU{{GET CHARS /TU/{15648
{{MOV{3,KVCOD{8,WA{{PUT IN KVCOD{15649
{{MOV{8,WA{3,TIMUP{{CHECK STATE OF TIMEUP SWITCH{15650
{{MNZ{3,TIMUP{{{SET SWITCH{15651
{{BNZ{8,WA{6,STOPR{{STOP RUN IF ALREADY SET{15652
{{ERB{1,245{26,Translation/execution time expired{{{15653
{{TTL{27,S P I T B O L -- UTILITY PROCEDURES{{{{15654
*
*      THE FOLLOWING SECTION CONTAINS PROCEDURES WHICH ARE
*      USED FOR VARIOUS PURPOSES THROUGHOUT THE SYSTEM.
*
*      EACH PROCEDURE IS PRECEDED BY A DESCRIPTION OF THE
*      CALLING SEQUENCE. USUALLY THE ARGUMENTS ARE IN REGISTERS
*      BUT ARGUMENTS CAN ALSO OCCUR ON THE STACK AND AS
*      PARAMETERS ASSEMBLED AFTER THE JSR INSTRUCTION.
*
*      THE FOLLOWING CONSIDERATIONS APPLY TO THESE DESCRIPTIONS.
*
*      1)   THE STACK POINTER (XS) IS NOT CHANGED UNLESS THE
*           CHANGE IS EXPLICITLY DOCUMENTED IN THE CALL.
*
*      2)   REGISTERS WHOSE ENTRY VALUES ARE NOT MENTIONED
*           MAY CONTAIN ANY VALUE EXCEPT THAT XL,XR MAY ONLY
*           CONTAIN PROPER (COLLECTABLE) POINTER VALUES.
*           THIS CONDITION ON MEANS THAT THE CALLED ROUTINE
*           MAY IF IT CHOOSES PRESERVE XL,XR BY STACKING.
*
*      3)   REGISTERS NOT MENTIONED ON EXIT CONTAIN THE SAME
*           VALUES AS THEY DID ON ENTRY EXCEPT THAT VALUES IN
*           XR,XL MAY HAVE BEEN RELOCATED BY THE COLLECTOR.
*
*      4)   REGISTERS WHICH ARE DESTROYED ON EXIT MAY CONTAIN
*           ANY VALUE EXCEPT THAT VALUES IN XL,XR ARE PROPER
*           (COLLECTABLE) POINTERS.
*
*      5)   THE CODE POINTER REGISTER POINTS TO THE CURRENT
*           CODE LOCATION ON ENTRY AND IS UNCHANGED ON EXIT.
*
*      IN THE ABOVE DESCRIPTION, A COLLECTABLE POINTER IS ONE
*      WHICH EITHER POINTS OUTSIDE THE DYNAMIC REGION OR
*      POINTS TO THE START OF A BLOCK IN THE DYNAMIC REGION.
*
*      IN THOSE CASES WHERE THE CALLING SEQUENCE CONTAINS
*      PARAMETERS WHICH ARE USED AS ALTERNATE RETURN POINTS,
*      THESE PARAMETERS MAY BE REPLACED BY ERROR CODES
*      ASSEMBLED WITH THE ERR INSTRUCTION. THIS WILL RESULT
*      IN THE POSTING OF THE ERROR IF THE RETURN IS TAKEN.
*
*      THE PROCEDURES ALL HAVE NAMES CONSISTING OF FIVE LETTERS
*      AND ARE IN ALPHABETICAL ORDER BY THEIR NAMES.
{{EJC{{{{{15698
*
*      ACESS - ACCESS VARIABLE VALUE WITH TRACE/INPUT CHECKS
*
*      ACESS LOADS THE VALUE OF A VARIABLE. TRACE AND INPUT
*      ASSOCIATIONS ARE TESTED FOR AND EXECUTED AS REQUIRED.
*      ACESS ALSO HANDLES THE SPECIAL CASES OF PSEUDO-VARIABLES.
*
*      (XL)                  VARIABLE NAME BASE
*      (WA)                  VARIABLE NAME OFFSET
*      JSR  ACESS            CALL TO ACCESS VALUE
*      PPM  LOC              TRANSFER LOC IF ACCESS FAILURE
*      (XR)                  VARIABLE VALUE
*      (WA,WB,WC)            DESTROYED
*      (XL,RA)               DESTROYED
*
*      FAILURE CAN OCCUR IF AN INPUT ASSOCIATION CAUSES AN END
*      OF FILE CONDITION OR IF THE EVALUATION OF AN EXPRESSION
*      ASSOCIATED WITH AN EXPRESSION VARIABLE FAILS.
*
{ACESS{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){15718
{{MOV{7,XR{7,XL{{COPY NAME BASE{15719
{{ADD{7,XR{8,WA{{POINT TO VARIABLE LOCATION{15720
{{MOV{7,XR{9,(XR){{LOAD VARIABLE VALUE{15721
*
*      LOOP HERE TO CHECK FOR SUCCESSIVE TRBLKS
*
{ACS02{BNE{9,(XR){22,=B_TRT{6,ACS18{JUMP IF NOT TRAPPED{15725
*
*      HERE IF TRAPPED
*
{{BEQ{7,XR{21,=TRBKV{6,ACS12{JUMP IF KEYWORD VARIABLE{15729
{{BNE{7,XR{21,=TRBEV{6,ACS05{JUMP IF NOT EXPRESSION VARIABLE{15730
*
*      HERE FOR EXPRESSION VARIABLE, EVALUATE VARIABLE
*
{{MOV{7,XR{13,EVEXP(XL){{LOAD EXPRESSION POINTER{15734
{{ZER{8,WB{{{EVALUATE BY VALUE{15735
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{15736
{{PPM{6,ACS04{{{JUMP IF EVALUATION FAILURE{15737
{{BRN{6,ACS02{{{CHECK VALUE FOR MORE TRBLKS{15738
{{EJC{{{{{15739
*
*      ACESS (CONTINUED)
*
*      HERE ON READING END OF FILE
*
{ACS03{ADD{7,XS{19,*NUM03{{POP TRBLK PTR, NAME BASE AND OFFSET{15745
{{MOV{3,DNAMP{7,XR{{POP UNUSED SCBLK{15746
*
*      MERGE HERE WHEN EVALUATION OF EXPRESSION FAILS
*
{ACS04{EXI{1,1{{{TAKE ALTERNATE (FAILURE) RETURN{15750
*
*      HERE IF NOT KEYWORD OR EXPRESSION VARIABLE
*
{ACS05{MOV{8,WB{13,TRTYP(XR){{LOAD TRAP TYPE CODE{15754
{{BNZ{8,WB{6,ACS10{{JUMP IF NOT INPUT ASSOCIATION{15755
{{BZE{3,KVINP{6,ACS09{{IGNORE INPUT ASSOC IF INPUT IS OFF{15756
*
*      HERE FOR INPUT ASSOCIATION
*
{{MOV{11,-(XS){7,XL{{STACK NAME BASE{15760
{{MOV{11,-(XS){8,WA{{STACK NAME OFFSET{15761
{{MOV{11,-(XS){7,XR{{STACK TRBLK POINTER{15762
{{MOV{3,ACTRM{3,KVTRM{{TEMP TO HOLD TRIM KEYWORD{15763
{{MOV{7,XL{13,TRFPT(XR){{GET FILE CTRL BLK PTR OR ZERO{15764
{{BNZ{7,XL{6,ACS06{{JUMP IF NOT STANDARD INPUT FILE{15765
{{BEQ{13,TRTER(XR){21,=V_TER{6,ACS21{JUMP IF TERMINAL{15766
*
*      HERE TO READ FROM STANDARD INPUT FILE
*
{{MOV{8,WA{3,CSWIN{{LENGTH FOR READ BUFFER{15770
{{JSR{6,ALOCS{{{BUILD STRING OF APPROPRIATE LENGTH{15771
{{JSR{6,SYSRD{{{READ NEXT STANDARD INPUT IMAGE{15772
{{PPM{6,ACS03{{{JUMP TO FAIL EXIT IF END OF FILE{15773
{{BRN{6,ACS07{{{ELSE MERGE WITH OTHER FILE CASE{15774
*
*      HERE FOR INPUT FROM OTHER THAN STANDARD INPUT FILE
*
{ACS06{MOV{8,WA{7,XL{{FCBLK PTR{15778
{{JSR{6,SYSIL{{{GET INPUT RECORD MAX LENGTH (TO WA){15779
{{BNZ{8,WC{6,ACS6A{{JUMP IF NOT BINARY FILE{15780
{{MOV{3,ACTRM{8,WC{{DISABLE TRIM FOR BINARY FILE{15781
{ACS6A{JSR{6,ALOCS{{{ALLOCATE STRING OF CORRECT SIZE{15782
{{MOV{8,WA{7,XL{{FCBLK PTR{15783
{{JSR{6,SYSIN{{{CALL SYSTEM INPUT ROUTINE{15784
{{PPM{6,ACS03{{{JUMP TO FAIL EXIT IF END OF FILE{15785
{{PPM{6,ACS22{{{ERROR{15786
{{PPM{6,ACS23{{{ERROR{15787
{{EJC{{{{{15788
*
*      ACESS (CONTINUED)
*
*      MERGE HERE AFTER OBTAINING INPUT RECORD
*
{ACS07{MOV{8,WB{3,ACTRM{{LOAD TRIM INDICATOR{15794
{{JSR{6,TRIMR{{{TRIM RECORD AS REQUIRED{15795
{{MOV{8,WB{7,XR{{COPY RESULT POINTER{15796
{{MOV{7,XR{9,(XS){{RELOAD POINTER TO TRBLK{15797
*
*      LOOP TO CHASE TO END OF TRBLK CHAIN AND STORE VALUE
*
{ACS08{MOV{7,XL{7,XR{{SAVE POINTER TO THIS TRBLK{15801
{{MOV{7,XR{13,TRNXT(XR){{LOAD FORWARD POINTER{15802
{{BEQ{9,(XR){22,=B_TRT{6,ACS08{LOOP IF THIS IS ANOTHER TRBLK{15803
{{MOV{13,TRNXT(XL){8,WB{{ELSE STORE RESULT AT END OF CHAIN{15804
{{MOV{7,XR{10,(XS)+{{RESTORE INITIAL TRBLK POINTER{15805
{{MOV{8,WA{10,(XS)+{{RESTORE NAME OFFSET{15806
{{MOV{7,XL{10,(XS)+{{RESTORE NAME BASE POINTER{15807
*
*      COME HERE TO MOVE TO NEXT TRBLK
*
{ACS09{MOV{7,XR{13,TRNXT(XR){{LOAD FORWARD PTR TO NEXT VALUE{15811
{{BRN{6,ACS02{{{BACK TO CHECK IF TRAPPED{15812
*
*      HERE TO CHECK FOR ACCESS TRACE TRBLK
*
{ACS10{BNE{8,WB{18,=TRTAC{6,ACS09{LOOP BACK IF NOT ACCESS TRACE{15816
{{BZE{3,KVTRA{6,ACS09{{IGNORE ACCESS TRACE IF TRACE OFF{15817
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{15818
{{BZE{13,TRFNC(XR){6,ACS11{{JUMP IF PRINT TRACE{15819
{{EJC{{{{{15820
*
*      ACESS (CONTINUED)
*
*      HERE FOR FULL FUNCTION TRACE
*
{{JSR{6,TRXEQ{{{CALL ROUTINE TO EXECUTE TRACE{15826
{{BRN{6,ACS09{{{JUMP FOR NEXT TRBLK{15827
*
*      HERE FOR CASE OF PRINT TRACE
*
{ACS11{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{15831
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{15832
{{BRN{6,ACS09{{{JUMP BACK FOR NEXT TRBLK{15833
*
*      HERE FOR KEYWORD VARIABLE
*
{ACS12{MOV{7,XR{13,KVNUM(XL){{LOAD KEYWORD NUMBER{15837
{{BGE{7,XR{18,=K_V__{6,ACS14{JUMP IF NOT ONE WORD VALUE{15838
{{MTI{15,KVABE(XR){{{ELSE LOAD VALUE AS INTEGER{15839
*
*      COMMON EXIT WITH KEYWORD VALUE AS INTEGER IN (IA)
*
{ACS13{JSR{6,ICBLD{{{BUILD ICBLK{15843
{{BRN{6,ACS18{{{JUMP TO EXIT{15844
*
*      HERE IF NOT ONE WORD KEYWORD VALUE
*
{ACS14{BGE{7,XR{18,=K_S__{6,ACS15{JUMP IF SPECIAL CASE{15848
{{SUB{7,XR{18,=K_V__{{ELSE GET OFFSET{15849
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{15850
{{ADD{7,XR{21,=NDABO{{POINT TO PATTERN VALUE{15851
{{BRN{6,ACS18{{{JUMP TO EXIT{15852
*
*      HERE IF SPECIAL KEYWORD CASE
*
{ACS15{MOV{7,XL{3,KVRTN{{LOAD RTNTYPE IN CASE{15856
{{LDI{3,KVSTL{{{LOAD STLIMIT IN CASE{15857
{{SUB{7,XR{18,=K_S__{{GET CASE NUMBER{15858
{{BSW{7,XR{2,K__N_{{SWITCH ON KEYWORD NUMBER{15859
{{IFF{2,K__AL{6,ACS16{{JUMP IF ALPHABET{15873
{{IFF{2,K__RT{6,ACS17{{RTNTYPE{15873
{{IFF{2,K__SC{6,ACS19{{STCOUNT{15873
{{IFF{2,K__ET{6,ACS20{{ERRTEXT{15873
{{IFF{2,K__FL{6,ACS26{{FILE{15873
{{IFF{2,K__LF{6,ACS27{{LASTFILE{15873
{{IFF{2,K__SL{6,ACS13{{STLIMIT{15873
{{IFF{2,K__LC{6,ACS24{{LCASE{15873
{{IFF{2,K__UC{6,ACS25{{UCASE{15873
{{ESW{{{{END SWITCH ON KEYWORD NUMBER{15873
{{EJC{{{{{15874
*
*      ACESS (CONTINUED)
*
*      LCASE
*
{ACS24{MOV{7,XR{21,=LCASE{{LOAD POINTER TO LCASE STRING{15881
{{BRN{6,ACS18{{{COMMON RETURN{15882
*
*      UCASE
*
{ACS25{MOV{7,XR{21,=UCASE{{LOAD POINTER TO UCASE STRING{15886
{{BRN{6,ACS18{{{COMMON RETURN{15887
*
*      FILE
*
{ACS26{MOV{8,WC{3,KVSTN{{LOAD CURRENT STMT NUMBER{15893
{{BRN{6,ACS28{{{MERGE TO OBTAIN FILE NAME{15894
*
*      LASTFILE
*
{ACS27{MOV{8,WC{3,KVLST{{LOAD LAST STMT NUMBER{15898
*
*      MERGE HERE TO MAP STATEMENT NUMBER IN WC TO FILE NAME
*
{ACS28{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STMT{15902
{{BRN{6,ACS17{{{MERGE TO RETURN STRING IN XL{15903
*      ALPHABET
*
{ACS16{MOV{7,XL{3,KVALP{{LOAD POINTER TO ALPHABET STRING{15907
*
*      RTNTYPE MERGES HERE
*
{ACS17{MOV{7,XR{7,XL{{COPY STRING PTR TO PROPER REG{15911
*
*      COMMON RETURN POINT
*
{ACS18{EXI{{{{RETURN TO ACESS CALLER{15915
*
*      HERE FOR STCOUNT (IA HAS STLIMIT)
*
{ACS19{ILT{6,ACS29{{{IF COUNTING SUPPRESSED{15919
{{MOV{8,WA{3,STMCS{{REFINE WITH COUNTER START VALUE{15920
{{SUB{8,WA{3,STMCT{{MINUS CURRENT COUNTER{15921
{{MTI{8,WA{{{CONVERT TO INTEGER{15922
{{ADI{3,KVSTL{{{ADD STLIMIT{15923
{ACS29{SBI{3,KVSTC{{{STCOUNT = LIMIT - LEFT{15924
{{BRN{6,ACS13{{{MERGE BACK WITH INTEGER RESULT{15925
*
*      ERRTEXT
*
{ACS20{MOV{7,XR{3,R_ETX{{GET ERRTEXT STRING{15929
{{BRN{6,ACS18{{{MERGE WITH RESULT{15930
*
*      HERE TO READ A RECORD FROM TERMINAL
*
{ACS21{MOV{8,WA{18,=RILEN{{BUFFER LENGTH{15934
{{JSR{6,ALOCS{{{ALLOCATE BUFFER{15935
{{JSR{6,SYSRI{{{READ RECORD{15936
{{PPM{6,ACS03{{{ENDFILE{15937
{{BRN{6,ACS07{{{MERGE WITH RECORD READ{15938
*
*      ERROR RETURNS
*
{ACS22{MOV{3,DNAMP{7,XR{{POP UNUSED SCBLK{15942
{{ERB{1,202{26,Input from file caused non-recoverable error{{{15943
*
{ACS23{MOV{3,DNAMP{7,XR{{POP UNUSED SCBLK{15945
{{ERB{1,203{26,Input file record has incorrect format{{{15946
{{ENP{{{{END PROCEDURE ACESS{15947
{{EJC{{{{{15948
*
*      ACOMP -- COMPARE TWO ARITHMETIC VALUES
*
*      1(XS)                 FIRST ARGUMENT
*      0(XS)                 SECOND ARGUMENT
*      JSR  ACOMP            CALL TO COMPARE VALUES
*      PPM  LOC              TRANSFER LOC IF ARG1 IS NON-NUMERIC
*      PPM  LOC              TRANSFER LOC IF ARG2 IS NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR ARG1 LT ARG2
*      PPM  LOC              TRANSFER LOC FOR ARG1 EQ ARG2
*      PPM  LOC              TRANSFER LOC FOR ARG1 GT ARG2
*      (NORMAL RETURN IS NEVER GIVEN)
*      (WA,WB,WC,IA,RA)      DESTROYED
*      (XL,XR)               DESTROYED
*
{ACOMP{PRC{25,N{1,5{{ENTRY POINT{15964
{{JSR{6,ARITH{{{LOAD ARITHMETIC OPERANDS{15965
{{PPM{6,ACMP7{{{JUMP IF FIRST ARG NON-NUMERIC{15966
{{PPM{6,ACMP8{{{JUMP IF SECOND ARG NON-NUMERIC{15967
{{PPM{6,ACMP4{{{JUMP IF REAL ARGUMENTS{15970
*
*      HERE FOR INTEGER ARGUMENTS
*
{{SBI{13,ICVAL(XL){{{SUBTRACT TO COMPARE{15975
{{IOV{6,ACMP3{{{JUMP IF OVERFLOW{15976
{{ILT{6,ACMP5{{{ELSE JUMP IF ARG1 LT ARG2{15977
{{IEQ{6,ACMP2{{{JUMP IF ARG1 EQ ARG2{15978
*
*      HERE IF ARG1 GT ARG2
*
{ACMP1{EXI{1,5{{{TAKE GT EXIT{15982
*
*      HERE IF ARG1 EQ ARG2
*
{ACMP2{EXI{1,4{{{TAKE EQ EXIT{15986
{{EJC{{{{{15987
*
*      ACOMP (CONTINUED)
*
*      HERE FOR INTEGER OVERFLOW ON SUBTRACT
*
{ACMP3{LDI{13,ICVAL(XL){{{LOAD SECOND ARGUMENT{15993
{{ILT{6,ACMP1{{{GT IF NEGATIVE{15994
{{BRN{6,ACMP5{{{ELSE LT{15995
*
*      HERE FOR REAL OPERANDS
*
{ACMP4{SBR{13,RCVAL(XL){{{SUBTRACT TO COMPARE{16001
{{ROV{6,ACMP6{{{JUMP IF OVERFLOW{16002
{{RGT{6,ACMP1{{{ELSE JUMP IF ARG1 GT{16003
{{REQ{6,ACMP2{{{JUMP IF ARG1 EQ ARG2{16004
*
*      HERE IF ARG1 LT ARG2
*
{ACMP5{EXI{1,3{{{TAKE LT EXIT{16009
*
*      HERE IF OVERFLOW ON REAL SUBTRACTION
*
{ACMP6{LDR{13,RCVAL(XL){{{RELOAD ARG2{16015
{{RLT{6,ACMP1{{{GT IF NEGATIVE{16016
{{BRN{6,ACMP5{{{ELSE LT{16017
*
*      HERE IF ARG1 NON-NUMERIC
*
{ACMP7{EXI{1,1{{{TAKE ERROR EXIT{16022
*
*      HERE IF ARG2 NON-NUMERIC
*
{ACMP8{EXI{1,2{{{TAKE ERROR EXIT{16026
{{ENP{{{{END PROCEDURE ACOMP{16027
{{EJC{{{{{16028
*
*      ALLOC                 ALLOCATE BLOCK OF DYNAMIC STORAGE
*
*      (WA)                  LENGTH REQUIRED IN BYTES
*      JSR  ALLOC            CALL TO ALLOCATE BLOCK
*      (XR)                  POINTER TO ALLOCATED BLOCK
*
*      A POSSIBLE ALTERNATIVE TO AOV ... AND FOLLOWING STMT IS -
*      MOV  DNAME,XR .  SUB  WA,XR .  BLO XR,DNAMP,ALOC2 .
*      MOV  DNAMP,XR .  ADD  WA,XR
*
{ALLOC{PRC{25,E{1,0{{ENTRY POINT{16040
*
*      COMMON EXIT POINT
*
{ALOC1{MOV{7,XR{3,DNAMP{{POINT TO NEXT AVAILABLE LOC{16044
{{AOV{8,WA{7,XR{6,ALOC2{POINT PAST ALLOCATED BLOCK{16045
{{BGT{7,XR{3,DNAME{6,ALOC2{JUMP IF NOT ENOUGH ROOM{16046
{{MOV{3,DNAMP{7,XR{{STORE NEW POINTER{16047
{{SUB{7,XR{8,WA{{POINT BACK TO START OF ALLOCATED BK{16048
{{EXI{{{{RETURN TO CALLER{16049
*
*      HERE IF INSUFFICIENT ROOM, TRY A GARBAGE COLLECTION
*
{ALOC2{MOV{3,ALLSV{8,WB{{SAVE WB{16053
{ALC2A{ZER{8,WB{{{SET NO UPWARD MOVE FOR GBCOL{16054
{{JSR{6,GBCOL{{{GARBAGE COLLECT{16055
{{MOV{8,WB{7,XR{{REMEMBER NEW SEDIMENT SIZE{16057
*
*      SEE IF ROOM AFTER GBCOL OR SYSMM CALL
*
{ALOC3{MOV{7,XR{3,DNAMP{{POINT TO FIRST AVAILABLE LOC{16062
{{AOV{8,WA{7,XR{6,ALC3A{POINT PAST NEW BLOCK{16063
{{BLO{7,XR{3,DNAME{6,ALOC4{JUMP IF THERE IS ROOM NOW{16064
*
*      FAILED AGAIN, SEE IF WE CAN GET MORE CORE
*
{ALC3A{JSR{6,SYSMM{{{TRY TO GET MORE MEMORY{16068
{{WTB{7,XR{{{CONVERT TO BAUS (SGD05){16069
{{ADD{3,DNAME{7,XR{{BUMP PTR BY AMOUNT OBTAINED{16070
{{BNZ{7,XR{6,ALOC3{{JUMP IF GOT MORE CORE{16071
{{BZE{3,DNAMS{6,ALC3B{{JUMP IF THERE WAS NO SEDIMENT{16073
{{ZER{3,DNAMS{{{TRY COLLECTING THE SEDIMENT{16074
{{BRN{6,ALC2A{{{{16075
*
*      SYSMM FAILED AND THERE WAS NO SEDIMENT TO COLLECT
*
{ALC3B{ADD{3,DNAME{3,RSMEM{{GET THE RESERVE MEMORY{16079
{{ZER{3,RSMEM{{{ONLY PERMISSIBLE ONCE{16083
{{ICV{3,ERRFT{{{FATAL ERROR{16084
{{ERB{1,204{26,Memory overflow{{{16085
{{EJC{{{{{16086
*
*      HERE AFTER SUCCESSFUL GARBAGE COLLECTION
*
{ALOC4{STI{3,ALLIA{{{SAVE IA{16090
{{MOV{3,DNAMS{8,WB{{RECORD NEW SEDIMENT SIZE{16092
{{MOV{8,WB{3,DNAME{{GET DYNAMIC END ADRS{16094
{{SUB{8,WB{3,DNAMP{{COMPUTE FREE STORE{16095
{{BTW{8,WB{{{CONVERT BYTES TO WORDS{16096
{{MTI{8,WB{{{PUT FREE STORE IN IA{16097
{{MLI{3,ALFSF{{{MULTIPLY BY FREE STORE FACTOR{16098
{{IOV{6,ALOC5{{{JUMP IF OVERFLOWED{16099
{{MOV{8,WB{3,DNAME{{DYNAMIC END ADRS{16100
{{SUB{8,WB{3,DNAMB{{COMPUTE TOTAL AMOUNT OF DYNAMIC{16101
{{BTW{8,WB{{{CONVERT TO WORDS{16102
{{MOV{3,ALDYN{8,WB{{STORE IT{16103
{{SBI{3,ALDYN{{{SUBTRACT FROM SCALED UP FREE STORE{16104
{{IGT{6,ALOC5{{{JUMP IF SUFFICIENT FREE STORE{16105
{{JSR{6,SYSMM{{{TRY TO GET MORE STORE{16106
{{WTB{7,XR{{{CONVERT TO BAUS (SGD05){16107
{{ADD{3,DNAME{7,XR{{ADJUST DYNAMIC END ADRS{16108
*
*      MERGE TO RESTORE IA AND WB
*
{ALOC5{LDI{3,ALLIA{{{RECOVER IA{16112
{{MOV{8,WB{3,ALLSV{{RESTORE WB{16113
{{BRN{6,ALOC1{{{JUMP BACK TO EXIT{16114
{{ENP{{{{END PROCEDURE ALLOC{16115
{{EJC{{{{{16116
*
*      ALOCS -- ALLOCATE STRING BLOCK
*
*      ALOCS IS USED TO BUILD A FRAME FOR A STRING BLOCK INTO
*      WHICH THE ACTUAL CHARACTERS ARE PLACED BY THE CALLER.
*      ALL STRINGS ARE CREATED WITH A CALL TO ALOCS (THE
*      EXCEPTIONS OCCUR IN TRIMR AND S_RPL PROCEDURES).
*
*      (WA)                  LENGTH OF STRING TO BE ALLOCATED
*      JSR  ALOCS            CALL TO ALLOCATE SCBLK
*      (XR)                  POINTER TO RESULTING SCBLK
*      (WA)                  DESTROYED
*      (WC)                  CHARACTER COUNT (ENTRY VALUE OF WA)
*
*      THE RESULTING SCBLK HAS THE TYPE WORD AND THE LENGTH
*      FILLED IN AND THE LAST WORD IS CLEARED TO ZERO CHARACTERS
*      TO ENSURE CORRECT RIGHT PADDING OF THE FINAL WORD.
*
{ALOCS{PRC{25,E{1,0{{ENTRY POINT{16176
{{BGT{8,WA{3,KVMXL{6,ALCS2{JUMP IF LENGTH EXCEEDS MAXLENGTH{16177
{{MOV{8,WC{8,WA{{ELSE COPY LENGTH{16178
{{CTB{8,WA{2,SCSI_{{COMPUTE LENGTH OF SCBLK IN BYTES{16179
{{MOV{7,XR{3,DNAMP{{POINT TO NEXT AVAILABLE LOCATION{16180
{{AOV{8,WA{7,XR{6,ALCS0{POINT PAST BLOCK{16181
{{BLO{7,XR{3,DNAME{6,ALCS1{JUMP IF THERE IS ROOM{16182
*
*      INSUFFICIENT MEMORY
*
{ALCS0{ZER{7,XR{{{ELSE CLEAR GARBAGE XR VALUE{16186
{{JSR{6,ALLOC{{{AND USE STANDARD ALLOCATOR{16187
{{ADD{7,XR{8,WA{{POINT PAST END OF BLOCK TO MERGE{16188
*
*      MERGE HERE WITH XR POINTING BEYOND NEW BLOCK
*
{ALCS1{MOV{3,DNAMP{7,XR{{SET UPDATED STORAGE POINTER{16192
{{ZER{11,-(XR){{{STORE ZERO CHARS IN LAST WORD{16193
{{DCA{8,WA{{{DECREMENT LENGTH{16194
{{SUB{7,XR{8,WA{{POINT BACK TO START OF BLOCK{16195
{{MOV{9,(XR){22,=B_SCL{{SET TYPE WORD{16196
{{MOV{13,SCLEN(XR){8,WC{{STORE LENGTH IN CHARS{16197
{{EXI{{{{RETURN TO ALOCS CALLER{16198
*
*      COME HERE IF STRING IS TOO LONG
*
{ALCS2{ERB{1,205{26,String length exceeds value of MAXLNGTH keyword{{{16202
{{ENP{{{{END PROCEDURE ALOCS{16203
{{EJC{{{{{16204
*
*      ALOST -- ALLOCATE SPACE IN STATIC REGION
*
*      (WA)                  LENGTH REQUIRED IN BYTES
*      JSR  ALOST            CALL TO ALLOCATE SPACE
*      (XR)                  POINTER TO ALLOCATED BLOCK
*      (WB)                  DESTROYED
*
*      NOTE THAT THE CODING ENSURES THAT THE RESULTING VALUE
*      OF STATE IS ALWAYS LESS THAN DNAMB. THIS FACT IS USED
*      IN TESTING A VARIABLE NAME FOR BEING IN THE STATIC REGION
*
{ALOST{PRC{25,E{1,0{{ENTRY POINT{16217
*
*      MERGE BACK HERE AFTER ALLOCATING NEW CHUNK
*
{ALST1{MOV{7,XR{3,STATE{{POINT TO CURRENT END OF AREA{16221
{{AOV{8,WA{7,XR{6,ALST2{POINT BEYOND PROPOSED BLOCK{16222
{{BGE{7,XR{3,DNAMB{6,ALST2{JUMP IF OVERLAP WITH DYNAMIC AREA{16223
{{MOV{3,STATE{7,XR{{ELSE STORE NEW POINTER{16224
{{SUB{7,XR{8,WA{{POINT BACK TO START OF BLOCK{16225
{{EXI{{{{RETURN TO ALOST CALLER{16226
*
*      HERE IF NO ROOM, PREPARE TO MOVE DYNAMIC STORAGE UP
*
{ALST2{MOV{3,ALSTA{8,WA{{SAVE WA{16230
{{BGE{8,WA{19,*E_STS{6,ALST3{SKIP IF REQUESTED CHUNK IS LARGE{16231
{{MOV{8,WA{19,*E_STS{{ELSE SET TO GET LARGE ENOUGH CHUNK{16232
*
*      HERE WITH AMOUNT TO MOVE UP IN WA
*
{ALST3{JSR{6,ALLOC{{{ALLOCATE BLOCK TO ENSURE ROOM{16236
{{MOV{3,DNAMP{7,XR{{AND DELETE IT{16237
{{MOV{8,WB{8,WA{{COPY MOVE UP AMOUNT{16238
{{JSR{6,GBCOL{{{CALL GBCOL TO MOVE DYNAMIC AREA UP{16239
{{MOV{3,DNAMS{7,XR{{REMEMBER NEW SEDIMENT SIZE{16241
{{MOV{8,WA{3,ALSTA{{RESTORE WA{16243
{{BRN{6,ALST1{{{LOOP BACK TO TRY AGAIN{16244
{{ENP{{{{END PROCEDURE ALOST{16245
{{EJC{{{{{16246
*
*      ARITH -- FETCH ARITHMETIC OPERANDS
*
*      ARITH IS USED BY FUNCTIONS AND OPERATORS WHICH EXPECT
*      TWO NUMERIC ARGUMENTS (OPERANDS) WHICH MUST BOTH BE
*      INTEGER OR BOTH BE REAL. ARITH FETCHES TWO ARGUMENTS FROM
*      THE STACK AND PERFORMS ANY NECESSARY CONVERSIONS.
*
*      1(XS)                 FIRST ARGUMENT (LEFT OPERAND)
*      0(XS)                 SECOND ARGUMENT (RIGHT OPERAND)
*      JSR  ARITH            CALL TO FETCH NUMERIC ARGUMENTS
*      PPM  LOC              TRANSFER LOC FOR OPND 1 NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR OPND 2 NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR REAL OPERANDS
*
*      FOR INTEGER ARGS, CONTROL RETURNS PAST THE PARAMETERS
*
*      (IA)                  LEFT OPERAND VALUE
*      (XR)                  PTR TO ICBLK FOR LEFT OPERAND
*      (XL)                  PTR TO ICBLK FOR RIGHT OPERAND
*      (XS)                  POPPED TWICE
*      (WA,WB,RA)            DESTROYED
*
*      FOR REAL ARGUMENTS, CONTROL RETURNS TO THE LOCATION
*      SPECIFIED BY THE THIRD PARAMETER.
*
*      (RA)                  LEFT OPERAND VALUE
*      (XR)                  PTR TO RCBLK FOR LEFT OPERAND
*      (XL)                  PTR TO RCBLK FOR RIGHT OPERAND
*      (WA,WB,WC)            DESTROYED
*      (XS)                  POPPED TWICE
{{EJC{{{{{16320
*
*      ARITH (CONTINUED)
*
*      ENTRY POINT
*
{ARITH{PRC{25,N{1,3{{ENTRY POINT{16329
{{MOV{7,XL{10,(XS)+{{LOAD RIGHT OPERAND{16331
{{MOV{7,XR{10,(XS)+{{LOAD LEFT OPERAND{16332
{{MOV{8,WA{9,(XL){{GET RIGHT OPERAND TYPE WORD{16333
{{BEQ{8,WA{22,=B_ICL{6,ARTH1{JUMP IF INTEGER{16334
{{BEQ{8,WA{22,=B_RCL{6,ARTH4{JUMP IF REAL{16337
{{MOV{11,-(XS){7,XR{{ELSE REPLACE LEFT ARG ON STACK{16339
{{MOV{7,XR{7,XL{{COPY LEFT ARG POINTER{16340
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{16341
{{PPM{6,ARTH6{{{JUMP IF UNCONVERTIBLE{16342
{{MOV{7,XL{7,XR{{ELSE COPY CONVERTED RESULT{16343
{{MOV{8,WA{9,(XL){{GET RIGHT OPERAND TYPE WORD{16344
{{MOV{7,XR{10,(XS)+{{RELOAD LEFT ARGUMENT{16345
{{BEQ{8,WA{22,=B_RCL{6,ARTH4{JUMP IF RIGHT ARG IS REAL{16348
*
*      HERE IF RIGHT ARG IS AN INTEGER
*
{ARTH1{BNE{9,(XR){22,=B_ICL{6,ARTH3{JUMP IF LEFT ARG NOT INTEGER{16353
*
*      EXIT FOR INTEGER CASE
*
{ARTH2{LDI{13,ICVAL(XR){{{LOAD LEFT OPERAND VALUE{16357
{{EXI{{{{RETURN TO ARITH CALLER{16358
*
*      HERE FOR RIGHT OPERAND INTEGER, LEFT OPERAND NOT
*
{ARTH3{JSR{6,GTNUM{{{CONVERT LEFT ARG TO NUMERIC{16362
{{PPM{6,ARTH7{{{JUMP IF NOT CONVERTIBLE{16363
{{BEQ{8,WA{22,=B_ICL{6,ARTH2{JUMP BACK IF INTEGER-INTEGER{16364
*
*      HERE WE MUST CONVERT REAL-INTEGER TO REAL-REAL
*
{{MOV{11,-(XS){7,XR{{PUT LEFT ARG BACK ON STACK{16370
{{LDI{13,ICVAL(XL){{{LOAD RIGHT ARGUMENT VALUE{16371
{{ITR{{{{CONVERT TO REAL{16372
{{JSR{6,RCBLD{{{GET REAL BLOCK FOR RIGHT ARG, MERGE{16373
{{MOV{7,XL{7,XR{{COPY RIGHT ARG PTR{16374
{{MOV{7,XR{10,(XS)+{{LOAD LEFT ARGUMENT{16375
{{BRN{6,ARTH5{{{MERGE FOR REAL-REAL CASE{16376
{{EJC{{{{{16377
*
*      ARITH (CONTINUED)
*
*      HERE IF RIGHT ARGUMENT IS REAL
*
{ARTH4{BEQ{9,(XR){22,=B_RCL{6,ARTH5{JUMP IF LEFT ARG REAL{16383
{{JSR{6,GTREA{{{ELSE CONVERT TO REAL{16384
{{PPM{6,ARTH7{{{ERROR IF UNCONVERTIBLE{16385
*
*      HERE FOR REAL-REAL
*
{ARTH5{LDR{13,RCVAL(XR){{{LOAD LEFT OPERAND VALUE{16389
{{EXI{1,3{{{TAKE REAL-REAL EXIT{16390
*
*      HERE FOR ERROR CONVERTING RIGHT ARGUMENT
*
{ARTH6{ICA{7,XS{{{POP UNWANTED LEFT ARG{16395
{{EXI{1,2{{{TAKE APPROPRIATE ERROR EXIT{16396
*
*      HERE FOR ERROR CONVERTING LEFT OPERAND
*
{ARTH7{EXI{1,1{{{TAKE APPROPRIATE ERROR RETURN{16400
{{ENP{{{{END PROCEDURE ARITH{16401
{{EJC{{{{{16402
*
*      ASIGN -- PERFORM ASSIGNMENT
*
*      ASIGN PERFORMS THE ASSIGNMENT OF A VALUE TO A VARIABLE
*      WITH APPROPRIATE CHECKS FOR OUTPUT ASSOCIATIONS AND
*      VALUE TRACE ASSOCIATIONS WHICH ARE EXECUTED AS REQUIRED.
*      ASIGN ALSO HANDLES THE SPECIAL CASES OF ASSIGNMENT TO
*      PATTERN AND EXPRESSION VARIABLES.
*
*      (WB)                  VALUE TO BE ASSIGNED
*      (XL)                  BASE POINTER FOR VARIABLE
*      (WA)                  OFFSET FOR VARIABLE
*      JSR  ASIGN            CALL TO ASSIGN VALUE TO VARIABLE
*      PPM  LOC              TRANSFER LOC FOR FAILURE
*      (XR,XL,WA,WB,WC)      DESTROYED
*      (RA)                  DESTROYED
*
*      FAILURE OCCURS IF THE EVALUATION OF AN EXPRESSION
*      ASSOCIATED WITH AN EXPRESSION VARIABLE FAILS.
*
{ASIGN{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){16423
*
*      MERGE BACK HERE TO ASSIGN RESULT TO EXPRESSION VARIABLE.
*
{ASG01{ADD{7,XL{8,WA{{POINT TO VARIABLE VALUE{16427
{{MOV{7,XR{9,(XL){{LOAD VARIABLE VALUE{16428
{{BEQ{9,(XR){22,=B_TRT{6,ASG02{JUMP IF TRAPPED{16429
{{MOV{9,(XL){8,WB{{ELSE PERFORM ASSIGNMENT{16430
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{16431
{{EXI{{{{AND RETURN TO ASIGN CALLER{16432
*
*      HERE IF VALUE IS TRAPPED
*
{ASG02{SUB{7,XL{8,WA{{RESTORE NAME BASE{16436
{{BEQ{7,XR{21,=TRBKV{6,ASG14{JUMP IF KEYWORD VARIABLE{16437
{{BNE{7,XR{21,=TRBEV{6,ASG04{JUMP IF NOT EXPRESSION VARIABLE{16438
*
*      HERE FOR ASSIGNMENT TO EXPRESSION VARIABLE
*
{{MOV{7,XR{13,EVEXP(XL){{POINT TO EXPRESSION{16442
{{MOV{11,-(XS){8,WB{{STORE VALUE TO ASSIGN ON STACK{16443
{{MOV{8,WB{18,=NUM01{{SET FOR EVALUATION BY NAME{16444
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY NAME{16445
{{PPM{6,ASG03{{{JUMP IF EVALUATION FAILS{16446
{{MOV{8,WB{10,(XS)+{{ELSE RELOAD VALUE TO ASSIGN{16447
{{BRN{6,ASG01{{{LOOP BACK TO PERFORM ASSIGNMENT{16448
{{EJC{{{{{16449
*
*      ASIGN (CONTINUED)
*
*      HERE FOR FAILURE DURING EXPRESSION EVALUATION
*
{ASG03{ICA{7,XS{{{REMOVE STACKED VALUE ENTRY{16455
{{EXI{1,1{{{TAKE FAILURE EXIT{16456
*
*      HERE IF NOT KEYWORD OR EXPRESSION VARIABLE
*
{ASG04{MOV{11,-(XS){7,XR{{SAVE PTR TO FIRST TRBLK{16460
*
*      LOOP TO CHASE DOWN TRBLK CHAIN AND ASSIGN VALUE AT END
*
{ASG05{MOV{8,WC{7,XR{{SAVE PTR TO THIS TRBLK{16464
{{MOV{7,XR{13,TRNXT(XR){{POINT TO NEXT TRBLK{16465
{{BEQ{9,(XR){22,=B_TRT{6,ASG05{LOOP BACK IF ANOTHER TRBLK{16466
{{MOV{7,XR{8,WC{{ELSE POINT BACK TO LAST TRBLK{16467
{{MOV{13,TRVAL(XR){8,WB{{STORE VALUE AT END OF CHAIN{16468
{{MOV{7,XR{10,(XS)+{{RESTORE PTR TO FIRST TRBLK{16469
*
*      LOOP TO PROCESS TRBLK ENTRIES ON CHAIN
*
{ASG06{MOV{8,WB{13,TRTYP(XR){{LOAD TYPE CODE OF TRBLK{16473
{{BEQ{8,WB{18,=TRTVL{6,ASG08{JUMP IF VALUE TRACE{16474
{{BEQ{8,WB{18,=TRTOU{6,ASG10{JUMP IF OUTPUT ASSOCIATION{16475
*
*      HERE TO MOVE TO NEXT TRBLK ON CHAIN
*
{ASG07{MOV{7,XR{13,TRNXT(XR){{POINT TO NEXT TRBLK ON CHAIN{16479
{{BEQ{9,(XR){22,=B_TRT{6,ASG06{LOOP BACK IF ANOTHER TRBLK{16480
{{EXI{{{{ELSE END OF CHAIN, RETURN TO CALLER{16481
*
*      HERE TO PROCESS VALUE TRACE
*
{ASG08{BZE{3,KVTRA{6,ASG07{{IGNORE VALUE TRACE IF TRACE OFF{16485
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{16486
{{BZE{13,TRFNC(XR){6,ASG09{{JUMP IF PRINT TRACE{16487
{{JSR{6,TRXEQ{{{ELSE EXECUTE FUNCTION TRACE{16488
{{BRN{6,ASG07{{{AND LOOP BACK{16489
{{EJC{{{{{16490
*
*      ASIGN (CONTINUED)
*
*      HERE FOR PRINT TRACE
*
{ASG09{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{16496
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{16497
{{BRN{6,ASG07{{{LOOP BACK FOR NEXT TRBLK{16498
*
*      HERE FOR OUTPUT ASSOCIATION
*
{ASG10{BZE{3,KVOUP{6,ASG07{{IGNORE OUTPUT ASSOC IF OUTPUT OFF{16502
{ASG1B{MOV{7,XL{7,XR{{COPY TRBLK POINTER{16503
{{MOV{7,XR{13,TRNXT(XR){{POINT TO NEXT TRBLK{16504
{{BEQ{9,(XR){22,=B_TRT{6,ASG1B{LOOP BACK IF ANOTHER TRBLK{16505
{{MOV{7,XR{7,XL{{ELSE POINT BACK TO LAST TRBLK{16506
{{MOV{11,-(XS){13,TRVAL(XR){{STACK VALUE TO OUTPUT{16508
{{JSR{6,GTSTG{{{CONVERT TO STRING{16514
{{PPM{6,ASG12{{{GET DATATYPE NAME IF UNCONVERTIBLE{16515
*
*      MERGE WITH STRING OR BUFFER TO OUTPUT IN XR
*
{ASG11{MOV{8,WA{13,TRFPT(XL){{FCBLK PTR{16519
{{BZE{8,WA{6,ASG13{{JUMP IF STANDARD OUTPUT FILE{16520
*
*      HERE FOR OUTPUT TO FILE
*
{ASG1A{JSR{6,SYSOU{{{CALL SYSTEM OUTPUT ROUTINE{16524
{{ERR{1,206{26,Output caused file overflow{{{16525
{{ERR{1,207{26,Output caused non-recoverable error{{{16526
{{EXI{{{{ELSE ALL DONE, RETURN TO CALLER{16527
*
*      IF NOT PRINTABLE, GET DATATYPE NAME INSTEAD
*
{ASG12{JSR{6,DTYPE{{{CALL DATATYPE ROUTINE{16531
{{BRN{6,ASG11{{{MERGE{16532
*
*      HERE TO PRINT A STRING TO STANDARD OUTPUT OR TERMINAL
*
{ASG13{BEQ{13,TRTER(XL){21,=V_TER{6,ASG1A{JUMP IF TERMINAL OUTPUT{16537
{{ICV{8,WA{{{SIGNAL STANDARD OUTPUT{16538
{{BRN{6,ASG1A{{{USE SYSOU TO PERFORM OUTPUT{16539
{{EJC{{{{{16554
*
*      ASIGN (CONTINUED)
*
*      HERE FOR KEYWORD ASSIGNMENT
*
{ASG14{MOV{7,XL{13,KVNUM(XL){{LOAD KEYWORD NUMBER{16560
{{BEQ{7,XL{18,=K_ETX{6,ASG19{JUMP IF ERRTEXT{16561
{{MOV{7,XR{8,WB{{COPY VALUE TO BE ASSIGNED{16562
{{JSR{6,GTINT{{{CONVERT TO INTEGER{16563
{{ERR{1,208{26,Keyword value assigned is not integer{{{16564
{{LDI{13,ICVAL(XR){{{ELSE LOAD VALUE{16565
{{BEQ{7,XL{18,=K_STL{6,ASG16{JUMP IF SPECIAL CASE OF STLIMIT{16566
{{MFI{8,WA{6,ASG18{{ELSE GET ADDR INTEGER, TEST OVFLOW{16567
{{BGT{8,WA{3,MXLEN{6,ASG18{FAIL IF TOO LARGE{16568
{{BEQ{7,XL{18,=K_ERT{6,ASG17{JUMP IF SPECIAL CASE OF ERRTYPE{16569
{{BEQ{7,XL{18,=K_PFL{6,ASG21{JUMP IF SPECIAL CASE OF PROFILE{16572
{{BEQ{7,XL{18,=K_MXL{6,ASG24{JUMP IF SPECIAL CASE OF MAXLNGTH{16574
{{BEQ{7,XL{18,=K_FLS{6,ASG26{JUMP IF SPECIAL CASE OF FULLSCAN{16575
{{BLT{7,XL{18,=K_P__{6,ASG15{JUMP UNLESS PROTECTED{16576
{{ERB{1,209{26,Keyword in assignment is protected{{{16577
*
*      HERE TO DO ASSIGNMENT IF NOT PROTECTED
*
{ASG15{MOV{15,KVABE(XL){8,WA{{STORE NEW VALUE{16581
{{EXI{{{{RETURN TO ASIGN CALLER{16582
*
*      HERE FOR SPECIAL CASE OF STLIMIT
*
*      SINCE STCOUNT IS MAINTAINED AS (STLIMIT-STCOUNT)
*      IT IS ALSO NECESSARY TO MODIFY STCOUNT APPROPRIATELY.
*
{ASG16{SBI{3,KVSTL{{{SUBTRACT OLD LIMIT{16589
{{ADI{3,KVSTC{{{ADD OLD COUNTER{16590
{{STI{3,KVSTC{{{STORE COURSE COUNTER VALUE{16591
{{LDI{3,KVSTL{{{CHECK IF COUNTING SUPPRESSED{16592
{{ILT{6,ASG25{{{DO NOT REFINE IF SO{16593
{{MOV{8,WA{3,STMCS{{REFINE WITH COUNTER BREAKOUT{16594
{{SUB{8,WA{3,STMCT{{VALUES{16595
{{MTI{8,WA{{{CONVERT TO INTEGER{16596
{{NGI{{{{CURRENT-START VALUE{16597
{{ADI{3,KVSTC{{{ADD IN COURSE COUNTER VALUE{16598
{{STI{3,KVSTC{{{SAVE REFINED VALUE{16599
{ASG25{LDI{13,ICVAL(XR){{{RELOAD NEW LIMIT VALUE{16600
{{STI{3,KVSTL{{{STORE NEW LIMIT VALUE{16601
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{16602
{{EXI{{{{RETURN TO ASIGN CALLER{16603
*
*      HERE FOR SPECIAL CASE OF ERRTYPE
*
{ASG17{BLE{8,WA{18,=NINI9{6,ERROR{OK TO SIGNAL IF IN RANGE{16607
*
*      HERE IF VALUE ASSIGNED IS OUT OF RANGE
*
{ASG18{ERB{1,210{26,Keyword value assigned is negative or too large{{{16611
*
*      HERE FOR SPECIAL CASE OF ERRTEXT
*
{ASG19{MOV{11,-(XS){8,WB{{STACK VALUE{16615
{{JSR{6,GTSTG{{{CONVERT TO STRING{16616
{{ERR{1,211{26,Value assigned to keyword ERRTEXT not a string{{{16617
{{MOV{3,R_ETX{7,XR{{MAKE ASSIGNMENT{16618
{{EXI{{{{RETURN TO CALLER{16619
*
*      HERE FOR KEYWORD PROFILE
*
{ASG21{BGT{8,WA{18,=NUM02{6,ASG18{MOAN IF NOT 0,1, OR 2{16633
{{BZE{8,WA{6,ASG15{{JUST ASSIGN IF ZERO{16634
{{BZE{3,PFDMP{6,ASG22{{BRANCH IF FIRST ASSIGNMENT{16635
{{BEQ{8,WA{3,PFDMP{6,ASG23{ALSO IF SAME VALUE AS BEFORE{16636
{{ERB{1,268{26,Inconsistent value assigned to keyword PROFILE{{{16637
*
{ASG22{MOV{3,PFDMP{8,WA{{NOTE VALUE ON FIRST ASSIGNMENT{16639
{ASG23{MOV{3,KVPFL{8,WA{{STORE NEW VALUE{16640
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTS{16641
{{JSR{6,SYSTM{{{GET THE TIME{16642
{{STI{3,PFSTM{{{FUDGE SOME KIND OF START TIME{16643
{{EXI{{{{RETURN TO ASIGN CALLER{16644
*
*      HERE FOR KEYWORD MAXLNGTH
*
{ASG24{BGE{8,WA{18,=MNLEN{6,ASG15{IF ACCEPTABLE VALUE{16649
{{ERB{1,287{26,Value assigned to keyword MAXLNGTH is too small{{{16650
*
*      HERE FOR KEYWORD FULLSCAN
*
{ASG26{BNZ{8,WA{6,ASG15{{IF ACCEPTABLE VALUE{16654
{{ERB{1,274{26,Value assigned to keyword FULLSCAN is zero{{{16655
*
{{ENP{{{{END PROCEDURE ASIGN{16657
{{EJC{{{{{16658
*
*      ASINP -- ASSIGN DURING PATTERN MATCH
*
*      ASINP IS LIKE ASIGN AND HAS A SIMILAR CALLING SEQUENCE
*      AND EFFECT. THE DIFFERENCE IS THAT THE GLOBAL PATTERN
*      VARIABLES ARE SAVED AND RESTORED IF REQUIRED.
*
*      (XL)                  BASE POINTER FOR VARIABLE
*      (WA)                  OFFSET FOR VARIABLE
*      (WB)                  VALUE TO BE ASSIGNED
*      JSR  ASINP            CALL TO ASSIGN VALUE TO VARIABLE
*      PPM  LOC              TRANSFER LOC IF FAILURE
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
{ASINP{PRC{25,R{1,1{{ENTRY POINT, RECURSIVE{16674
{{ADD{7,XL{8,WA{{POINT TO VARIABLE{16675
{{MOV{7,XR{9,(XL){{LOAD CURRENT CONTENTS{16676
{{BEQ{9,(XR){22,=B_TRT{6,ASNP1{JUMP IF TRAPPED{16677
{{MOV{9,(XL){8,WB{{ELSE PERFORM ASSIGNMENT{16678
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{16679
{{EXI{{{{RETURN TO ASINP CALLER{16680
*
*      HERE IF VARIABLE IS TRAPPED
*
{ASNP1{SUB{7,XL{8,WA{{RESTORE BASE POINTER{16684
{{MOV{11,-(XS){3,PMSSL{{STACK SUBJECT STRING LENGTH{16685
{{MOV{11,-(XS){3,PMHBS{{STACK HISTORY STACK BASE PTR{16686
{{MOV{11,-(XS){3,R_PMS{{STACK SUBJECT STRING POINTER{16687
{{MOV{11,-(XS){3,PMDFL{{STACK DOT FLAG{16688
{{JSR{6,ASIGN{{{CALL FULL-BLOWN ASSIGNMENT ROUTINE{16689
{{PPM{6,ASNP2{{{JUMP IF FAILURE{16690
{{MOV{3,PMDFL{10,(XS)+{{RESTORE DOT FLAG{16691
{{MOV{3,R_PMS{10,(XS)+{{RESTORE SUBJECT STRING POINTER{16692
{{MOV{3,PMHBS{10,(XS)+{{RESTORE HISTORY STACK BASE POINTER{16693
{{MOV{3,PMSSL{10,(XS)+{{RESTORE SUBJECT STRING LENGTH{16694
{{EXI{{{{RETURN TO ASINP CALLER{16695
*
*      HERE IF FAILURE IN ASIGN CALL
*
{ASNP2{MOV{3,PMDFL{10,(XS)+{{RESTORE DOT FLAG{16699
{{MOV{3,R_PMS{10,(XS)+{{RESTORE SUBJECT STRING POINTER{16700
{{MOV{3,PMHBS{10,(XS)+{{RESTORE HISTORY STACK BASE POINTER{16701
{{MOV{3,PMSSL{10,(XS)+{{RESTORE SUBJECT STRING LENGTH{16702
{{EXI{1,1{{{TAKE FAILURE EXIT{16703
{{ENP{{{{END PROCEDURE ASINP{16704
{{EJC{{{{{16705
*
*      BLKLN -- DETERMINE LENGTH OF BLOCK
*
*      BLKLN DETERMINES THE LENGTH OF A BLOCK IN DYNAMIC STORE.
*
*      (WA)                  FIRST WORD OF BLOCK
*      (XR)                  POINTER TO BLOCK
*      JSR  BLKLN            CALL TO GET BLOCK LENGTH
*      (WA)                  LENGTH OF BLOCK IN BYTES
*      (XL)                  DESTROYED
*
*      BLKLN IS USED BY THE GARBAGE COLLECTOR AND IS NOT
*      PERMITTED TO CALL GBCOL DIRECTLY OR INDIRECTLY.
*
*      THE FIRST WORD STORED IN THE BLOCK (I.E. AT XR) MAY
*      BE ANYTHING, BUT THE CONTENTS OF WA MUST BE CORRECT.
*
{BLKLN{PRC{25,E{1,0{{ENTRY POINT{16723
{{MOV{7,XL{8,WA{{COPY FIRST WORD{16724
{{LEI{7,XL{{{GET ENTRY ID (BL_XX){16725
{{BSW{7,XL{2,BL___{6,BLN00{SWITCH ON BLOCK TYPE{16726
{{IFF{2,BL_AR{6,BLN01{{ARBLK{16766
{{IFF{2,BL_CD{6,BLN12{{CDBLK{16766
{{IFF{2,BL_EX{6,BLN12{{EXBLK{16766
{{IFF{2,BL_IC{6,BLN07{{ICBLK{16766
{{IFF{2,BL_NM{6,BLN03{{NMBLK{16766
{{IFF{2,BL_P0{6,BLN02{{P0BLK{16766
{{IFF{2,BL_P1{6,BLN03{{P1BLK{16766
{{IFF{2,BL_P2{6,BLN04{{P2BLK{16766
{{IFF{2,BL_RC{6,BLN09{{RCBLK{16766
{{IFF{2,BL_SC{6,BLN10{{SCBLK{16766
{{IFF{2,BL_SE{6,BLN02{{SEBLK{16766
{{IFF{2,BL_TB{6,BLN01{{TBBLK{16766
{{IFF{2,BL_VC{6,BLN01{{VCBLK{16766
{{IFF{1,13{6,BLN00{{{16766
{{IFF{1,14{6,BLN00{{{16766
{{IFF{1,15{6,BLN00{{{16766
{{IFF{2,BL_PD{6,BLN08{{PDBLK{16766
{{IFF{2,BL_TR{6,BLN05{{TRBLK{16766
{{IFF{1,18{6,BLN00{{{16766
{{IFF{1,19{6,BLN00{{{16766
{{IFF{1,20{6,BLN00{{{16766
{{IFF{2,BL_CT{6,BLN06{{CTBLK{16766
{{IFF{2,BL_DF{6,BLN01{{DFBLK{16766
{{IFF{2,BL_EF{6,BLN01{{EFBLK{16766
{{IFF{2,BL_EV{6,BLN03{{EVBLK{16766
{{IFF{2,BL_FF{6,BLN05{{FFBLK{16766
{{IFF{2,BL_KV{6,BLN03{{KVBLK{16766
{{IFF{2,BL_PF{6,BLN01{{PFBLK{16766
{{IFF{2,BL_TE{6,BLN04{{TEBLK{16766
{{ESW{{{{END OF JUMP TABLE ON BLOCK TYPE{16766
{{EJC{{{{{16767
*
*      BLKLN (CONTINUED)
*
*      HERE FOR BLOCKS WITH LENGTH IN SECOND WORD
*
{BLN00{MOV{8,WA{13,NUM01(XR){{LOAD LENGTH{16773
{{EXI{{{{RETURN TO BLKLN CALLER{16774
*
*      HERE FOR LENGTH IN THIRD WORD (AR,CD,DF,EF,EX,PF,TB,VC)
*
{BLN01{MOV{8,WA{13,NUM02(XR){{LOAD LENGTH FROM THIRD WORD{16778
{{EXI{{{{RETURN TO BLKLN CALLER{16779
*
*      HERE FOR TWO WORD BLOCKS (P0,SE)
*
{BLN02{MOV{8,WA{19,*NUM02{{LOAD LENGTH (TWO WORDS){16783
{{EXI{{{{RETURN TO BLKLN CALLER{16784
*
*      HERE FOR THREE WORD BLOCKS (NM,P1,EV,KV)
*
{BLN03{MOV{8,WA{19,*NUM03{{LOAD LENGTH (THREE WORDS){16788
{{EXI{{{{RETURN TO BLKLN CALLER{16789
*
*      HERE FOR FOUR WORD BLOCKS (P2,TE,BC)
*
{BLN04{MOV{8,WA{19,*NUM04{{LOAD LENGTH (FOUR WORDS){16793
{{EXI{{{{RETURN TO BLKLN CALLER{16794
*
*      HERE FOR FIVE WORD BLOCKS (FF,TR)
*
{BLN05{MOV{8,WA{19,*NUM05{{LOAD LENGTH{16798
{{EXI{{{{RETURN TO BLKLN CALLER{16799
{{EJC{{{{{16800
*
*      BLKLN (CONTINUED)
*
*      HERE FOR CTBLK
*
{BLN06{MOV{8,WA{19,*CTSI_{{SET SIZE OF CTBLK{16806
{{EXI{{{{RETURN TO BLKLN CALLER{16807
*
*      HERE FOR ICBLK
*
{BLN07{MOV{8,WA{19,*ICSI_{{SET SIZE OF ICBLK{16811
{{EXI{{{{RETURN TO BLKLN CALLER{16812
*
*      HERE FOR PDBLK
*
{BLN08{MOV{7,XL{13,PDDFP(XR){{POINT TO DFBLK{16816
{{MOV{8,WA{13,DFPDL(XL){{LOAD PDBLK LENGTH FROM DFBLK{16817
{{EXI{{{{RETURN TO BLKLN CALLER{16818
*
*      HERE FOR RCBLK
*
{BLN09{MOV{8,WA{19,*RCSI_{{SET SIZE OF RCBLK{16824
{{EXI{{{{RETURN TO BLKLN CALLER{16825
*
*      HERE FOR SCBLK
*
{BLN10{MOV{8,WA{13,SCLEN(XR){{LOAD LENGTH IN CHARACTERS{16830
{{CTB{8,WA{2,SCSI_{{CALCULATE LENGTH IN BYTES{16831
{{EXI{{{{RETURN TO BLKLN CALLER{16832
*
*      HERE FOR LENGTH IN FOURTH WORD (CD,EX)
*
{BLN12{MOV{8,WA{13,NUM03(XR){{LOAD LENGTH FROM CDLEN/EXLEN{16846
{{EXI{{{{RETURN TO BLKLN CALLER{16847
{{ENP{{{{END PROCEDURE BLKLN{16849
{{EJC{{{{{16850
*
*      COPYB -- COPY A BLOCK
*
*      (XS)                  BLOCK TO BE COPIED
*      JSR  COPYB            CALL TO COPY BLOCK
*      PPM  LOC              RETURN IF BLOCK HAS NO IDVAL FIELD
*                            NORMAL RETURN IF IDVAL FIELD
*      (XR)                  COPY OF BLOCK
*      (XS)                  POPPED
*      (XL,WA,WB,WC)         DESTROYED
*
{COPYB{PRC{25,N{1,1{{ENTRY POINT{16862
{{MOV{7,XR{9,(XS){{LOAD ARGUMENT{16863
{{BEQ{7,XR{21,=NULLS{6,COP10{RETURN ARGUMENT IF IT IS NULL{16864
{{MOV{8,WA{9,(XR){{ELSE LOAD TYPE WORD{16865
{{MOV{8,WB{8,WA{{COPY TYPE WORD{16866
{{JSR{6,BLKLN{{{GET LENGTH OF ARGUMENT BLOCK{16867
{{MOV{7,XL{7,XR{{COPY POINTER{16868
{{JSR{6,ALLOC{{{ALLOCATE BLOCK OF SAME SIZE{16869
{{MOV{9,(XS){7,XR{{STORE POINTER TO COPY{16870
{{MVW{{{{COPY CONTENTS OF OLD BLOCK TO NEW{16871
{{ZER{7,XL{{{CLEAR GARBAGE XL{16872
{{MOV{7,XR{9,(XS){{RELOAD POINTER TO START OF COPY{16873
{{BEQ{8,WB{22,=B_TBT{6,COP05{JUMP IF TABLE{16874
{{BEQ{8,WB{22,=B_VCT{6,COP01{JUMP IF VECTOR{16875
{{BEQ{8,WB{22,=B_PDT{6,COP01{JUMP IF PROGRAM DEFINED{16876
{{BNE{8,WB{22,=B_ART{6,COP10{RETURN COPY IF NOT ARRAY{16881
*
*      HERE FOR ARRAY (ARBLK)
*
{{ADD{7,XR{13,AROFS(XR){{POINT TO PROTOTYPE FIELD{16885
{{BRN{6,COP02{{{JUMP TO MERGE{16886
*
*      HERE FOR VECTOR, PROGRAM DEFINED
*
{COP01{ADD{7,XR{19,*PDFLD{{POINT TO PDFLD = VCVLS{16890
*
*      MERGE HERE FOR ARBLK, VCBLK, PDBLK TO DELETE TRAP
*      BLOCKS FROM ALL VALUE FIELDS (THE COPY IS UNTRAPPED)
*
{COP02{MOV{7,XL{9,(XR){{LOAD NEXT POINTER{16895
*
*      LOOP TO GET VALUE AT END OF TRBLK CHAIN
*
{COP03{BNE{9,(XL){22,=B_TRT{6,COP04{JUMP IF NOT TRAPPED{16899
{{MOV{7,XL{13,TRVAL(XL){{ELSE POINT TO NEXT VALUE{16900
{{BRN{6,COP03{{{AND LOOP BACK{16901
{{EJC{{{{{16902
*
*      COPYB (CONTINUED)
*
*      HERE WITH UNTRAPPED VALUE IN XL
*
{COP04{MOV{10,(XR)+{7,XL{{STORE REAL VALUE, BUMP POINTER{16908
{{BNE{7,XR{3,DNAMP{6,COP02{LOOP BACK IF MORE TO GO{16909
{{BRN{6,COP09{{{ELSE JUMP TO EXIT{16910
*
*      HERE TO COPY A TABLE
*
{COP05{ZER{13,IDVAL(XR){{{ZERO ID TO STOP DUMP BLOWING UP{16914
{{MOV{8,WA{19,*TESI_{{SET SIZE OF TEBLK{16915
{{MOV{8,WC{19,*TBBUK{{SET INITIAL OFFSET{16916
*
*      LOOP THROUGH BUCKETS IN TABLE
*
{COP06{MOV{7,XR{9,(XS){{LOAD TABLE POINTER{16920
{{BEQ{8,WC{13,TBLEN(XR){6,COP09{JUMP TO EXIT IF ALL DONE{16921
{{MOV{8,WB{8,WC{{ELSE COPY OFFSET{16922
{{SUB{8,WB{19,*TENXT{{SUBTRACT LINK OFFSET TO MERGE{16923
{{ADD{7,XR{8,WB{{NEXT BUCKET HEADER LESS LINK OFFSET{16924
{{ICA{8,WC{{{BUMP OFFSET{16925
*
*      LOOP THROUGH TEBLKS ON ONE CHAIN
*
{COP07{MOV{7,XL{13,TENXT(XR){{LOAD POINTER TO NEXT TEBLK{16929
{{MOV{13,TENXT(XR){9,(XS){{SET END OF CHAIN POINTER IN CASE{16930
{{BEQ{9,(XL){22,=B_TBT{6,COP06{BACK FOR NEXT BUCKET IF CHAIN END{16931
{{SUB{7,XR{8,WB{{POINT TO HEAD OF PREVIOUS BLOCK{16932
{{MOV{11,-(XS){7,XR{{STACK PTR TO PREVIOUS BLOCK{16933
{{MOV{8,WA{19,*TESI_{{SET SIZE OF TEBLK{16934
{{JSR{6,ALLOC{{{ALLOCATE NEW TEBLK{16935
{{MOV{11,-(XS){7,XR{{STACK PTR TO NEW TEBLK{16936
{{MVW{{{{COPY OLD TEBLK TO NEW TEBLK{16937
{{MOV{7,XR{10,(XS)+{{RESTORE POINTER TO NEW TEBLK{16938
{{MOV{7,XL{10,(XS)+{{RESTORE POINTER TO PREVIOUS BLOCK{16939
{{ADD{7,XL{8,WB{{ADD OFFSET BACK IN{16940
{{MOV{13,TENXT(XL){7,XR{{LINK NEW BLOCK TO PREVIOUS{16941
{{MOV{7,XL{7,XR{{COPY POINTER TO NEW BLOCK{16942
*
*      LOOP TO SET REAL VALUE AFTER REMOVING TRAP CHAIN
*
{COP08{MOV{7,XL{13,TEVAL(XL){{LOAD VALUE{16946
{{BEQ{9,(XL){22,=B_TRT{6,COP08{LOOP BACK IF TRAPPED{16947
{{MOV{13,TEVAL(XR){7,XL{{STORE UNTRAPPED VALUE IN TEBLK{16948
{{ZER{8,WB{{{ZERO OFFSET WITHIN TEBLK{16949
{{BRN{6,COP07{{{BACK FOR NEXT TEBLK{16950
*
*      COMMON EXIT POINT
*
{COP09{MOV{7,XR{10,(XS)+{{LOAD POINTER TO BLOCK{16954
{{EXI{{{{RETURN{16955
*
*      ALTERNATIVE RETURN
*
{COP10{EXI{1,1{{{RETURN{16959
{{EJC{{{{{16960
{{ENP{{{{END PROCEDURE COPYB{16978
*
*      CDGCG -- GENERATE CODE FOR COMPLEX GOTO
*
*      USED BY CMPIL TO PROCESS COMPLEX GOTO TREE
*
*      (WB)                  MUST BE COLLECTABLE
*      (XR)                  EXPRESSION POINTER
*      JSR  CDGCG            CALL TO GENERATE COMPLEX GOTO
*      (XL,XR,WA)            DESTROYED
*
{CDGCG{PRC{25,E{1,0{{ENTRY POINT{16989
{{MOV{7,XL{13,CMOPN(XR){{GET UNARY GOTO OPERATOR{16990
{{MOV{7,XR{13,CMROP(XR){{POINT TO GOTO OPERAND{16991
{{BEQ{7,XL{21,=OPDVD{6,CDGC2{JUMP IF DIRECT GOTO{16992
{{JSR{6,CDGNM{{{GENERATE OPND BY NAME IF NOT DIRECT{16993
*
*      RETURN POINT
*
{CDGC1{MOV{8,WA{7,XL{{GOTO OPERATOR{16997
{{JSR{6,CDWRD{{{GENERATE IT{16998
{{EXI{{{{RETURN TO CALLER{16999
*
*      DIRECT GOTO
*
{CDGC2{JSR{6,CDGVL{{{GENERATE OPERAND BY VALUE{17003
{{BRN{6,CDGC1{{{MERGE TO RETURN{17004
{{ENP{{{{END PROCEDURE CDGCG{17005
{{EJC{{{{{17006
*
*      CDGEX -- BUILD EXPRESSION BLOCK
*
*      CDGEX IS PASSED A POINTER TO AN EXPRESSION TREE (SEE
*      EXPAN) AND RETURNS AN EXPRESSION (SEBLK OR EXBLK).
*
*      (WA)                  0 IF BY VALUE, 1 IF BY NAME
*      (WC)                  SOME COLLECTABLE VALUE
*      (WB)                  INTEGER IN RANGE 0 LE X LE MXLEN
*      (XL)                  PTR TO EXPRESSION TREE
*      JSR  CDGEX            CALL TO BUILD EXPRESSION
*      (XR)                  PTR TO SEBLK OR EXBLK
*      (XL,WA,WB)            DESTROYED
*
{CDGEX{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{17023
{{BLO{9,(XL){22,=B_VR_{6,CDGX1{JUMP IF NOT VARIABLE{17024
*
*      HERE FOR NATURAL VARIABLE, BUILD SEBLK
*
{{MOV{8,WA{19,*SESI_{{SET SIZE OF SEBLK{17028
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR SEBLK{17029
{{MOV{9,(XR){22,=B_SEL{{SET TYPE WORD{17030
{{MOV{13,SEVAR(XR){7,XL{{STORE VRBLK POINTER{17031
{{EXI{{{{RETURN TO CDGEX CALLER{17032
*
*      HERE IF NOT VARIABLE, BUILD EXBLK
*
{CDGX1{MOV{7,XR{7,XL{{COPY TREE POINTER{17036
{{MOV{11,-(XS){8,WC{{SAVE WC{17037
{{MOV{7,XL{3,CWCOF{{SAVE CURRENT OFFSET{17038
{{BZE{8,WA{6,CDGX2{{JUMP IF BY VALUE{17040
{{MOV{8,WA{9,(XR){{GET TYPE WORD{17042
{{BNE{8,WA{22,=B_CMT{6,CDGX2{CALL BY VALUE IF NOT CMBLK{17043
{{BGE{13,CMTYP(XR){18,=C__NM{6,CDGX2{JUMP IF CMBLK ONLY BY VALUE{17044
{{EJC{{{{{17045
*
*      CDGEX (CONTINUED)
*
*      HERE IF EXPRESSION CAN BE EVALUATED BY NAME
*
{{JSR{6,CDGNM{{{GENERATE CODE BY NAME{17051
{{MOV{8,WA{21,=ORNM_{{LOAD RETURN BY NAME WORD{17052
{{BRN{6,CDGX3{{{MERGE WITH VALUE CASE{17053
*
*      HERE IF EXPRESSION CAN ONLY BE EVALUATED BY VALUE
*
{CDGX2{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{17057
{{MOV{8,WA{21,=ORVL_{{LOAD RETURN BY VALUE WORD{17058
*
*      MERGE HERE TO CONSTRUCT EXBLK
*
{CDGX3{JSR{6,CDWRD{{{GENERATE RETURN WORD{17062
{{JSR{6,EXBLD{{{BUILD EXBLK{17063
{{MOV{8,WC{10,(XS)+{{RESTORE WC{17064
{{EXI{{{{RETURN TO CDGEX CALLER{17065
{{ENP{{{{END PROCEDURE CDGEX{17066
{{EJC{{{{{17067
*
*      CDGNM -- GENERATE CODE BY NAME
*
*      CDGNM IS CALLED DURING THE COMPILATION PROCESS TO
*      GENERATE CODE BY NAME FOR AN EXPRESSION. SEE CDBLK
*      DESCRIPTION FOR DETAILS OF CODE GENERATED. THE INPUT
*      TO CDGNM IS AN EXPRESSION TREE AS GENERATED BY EXPAN.
*
*      CDGNM IS A RECURSIVE PROCEDURE WHICH PROCEEDS BY MAKING
*      RECURSIVE CALLS TO GENERATE CODE FOR OPERANDS.
*
*      (WB)                  INTEGER IN RANGE 0 LE N LE DNAMB
*      (XR)                  PTR TO TREE GENERATED BY EXPAN
*      (WC)                  CONSTANT FLAG (SEE BELOW)
*      JSR  CDGNM            CALL TO GENERATE CODE BY NAME
*      (XR,WA)               DESTROYED
*      (WC)                  SET NON-ZERO IF NON-CONSTANT
*
*      WC IS SET TO A NON-ZERO (COLLECTABLE) VALUE IF THE
*      EXPRESSION FOR WHICH CODE IS GENERATED CANNOT BE
*      EVALUATED AT COMPILE TIME, OTHERWISE WC IS UNCHANGED.
*
*      THE CODE IS GENERATED IN THE CURRENT CCBLK (SEE CDWRD).
*
{CDGNM{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{17092
{{MOV{11,-(XS){7,XL{{SAVE ENTRY XL{17093
{{MOV{11,-(XS){8,WB{{SAVE ENTRY WB{17094
{{CHK{{{{CHECK FOR STACK OVERFLOW{17095
{{MOV{8,WA{9,(XR){{LOAD TYPE WORD{17096
{{BEQ{8,WA{22,=B_CMT{6,CGN04{JUMP IF CMBLK{17097
{{BHI{8,WA{22,=B_VR_{6,CGN02{JUMP IF SIMPLE VARIABLE{17098
*
*      MERGE HERE FOR OPERAND YIELDING VALUE (E.G. CONSTANT)
*
{CGN01{ERB{1,212{26,Syntax error: Value used where name is required{{{17102
*
*      HERE FOR NATURAL VARIABLE REFERENCE
*
{CGN02{MOV{8,WA{21,=OLVN_{{LOAD VARIABLE LOAD CALL{17106
{{JSR{6,CDWRD{{{GENERATE IT{17107
{{MOV{8,WA{7,XR{{COPY VRBLK POINTER{17108
{{JSR{6,CDWRD{{{GENERATE VRBLK POINTER{17109
{{EJC{{{{{17110
*
*      CDGNM (CONTINUED)
*
*      HERE TO EXIT WITH WC SET CORRECTLY
*
{CGN03{MOV{8,WB{10,(XS)+{{RESTORE ENTRY WB{17116
{{MOV{7,XL{10,(XS)+{{RESTORE ENTRY XL{17117
{{EXI{{{{RETURN TO CDGNM CALLER{17118
*
*      HERE FOR CMBLK
*
{CGN04{MOV{7,XL{7,XR{{COPY CMBLK POINTER{17122
{{MOV{7,XR{13,CMTYP(XR){{LOAD CMBLK TYPE{17123
{{BGE{7,XR{18,=C__NM{6,CGN01{ERROR IF NOT NAME OPERAND{17124
{{BSW{7,XR{2,C__NM{{ELSE SWITCH ON TYPE{17125
{{IFF{2,C_ARR{6,CGN05{{ARRAY REFERENCE{17133
{{IFF{2,C_FNC{6,CGN08{{FUNCTION CALL{17133
{{IFF{2,C_DEF{6,CGN09{{DEFERRED EXPRESSION{17133
{{IFF{2,C_IND{6,CGN10{{INDIRECT REFERENCE{17133
{{IFF{2,C_KEY{6,CGN11{{KEYWORD REFERENCE{17133
{{IFF{2,C_UBO{6,CGN08{{UNDEFINED BINARY OP{17133
{{IFF{2,C_UUO{6,CGN08{{UNDEFINED UNARY OP{17133
{{ESW{{{{END SWITCH ON CMBLK TYPE{17133
*
*      HERE TO GENERATE CODE FOR ARRAY REFERENCE
*
{CGN05{MOV{8,WB{19,*CMOPN{{POINT TO ARRAY OPERAND{17137
*
*      LOOP TO GENERATE CODE FOR ARRAY OPERAND AND SUBSCRIPTS
*
{CGN06{JSR{6,CMGEN{{{GENERATE CODE FOR NEXT OPERAND{17141
{{MOV{8,WC{13,CMLEN(XL){{LOAD LENGTH OF CMBLK{17142
{{BLT{8,WB{8,WC{6,CGN06{LOOP TILL ALL GENERATED{17143
*
*      GENERATE APPROPRIATE ARRAY CALL
*
{{MOV{8,WA{21,=OAON_{{LOAD ONE-SUBSCRIPT CASE CALL{17147
{{BEQ{8,WC{19,*CMAR1{6,CGN07{JUMP TO EXIT IF ONE SUBSCRIPT CASE{17148
{{MOV{8,WA{21,=OAMN_{{ELSE LOAD MULTI-SUBSCRIPT CASE CALL{17149
{{JSR{6,CDWRD{{{GENERATE CALL{17150
{{MOV{8,WA{8,WC{{COPY CMBLK LENGTH{17151
{{BTW{8,WA{{{CONVERT TO WORDS{17152
{{SUB{8,WA{18,=CMVLS{{CALCULATE NUMBER OF SUBSCRIPTS{17153
{{EJC{{{{{17154
*
*      CDGNM (CONTINUED)
*
*      HERE TO EXIT GENERATING WORD (NON-CONSTANT)
*
{CGN07{MNZ{8,WC{{{SET RESULT NON-CONSTANT{17160
{{JSR{6,CDWRD{{{GENERATE WORD{17161
{{BRN{6,CGN03{{{BACK TO EXIT{17162
*
*      HERE TO GENERATE CODE FOR FUNCTIONS AND UNDEFINED OPRS
*
{CGN08{MOV{7,XR{7,XL{{COPY CMBLK POINTER{17166
{{JSR{6,CDGVL{{{GEN CODE BY VALUE FOR CALL{17167
{{MOV{8,WA{21,=OFNE_{{GET EXTRA CALL FOR BY NAME{17168
{{BRN{6,CGN07{{{BACK TO GENERATE AND EXIT{17169
*
*      HERE TO GENERATE CODE FOR DEFERED EXPRESSION
*
{CGN09{MOV{7,XR{13,CMROP(XL){{CHECK IF VARIABLE{17173
{{BHI{9,(XR){22,=B_VR_{6,CGN02{TREAT *VARIABLE AS SIMPLE VAR{17174
{{MOV{7,XL{7,XR{{COPY PTR TO EXPRESSION TREE{17175
{{MOV{8,WA{18,=NUM01{{RETURN NAME{17177
{{JSR{6,CDGEX{{{ELSE BUILD EXBLK{17179
{{MOV{8,WA{21,=OLEX_{{SET CALL TO LOAD EXPR BY NAME{17180
{{JSR{6,CDWRD{{{GENERATE IT{17181
{{MOV{8,WA{7,XR{{COPY EXBLK POINTER{17182
{{JSR{6,CDWRD{{{GENERATE EXBLK POINTER{17183
{{BRN{6,CGN03{{{BACK TO EXIT{17184
*
*      HERE TO GENERATE CODE FOR INDIRECT REFERENCE
*
{CGN10{MOV{7,XR{13,CMROP(XL){{GET OPERAND{17188
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE FOR IT{17189
{{MOV{8,WA{21,=OINN_{{LOAD CALL FOR INDIRECT BY NAME{17190
{{BRN{6,CGN12{{{MERGE{17191
*
*      HERE TO GENERATE CODE FOR KEYWORD REFERENCE
*
{CGN11{MOV{7,XR{13,CMROP(XL){{GET OPERAND{17195
{{JSR{6,CDGNM{{{GENERATE CODE BY NAME FOR IT{17196
{{MOV{8,WA{21,=OKWN_{{LOAD CALL FOR KEYWORD BY NAME{17197
*
*      KEYWORD, INDIRECT MERGE HERE
*
{CGN12{JSR{6,CDWRD{{{GENERATE CODE FOR OPERATOR{17201
{{BRN{6,CGN03{{{EXIT{17202
{{ENP{{{{END PROCEDURE CDGNM{17203
{{EJC{{{{{17204
*
*      CDGVL -- GENERATE CODE BY VALUE
*
*      CDGVL IS CALLED DURING THE COMPILATION PROCESS TO
*      GENERATE CODE BY VALUE FOR AN EXPRESSION. SEE CDBLK
*      DESCRIPTION FOR DETAILS OF THE CODE GENERATED. THE INPUT
*      TO CDGVL IS AN EXPRESSION TREE AS GENERATED BY EXPAN.
*
*      CDGVL IS A RECURSIVE PROCEDURE WHICH PROCEEDS BY MAKING
*      RECURSIVE CALLS TO GENERATE CODE FOR OPERANDS.
*
*      (WB)                  INTEGER IN RANGE 0 LE N LE DNAMB
*      (XR)                  PTR TO TREE GENERATED BY EXPAN
*      (WC)                  CONSTANT FLAG (SEE BELOW)
*      JSR  CDGVL            CALL TO GENERATE CODE BY VALUE
*      (XR,WA)               DESTROYED
*      (WC)                  SET NON-ZERO IF NON-CONSTANT
*
*      WC IS SET TO A NON-ZERO (COLLECTABLE) VALUE IF THE
*      EXPRESSION FOR WHICH CODE IS GENERATED CANNOT BE
*      EVALUATED AT COMPILE TIME, OTHERWISE WC IS UNCHANGED.
*
*      IF WC IS NON-ZERO ON ENTRY, THEN PREEVALUATION IS NOT
*      ALLOWED REGARDLESS OF THE NATURE OF THE OPERAND.
*
*      THE CODE IS GENERATED IN THE CURRENT CCBLK (SEE CDWRD).
*
{CDGVL{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{17232
{{MOV{8,WA{9,(XR){{LOAD TYPE WORD{17233
{{BEQ{8,WA{22,=B_CMT{6,CGV01{JUMP IF CMBLK{17234
{{BLT{8,WA{22,=B_VRA{6,CGV00{JUMP IF ICBLK, RCBLK, SCBLK{17235
{{BNZ{13,VRLEN(XR){6,CGVL0{{JUMP IF NOT SYSTEM VARIABLE{17236
{{MOV{11,-(XS){7,XR{{STACK XR{17237
{{MOV{7,XR{13,VRSVP(XR){{POINT TO SVBLK{17238
{{MOV{8,WA{13,SVBIT(XR){{GET SVBLK PROPERTY BITS{17239
{{MOV{7,XR{10,(XS)+{{RECOVER XR{17240
{{ANB{8,WA{4,BTKWV{{CHECK IF CONSTANT KEYWORD VALUE{17241
{{BEQ{8,WA{4,BTKWV{6,CGV00{JUMP IF CONSTANT KEYWORD VALUE{17242
*
*      HERE FOR VARIABLE VALUE REFERENCE
*
{CGVL0{MNZ{8,WC{{{INDICATE NON-CONSTANT VALUE{17246
*
*      MERGE HERE FOR SIMPLE CONSTANT (ICBLK,RCBLK,SCBLK)
*      AND FOR VARIABLES CORRESPONDING TO CONSTANT KEYWORDS.
*
{CGV00{MOV{8,WA{7,XR{{COPY PTR TO VAR OR CONSTANT{17251
{{JSR{6,CDWRD{{{GENERATE AS CODE WORD{17252
{{EXI{{{{RETURN TO CALLER{17253
{{EJC{{{{{17254
*
*      CDGVL (CONTINUED)
*
*      HERE FOR TREE NODE (CMBLK)
*
{CGV01{MOV{11,-(XS){8,WB{{SAVE ENTRY WB{17260
{{MOV{11,-(XS){7,XL{{SAVE ENTRY XL{17261
{{MOV{11,-(XS){8,WC{{SAVE ENTRY CONSTANT FLAG{17262
{{MOV{11,-(XS){3,CWCOF{{SAVE INITIAL CODE OFFSET{17263
{{CHK{{{{CHECK FOR STACK OVERFLOW{17264
*
*      PREPARE TO GENERATE CODE FOR CMBLK. WC IS SET TO THE
*      VALUE OF CSWNO (ZERO IF -OPTIMISE, 1 IF -NOOPT) TO
*      START WITH AND IS RESET NON-ZERO FOR ANY NON-CONSTANT
*      CODE GENERATED. IF IT IS STILL ZERO AFTER GENERATING ALL
*      THE CMBLK CODE, THEN ITS VALUE IS COMPUTED AS THE RESULT.
*
{{MOV{7,XL{7,XR{{COPY CMBLK POINTER{17272
{{MOV{7,XR{13,CMTYP(XR){{LOAD CMBLK TYPE{17273
{{MOV{8,WC{3,CSWNO{{RESET CONSTANT FLAG{17274
{{BLE{7,XR{18,=C_PR_{6,CGV02{JUMP IF NOT PREDICATE VALUE{17275
{{MNZ{8,WC{{{ELSE FORCE NON-CONSTANT CASE{17276
*
*      HERE WITH WC SET APPROPRIATELY
*
{CGV02{BSW{7,XR{2,C__NV{{SWITCH TO APPROPRIATE GENERATOR{17280
{{IFF{2,C_ARR{6,CGV03{{ARRAY REFERENCE{17300
{{IFF{2,C_FNC{6,CGV05{{FUNCTION CALL{17300
{{IFF{2,C_DEF{6,CGV14{{DEFERRED EXPRESSION{17300
{{IFF{2,C_IND{6,CGV31{{INDIRECT REFERENCE{17300
{{IFF{2,C_KEY{6,CGV27{{KEYWORD REFERENCE{17300
{{IFF{2,C_UBO{6,CGV29{{UNDEFINED BINOP{17300
{{IFF{2,C_UUO{6,CGV30{{UNDEFINED UNOP{17300
{{IFF{2,C_BVL{6,CGV18{{BINOPS WITH VAL OPDS{17300
{{IFF{2,C_UVL{6,CGV19{{UNOPS WITH VALU OPND{17300
{{IFF{2,C_ALT{6,CGV18{{ALTERNATION{17300
{{IFF{2,C_CNC{6,CGV24{{CONCATENATION{17300
{{IFF{2,C_CNP{6,CGV24{{CONCATENATION (NOT PATTERN MATCH){17300
{{IFF{2,C_UNM{6,CGV27{{UNOPS WITH NAME OPND{17300
{{IFF{2,C_BVN{6,CGV26{{BINARY _ AND .{17300
{{IFF{2,C_ASS{6,CGV21{{ASSIGNMENT{17300
{{IFF{2,C_INT{6,CGV31{{INTERROGATION{17300
{{IFF{2,C_NEG{6,CGV28{{NEGATION{17300
{{IFF{2,C_SEL{6,CGV15{{SELECTION{17300
{{IFF{2,C_PMT{6,CGV18{{PATTERN MATCH{17300
{{ESW{{{{END SWITCH ON CMBLK TYPE{17300
{{EJC{{{{{17301
*
*      CDGVL (CONTINUED)
*
*      HERE TO GENERATE CODE FOR ARRAY REFERENCE
*
{CGV03{MOV{8,WB{19,*CMOPN{{SET OFFSET TO ARRAY OPERAND{17307
*
*      LOOP TO GENERATE CODE FOR ARRAY OPERAND AND SUBSCRIPTS
*
{CGV04{JSR{6,CMGEN{{{GEN VALUE CODE FOR NEXT OPERAND{17311
{{MOV{8,WC{13,CMLEN(XL){{LOAD CMBLK LENGTH{17312
{{BLT{8,WB{8,WC{6,CGV04{LOOP BACK IF MORE TO GO{17313
*
*      GENERATE CALL TO APPROPRIATE ARRAY REFERENCE ROUTINE
*
{{MOV{8,WA{21,=OAOV_{{SET ONE SUBSCRIPT CALL IN CASE{17317
{{BEQ{8,WC{19,*CMAR1{6,CGV32{JUMP TO EXIT IF 1-SUB CASE{17318
{{MOV{8,WA{21,=OAMV_{{ELSE SET CALL FOR MULTI-SUBSCRIPTS{17319
{{JSR{6,CDWRD{{{GENERATE CALL{17320
{{MOV{8,WA{8,WC{{COPY LENGTH OF CMBLK{17321
{{SUB{8,WA{19,*CMVLS{{SUBTRACT STANDARD LENGTH{17322
{{BTW{8,WA{{{GET NUMBER OF WORDS{17323
{{BRN{6,CGV32{{{JUMP TO GENERATE SUBSCRIPT COUNT{17324
*
*      HERE TO GENERATE CODE FOR FUNCTION CALL
*
{CGV05{MOV{8,WB{19,*CMVLS{{SET OFFSET TO FIRST ARGUMENT{17328
*
*      LOOP TO GENERATE CODE FOR ARGUMENTS
*
{CGV06{BEQ{8,WB{13,CMLEN(XL){6,CGV07{JUMP IF ALL GENERATED{17332
{{JSR{6,CMGEN{{{ELSE GEN VALUE CODE FOR NEXT ARG{17333
{{BRN{6,CGV06{{{BACK TO GENERATE NEXT ARGUMENT{17334
*
*      HERE TO GENERATE ACTUAL FUNCTION CALL
*
{CGV07{SUB{8,WB{19,*CMVLS{{GET NUMBER OF ARG PTRS (BYTES){17338
{{BTW{8,WB{{{CONVERT BYTES TO WORDS{17339
{{MOV{7,XR{13,CMOPN(XL){{LOAD FUNCTION VRBLK POINTER{17340
{{BNZ{13,VRLEN(XR){6,CGV12{{JUMP IF NOT SYSTEM FUNCTION{17341
{{MOV{7,XL{13,VRSVP(XR){{LOAD SVBLK PTR IF SYSTEM VAR{17342
{{MOV{8,WA{13,SVBIT(XL){{LOAD BIT MASK{17343
{{ANB{8,WA{4,BTFFC{{TEST FOR FAST FUNCTION CALL ALLOWED{17344
{{ZRB{8,WA{6,CGV12{{JUMP IF NOT{17345
{{EJC{{{{{17346
*
*      CDGVL (CONTINUED)
*
*      HERE IF FAST FUNCTION CALL IS ALLOWED
*
{{MOV{8,WA{13,SVBIT(XL){{RELOAD BIT INDICATORS{17352
{{ANB{8,WA{4,BTPRE{{TEST FOR PREEVALUATION OK{17353
{{NZB{8,WA{6,CGV08{{JUMP IF PREEVALUATION PERMITTED{17354
{{MNZ{8,WC{{{ELSE SET RESULT NON-CONSTANT{17355
*
*      TEST FOR CORRECT NUMBER OF ARGS FOR FAST CALL
*
{CGV08{MOV{7,XL{13,VRFNC(XR){{LOAD PTR TO SVFNC FIELD{17359
{{MOV{8,WA{13,FARGS(XL){{LOAD SVNAR FIELD VALUE{17360
{{BEQ{8,WA{8,WB{6,CGV11{JUMP IF ARGUMENT COUNT IS CORRECT{17361
{{BHI{8,WA{8,WB{6,CGV09{JUMP IF TOO FEW ARGUMENTS GIVEN{17362
*
*      HERE IF TOO MANY ARGUMENTS, PREPARE TO GENERATE O_POPS
*
{{SUB{8,WB{8,WA{{GET NUMBER OF EXTRA ARGS{17366
{{LCT{8,WB{8,WB{{SET AS COUNT TO CONTROL LOOP{17367
{{MOV{8,WA{21,=OPOP_{{SET POP CALL{17368
{{BRN{6,CGV10{{{JUMP TO COMMON LOOP{17369
*
*      HERE IF TOO FEW ARGUMENTS, PREPARE TO GENERATE NULLS
*
{CGV09{SUB{8,WA{8,WB{{GET NUMBER OF MISSING ARGUMENTS{17373
{{LCT{8,WB{8,WA{{LOAD AS COUNT TO CONTROL LOOP{17374
{{MOV{8,WA{21,=NULLS{{LOAD PTR TO NULL CONSTANT{17375
*
*      LOOP TO GENERATE CALLS TO FIX ARGUMENT COUNT
*
{CGV10{JSR{6,CDWRD{{{GENERATE ONE CALL{17379
{{BCT{8,WB{6,CGV10{{LOOP TILL ALL GENERATED{17380
*
*      HERE AFTER ADJUSTING ARG COUNT AS REQUIRED
*
{CGV11{MOV{8,WA{7,XL{{COPY POINTER TO SVFNC FIELD{17384
{{BRN{6,CGV36{{{JUMP TO GENERATE CALL{17385
{{EJC{{{{{17386
*
*      CDGVL (CONTINUED)
*
*      COME HERE IF FAST CALL IS NOT PERMITTED
*
{CGV12{MOV{8,WA{21,=OFNS_{{SET ONE ARG CALL IN CASE{17392
{{BEQ{8,WB{18,=NUM01{6,CGV13{JUMP IF ONE ARG CASE{17393
{{MOV{8,WA{21,=OFNC_{{ELSE LOAD CALL FOR MORE THAN 1 ARG{17394
{{JSR{6,CDWRD{{{GENERATE IT{17395
{{MOV{8,WA{8,WB{{COPY ARGUMENT COUNT{17396
*
*      ONE ARG CASE MERGES HERE
*
{CGV13{JSR{6,CDWRD{{{GENERATE =O_FNS OR ARG COUNT{17400
{{MOV{8,WA{7,XR{{COPY VRBLK POINTER{17401
{{BRN{6,CGV32{{{JUMP TO GENERATE VRBLK PTR{17402
*
*      HERE FOR DEFERRED EXPRESSION
*
{CGV14{MOV{7,XL{13,CMROP(XL){{POINT TO EXPRESSION TREE{17406
{{ZER{8,WA{{{RETURN VALUE{17408
{{JSR{6,CDGEX{{{BUILD EXBLK OR SEBLK{17410
{{MOV{8,WA{7,XR{{COPY BLOCK PTR{17411
{{JSR{6,CDWRD{{{GENERATE PTR TO EXBLK OR SEBLK{17412
{{BRN{6,CGV34{{{JUMP TO EXIT, CONSTANT TEST{17413
*
*      HERE TO GENERATE CODE FOR SELECTION
*
{CGV15{ZER{11,-(XS){{{ZERO PTR TO CHAIN OF FORWARD JUMPS{17417
{{ZER{11,-(XS){{{ZERO PTR TO PREV O_SLC FORWARD PTR{17418
{{MOV{8,WB{19,*CMVLS{{POINT TO FIRST ALTERNATIVE{17419
{{MOV{8,WA{21,=OSLA_{{SET INITIAL CODE WORD{17420
*
*      0(XS)                 IS THE OFFSET TO THE PREVIOUS WORD
*                            WHICH REQUIRES FILLING IN WITH AN
*                            OFFSET TO THE FOLLOWING O_SLC,O_SLD
*
*      1(XS)                 IS THE HEAD OF A CHAIN OF OFFSET
*                            POINTERS INDICATING THOSE LOCATIONS
*                            TO BE FILLED WITH OFFSETS PAST
*                            THE END OF ALL THE ALTERNATIVES
*
{CGV16{JSR{6,CDWRD{{{GENERATE O_SLC (O_SLA FIRST TIME){17431
{{MOV{9,(XS){3,CWCOF{{SET CURRENT LOC AS PTR TO FILL IN{17432
{{JSR{6,CDWRD{{{GENERATE GARBAGE WORD THERE FOR NOW{17433
{{JSR{6,CMGEN{{{GEN VALUE CODE FOR ALTERNATIVE{17434
{{MOV{8,WA{21,=OSLB_{{LOAD O_SLB POINTER{17435
{{JSR{6,CDWRD{{{GENERATE O_SLB CALL{17436
{{MOV{8,WA{13,NUM01(XS){{LOAD OLD CHAIN PTR{17437
{{MOV{13,NUM01(XS){3,CWCOF{{SET CURRENT LOC AS NEW CHAIN HEAD{17438
{{JSR{6,CDWRD{{{GENERATE FORWARD CHAIN LINK{17439
{{EJC{{{{{17440
*
*      CDGVL (CONTINUED)
*
*      NOW TO FILL IN THE SKIP OFFSET TO O_SLC,O_SLD
*
{{MOV{7,XR{9,(XS){{LOAD OFFSET TO WORD TO PLUG{17446
{{ADD{7,XR{3,R_CCB{{POINT TO ACTUAL LOCATION TO PLUG{17447
{{MOV{9,(XR){3,CWCOF{{PLUG PROPER OFFSET IN{17448
{{MOV{8,WA{21,=OSLC_{{LOAD O_SLC PTR FOR NEXT ALTERNATIVE{17449
{{MOV{7,XR{8,WB{{COPY OFFSET (DESTROY GARBAGE XR){17450
{{ICA{7,XR{{{BUMP EXTRA TIME FOR TEST{17451
{{BLT{7,XR{13,CMLEN(XL){6,CGV16{LOOP BACK IF NOT LAST ALTERNATIVE{17452
*
*      HERE TO GENERATE CODE FOR LAST ALTERNATIVE
*
{{MOV{8,WA{21,=OSLD_{{GET HEADER CALL{17456
{{JSR{6,CDWRD{{{GENERATE O_SLD CALL{17457
{{JSR{6,CMGEN{{{GENERATE CODE FOR LAST ALTERNATIVE{17458
{{ICA{7,XS{{{POP OFFSET PTR{17459
{{MOV{7,XR{10,(XS)+{{LOAD CHAIN PTR{17460
*
*      LOOP TO PLUG OFFSETS PAST STRUCTURE
*
{CGV17{ADD{7,XR{3,R_CCB{{MAKE NEXT PTR ABSOLUTE{17464
{{MOV{8,WA{9,(XR){{LOAD FORWARD PTR{17465
{{MOV{9,(XR){3,CWCOF{{PLUG REQUIRED OFFSET{17466
{{MOV{7,XR{8,WA{{COPY FORWARD PTR{17467
{{BNZ{8,WA{6,CGV17{{LOOP BACK IF MORE TO GO{17468
{{BRN{6,CGV33{{{ELSE JUMP TO EXIT (NOT CONSTANT){17469
*
*      HERE FOR BINARY OPS WITH VALUE OPERANDS
*
{CGV18{MOV{7,XR{13,CMLOP(XL){{LOAD LEFT OPERAND POINTER{17473
{{JSR{6,CDGVL{{{GEN VALUE CODE FOR LEFT OPERAND{17474
*
*      HERE FOR UNARY OPS WITH VALUE OPERAND (BINOPS MERGE)
*
{CGV19{MOV{7,XR{13,CMROP(XL){{LOAD RIGHT (ONLY) OPERAND PTR{17478
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{17479
{{EJC{{{{{17480
*
*      CDGVL (CONTINUED)
*
*      MERGE HERE TO GENERATE OPERATOR CALL FROM CMOPN FIELD
*
{CGV20{MOV{8,WA{13,CMOPN(XL){{LOAD OPERATOR CALL POINTER{17486
{{BRN{6,CGV36{{{JUMP TO GENERATE IT WITH CONS TEST{17487
*
*      HERE FOR ASSIGNMENT
*
{CGV21{MOV{7,XR{13,CMLOP(XL){{LOAD LEFT OPERAND POINTER{17491
{{BLO{9,(XR){22,=B_VR_{6,CGV22{JUMP IF NOT VARIABLE{17492
*
*      HERE FOR ASSIGNMENT TO SIMPLE VARIABLE
*
{{MOV{7,XR{13,CMROP(XL){{LOAD RIGHT OPERAND PTR{17496
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{17497
{{MOV{8,WA{13,CMLOP(XL){{RELOAD LEFT OPERAND VRBLK PTR{17498
{{ADD{8,WA{19,*VRSTO{{POINT TO VRSTO FIELD{17499
{{BRN{6,CGV32{{{JUMP TO GENERATE STORE PTR{17500
*
*      HERE IF NOT SIMPLE VARIABLE ASSIGNMENT
*
{CGV22{JSR{6,EXPAP{{{TEST FOR PATTERN MATCH ON LEFT SIDE{17504
{{PPM{6,CGV23{{{JUMP IF NOT PATTERN MATCH{17505
*
*      HERE FOR PATTERN REPLACEMENT
*
{{MOV{13,CMLOP(XL){13,CMROP(XR){{SAVE PATTERN PTR IN SAFE PLACE{17509
{{MOV{7,XR{13,CMLOP(XR){{LOAD SUBJECT PTR{17510
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR SUBJECT{17511
{{MOV{7,XR{13,CMLOP(XL){{LOAD PATTERN PTR{17512
{{JSR{6,CDGVL{{{GEN CODE BY VALUE FOR PATTERN{17513
{{MOV{8,WA{21,=OPMN_{{LOAD MATCH BY NAME CALL{17514
{{JSR{6,CDWRD{{{GENERATE IT{17515
{{MOV{7,XR{13,CMROP(XL){{LOAD REPLACEMENT VALUE PTR{17516
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{17517
{{MOV{8,WA{21,=ORPL_{{LOAD REPLACE CALL{17518
{{BRN{6,CGV32{{{JUMP TO GEN AND EXIT (NOT CONSTANT){17519
*
*      HERE FOR ASSIGNMENT TO COMPLEX VARIABLE
*
{CGV23{MNZ{8,WC{{{INHIBIT PRE-EVALUATION{17523
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR LEFT SIDE{17524
{{BRN{6,CGV31{{{MERGE WITH UNOP CIRCUIT{17525
{{EJC{{{{{17526
*
*      CDGVL (CONTINUED)
*
*      HERE FOR CONCATENATION
*
{CGV24{MOV{7,XR{13,CMLOP(XL){{LOAD LEFT OPERAND PTR{17532
{{BNE{9,(XR){22,=B_CMT{6,CGV18{ORDINARY BINOP IF NOT CMBLK{17533
{{MOV{8,WB{13,CMTYP(XR){{LOAD CMBLK TYPE CODE{17534
{{BEQ{8,WB{18,=C_INT{6,CGV25{SPECIAL CASE IF INTERROGATION{17535
{{BEQ{8,WB{18,=C_NEG{6,CGV25{OR NEGATION{17536
{{BNE{8,WB{18,=C_FNC{6,CGV18{ELSE ORDINARY BINOP IF NOT FUNCTION{17537
{{MOV{7,XR{13,CMOPN(XR){{ELSE LOAD FUNCTION VRBLK PTR{17538
{{BNZ{13,VRLEN(XR){6,CGV18{{ORDINARY BINOP IF NOT SYSTEM VAR{17539
{{MOV{7,XR{13,VRSVP(XR){{ELSE POINT TO SVBLK{17540
{{MOV{8,WA{13,SVBIT(XR){{LOAD BIT INDICATORS{17541
{{ANB{8,WA{4,BTPRD{{TEST FOR PREDICATE FUNCTION{17542
{{ZRB{8,WA{6,CGV18{{ORDINARY BINOP IF NOT{17543
*
*      HERE IF LEFT ARG OF CONCATENATION IS PREDICATE FUNCTION
*
{CGV25{MOV{7,XR{13,CMLOP(XL){{RELOAD LEFT ARG{17547
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{17548
{{MOV{8,WA{21,=OPOP_{{LOAD POP CALL{17549
{{JSR{6,CDWRD{{{GENERATE IT{17550
{{MOV{7,XR{13,CMROP(XL){{LOAD RIGHT OPERAND{17551
{{JSR{6,CDGVL{{{GEN CODE BY VALUE AS RESULT CODE{17552
{{BRN{6,CGV33{{{EXIT (NOT CONSTANT){17553
*
*      HERE TO GENERATE CODE FOR PATTERN, IMMEDIATE ASSIGNMENT
*
{CGV26{MOV{7,XR{13,CMLOP(XL){{LOAD LEFT OPERAND{17557
{{JSR{6,CDGVL{{{GEN CODE BY VALUE, MERGE{17558
*
*      HERE FOR UNOPS WITH ARG BY NAME (BINARY _ . MERGE)
*
{CGV27{MOV{7,XR{13,CMROP(XL){{LOAD RIGHT OPERAND PTR{17562
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR RIGHT ARG{17563
{{MOV{7,XR{13,CMOPN(XL){{GET OPERATOR CODE WORD{17564
{{BNE{9,(XR){22,=O_KWV{6,CGV20{GEN CALL UNLESS KEYWORD VALUE{17565
{{EJC{{{{{17566
*
*      CDGVL (CONTINUED)
*
*      HERE FOR KEYWORD BY VALUE. THIS IS CONSTANT ONLY IF
*      THE OPERAND IS ONE OF THE SPECIAL SYSTEM VARIABLES WITH
*      THE SVCKW BIT SET TO INDICATE A CONSTANT KEYWORD VALUE.
*      NOTE THAT THE ONLY CONSTANT OPERAND BY NAME IS A VARIABLE
*
{{BNZ{8,WC{6,CGV20{{GEN CALL IF NON-CONSTANT (NOT VAR){17575
{{MNZ{8,WC{{{ELSE SET NON-CONSTANT IN CASE{17576
{{MOV{7,XR{13,CMROP(XL){{LOAD PTR TO OPERAND VRBLK{17577
{{BNZ{13,VRLEN(XR){6,CGV20{{GEN (NON-CONSTANT) IF NOT SYS VAR{17578
{{MOV{7,XR{13,VRSVP(XR){{ELSE LOAD PTR TO SVBLK{17579
{{MOV{8,WA{13,SVBIT(XR){{LOAD BIT MASK{17580
{{ANB{8,WA{4,BTCKW{{TEST FOR CONSTANT KEYWORD{17581
{{ZRB{8,WA{6,CGV20{{GO GEN IF NOT CONSTANT{17582
{{ZER{8,WC{{{ELSE SET RESULT CONSTANT{17583
{{BRN{6,CGV20{{{AND JUMP BACK TO GENERATE CALL{17584
*
*      HERE TO GENERATE CODE FOR NEGATION
*
{CGV28{MOV{8,WA{21,=ONTA_{{GET INITIAL WORD{17588
{{JSR{6,CDWRD{{{GENERATE IT{17589
{{MOV{8,WB{3,CWCOF{{SAVE NEXT OFFSET{17590
{{JSR{6,CDWRD{{{GENERATE GUNK WORD FOR NOW{17591
{{MOV{7,XR{13,CMROP(XL){{LOAD RIGHT OPERAND PTR{17592
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{17593
{{MOV{8,WA{21,=ONTB_{{LOAD END OF EVALUATION CALL{17594
{{JSR{6,CDWRD{{{GENERATE IT{17595
{{MOV{7,XR{8,WB{{COPY OFFSET TO WORD TO PLUG{17596
{{ADD{7,XR{3,R_CCB{{POINT TO ACTUAL WORD TO PLUG{17597
{{MOV{9,(XR){3,CWCOF{{PLUG WORD WITH CURRENT OFFSET{17598
{{MOV{8,WA{21,=ONTC_{{LOAD FINAL CALL{17599
{{BRN{6,CGV32{{{JUMP TO GENERATE IT (NOT CONSTANT){17600
*
*      HERE TO GENERATE CODE FOR UNDEFINED BINARY OPERATOR
*
{CGV29{MOV{7,XR{13,CMLOP(XL){{LOAD LEFT OPERAND PTR{17604
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{17605
{{EJC{{{{{17606
*
*      CDGVL (CONTINUED)
*
*      HERE TO GENERATE CODE FOR UNDEFINED UNARY OPERATOR
*
{CGV30{MOV{8,WB{18,=C_UO_{{SET UNOP CODE + 1{17612
{{SUB{8,WB{13,CMTYP(XL){{SET NUMBER OF ARGS (1 OR 2){17613
*
*      MERGE HERE FOR UNDEFINED OPERATORS
*
{{MOV{7,XR{13,CMROP(XL){{LOAD RIGHT (ONLY) OPERAND POINTER{17617
{{JSR{6,CDGVL{{{GEN VALUE CODE FOR RIGHT OPERAND{17618
{{MOV{7,XR{13,CMOPN(XL){{LOAD POINTER TO OPERATOR DV{17619
{{MOV{7,XR{13,DVOPN(XR){{LOAD POINTER OFFSET{17620
{{WTB{7,XR{{{CONVERT WORD OFFSET TO BYTES{17621
{{ADD{7,XR{20,=R_UBA{{POINT TO PROPER FUNCTION PTR{17622
{{SUB{7,XR{19,*VRFNC{{SET STANDARD FUNCTION OFFSET{17623
{{BRN{6,CGV12{{{MERGE WITH FUNCTION CALL CIRCUIT{17624
*
*      HERE TO GENERATE CODE FOR INTERROGATION, INDIRECTION
*
{CGV31{MNZ{8,WC{{{SET NON CONSTANT{17628
{{BRN{6,CGV19{{{MERGE{17629
*
*      HERE TO EXIT GENERATING A WORD, RESULT NOT CONSTANT
*
{CGV32{JSR{6,CDWRD{{{GENERATE WORD, MERGE{17633
*
*      HERE TO EXIT WITH NO WORD GENERATED, NOT CONSTANT
*
{CGV33{MNZ{8,WC{{{INDICATE RESULT IS NOT CONSTANT{17637
*
*      COMMON EXIT POINT
*
{CGV34{ICA{7,XS{{{POP INITIAL CODE OFFSET{17641
{{MOV{8,WA{10,(XS)+{{RESTORE OLD CONSTANT FLAG{17642
{{MOV{7,XL{10,(XS)+{{RESTORE ENTRY XL{17643
{{MOV{8,WB{10,(XS)+{{RESTORE ENTRY WB{17644
{{BNZ{8,WC{6,CGV35{{JUMP IF NOT CONSTANT{17645
{{MOV{8,WC{8,WA{{ELSE RESTORE ENTRY CONSTANT FLAG{17646
*
*      HERE TO RETURN AFTER DEALING WITH WC SETTING
*
{CGV35{EXI{{{{RETURN TO CDGVL CALLER{17650
*
*      EXIT HERE TO GENERATE WORD AND TEST FOR CONSTANT
*
{CGV36{JSR{6,CDWRD{{{GENERATE WORD{17654
{{BNZ{8,WC{6,CGV34{{JUMP TO EXIT IF NOT CONSTANT{17655
{{EJC{{{{{17656
*
*      CDGVL (CONTINUED)
*
*      HERE TO PREEVALUATE CONSTANT SUB-EXPRESSION
*
{{MOV{8,WA{21,=ORVL_{{LOAD CALL TO RETURN VALUE{17662
{{JSR{6,CDWRD{{{GENERATE IT{17663
{{MOV{7,XL{9,(XS){{LOAD INITIAL CODE OFFSET{17664
{{JSR{6,EXBLD{{{BUILD EXBLK FOR EXPRESSION{17665
{{ZER{8,WB{{{SET TO EVALUATE BY VALUE{17666
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{17667
{{PPM{{{{SHOULD NOT FAIL{17668
{{MOV{8,WA{9,(XR){{LOAD TYPE WORD OF RESULT{17669
{{BLO{8,WA{22,=P_AAA{6,CGV37{JUMP IF NOT PATTERN{17670
{{MOV{8,WA{21,=OLPT_{{ELSE LOAD SPECIAL PATTERN LOAD CALL{17671
{{JSR{6,CDWRD{{{GENERATE IT{17672
*
*      MERGE HERE TO GENERATE POINTER TO RESULTING CONSTANT
*
{CGV37{MOV{8,WA{7,XR{{COPY CONSTANT POINTER{17676
{{JSR{6,CDWRD{{{GENERATE PTR{17677
{{ZER{8,WC{{{SET RESULT CONSTANT{17678
{{BRN{6,CGV34{{{JUMP BACK TO EXIT{17679
{{ENP{{{{END PROCEDURE CDGVL{17680
{{EJC{{{{{17681
*
*      CDWRD -- GENERATE ONE WORD OF CODE
*
*      CDWRD WRITES ONE WORD INTO THE CURRENT CODE BLOCK UNDER
*      CONSTRUCTION. A NEW, LARGER, BLOCK IS ALLOCATED IF THERE
*      IS INSUFFICIENT ROOM IN THE CURRENT BLOCK. CDWRD ENSURES
*      THAT THERE ARE AT LEAST FOUR WORDS LEFT IN THE BLOCK
*      AFTER ENTERING THE NEW WORD. THIS GUARANTEES THAT ANY
*      EXTRA SPACE AT THE END CAN BE SPLIT OFF AS A CCBLK.
*
*      (WA)                  WORD TO BE GENERATED
*      JSR  CDWRD            CALL TO GENERATE WORD
*
{CDWRD{PRC{25,E{1,0{{ENTRY POINT{17699
{{MOV{11,-(XS){7,XR{{SAVE ENTRY XR{17700
{{MOV{11,-(XS){8,WA{{SAVE CODE WORD TO BE GENERATED{17701
*
*      MERGE BACK HERE AFTER ALLOCATING LARGER BLOCK
*
{CDWD1{MOV{7,XR{3,R_CCB{{LOAD PTR TO CCBLK BEING BUILT{17705
{{BNZ{7,XR{6,CDWD2{{JUMP IF BLOCK ALLOCATED{17706
*
*      HERE WE ALLOCATE AN ENTIRELY FRESH BLOCK
*
{{MOV{8,WA{19,*E_CBS{{LOAD INITIAL LENGTH{17710
{{JSR{6,ALLOC{{{ALLOCATE CCBLK{17711
{{MOV{9,(XR){22,=B_CCT{{STORE TYPE WORD{17712
{{MOV{3,CWCOF{19,*CCCOD{{SET INITIAL OFFSET{17713
{{MOV{13,CCLEN(XR){8,WA{{STORE BLOCK LENGTH{17714
{{ZER{13,CCSLN(XR){{{ZERO LINE NUMBER{17716
{{MOV{3,R_CCB{7,XR{{STORE PTR TO NEW BLOCK{17718
*
*      HERE WE HAVE A BLOCK WE CAN USE
*
{CDWD2{MOV{8,WA{3,CWCOF{{LOAD CURRENT OFFSET{17722
{{ADD{8,WA{19,*NUM05{{ADJUST FOR TEST (FIVE WORDS){17724
{{BLO{8,WA{13,CCLEN(XR){6,CDWD4{JUMP IF ROOM IN THIS BLOCK{17728
*
*      HERE IF NO ROOM IN CURRENT BLOCK
*
{{BGE{8,WA{3,MXLEN{6,CDWD5{JUMP IF ALREADY AT MAX SIZE{17732
{{ADD{8,WA{19,*E_CBS{{ELSE GET NEW SIZE{17733
{{MOV{11,-(XS){7,XL{{SAVE ENTRY XL{17734
{{MOV{7,XL{7,XR{{COPY POINTER{17735
{{BLT{8,WA{3,MXLEN{6,CDWD3{JUMP IF NOT TOO LARGE{17736
{{MOV{8,WA{3,MXLEN{{ELSE RESET TO MAX ALLOWED SIZE{17737
{{EJC{{{{{17738
*
*      CDWRD (CONTINUED)
*
*      HERE WITH NEW BLOCK SIZE IN WA
*
{CDWD3{JSR{6,ALLOC{{{ALLOCATE NEW BLOCK{17744
{{MOV{3,R_CCB{7,XR{{STORE POINTER TO NEW BLOCK{17745
{{MOV{10,(XR)+{22,=B_CCT{{STORE TYPE WORD IN NEW BLOCK{17746
{{MOV{10,(XR)+{8,WA{{STORE BLOCK LENGTH{17747
{{MOV{10,(XR)+{13,CCSLN(XL){{COPY SOURCE LINE NUMBER WORD{17749
{{ADD{7,XL{19,*CCUSE{{POINT TO CCUSE,CCCOD FIELDS IN OLD{17751
{{MOV{8,WA{9,(XL){{LOAD CCUSE VALUE{17752
{{MVW{{{{COPY USEFUL WORDS FROM OLD BLOCK{17753
{{MOV{7,XL{10,(XS)+{{RESTORE XL{17754
{{BRN{6,CDWD1{{{MERGE BACK TO TRY AGAIN{17755
*
*      HERE WITH ROOM IN CURRENT BLOCK
*
{CDWD4{MOV{8,WA{3,CWCOF{{LOAD CURRENT OFFSET{17759
{{ICA{8,WA{{{GET NEW OFFSET{17760
{{MOV{3,CWCOF{8,WA{{STORE NEW OFFSET{17761
{{MOV{13,CCUSE(XR){8,WA{{STORE IN CCBLK FOR GBCOL{17762
{{DCA{8,WA{{{RESTORE PTR TO THIS WORD{17763
{{ADD{7,XR{8,WA{{POINT TO CURRENT ENTRY{17764
{{MOV{8,WA{10,(XS)+{{RELOAD WORD TO GENERATE{17765
{{MOV{9,(XR){8,WA{{STORE WORD IN BLOCK{17766
{{MOV{7,XR{10,(XS)+{{RESTORE ENTRY XR{17767
{{EXI{{{{RETURN TO CALLER{17768
*
*      HERE IF COMPILED CODE IS TOO LONG FOR CDBLK
*
{CDWD5{ERB{1,213{26,Syntax error: Statement is too complicated.{{{17772
{{ENP{{{{END PROCEDURE CDWRD{17773
{{EJC{{{{{17774
*
*      CMGEN -- GENERATE CODE FOR CMBLK PTR
*
*      CMGEN IS A SUBSIDIARY PROCEDURE USED TO GENERATE VALUE
*      CODE FOR A CMBLK PTR FROM THE MAIN CODE GENERATORS.
*
*      (XL)                  CMBLK POINTER
*      (WB)                  OFFSET TO POINTER IN CMBLK
*      JSR  CMGEN            CALL TO GENERATE CODE
*      (XR,WA)               DESTROYED
*      (WB)                  BUMPED BY ONE WORD
*
{CMGEN{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{17787
{{MOV{7,XR{7,XL{{COPY CMBLK POINTER{17788
{{ADD{7,XR{8,WB{{POINT TO CMBLK POINTER{17789
{{MOV{7,XR{9,(XR){{LOAD CMBLK POINTER{17790
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{17791
{{ICA{8,WB{{{BUMP OFFSET{17792
{{EXI{{{{RETURN TO CALLER{17793
{{ENP{{{{END PROCEDURE CMGEN{17794
{{EJC{{{{{17795
*
*      CMPIL (COMPILE SOURCE CODE)
*
*      CMPIL IS USED TO CONVERT SNOBOL4 SOURCE CODE TO INTERNAL
*      FORM (SEE CDBLK FORMAT). IT IS USED BOTH FOR THE INITIAL
*      COMPILE AND AT RUN TIME BY THE CODE AND CONVERT FUNCTIONS
*      THIS PROCEDURE HAS CONTROL FOR THE ENTIRE DURATION OF
*      INITIAL COMPILATION. AN ERROR IN ANY PROCEDURE CALLED
*      DURING COMPILATION WILL LEAD FIRST TO THE ERROR SECTION
*      AND ULTIMATELY BACK HERE FOR RESUMED COMPILATION. THE
*      RE-ENTRY POINTS AFTER AN ERROR ARE SPECIALLY LABELLED -
*
*      CMPCE                 RESUME AFTER CONTROL CARD ERROR
*      CMPLE                 RESUME AFTER LABEL ERROR
*      CMPSE                 RESUME AFTER STATEMENT ERROR
*
*      JSR  CMPIL            CALL TO COMPILE CODE
*      (XR)                  PTR TO CDBLK FOR ENTRY STATEMENT
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      THE FOLLOWING GLOBAL VARIABLES ARE REFERENCED
*
*      CMPLN                 LINE NUMBER OF FIRST LINE OF
*                            STATEMENT TO BE COMPILED
*
*      CMPSN                 NUMBER OF NEXT STATEMENT
*                            TO BE COMPILED.
*
*      CSWXX                 CONTROL CARD SWITCH VALUES ARE
*                            CHANGED WHEN RELEVANT CONTROL
*                            CARDS ARE MET.
*
*      CWCOF                 OFFSET TO NEXT WORD IN CODE BLOCK
*                            BEING BUILT (SEE CDWRD).
*
*      LSTSN                 NUMBER OF STATEMENT MOST RECENTLY
*                            COMPILED (INITIALLY SET TO ZERO).
*
*      R_CIM                 CURRENT (INITIAL) COMPILER IMAGE
*                            (ZERO FOR INITIAL COMPILE CALL)
*
*      R_CNI                 USED TO POINT TO FOLLOWING IMAGE.
*                            (SEE READR PROCEDURE).
*
*      SCNGO                 GOTO SWITCH FOR SCANE PROCEDURE
*
*      SCNIL                 LENGTH OF CURRENT IMAGE EXCLUDING
*                            CHARACTERS REMOVED BY -INPUT.
*
*      SCNPT                 CURRENT SCAN OFFSET, SEE SCANE.
*
*      SCNRS                 RESCAN SWITCH FOR SCANE PROCEDURE.
*
*      SCNSE                 OFFSET (IN R_CIM) OF MOST RECENTLY
*                            SCANNED ELEMENT. SET ZERO IF NOT
*                            CURRENTLY SCANNING ITEMS
{{EJC{{{{{17852
*
*      CMPIL (CONTINUED)
*
*      STAGE               STGIC  INITIAL COMPILE IN PROGRESS
*                          STGXC  CODE/CONVERT COMPILE
*                          STGEV  BUILDING EXBLK FOR EVAL
*                          STGXT  EXECUTE TIME (OUTSIDE COMPILE)
*                          STGCE  INITIAL COMPILE AFTER END LINE
*                          STGXE  EXECUTE COMPILE AFTER END LINE
*
*      CMPIL ALSO USES A FIXED NUMBER OF LOCATIONS ON THE
*      MAIN STACK AS FOLLOWS. (THE DEFINITIONS OF THE ACTUAL
*      OFFSETS ARE IN THE DEFINITIONS SECTION).
*
*      CMSTM(XS)             POINTER TO EXPAN TREE FOR BODY OF
*                            STATEMENT (SEE EXPAN PROCEDURE).
*
*      CMSGO(XS)             POINTER TO TREE REPRESENTATION OF
*                            SUCCESS GOTO (SEE PROCEDURE SCNGO)
*                            ZERO IF NO SUCCESS GOTO IS GIVEN
*
*      CMFGO(XS)             LIKE CMSGO FOR FAILURE GOTO.
*
*      CMCGO(XS)             SET NON-ZERO ONLY IF THERE IS A
*                            CONDITIONAL GOTO. USED FOR -FAIL,
*                            -NOFAIL CODE GENERATION.
*
*      CMPCD(XS)             POINTER TO CDBLK FOR PREVIOUS
*                            STATEMENT. ZERO FOR 1ST STATEMENT.
*
*      CMFFP(XS)             SET NON-ZERO IF CDFAL IN PREVIOUS
*                            CDBLK NEEDS FILLING WITH FORWARD
*                            POINTER, ELSE SET TO ZERO.
*
*      CMFFC(XS)             SAME AS CMFFP FOR CURRENT CDBLK
*
*      CMSOP(XS)             OFFSET TO WORD IN PREVIOUS CDBLK
*                            TO BE FILLED IN WITH FORWARD PTR
*                            TO NEXT CDBLK FOR SUCCESS GOTO.
*                            ZERO IF NO FILL IN IS REQUIRED.
*
*      CMSOC(XS)             SAME AS CMSOP FOR CURRENT CDBLK.
*
*      CMLBL(XS)             POINTER TO VRBLK FOR LABEL OF
*                            CURRENT STATEMENT. ZERO IF NO LABEL
*
*      CMTRA(XS)             POINTER TO CDBLK FOR ENTRY STMNT.
{{EJC{{{{{17900
*
*      CMPIL (CONTINUED)
*
*      ENTRY POINT
*
{CMPIL{PRC{25,E{1,0{{ENTRY POINT{17906
{{LCT{8,WB{18,=CMNEN{{SET NUMBER OF STACK WORK LOCATIONS{17907
*
*      LOOP TO INITIALIZE STACK WORKING LOCATIONS
*
{CMP00{ZER{11,-(XS){{{STORE A ZERO, MAKE ONE ENTRY{17911
{{BCT{8,WB{6,CMP00{{LOOP BACK UNTIL ALL SET{17912
{{MOV{3,CMPXS{7,XS{{SAVE STACK POINTER FOR ERROR SEC{17913
{{SSS{3,CMPSS{{{SAVE S-R STACK POINTER IF ANY{17914
*
*      LOOP THROUGH STATEMENTS
*
{CMP01{MOV{8,WB{3,SCNPT{{SET SCAN POINTER OFFSET{17918
{{MOV{3,SCNSE{8,WB{{SET START OF ELEMENT LOCATION{17919
{{MOV{8,WA{21,=OCER_{{POINT TO COMPILE ERROR CALL{17920
{{JSR{6,CDWRD{{{GENERATE AS TEMPORARY CDFAL{17921
{{BLT{8,WB{3,SCNIL{6,CMP04{JUMP IF CHARS LEFT ON THIS IMAGE{17922
*
*      LOOP HERE AFTER COMMENT OR CONTROL CARD
*      ALSO SPECIAL ENTRY AFTER CONTROL CARD ERROR
*
{CMPCE{ZER{7,XR{{{CLEAR POSSIBLE GARBAGE XR VALUE{17927
{{BNZ{3,CNIND{6,CMPC2{{IF WITHIN INCLUDE FILE{17929
{{BNE{3,STAGE{18,=STGIC{6,CMP02{SKIP UNLESS INITIAL COMPILE{17931
{CMPC2{JSR{6,READR{{{READ NEXT INPUT IMAGE{17932
{{BZE{7,XR{6,CMP09{{JUMP IF NO INPUT AVAILABLE{17933
{{JSR{6,NEXTS{{{ACQUIRE NEXT SOURCE IMAGE{17934
{{MOV{3,LSTSN{3,CMPSN{{STORE STMT NO FOR USE BY LISTR{17935
{{MOV{3,CMPLN{3,RDCLN{{STORE LINE NUMBER AT START OF STMT{17936
{{ZER{3,SCNPT{{{RESET SCAN POINTER{17937
{{BRN{6,CMP04{{{GO PROCESS IMAGE{17938
*
*      FOR EXECUTE TIME COMPILE, PERMIT EMBEDDED CONTROL CARDS
*      AND COMMENTS (BY SKIPPING TO NEXT SEMI-COLON)
*
{CMP02{MOV{7,XR{3,R_CIM{{GET CURRENT IMAGE{17943
{{MOV{8,WB{3,SCNPT{{GET CURRENT OFFSET{17944
{{PLC{7,XR{8,WB{{PREPARE TO GET CHARS{17945
*
*      SKIP TO SEMI-COLON
*
{CMP03{BGE{3,SCNPT{3,SCNIL{6,CMP09{END LOOP IF END OF IMAGE{17949
{{LCH{8,WC{10,(XR)+{{GET CHAR{17950
{{ICV{3,SCNPT{{{ADVANCE OFFSET{17951
{{BNE{8,WC{18,=CH_SM{6,CMP03{LOOP IF NOT SEMI-COLON{17952
{{EJC{{{{{17953
*
*      CMPIL (CONTINUED)
*
*      HERE WITH IMAGE AVAILABLE TO SCAN. NOTE THAT IF THE INPUT
*      STRING IS NULL, THEN EVERYTHING IS OK SINCE NULL IS
*      ACTUALLY ASSEMBLED AS A WORD OF BLANKS.
*
{CMP04{MOV{7,XR{3,R_CIM{{POINT TO CURRENT IMAGE{17961
{{MOV{8,WB{3,SCNPT{{LOAD CURRENT OFFSET{17962
{{MOV{8,WA{8,WB{{COPY FOR LABEL SCAN{17963
{{PLC{7,XR{8,WB{{POINT TO FIRST CHARACTER{17964
{{LCH{8,WC{10,(XR)+{{LOAD FIRST CHARACTER{17965
{{BEQ{8,WC{18,=CH_SM{6,CMP12{NO LABEL IF SEMICOLON{17966
{{BEQ{8,WC{18,=CH_AS{6,CMPCE{LOOP BACK IF COMMENT CARD{17967
{{BEQ{8,WC{18,=CH_MN{6,CMP32{JUMP IF CONTROL CARD{17968
{{MOV{3,R_CMP{3,R_CIM{{ABOUT TO DESTROY R_CIM{17969
{{MOV{7,XL{20,=CMLAB{{POINT TO LABEL WORK STRING{17970
{{MOV{3,R_CIM{7,XL{{SCANE IS TO SCAN WORK STRING{17971
{{PSC{7,XL{{{POINT TO FIRST CHARACTER POSITION{17972
{{SCH{8,WC{10,(XL)+{{STORE CHAR JUST LOADED{17973
{{MOV{8,WC{18,=CH_SM{{GET A SEMICOLON{17974
{{SCH{8,WC{9,(XL){{STORE AFTER FIRST CHAR{17975
{{CSC{7,XL{{{FINISHED CHARACTER STORING{17976
{{ZER{7,XL{{{CLEAR POINTER{17977
{{ZER{3,SCNPT{{{START AT FIRST CHARACTER{17978
{{MOV{11,-(XS){3,SCNIL{{PRESERVE IMAGE LENGTH{17979
{{MOV{3,SCNIL{18,=NUM02{{READ 2 CHARS AT MOST{17980
{{JSR{6,SCANE{{{SCAN FIRST CHAR FOR TYPE{17981
{{MOV{3,SCNIL{10,(XS)+{{RESTORE IMAGE LENGTH{17982
{{MOV{8,WC{7,XL{{NOTE RETURN CODE{17983
{{MOV{7,XL{3,R_CMP{{GET OLD R_CIM{17984
{{MOV{3,R_CIM{7,XL{{PUT IT BACK{17985
{{MOV{3,SCNPT{8,WB{{REINSTATE OFFSET{17986
{{BNZ{3,SCNBL{6,CMP12{{BLANK SEEN - CANT BE LABEL{17987
{{MOV{7,XR{7,XL{{POINT TO CURRENT IMAGE{17988
{{PLC{7,XR{8,WB{{POINT TO FIRST CHAR AGAIN{17989
{{BEQ{8,WC{18,=T_VAR{6,CMP06{OK IF LETTER{17990
{{BEQ{8,WC{18,=T_CON{6,CMP06{OK IF DIGIT{17991
*
*      DROP IN OR JUMP FROM ERROR SECTION IF SCANE FAILED
*
{CMPLE{MOV{3,R_CIM{3,R_CMP{{POINT TO BAD LINE{17995
{{ERB{1,214{26,Bad label or misplaced continuation line{{{17996
*
*      LOOP TO SCAN LABEL
*
{CMP05{BEQ{8,WC{18,=CH_SM{6,CMP07{SKIP IF SEMICOLON{18000
{{ICV{8,WA{{{BUMP OFFSET{18001
{{BEQ{8,WA{3,SCNIL{6,CMP07{JUMP IF END OF IMAGE (LABEL END){18002
{{EJC{{{{{18003
*
*      CMPIL (CONTINUED)
*
*      ENTER LOOP AT THIS POINT
*
{CMP06{LCH{8,WC{10,(XR)+{{ELSE LOAD NEXT CHARACTER{18009
{{BEQ{8,WC{18,=CH_HT{6,CMP07{JUMP IF HORIZONTAL TAB{18011
{{BNE{8,WC{18,=CH_BL{6,CMP05{LOOP BACK IF NON-BLANK{18016
*
*      HERE AFTER SCANNING OUT LABEL
*
{CMP07{MOV{3,SCNPT{8,WA{{SAVE UPDATED SCAN OFFSET{18020
{{SUB{8,WA{8,WB{{GET LENGTH OF LABEL{18021
{{BZE{8,WA{6,CMP12{{SKIP IF LABEL LENGTH ZERO{18022
{{ZER{7,XR{{{CLEAR GARBAGE XR VALUE{18023
{{JSR{6,SBSTR{{{BUILD SCBLK FOR LABEL NAME{18024
{{JSR{6,GTNVR{{{LOCATE/CONTRUCT VRBLK{18025
{{PPM{{{{DUMMY (IMPOSSIBLE) ERROR RETURN{18026
{{MOV{13,CMLBL(XS){7,XR{{STORE LABEL POINTER{18027
{{BNZ{13,VRLEN(XR){6,CMP11{{JUMP IF NOT SYSTEM LABEL{18028
{{BNE{13,VRSVP(XR){21,=V_END{6,CMP11{JUMP IF NOT END LABEL{18029
*
*      HERE FOR END LABEL SCANNED OUT
*
{{ADD{3,STAGE{18,=STGND{{ADJUST STAGE APPROPRIATELY{18033
{{JSR{6,SCANE{{{SCAN OUT NEXT ELEMENT{18034
{{BEQ{7,XL{18,=T_SMC{6,CMP10{JUMP IF END OF IMAGE{18035
{{BNE{7,XL{18,=T_VAR{6,CMP08{ELSE ERROR IF NOT VARIABLE{18036
*
*      HERE CHECK FOR VALID INITIAL TRANSFER
*
{{BEQ{13,VRLBL(XR){21,=STNDL{6,CMP08{JUMP IF NOT DEFINED (ERROR){18040
{{MOV{13,CMTRA(XS){13,VRLBL(XR){{ELSE SET INITIAL ENTRY POINTER{18041
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{18042
{{BEQ{7,XL{18,=T_SMC{6,CMP10{JUMP IF OK (END OF IMAGE){18043
*
*      HERE FOR BAD TRANSFER LABEL
*
{CMP08{ERB{1,215{26,Syntax error: Undefined or erroneous entry label{{{18047
*
*      HERE FOR END OF INPUT (NO END LABEL DETECTED)
*
{CMP09{ZER{7,XR{{{CLEAR GARBAGE XR VALUE{18051
{{ADD{3,STAGE{18,=STGND{{ADJUST STAGE APPROPRIATELY{18052
{{BEQ{3,STAGE{18,=STGXE{6,CMP10{JUMP IF CODE CALL (OK){18053
{{ERB{1,216{26,Syntax error: Missing END line{{{18054
*
*      HERE AFTER PROCESSING END LINE (MERGE HERE ON END ERROR)
*
{CMP10{MOV{8,WA{21,=OSTP_{{SET STOP CALL POINTER{18058
{{JSR{6,CDWRD{{{GENERATE AS STATEMENT CALL{18059
{{BRN{6,CMPSE{{{JUMP TO GENERATE AS FAILURE{18060
{{EJC{{{{{18061
*
*      CMPIL (CONTINUED)
*
*      HERE AFTER PROCESSING LABEL OTHER THAN END
*
{CMP11{BNE{3,STAGE{18,=STGIC{6,CMP12{JUMP IF CODE CALL - REDEF. OK{18067
{{BEQ{13,VRLBL(XR){21,=STNDL{6,CMP12{ELSE CHECK FOR REDEFINITION{18068
{{ZER{13,CMLBL(XS){{{LEAVE FIRST LABEL DECLN UNDISTURBED{18069
{{ERB{1,217{26,Syntax error: Duplicate label{{{18070
*
*      HERE AFTER DEALING WITH LABEL
*      NULL STATEMENTS AND STATEMENTS JUST CONTAINING A
*      CONSTANT SUBJECT ARE OPTIMIZED OUT BY RESETTING THE
*      CURRENT CCBLK TO EMPTY.
*
{CMP12{ZER{8,WB{{{SET FLAG FOR STATEMENT BODY{18077
{{JSR{6,EXPAN{{{GET TREE FOR STATEMENT BODY{18078
{{MOV{13,CMSTM(XS){7,XR{{STORE FOR LATER USE{18079
{{ZER{13,CMSGO(XS){{{CLEAR SUCCESS GOTO POINTER{18080
{{ZER{13,CMFGO(XS){{{CLEAR FAILURE GOTO POINTER{18081
{{ZER{13,CMCGO(XS){{{CLEAR CONDITIONAL GOTO FLAG{18082
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{18083
{{BEQ{7,XL{18,=T_COL{6,CMP13{JUMP IF COLON (GOTO){18084
{{BNZ{3,CSWNO{6,CMP18{{JUMP IF NOT OPTIMIZING{18085
{{BNZ{13,CMLBL(XS){6,CMP18{{JUMP IF LABEL PRESENT{18086
{{MOV{7,XR{13,CMSTM(XS){{LOAD TREE PTR FOR STATEMENT BODY{18087
{{MOV{8,WA{9,(XR){{LOAD TYPE WORD{18088
{{BEQ{8,WA{22,=B_CMT{6,CMP18{JUMP IF CMBLK{18089
{{BGE{8,WA{22,=B_VRA{6,CMP18{JUMP IF NOT ICBLK, SCBLK, OR RCBLK{18090
{{MOV{7,XL{3,R_CCB{{LOAD PTR TO CCBLK{18091
{{MOV{13,CCUSE(XL){19,*CCCOD{{RESET USE OFFSET IN CCBLK{18092
{{MOV{3,CWCOF{19,*CCCOD{{AND IN GLOBAL{18093
{{ICV{3,CMPSN{{{BUMP STATEMENT NUMBER{18094
{{BRN{6,CMP01{{{GENERATE NO CODE FOR STATEMENT{18095
*
*      LOOP TO PROCESS GOTO FIELDS
*
{CMP13{MNZ{3,SCNGO{{{SET GOTO FLAG{18099
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{18100
{{BEQ{7,XL{18,=T_SMC{6,CMP31{JUMP IF NO FIELDS LEFT{18101
{{BEQ{7,XL{18,=T_SGO{6,CMP14{JUMP IF S FOR SUCCESS GOTO{18102
{{BEQ{7,XL{18,=T_FGO{6,CMP16{JUMP IF F FOR FAILURE GOTO{18103
*
*      HERE FOR UNCONDITIONAL GOTO (I.E. NOT F OR S)
*
{{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT NOT F,S{18107
{{JSR{6,SCNGF{{{SCAN OUT GOTO FIELD{18108
{{BNZ{13,CMFGO(XS){6,CMP17{{ERROR IF FGOTO ALREADY{18109
{{MOV{13,CMFGO(XS){7,XR{{ELSE SET AS FGOTO{18110
{{BRN{6,CMP15{{{MERGE WITH SGOTO CIRCUIT{18111
*
*      HERE FOR SUCCESS GOTO
*
{CMP14{JSR{6,SCNGF{{{SCAN SUCCESS GOTO FIELD{18115
{{MOV{13,CMCGO(XS){18,=NUM01{{SET CONDITIONAL GOTO FLAG{18116
*
*      UNCONTIONAL GOTO MERGES HERE
*
{CMP15{BNZ{13,CMSGO(XS){6,CMP17{{ERROR IF SGOTO ALREADY GIVEN{18120
{{MOV{13,CMSGO(XS){7,XR{{ELSE SET SGOTO{18121
{{BRN{6,CMP13{{{LOOP BACK FOR NEXT GOTO FIELD{18122
*
*      HERE FOR FAILURE GOTO
*
{CMP16{JSR{6,SCNGF{{{SCAN GOTO FIELD{18126
{{MOV{13,CMCGO(XS){18,=NUM01{{SET CONDITONAL GOTO FLAG{18127
{{BNZ{13,CMFGO(XS){6,CMP17{{ERROR IF FGOTO ALREADY GIVEN{18128
{{MOV{13,CMFGO(XS){7,XR{{ELSE STORE FGOTO POINTER{18129
{{BRN{6,CMP13{{{LOOP BACK FOR NEXT FIELD{18130
{{EJC{{{{{18131
*
*      CMPIL (CONTINUED)
*
*      HERE FOR DUPLICATED GOTO FIELD
*
{CMP17{ERB{1,218{26,Syntax error: Duplicated goto field{{{18137
*
*      HERE TO GENERATE CODE
*
{CMP18{ZER{3,SCNSE{{{STOP POSITIONAL ERROR FLAGS{18141
{{MOV{7,XR{13,CMSTM(XS){{LOAD TREE PTR FOR STATEMENT BODY{18142
{{ZER{8,WB{{{COLLECTABLE VALUE FOR WB FOR CDGVL{18143
{{ZER{8,WC{{{RESET CONSTANT FLAG FOR CDGVL{18144
{{JSR{6,EXPAP{{{TEST FOR PATTERN MATCH{18145
{{PPM{6,CMP19{{{JUMP IF NOT PATTERN MATCH{18146
{{MOV{13,CMOPN(XR){21,=OPMS_{{ELSE SET PATTERN MATCH POINTER{18147
{{MOV{13,CMTYP(XR){18,=C_PMT{{{18148
*
*      HERE AFTER DEALING WITH SPECIAL PATTERN MATCH CASE
*
{CMP19{JSR{6,CDGVL{{{GENERATE CODE FOR BODY OF STATEMENT{18152
{{MOV{7,XR{13,CMSGO(XS){{LOAD SGOTO POINTER{18153
{{MOV{8,WA{7,XR{{COPY IT{18154
{{BZE{7,XR{6,CMP21{{JUMP IF NO SUCCESS GOTO{18155
{{ZER{13,CMSOC(XS){{{CLEAR SUCCESS OFFSET FILLIN PTR{18156
{{BHI{7,XR{3,STATE{6,CMP20{JUMP IF COMPLEX GOTO{18157
*
*      HERE FOR SIMPLE SUCCESS GOTO (LABEL)
*
{{ADD{8,WA{19,*VRTRA{{POINT TO VRTRA FIELD AS REQUIRED{18161
{{JSR{6,CDWRD{{{GENERATE SUCCESS GOTO{18162
{{BRN{6,CMP22{{{JUMP TO DEAL WITH FGOTO{18163
*
*      HERE FOR COMPLEX SUCCESS GOTO
*
{CMP20{BEQ{7,XR{13,CMFGO(XS){6,CMP22{NO CODE IF SAME AS FGOTO{18167
{{ZER{8,WB{{{ELSE SET OK VALUE FOR CDGVL IN WB{18168
{{JSR{6,CDGCG{{{GENERATE CODE FOR SUCCESS GOTO{18169
{{BRN{6,CMP22{{{JUMP TO DEAL WITH FGOTO{18170
*
*      HERE FOR NO SUCCESS GOTO
*
{CMP21{MOV{13,CMSOC(XS){3,CWCOF{{SET SUCCESS FILL IN OFFSET{18174
{{MOV{8,WA{21,=OCER_{{POINT TO COMPILE ERROR CALL{18175
{{JSR{6,CDWRD{{{GENERATE AS TEMPORARY VALUE{18176
{{EJC{{{{{18177
*
*      CMPIL (CONTINUED)
*
*      HERE TO DEAL WITH FAILURE GOTO
*
{CMP22{MOV{7,XR{13,CMFGO(XS){{LOAD FAILURE GOTO POINTER{18183
{{MOV{8,WA{7,XR{{COPY IT{18184
{{ZER{13,CMFFC(XS){{{SET NO FILL IN REQUIRED YET{18185
{{BZE{7,XR{6,CMP23{{JUMP IF NO FAILURE GOTO GIVEN{18186
{{ADD{8,WA{19,*VRTRA{{POINT TO VRTRA FIELD IN CASE{18187
{{BLO{7,XR{3,STATE{6,CMPSE{JUMP TO GEN IF SIMPLE FGOTO{18188
*
*      HERE FOR COMPLEX FAILURE GOTO
*
{{MOV{8,WB{3,CWCOF{{SAVE OFFSET TO O_GOF CALL{18192
{{MOV{8,WA{21,=OGOF_{{POINT TO FAILURE GOTO CALL{18193
{{JSR{6,CDWRD{{{GENERATE{18194
{{MOV{8,WA{21,=OFIF_{{POINT TO FAIL IN FAIL WORD{18195
{{JSR{6,CDWRD{{{GENERATE{18196
{{JSR{6,CDGCG{{{GENERATE CODE FOR FAILURE GOTO{18197
{{MOV{8,WA{8,WB{{COPY OFFSET TO O_GOF FOR CDFAL{18198
{{MOV{8,WB{22,=B_CDC{{SET COMPLEX CASE CDTYP{18199
{{BRN{6,CMP25{{{JUMP TO BUILD CDBLK{18200
*
*      HERE IF NO FAILURE GOTO GIVEN
*
{CMP23{MOV{8,WA{21,=OUNF_{{LOAD UNEXPECTED FAILURE CALL IN CAS{18204
{{MOV{8,WC{3,CSWFL{{GET -NOFAIL FLAG{18205
{{ORB{8,WC{13,CMCGO(XS){{CHECK IF CONDITIONAL GOTO{18206
{{ZRB{8,WC{6,CMPSE{{JUMP IF -NOFAIL AND NO COND. GOTO{18207
{{MNZ{13,CMFFC(XS){{{ELSE SET FILL IN FLAG{18208
{{MOV{8,WA{21,=OCER_{{AND SET COMPILE ERROR FOR TEMPORARY{18209
*
*      MERGE HERE WITH CDFAL VALUE IN WA, SIMPLE CDBLK
*      ALSO SPECIAL ENTRY AFTER STATEMENT ERROR
*
{CMPSE{MOV{8,WB{22,=B_CDS{{SET CDTYP FOR SIMPLE CASE{18214
{{EJC{{{{{18215
*
*      CMPIL (CONTINUED)
*
*      MERGE HERE TO BUILD CDBLK
*
*      (WA)                  CDFAL VALUE TO BE GENERATED
*      (WB)                  CDTYP VALUE TO BE GENERATED
*
*      AT THIS STAGE, WE CHOP OFF AN APPROPRIATE CHUNK OF THE
*      CURRENT CCBLK AND CONVERT IT INTO A CDBLK. THE REMAINDER
*      OF THE CCBLK IS REFORMATTED TO BE THE NEW CCBLK.
*
{CMP25{MOV{7,XR{3,R_CCB{{POINT TO CCBLK{18228
{{MOV{7,XL{13,CMLBL(XS){{GET POSSIBLE LABEL POINTER{18229
{{BZE{7,XL{6,CMP26{{SKIP IF NO LABEL{18230
{{ZER{13,CMLBL(XS){{{CLEAR FLAG FOR NEXT STATEMENT{18231
{{MOV{13,VRLBL(XL){7,XR{{PUT CDBLK PTR IN VRBLK LABEL FIELD{18232
*
*      MERGE AFTER DOING LABEL
*
{CMP26{MOV{9,(XR){8,WB{{SET TYPE WORD FOR NEW CDBLK{18236
{{MOV{13,CDFAL(XR){8,WA{{SET FAILURE WORD{18237
{{MOV{7,XL{7,XR{{COPY POINTER TO CCBLK{18238
{{MOV{8,WB{13,CCUSE(XR){{LOAD LENGTH GEN (= NEW CDLEN){18239
{{MOV{8,WC{13,CCLEN(XR){{LOAD TOTAL CCBLK LENGTH{18240
{{ADD{7,XL{8,WB{{POINT PAST CDBLK{18241
{{SUB{8,WC{8,WB{{GET LENGTH LEFT FOR CHOP OFF{18242
{{MOV{9,(XL){22,=B_CCT{{SET TYPE CODE FOR NEW CCBLK AT END{18243
{{MOV{13,CCUSE(XL){19,*CCCOD{{SET INITIAL CODE OFFSET{18244
{{MOV{3,CWCOF{19,*CCCOD{{REINITIALISE CWCOF{18245
{{MOV{13,CCLEN(XL){8,WC{{SET NEW LENGTH{18246
{{MOV{3,R_CCB{7,XL{{SET NEW CCBLK POINTER{18247
{{ZER{13,CCSLN(XL){{{INITIALIZE NEW LINE NUMBER{18249
{{MOV{13,CDSLN(XR){3,CMPLN{{SET LINE NUMBER IN OLD BLOCK{18250
{{MOV{13,CDSTM(XR){3,CMPSN{{SET STATEMENT NUMBER{18252
{{ICV{3,CMPSN{{{BUMP STATEMENT NUMBER{18253
*
*      SET POINTERS IN PREVIOUS CODE BLOCK AS REQUIRED
*
{{MOV{7,XL{13,CMPCD(XS){{LOAD PTR TO PREVIOUS CDBLK{18257
{{BZE{13,CMFFP(XS){6,CMP27{{JUMP IF NO FAILURE FILL IN REQUIRED{18258
{{MOV{13,CDFAL(XL){7,XR{{ELSE SET FAILURE PTR IN PREVIOUS{18259
*
*      HERE TO DEAL WITH SUCCESS FORWARD POINTER
*
{CMP27{MOV{8,WA{13,CMSOP(XS){{LOAD SUCCESS OFFSET{18263
{{BZE{8,WA{6,CMP28{{JUMP IF NO FILL IN REQUIRED{18264
{{ADD{7,XL{8,WA{{ELSE POINT TO FILL IN LOCATION{18265
{{MOV{9,(XL){7,XR{{STORE FORWARD POINTER{18266
{{ZER{7,XL{{{CLEAR GARBAGE XL VALUE{18267
{{EJC{{{{{18268
*
*      CMPIL (CONTINUED)
*
*      NOW SET FILL IN POINTERS FOR THIS STATEMENT
*
{CMP28{MOV{13,CMFFP(XS){13,CMFFC(XS){{COPY FAILURE FILL IN FLAG{18274
{{MOV{13,CMSOP(XS){13,CMSOC(XS){{COPY SUCCESS FILL IN OFFSET{18275
{{MOV{13,CMPCD(XS){7,XR{{SAVE PTR TO THIS CDBLK{18276
{{BNZ{13,CMTRA(XS){6,CMP29{{JUMP IF INITIAL ENTRY ALREADY SET{18277
{{MOV{13,CMTRA(XS){7,XR{{ELSE SET PTR HERE AS DEFAULT{18278
*
*      HERE AFTER COMPILING ONE STATEMENT
*
{CMP29{BLT{3,STAGE{18,=STGCE{6,CMP01{JUMP IF NOT END LINE JUST DONE{18282
{{BZE{3,CSWLS{6,CMP30{{SKIP IF -NOLIST{18283
{{JSR{6,LISTR{{{LIST LAST LINE{18284
*
*      RETURN
*
{CMP30{MOV{7,XR{13,CMTRA(XS){{LOAD INITIAL ENTRY CDBLK POINTER{18288
{{ADD{7,XS{19,*CMNEN{{POP WORK LOCATIONS OFF STACK{18289
{{EXI{{{{AND RETURN TO CMPIL CALLER{18290
*
*      HERE AT END OF GOTO FIELD
*
{CMP31{MOV{8,WB{13,CMFGO(XS){{GET FAIL GOTO{18294
{{ORB{8,WB{13,CMSGO(XS){{OR IN SUCCESS GOTO{18295
{{BNZ{8,WB{6,CMP18{{OK IF NON-NULL FIELD{18296
{{ERB{1,219{26,Syntax error: Empty goto field{{{18297
*
*      CONTROL CARD FOUND
*
{CMP32{ICV{8,WB{{{POINT PAST CH_MN{18301
{{JSR{6,CNCRD{{{PROCESS CONTROL CARD{18302
{{ZER{3,SCNSE{{{CLEAR START OF ELEMENT LOC.{18303
{{BRN{6,CMPCE{{{LOOP FOR NEXT STATEMENT{18304
{{ENP{{{{END PROCEDURE CMPIL{18305
{{EJC{{{{{18306
*
*      CNCRD -- CONTROL CARD PROCESSOR
*
*      CALLED TO DEAL WITH CONTROL CARDS
*
*      R_CIM                 POINTS TO CURRENT IMAGE
*      (WB)                  OFFSET TO 1ST CHAR OF CONTROL CARD
*      JSR  CNCRD            CALL TO PROCESS CONTROL CARDS
*      (XL,XR,WA,WB,WC,IA)   DESTROYED
*
{CNCRD{PRC{25,E{1,0{{ENTRY POINT{18317
{{MOV{3,SCNPT{8,WB{{OFFSET FOR CONTROL CARD SCAN{18318
{{MOV{8,WA{18,=CCNOC{{NUMBER OF CHARS FOR COMPARISON{18319
{{CTW{8,WA{1,0{{CONVERT TO WORD COUNT{18320
{{MOV{3,CNSWC{8,WA{{SAVE WORD COUNT{18321
*
*      LOOP HERE IF MORE THAN ONE CONTROL CARD
*
{CNC01{BGE{3,SCNPT{3,SCNIL{6,CNC09{RETURN IF END OF IMAGE{18325
{{MOV{7,XR{3,R_CIM{{POINT TO IMAGE{18326
{{PLC{7,XR{3,SCNPT{{CHAR PTR FOR FIRST CHAR{18327
{{LCH{8,WA{10,(XR)+{{GET FIRST CHAR{18328
{{FLC{8,WA{{{FOLD TO UPPER CASE{18330
{{BEQ{8,WA{18,=CH_LI{6,CNC07{SPECIAL CASE OF -INXXX{18332
{CNC0A{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{18333
{{JSR{6,SCANE{{{SCAN CARD NAME{18334
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{18335
{{BNZ{7,XL{6,CNC06{{FAIL UNLESS CONTROL CARD NAME{18336
{{MOV{8,WA{18,=CCNOC{{NO. OF CHARS TO BE COMPARED{18337
{{BLT{13,SCLEN(XR){8,WA{6,CNC08{FAIL IF TOO FEW CHARS{18339
{{MOV{7,XL{7,XR{{POINT TO CONTROL CARD NAME{18343
{{ZER{8,WB{{{ZERO OFFSET FOR SUBSTRING{18344
{{JSR{6,SBSTR{{{EXTRACT SUBSTRING FOR COMPARISON{18345
{{MOV{8,WA{13,SCLEN(XR){{RELOAD LENGTH{18347
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{18348
{{MOV{3,CNSCC{7,XR{{KEEP CONTROL CARD SUBSTRING PTR{18350
{{MOV{7,XR{21,=CCNMS{{POINT TO LIST OF STANDARD NAMES{18351
{{ZER{8,WB{{{INITIALISE NAME OFFSET{18352
{{LCT{8,WC{18,=CC_NC{{NUMBER OF STANDARD NAMES{18353
*
*      TRY TO MATCH NAME
*
{CNC02{MOV{7,XL{3,CNSCC{{POINT TO NAME{18357
{{LCT{8,WA{3,CNSWC{{COUNTER FOR INNER LOOP{18358
{{BRN{6,CNC04{{{JUMP INTO LOOP{18359
*
*      INNER LOOP TO MATCH CARD NAME CHARS
*
{CNC03{ICA{7,XR{{{BUMP STANDARD NAMES PTR{18363
{{ICA{7,XL{{{BUMP NAME POINTER{18364
*
*      HERE TO INITIATE THE LOOP
*
{CNC04{CNE{13,SCHAR(XL){9,(XR){6,CNC05{COMP. UP TO CFP_C CHARS AT ONCE{18368
{{BCT{8,WA{6,CNC03{{LOOP IF MORE WORDS TO COMPARE{18369
{{EJC{{{{{18370
*
*      CNCRD (CONTINUED)
*
*      MATCHED - BRANCH ON CARD OFFSET
*
{{MOV{7,XL{8,WB{{GET NAME OFFSET{18376
{{BSW{7,XL{2,CC_NC{6,CNC08{SWITCH{18378
{{IFF{2,CC_CA{6,CNC37{{-CASE{18417
{{IFF{2,CC_DO{6,CNC10{{-DOUBLE{18417
{{IFF{1,2{6,CNC08{{{18417
{{IFF{2,CC_DU{6,CNC11{{-DUMP{18417
{{IFF{2,CC_CP{6,CNC41{{-COPY{18417
{{IFF{2,CC_EJ{6,CNC12{{-EJECT{18417
{{IFF{2,CC_ER{6,CNC13{{-ERRORS{18417
{{IFF{2,CC_EX{6,CNC14{{-EXECUTE{18417
{{IFF{2,CC_FA{6,CNC15{{-FAIL{18417
{{IFF{2,CC_IN{6,CNC41{{-INCLUDE{18417
{{IFF{2,CC_LN{6,CNC44{{-LINE{18417
{{IFF{2,CC_LI{6,CNC16{{-LIST{18417
{{IFF{2,CC_NR{6,CNC17{{-NOERRORS{18417
{{IFF{2,CC_NX{6,CNC18{{-NOEXECUTE{18417
{{IFF{2,CC_NF{6,CNC19{{-NOFAIL{18417
{{IFF{2,CC_NL{6,CNC20{{-NOLIST{18417
{{IFF{2,CC_NO{6,CNC21{{-NOOPT{18417
{{IFF{2,CC_NP{6,CNC22{{-NOPRINT{18417
{{IFF{2,CC_OP{6,CNC24{{-OPTIMISE{18417
{{IFF{2,CC_PR{6,CNC25{{-PRINT{18417
{{IFF{2,CC_SI{6,CNC27{{-SINGLE{18417
{{IFF{2,CC_SP{6,CNC28{{-SPACE{18417
{{IFF{2,CC_ST{6,CNC31{{-STITLE{18417
{{IFF{2,CC_TI{6,CNC32{{-TITLE{18417
{{IFF{2,CC_TR{6,CNC36{{-TRACE{18417
{{ESW{{{{END SWITCH{18417
*
*      NOT MATCHED YET. ALIGN STD NAMES PTR AND TRY AGAIN
*
{CNC05{ICA{7,XR{{{BUMP STANDARD NAMES PTR{18421
{{BCT{8,WA{6,CNC05{{LOOP{18422
{{ICV{8,WB{{{BUMP NAMES OFFSET{18423
{{BCT{8,WC{6,CNC02{{CONTINUE IF MORE NAMES{18424
{{BRN{6,CNC08{{{IGNORE UNRECOGNIZED CONTROL CARD{18426
*
*      INVALID CONTROL CARD NAME
*
{CNC06{ERB{1,247{26,Invalid control statement{{{18431
*
*      SPECIAL PROCESSING FOR -INXXX
*
{CNC07{LCH{8,WA{10,(XR)+{{GET NEXT CHAR{18435
{{FLC{8,WA{{{FOLD TO UPPER CASE{18437
{{BNE{8,WA{18,=CH_LN{6,CNC0A{IF NOT LETTER N{18439
{{LCH{8,WA{9,(XR){{GET THIRD CHAR{18440
{{BLT{8,WA{18,=CH_D0{6,CNC0A{IF NOT DIGIT{18441
{{BGT{8,WA{18,=CH_D9{6,CNC0A{IF NOT DIGIT{18442
{{ADD{3,SCNPT{18,=NUM02{{BUMP OFFSET PAST -IN{18443
{{JSR{6,SCANE{{{SCAN INTEGER AFTER -IN{18444
{{MOV{11,-(XS){7,XR{{STACK SCANNED ITEM{18445
{{JSR{6,GTSMI{{{CHECK IF INTEGER{18446
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{18447
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR LARGE{18448
{{MOV{3,CSWIN{7,XR{{KEEP INTEGER{18449
{{EJC{{{{{18450
*
*      CNCRD (CONTINUED)
*
*      CHECK FOR MORE CONTROL CARDS BEFORE RETURNING
*
{CNC08{MOV{8,WA{3,SCNPT{{PRESERVE IN CASE XEQ TIME COMPILE{18456
{{JSR{6,SCANE{{{LOOK FOR COMMA{18457
{{BEQ{7,XL{18,=T_CMA{6,CNC01{LOOP IF COMMA FOUND{18458
{{MOV{3,SCNPT{8,WA{{RESTORE SCNPT IN CASE XEQ TIME{18459
*
*      RETURN POINT
*
{CNC09{EXI{{{{RETURN{18463
*
*      -DOUBLE
*
{CNC10{MNZ{3,CSWDB{{{SET SWITCH{18467
{{BRN{6,CNC08{{{MERGE{18468
*
*      -DUMP
*      THIS IS USED FOR SYSTEM DEBUGGING . IT HAS THE EFFECT OF
*      PRODUCING A CORE DUMP AT COMPILATION TIME
*
{CNC11{JSR{6,SYSDM{{{CALL DUMPER{18474
{{BRN{6,CNC09{{{FINISHED{18475
*
*      -EJECT
*
{CNC12{BZE{3,CSWLS{6,CNC09{{RETURN IF -NOLIST{18479
{{JSR{6,PRTPS{{{EJECT{18480
{{JSR{6,LISTT{{{LIST TITLE{18481
{{BRN{6,CNC09{{{FINISHED{18482
*
*      -ERRORS
*
{CNC13{ZER{3,CSWER{{{CLEAR SWITCH{18486
{{BRN{6,CNC08{{{MERGE{18487
*
*      -EXECUTE
*
{CNC14{ZER{3,CSWEX{{{CLEAR SWITCH{18491
{{BRN{6,CNC08{{{MERGE{18492
*
*      -FAIL
*
{CNC15{MNZ{3,CSWFL{{{SET SWITCH{18496
{{BRN{6,CNC08{{{MERGE{18497
*
*      -LIST
*
{CNC16{MNZ{3,CSWLS{{{SET SWITCH{18501
{{BEQ{3,STAGE{18,=STGIC{6,CNC08{DONE IF COMPILE TIME{18502
*
*      LIST CODE LINE IF EXECUTE TIME COMPILE
*
{{ZER{3,LSTPF{{{PERMIT LISTING{18506
{{JSR{6,LISTR{{{LIST LINE{18507
{{BRN{6,CNC08{{{MERGE{18508
{{EJC{{{{{18509
*
*      CNCRD (CONTINUED)
*
*      -NOERRORS
*
{CNC17{MNZ{3,CSWER{{{SET SWITCH{18515
{{BRN{6,CNC08{{{MERGE{18516
*
*      -NOEXECUTE
*
{CNC18{MNZ{3,CSWEX{{{SET SWITCH{18520
{{BRN{6,CNC08{{{MERGE{18521
*
*      -NOFAIL
*
{CNC19{ZER{3,CSWFL{{{CLEAR SWITCH{18525
{{BRN{6,CNC08{{{MERGE{18526
*
*      -NOLIST
*
{CNC20{ZER{3,CSWLS{{{CLEAR SWITCH{18530
{{BRN{6,CNC08{{{MERGE{18531
*
*      -NOOPTIMISE
*
{CNC21{MNZ{3,CSWNO{{{SET SWITCH{18535
{{BRN{6,CNC08{{{MERGE{18536
*
*      -NOPRINT
*
{CNC22{ZER{3,CSWPR{{{CLEAR SWITCH{18540
{{BRN{6,CNC08{{{MERGE{18541
*
*      -OPTIMISE
*
{CNC24{ZER{3,CSWNO{{{CLEAR SWITCH{18545
{{BRN{6,CNC08{{{MERGE{18546
*
*      -PRINT
*
{CNC25{MNZ{3,CSWPR{{{SET SWITCH{18550
{{BRN{6,CNC08{{{MERGE{18551
{{EJC{{{{{18552
*
*      CNCRD (CONTINUED)
*
*      -SINGLE
*
{CNC27{ZER{3,CSWDB{{{CLEAR SWITCH{18558
{{BRN{6,CNC08{{{MERGE{18559
*
*      -SPACE
*
{CNC28{BZE{3,CSWLS{6,CNC09{{RETURN IF -NOLIST{18563
{{JSR{6,SCANE{{{SCAN INTEGER AFTER -SPACE{18564
{{MOV{8,WC{18,=NUM01{{1 SPACE IN CASE{18565
{{BEQ{7,XR{18,=T_SMC{6,CNC29{JUMP IF NO INTEGER{18566
{{MOV{11,-(XS){7,XR{{STACK IT{18567
{{JSR{6,GTSMI{{{CHECK INTEGER{18568
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{18569
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR LARGE{18570
{{BNZ{8,WC{6,CNC29{{JUMP IF NON ZERO{18571
{{MOV{8,WC{18,=NUM01{{ELSE 1 SPACE{18572
*
*      MERGE WITH COUNT OF LINES TO SKIP
*
{CNC29{ADD{3,LSTLC{8,WC{{BUMP LINE COUNT{18576
{{LCT{8,WC{8,WC{{CONVERT TO LOOP COUNTER{18577
{{BLT{3,LSTLC{3,LSTNP{6,CNC30{JUMP IF FITS ON PAGE{18578
{{JSR{6,PRTPS{{{EJECT{18579
{{JSR{6,LISTT{{{LIST TITLE{18580
{{BRN{6,CNC09{{{MERGE{18581
*
*      SKIP LINES
*
{CNC30{JSR{6,PRTNL{{{PRINT A BLANK{18585
{{BCT{8,WC{6,CNC30{{LOOP{18586
{{BRN{6,CNC09{{{MERGE{18587
{{EJC{{{{{18588
*
*      CNCRD (CONTINUED)
*
*      -STITL
*
{CNC31{MOV{3,CNR_T{20,=R_STL{{PTR TO R_STL{18594
{{BRN{6,CNC33{{{MERGE{18595
*
*      -TITLE
*
{CNC32{MOV{3,R_STL{21,=NULLS{{CLEAR SUBTITLE{18599
{{MOV{3,CNR_T{20,=R_TTL{{PTR TO R_TTL{18600
*
*      COMMON PROCESSING FOR -TITLE, -STITL
*
{CNC33{MOV{7,XR{21,=NULLS{{NULL IN CASE NEEDED{18604
{{MNZ{3,CNTTL{{{SET FLAG FOR NEXT LISTR CALL{18605
{{MOV{8,WB{18,=CCOFS{{OFFSET TO TITLE/SUBTITLE{18606
{{MOV{8,WA{3,SCNIL{{INPUT IMAGE LENGTH{18607
{{BLO{8,WA{8,WB{6,CNC34{JUMP IF NO CHARS LEFT{18608
{{SUB{8,WA{8,WB{{NO OF CHARS TO EXTRACT{18609
{{MOV{7,XL{3,R_CIM{{POINT TO IMAGE{18610
{{JSR{6,SBSTR{{{GET TITLE/SUBTITLE{18611
*
*      STORE TITLE/SUBTITLE
*
{CNC34{MOV{7,XL{3,CNR_T{{POINT TO STORAGE LOCATION{18615
{{MOV{9,(XL){7,XR{{STORE TITLE/SUBTITLE{18616
{{BEQ{7,XL{20,=R_STL{6,CNC09{RETURN IF STITL{18617
{{BNZ{3,PRECL{6,CNC09{{RETURN IF EXTENDED LISTING{18618
{{BZE{3,PRICH{6,CNC09{{RETURN IF REGULAR PRINTER{18619
{{MOV{7,XL{13,SCLEN(XR){{GET LENGTH OF TITLE{18620
{{MOV{8,WA{7,XL{{COPY IT{18621
{{BZE{7,XL{6,CNC35{{JUMP IF NULL{18622
{{ADD{7,XL{18,=NUM10{{INCREMENT{18623
{{BHI{7,XL{3,PRLEN{6,CNC09{USE DEFAULT LSTP0 VAL IF TOO LONG{18624
{{ADD{8,WA{18,=NUM04{{POINT JUST PAST TITLE{18625
*
*      STORE OFFSET TO PAGE NN MESSAGE FOR SHORT TITLE
*
{CNC35{MOV{3,LSTPO{8,WA{{STORE OFFSET{18629
{{BRN{6,CNC09{{{RETURN{18630
*
*      -TRACE
*      PROVIDED FOR SYSTEM DEBUGGING.  TOGGLES THE SYSTEM LABEL
*      TRACE SWITCH AT COMPILE TIME
*
{CNC36{JSR{6,SYSTT{{{TOGGLE SWITCH{18636
{{BRN{6,CNC08{{{MERGE{18637
*
*      -CASE
*      SETS VALUE OF KVCAS SO THAT NAMES ARE FOLDED OR NOT
*      DURING COMPILATION.
*
{CNC37{JSR{6,SCANE{{{SCAN INTEGER AFTER -CASE{18644
{{ZER{8,WC{{{GET 0 IN CASE NONE THERE{18645
{{BEQ{7,XL{18,=T_SMC{6,CNC38{SKIP IF NO INTEGER{18646
{{MOV{11,-(XS){7,XR{{STACK IT{18647
{{JSR{6,GTSMI{{{CHECK INTEGER{18648
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{18649
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR TOO LARGE{18650
{CNC38{MOV{3,KVCAS{8,WC{{STORE NEW CASE VALUE{18651
{{BRN{6,CNC09{{{MERGE{18652
*
*      -INCLUDE
*
{CNC41{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{18675
{{JSR{6,SCANE{{{SCAN QUOTED FILE NAME{18676
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{18677
{{BNE{7,XL{18,=T_CON{6,CNC06{IF NOT CONSTANT{18678
{{BNE{9,(XR){22,=B_SCL{6,CNC06{IF NOT STRING CONSTANT{18679
{{MOV{3,R_IFN{7,XR{{SAVE FILE NAME{18680
{{MOV{7,XL{3,R_INC{{EXAMINE INCLUDE FILE NAME TABLE{18681
{{ZER{8,WB{{{LOOKUP BY VALUE{18682
{{JSR{6,TFIND{{{DO LOOKUP{18683
{{PPM{{{{NEVER FAILS{18684
{{BEQ{7,XR{21,=INTON{6,CNC09{IGNORE IF ALREADY IN TABLE{18685
{{MNZ{8,WB{{{SET FOR TRIM{18686
{{MOV{7,XR{3,R_IFN{{FILE NAME{18687
{{JSR{6,TRIMR{{{REMOVE TRAILING BLANKS{18688
{{MOV{7,XL{3,R_INC{{INCLUDE FILE NAME TABLE{18689
{{MNZ{8,WB{{{LOOKUP BY NAME THIS TIME{18690
{{JSR{6,TFIND{{{DO LOOKUP{18691
{{PPM{{{{NEVER FAILS{18692
{{MOV{13,TEVAL(XL){21,=INTON{{MAKE TABLE VALUE INTEGER 1{18693
{{ICV{3,CNIND{{{INCREASE NESTING LEVEL{18694
{{MOV{8,WA{3,CNIND{{LOAD NEW NEST LEVEL{18695
{{BGT{8,WA{18,=CCINM{6,CNC42{FAIL IF EXCESSIVE NESTING{18696
*
*      RECORD THE NAME AND LINE NUMBER OF THE CURRENT INPUT FILE
*
{{MOV{7,XL{3,R_IFA{{ARRAY OF NESTED FILE NAMES{18701
{{ADD{8,WA{18,=VCVLB{{COMPUTE OFFSET IN WORDS{18702
{{WTB{8,WA{{{CONVERT TO BYTES{18703
{{ADD{7,XL{8,WA{{POINT TO ELEMENT{18704
{{MOV{9,(XL){3,R_SFC{{RECORD CURRENT FILE NAME{18705
{{MOV{7,XL{8,WA{{PRESERVE NESTING BYTE OFFSET{18706
{{MTI{3,RDNLN{{{FETCH SOURCE LINE NUMBER AS INTEGER{18707
{{JSR{6,ICBLD{{{CONVERT TO ICBLK{18708
{{ADD{7,XL{3,R_IFL{{ENTRY IN NESTED LINE NUMBER ARRAY{18709
{{MOV{9,(XL){7,XR{{RECORD IN ARRAY{18710
*
*      HERE TO SWITCH TO INCLUDE FILE NAMED IN R_IFN
*
{{MOV{8,WA{3,CSWIN{{MAX READ LENGTH{18715
{{MOV{7,XL{3,R_IFN{{INCLUDE FILE NAME{18716
{{JSR{6,ALOCS{{{GET BUFFER FOR COMPLETE FILE NAME{18717
{{JSR{6,SYSIF{{{OPEN INCLUDE FILE{18718
{{PPM{6,CNC43{{{COULD NOT OPEN{18719
*
*      MAKE NOTE OF THE COMPLETE FILE NAME FOR ERROR MESSAGES
*
{{ZER{8,WB{{{DO NOT TRIM TRAILING BLANKS{18724
{{JSR{6,TRIMR{{{ADJUST SCBLK FOR ACTUAL LENGTH{18725
{{MOV{3,R_SFC{7,XR{{SAVE PTR TO FILE NAME{18726
{{MTI{3,CMPSN{{{CURRENT STATEMENT AS INTEGER{18727
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{18728
{{MOV{7,XL{3,R_SFN{{FILE NAME TABLE{18729
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{18730
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{18731
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{18732
{{MOV{13,TEVAL(XL){3,R_SFC{{RECORD FILE NAME AS ENTRY VALUE{18733
{{ZER{3,RDNLN{{{RESTART LINE COUNTER FOR NEW FILE{18737
{{BEQ{3,STAGE{18,=STGIC{6,CNC09{IF INITIAL COMPILE{18738
{{BNE{3,CNIND{18,=NUM01{6,CNC09{IF NOT FIRST EXECUTE-TIME NESTING{18739
*
*      HERE FOR -INCLUDE DURING EXECUTE-TIME COMPILE
*
{{MOV{3,R_ICI{3,R_CIM{{REMEMBER CODE ARGUMENT STRING{18743
{{MOV{3,CNSPT{3,SCNPT{{SAVE POSITION IN STRING{18744
{{MOV{3,CNSIL{3,SCNIL{{AND LENGTH OF STRING{18745
{{BRN{6,CNC09{{{ALL DONE, MERGE{18746
*
*      HERE FOR EXCESSIVE INCLUDE FILE NESTING
*
{CNC42{ERB{1,284{26,Excessively nested INCLUDE files{{{18750
*
*      HERE IF INCLUDE FILE COULD NOT BE OPENED
*
{CNC43{MOV{3,DNAMP{7,XR{{RELEASE ALLOCATED SCBLK{18754
{{ERB{1,285{26,INCLUDE file cannot be opened{{{18755
*
*
*      -LINE N FILENAME
*
{CNC44{JSR{6,SCANE{{{SCAN INTEGER AFTER -LINE{18762
{{BNE{7,XL{18,=T_CON{6,CNC06{JUMP IF NO LINE NUMBER{18763
{{BNE{9,(XR){22,=B_ICL{6,CNC06{JUMP IF NOT INTEGER{18764
{{LDI{13,ICVAL(XR){{{FETCH INTEGER LINE NUMBER{18765
{{ILE{6,CNC06{{{ERROR IF NEGATIVE OR ZERO{18766
{{BEQ{3,STAGE{18,=STGIC{6,CNC45{SKIP IF INITIAL COMPILE{18767
{{MFI{3,CMPLN{{{SET DIRECTLY FOR OTHER COMPILES{18768
{{BRN{6,CNC46{{{NO NEED TO SET RDNLN{18769
{CNC45{SBI{4,INTV1{{{ADJUST NUMBER BY ONE{18770
{{MFI{3,RDNLN{{{SAVE LINE NUMBER{18771
{CNC46{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{18773
{{JSR{6,SCANE{{{SCAN QUOTED FILE NAME{18774
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{18775
{{BEQ{7,XL{18,=T_SMC{6,CNC47{DONE IF NO FILE NAME{18776
{{BNE{7,XL{18,=T_CON{6,CNC06{ERROR IF NOT CONSTANT{18777
{{BNE{9,(XR){22,=B_SCL{6,CNC06{IF NOT STRING CONSTANT{18778
{{JSR{6,NEWFN{{{RECORD NEW FILE NAME{18779
{{BRN{6,CNC09{{{MERGE{18780
*
*      HERE IF FILE NAME NOT PRESENT
*
{CNC47{DCV{3,SCNPT{{{SET TO RESCAN THE TERMINATOR{18784
{{BRN{6,CNC09{{{MERGE{18785
{{ENP{{{{END PROCEDURE CNCRD{18790
{{EJC{{{{{18791
*
*      DFFNC -- DEFINE FUNCTION
*
*      DFFNC IS CALLED WHENEVER A NEW FUNCTION IS ASSIGNED TO
*      A VARIABLE. IT DEALS WITH EXTERNAL FUNCTION USE COUNTS.
*
*      (XR)                  POINTER TO VRBLK
*      (XL)                  POINTER TO NEW FUNCTION BLOCK
*      JSR  DFFNC            CALL TO DEFINE FUNCTION
*      (WA,WB)               DESTROYED
*
{DFFNC{PRC{25,E{1,0{{ENTRY POINT{18873
{{BNE{9,(XL){22,=B_EFC{6,DFFN1{SKIP IF NEW FUNCTION NOT EXTERNAL{18876
{{ICV{13,EFUSE(XL){{{ELSE INCREMENT ITS USE COUNT{18877
*
*      HERE AFTER DEALING WITH NEW FUNCTION USE COUNT
*
{DFFN1{MOV{8,WA{7,XR{{SAVE VRBLK POINTER{18881
{{MOV{7,XR{13,VRFNC(XR){{LOAD OLD FUNCTION POINTER{18882
{{BNE{9,(XR){22,=B_EFC{6,DFFN2{JUMP IF OLD FUNCTION NOT EXTERNAL{18883
{{MOV{8,WB{13,EFUSE(XR){{ELSE GET USE COUNT{18884
{{DCV{8,WB{{{DECREMENT{18885
{{MOV{13,EFUSE(XR){8,WB{{STORE DECREMENTED VALUE{18886
{{BNZ{8,WB{6,DFFN2{{JUMP IF USE COUNT STILL NON-ZERO{18887
{{JSR{6,SYSUL{{{ELSE CALL SYSTEM UNLOAD FUNCTION{18888
*
*      HERE AFTER DEALING WITH OLD FUNCTION USE COUNT
*
{DFFN2{MOV{7,XR{8,WA{{RESTORE VRBLK POINTER{18892
{{MOV{8,WA{7,XL{{COPY FUNCTION BLOCK PTR{18894
{{BLT{7,XR{20,=R_YYY{6,DFFN3{SKIP CHECKS IF OPSYN OP DEFINITION{18895
{{BNZ{13,VRLEN(XR){6,DFFN3{{JUMP IF NOT SYSTEM VARIABLE{18896
*
*      FOR SYSTEM VARIABLE, CHECK FOR ILLEGAL REDEFINITION
*
{{MOV{7,XL{13,VRSVP(XR){{POINT TO SVBLK{18900
{{MOV{8,WB{13,SVBIT(XL){{LOAD BIT INDICATORS{18901
{{ANB{8,WB{4,BTFNC{{IS IT A SYSTEM FUNCTION{18902
{{ZRB{8,WB{6,DFFN3{{REDEF OK IF NOT{18903
{{ERB{1,248{26,Attempted redefinition of system function{{{18904
*
*      HERE IF REDEFINITION IS PERMITTED
*
{DFFN3{MOV{13,VRFNC(XR){8,WA{{STORE NEW FUNCTION POINTER{18908
{{MOV{7,XL{8,WA{{RESTORE FUNCTION BLOCK POINTER{18909
{{EXI{{{{RETURN TO DFFNC CALLER{18910
{{ENP{{{{END PROCEDURE DFFNC{18911
{{EJC{{{{{18912
*
*      DTACH -- DETACH I/O ASSOCIATED NAMES
*
*      DETACHES TRBLKS FROM I/O ASSOCIATED VARIABLES, REMOVES
*      ENTRY FROM IOCHN CHAIN ATTACHED TO FILEARG1 VRBLK AND MAY
*      REMOVE VRBLK ACCESS AND STORE TRAPS.
*      INPUT, OUTPUT, TERMINAL ARE HANDLED SPECIALLY.
*
*      (XL)                  I/O ASSOC. VBL NAME BASE PTR
*      (WA)                  OFFSET TO NAME
*      JSR  DTACH            CALL FOR DETACH OPERATION
*      (XL,XR,WA,WB,WC)      DESTROYED
*
{DTACH{PRC{25,E{1,0{{ENTRY POINT{18926
{{MOV{3,DTCNB{7,XL{{STORE NAME BASE (GBCOL NOT CALLED){18927
{{ADD{7,XL{8,WA{{POINT TO NAME LOCATION{18928
{{MOV{3,DTCNM{7,XL{{STORE IT{18929
*
*      LOOP TO SEARCH FOR I/O TRBLK
*
{DTCH1{MOV{7,XR{7,XL{{COPY NAME POINTER{18933
*
*      CONTINUE AFTER BLOCK DELETION
*
{DTCH2{MOV{7,XL{9,(XL){{POINT TO NEXT VALUE{18937
{{BNE{9,(XL){22,=B_TRT{6,DTCH6{JUMP AT CHAIN END{18938
{{MOV{8,WA{13,TRTYP(XL){{GET TRAP BLOCK TYPE{18939
{{BEQ{8,WA{18,=TRTIN{6,DTCH3{JUMP IF INPUT{18940
{{BEQ{8,WA{18,=TRTOU{6,DTCH3{JUMP IF OUTPUT{18941
{{ADD{7,XL{19,*TRNXT{{POINT TO NEXT LINK{18942
{{BRN{6,DTCH1{{{LOOP{18943
*
*      DELETE AN OLD ASSOCIATION
*
{DTCH3{MOV{9,(XR){13,TRVAL(XL){{DELETE TRBLK{18947
{{MOV{8,WA{7,XL{{DUMP XL ...{18948
{{MOV{8,WB{7,XR{{... AND XR{18949
{{MOV{7,XL{13,TRTRF(XL){{POINT TO TRTRF TRAP BLOCK{18950
{{BZE{7,XL{6,DTCH5{{JUMP IF NO IOCHN{18951
{{BNE{9,(XL){22,=B_TRT{6,DTCH5{JUMP IF INPUT, OUTPUT, TERMINAL{18952
*
*      LOOP TO SEARCH IOCHN CHAIN FOR NAME PTR
*
{DTCH4{MOV{7,XR{7,XL{{REMEMBER LINK PTR{18956
{{MOV{7,XL{13,TRTRF(XL){{POINT TO NEXT LINK{18957
{{BZE{7,XL{6,DTCH5{{JUMP IF END OF CHAIN{18958
{{MOV{8,WC{13,IONMB(XL){{GET NAME BASE{18959
{{ADD{8,WC{13,IONMO(XL){{ADD OFFSET{18960
{{BNE{8,WC{3,DTCNM{6,DTCH4{LOOP IF NO MATCH{18961
{{MOV{13,TRTRF(XR){13,TRTRF(XL){{REMOVE NAME FROM CHAIN{18962
{{EJC{{{{{18963
*
*      DTACH (CONTINUED)
*
*      PREPARE TO RESUME I/O TRBLK SCAN
*
{DTCH5{MOV{7,XL{8,WA{{RECOVER XL ...{18969
{{MOV{7,XR{8,WB{{... AND XR{18970
{{ADD{7,XL{19,*TRVAL{{POINT TO VALUE FIELD{18971
{{BRN{6,DTCH2{{{CONTINUE{18972
*
*      EXIT POINT
*
{DTCH6{MOV{7,XR{3,DTCNB{{POSSIBLE VRBLK PTR{18976
{{JSR{6,SETVR{{{RESET VRBLK IF NECESSARY{18977
{{EXI{{{{RETURN{18978
{{ENP{{{{END PROCEDURE DTACH{18979
{{EJC{{{{{18980
*
*      DTYPE -- GET DATATYPE NAME
*
*      (XR)                  OBJECT WHOSE DATATYPE IS REQUIRED
*      JSR  DTYPE            CALL TO GET DATATYPE
*      (XR)                  RESULT DATATYPE
*
{DTYPE{PRC{25,E{1,0{{ENTRY POINT{18988
{{BEQ{9,(XR){22,=B_PDT{6,DTYP1{JUMP IF PROG.DEFINED{18989
{{MOV{7,XR{9,(XR){{LOAD TYPE WORD{18990
{{LEI{7,XR{{{GET ENTRY POINT ID (BLOCK CODE){18991
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{18992
{{MOV{7,XR{14,SCNMT(XR){{LOAD TABLE ENTRY{18993
{{EXI{{{{EXIT TO DTYPE CALLER{18994
*
*      HERE IF PROGRAM DEFINED
*
{DTYP1{MOV{7,XR{13,PDDFP(XR){{POINT TO DFBLK{18998
{{MOV{7,XR{13,DFNAM(XR){{GET DATATYPE NAME FROM DFBLK{18999
{{EXI{{{{RETURN TO DTYPE CALLER{19000
{{ENP{{{{END PROCEDURE DTYPE{19001
{{EJC{{{{{19002
*
*      DUMPR -- PRINT DUMP OF STORAGE
*
*      (XR)                  DUMP ARGUMENT (SEE BELOW)
*      JSR  DUMPR            CALL TO PRINT DUMP
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
*      THE DUMP ARGUMENT HAS THE FOLLOWING SIGNIFICANCE
*
*      DMARG = 0             NO DUMP PRINTED
*      DMARG = 1             PARTIAL DUMP (NAT VARS, KEYWORDS)
*      DMARG = 2             FULL DUMP (ARRAYS, TABLES, ETC.)
*      DMARG = 3             FULL DUMP + NULL VARIABLES
*      DMARG GE 4            CORE DUMP
*
*      SINCE DUMPR SCRAMBLES STORE, IT IS NOT PERMISSIBLE TO
*      COLLECT IN MID-DUMP. HENCE A COLLECT IS DONE INITIALLY
*      AND THEN IF STORE RUNS OUT AN ERROR MESSAGE IS PRODUCED.
*
{DUMPR{PRC{25,E{1,0{{ENTRY POINT{19023
{{BZE{7,XR{6,DMP28{{SKIP DUMP IF ARGUMENT IS ZERO{19024
{{BGT{7,XR{18,=NUM03{6,DMP29{JUMP IF CORE DUMP REQUIRED{19025
{{ZER{7,XL{{{CLEAR XL{19026
{{ZER{8,WB{{{ZERO MOVE OFFSET{19027
{{MOV{3,DMARG{7,XR{{SAVE DUMP ARGUMENT{19028
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{19030
{{JSR{6,GBCOL{{{COLLECT GARBAGE{19032
{{JSR{6,PRTPG{{{EJECT PRINTER{19033
{{MOV{7,XR{21,=DMHDV{{POINT TO HEADING FOR VARIABLES{19034
{{JSR{6,PRTST{{{PRINT IT{19035
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{19036
{{JSR{6,PRTNL{{{AND PRINT A BLANK LINE{19037
*
*      FIRST ALL NATURAL VARIABLE BLOCKS (VRBLK) WHOSE VALUES
*      ARE NON-NULL ARE LINKED IN LEXICAL ORDER USING DMVCH AS
*      THE CHAIN HEAD AND CHAINING THROUGH THE VRGET FIELDS.
*      NOTE THAT THIS SCRAMBLES STORE IF THE PROCESS IS
*      INTERRUPTED BEFORE COMPLETION E.G. BY EXCEEDING TIME  OR
*      PRINT LIMITS. SINCE THE SUBSEQUENT CORE DUMPS AND
*      FAILURES IF EXECUTION IS RESUMED ARE VERY CONFUSING, THE
*      EXECUTION TIME ERROR ROUTINE CHECKS FOR THIS EVENT AND
*      ATTEMPTS AN UNSCRAMBLE. SIMILAR PRECAUTIONS SHOULD BE
*      OBSERVED IF TRANSLATE TIME DUMPING IS IMPLEMENTED.
*
{{ZER{3,DMVCH{{{SET NULL CHAIN TO START{19050
{{MOV{8,WA{3,HSHTB{{POINT TO HASH TABLE{19051
*
*      LOOP THROUGH HEADERS IN HASH TABLE
*
{DMP00{MOV{7,XR{8,WA{{COPY HASH BUCKET POINTER{19055
{{ICA{8,WA{{{BUMP POINTER{19056
{{SUB{7,XR{19,*VRNXT{{SET OFFSET TO MERGE{19057
*
*      LOOP THROUGH VRBLKS ON ONE CHAIN
*
{DMP01{MOV{7,XR{13,VRNXT(XR){{POINT TO NEXT VRBLK ON CHAIN{19061
{{BZE{7,XR{6,DMP09{{JUMP IF END OF THIS HASH CHAIN{19062
{{MOV{7,XL{7,XR{{ELSE COPY VRBLK POINTER{19063
{{EJC{{{{{19064
*
*      DUMPR (CONTINUED)
*
*      LOOP TO FIND VALUE AND SKIP IF NULL
*
{DMP02{MOV{7,XL{13,VRVAL(XL){{LOAD VALUE{19070
{{BEQ{3,DMARG{18,=NUM03{6,DMP2A{SKIP NULL VALUE CHECK IF DUMP(3){19071
{{BEQ{7,XL{21,=NULLS{6,DMP01{LOOP FOR NEXT VRBLK IF NULL VALUE{19072
{DMP2A{BEQ{9,(XL){22,=B_TRT{6,DMP02{LOOP BACK IF VALUE IS TRAPPED{19073
*
*      NON-NULL VALUE, PREPARE TO SEARCH CHAIN
*
{{MOV{8,WC{7,XR{{SAVE VRBLK POINTER{19077
{{ADD{7,XR{19,*VRSOF{{ADJUST PTR TO BE LIKE SCBLK PTR{19078
{{BNZ{13,SCLEN(XR){6,DMP03{{JUMP IF NON-SYSTEM VARIABLE{19079
{{MOV{7,XR{13,VRSVO(XR){{ELSE LOAD PTR TO NAME IN SVBLK{19080
*
*      HERE WITH NAME POINTER FOR NEW BLOCK IN XR
*
{DMP03{MOV{8,WB{7,XR{{SAVE POINTER TO CHARS{19084
{{MOV{3,DMPSV{8,WA{{SAVE HASH BUCKET POINTER{19085
{{MOV{8,WA{20,=DMVCH{{POINT TO CHAIN HEAD{19086
*
*      LOOP TO SEARCH CHAIN FOR CORRECT INSERTION POINT
*
{DMP04{MOV{3,DMPCH{8,WA{{SAVE CHAIN POINTER{19090
{{MOV{7,XL{8,WA{{COPY IT{19091
{{MOV{7,XR{9,(XL){{LOAD POINTER TO NEXT ENTRY{19092
{{BZE{7,XR{6,DMP08{{JUMP IF END OF CHAIN TO INSERT{19093
{{ADD{7,XR{19,*VRSOF{{ELSE GET NAME PTR FOR CHAINED VRBLK{19094
{{BNZ{13,SCLEN(XR){6,DMP05{{JUMP IF NOT SYSTEM VARIABLE{19095
{{MOV{7,XR{13,VRSVO(XR){{ELSE POINT TO NAME IN SVBLK{19096
*
*      HERE PREPARE TO COMPARE THE NAMES
*
*      (WA)                  SCRATCH
*      (WB)                  POINTER TO STRING OF ENTERING VRBLK
*      (WC)                  POINTER TO ENTERING VRBLK
*      (XR)                  POINTER TO STRING OF CURRENT BLOCK
*      (XL)                  SCRATCH
*
{DMP05{MOV{7,XL{8,WB{{POINT TO ENTERING VRBLK STRING{19106
{{MOV{8,WA{13,SCLEN(XL){{LOAD ITS LENGTH{19107
{{PLC{7,XL{{{POINT TO CHARS OF ENTERING STRING{19108
{{BHI{8,WA{13,SCLEN(XR){6,DMP06{JUMP IF ENTERING LENGTH HIGH{19131
{{PLC{7,XR{{{ELSE POINT TO CHARS OF OLD STRING{19132
{{CMC{6,DMP08{6,DMP07{{COMPARE, INSERT IF NEW IS LLT OLD{19133
{{BRN{6,DMP08{{{OR IF LEQ (WE HAD SHORTER LENGTH){19134
*
*      HERE WHEN NEW LENGTH IS LONGER THAN OLD LENGTH
*
{DMP06{MOV{8,WA{13,SCLEN(XR){{LOAD SHORTER LENGTH{19138
{{PLC{7,XR{{{POINT TO CHARS OF OLD STRING{19139
{{CMC{6,DMP08{6,DMP07{{COMPARE, INSERT IF NEW ONE LOW{19140
{{EJC{{{{{19141
*
*      DUMPR (CONTINUED)
*
*      HERE WE MOVE OUT ON THE CHAIN
*
{DMP07{MOV{7,XL{3,DMPCH{{COPY CHAIN POINTER{19147
{{MOV{8,WA{9,(XL){{MOVE TO NEXT ENTRY ON CHAIN{19149
{{BRN{6,DMP04{{{LOOP BACK{19150
*
*      HERE AFTER LOCATING THE PROPER INSERTION POINT
*
{DMP08{MOV{7,XL{3,DMPCH{{COPY CHAIN POINTER{19154
{{MOV{8,WA{3,DMPSV{{RESTORE HASH BUCKET POINTER{19155
{{MOV{7,XR{8,WC{{RESTORE VRBLK POINTER{19156
{{MOV{13,VRGET(XR){9,(XL){{LINK VRBLK TO REST OF CHAIN{19157
{{MOV{9,(XL){7,XR{{LINK VRBLK INTO CURRENT CHAIN LOC{19158
{{BRN{6,DMP01{{{LOOP BACK FOR NEXT VRBLK{19159
*
*      HERE AFTER PROCESSING ALL VRBLKS ON ONE CHAIN
*
{DMP09{BNE{8,WA{3,HSHTE{6,DMP00{LOOP BACK IF MORE BUCKETS TO GO{19163
*
*      LOOP TO GENERATE DUMP OF NATURAL VARIABLE VALUES
*
{DMP10{MOV{7,XR{3,DMVCH{{LOAD POINTER TO NEXT ENTRY ON CHAIN{19167
{{BZE{7,XR{6,DMP11{{JUMP IF END OF CHAIN{19168
{{MOV{3,DMVCH{9,(XR){{ELSE UPDATE CHAIN PTR TO NEXT ENTRY{19169
{{JSR{6,SETVR{{{RESTORE VRGET FIELD{19170
{{MOV{7,XL{7,XR{{COPY VRBLK POINTER (NAME BASE){19171
{{MOV{8,WA{19,*VRVAL{{SET OFFSET FOR VRBLK NAME{19172
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{19173
{{BRN{6,DMP10{{{LOOP BACK TILL ALL PRINTED{19174
*
*      PREPARE TO PRINT KEYWORDS
*
{DMP11{JSR{6,PRTNL{{{PRINT BLANK LINE{19178
{{JSR{6,PRTNL{{{AND ANOTHER{19179
{{MOV{7,XR{21,=DMHDK{{POINT TO KEYWORD HEADING{19180
{{JSR{6,PRTST{{{PRINT HEADING{19181
{{JSR{6,PRTNL{{{END LINE{19182
{{JSR{6,PRTNL{{{PRINT ONE BLANK LINE{19183
{{MOV{7,XL{21,=VDMKW{{POINT TO LIST OF KEYWORD SVBLK PTRS{19184
{{EJC{{{{{19185
*
*      DUMPR (CONTINUED)
*
*      LOOP TO DUMP KEYWORD VALUES
*
{DMP12{MOV{7,XR{10,(XL)+{{LOAD NEXT SVBLK PTR FROM TABLE{19191
{{BZE{7,XR{6,DMP13{{JUMP IF END OF LIST{19192
{{BEQ{7,XR{18,=NUM01{6,DMP12{&COMPARE IGNORED IF NOT IMPLEMENTED{19194
{{MOV{8,WA{18,=CH_AM{{LOAD AMPERSAND{19196
{{JSR{6,PRTCH{{{PRINT AMPERSAND{19197
{{JSR{6,PRTST{{{PRINT KEYWORD NAME{19198
{{MOV{8,WA{13,SVLEN(XR){{LOAD NAME LENGTH FROM SVBLK{19199
{{CTB{8,WA{2,SVCHS{{GET LENGTH OF NAME{19200
{{ADD{7,XR{8,WA{{POINT TO SVKNM FIELD{19201
{{MOV{3,DMPKN{9,(XR){{STORE IN DUMMY KVBLK{19202
{{MOV{7,XR{21,=TMBEB{{POINT TO BLANK-EQUAL-BLANK{19203
{{JSR{6,PRTST{{{PRINT IT{19204
{{MOV{3,DMPSV{7,XL{{SAVE TABLE POINTER{19205
{{MOV{7,XL{20,=DMPKB{{POINT TO DUMMY KVBLK{19206
{{MOV{9,(XL){22,=B_KVT{{BUILD TYPE WORD{19207
{{MOV{13,KVVAR(XL){21,=TRBKV{{BUILD PTR TO DUMMY TRACE BLOCK{19208
{{MOV{8,WA{19,*KVVAR{{SET ZERO OFFSET{19209
{{JSR{6,ACESS{{{GET KEYWORD VALUE{19210
{{PPM{{{{FAILURE IS IMPOSSIBLE{19211
{{JSR{6,PRTVL{{{PRINT KEYWORD VALUE{19212
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{19213
{{MOV{7,XL{3,DMPSV{{RESTORE TABLE POINTER{19214
{{BRN{6,DMP12{{{LOOP BACK TILL ALL PRINTED{19215
*
*      HERE AFTER COMPLETING PARTIAL DUMP
*
{DMP13{BEQ{3,DMARG{18,=NUM01{6,DMP27{EXIT IF PARTIAL DUMP COMPLETE{19219
{{MOV{7,XR{3,DNAMB{{ELSE POINT TO FIRST DYNAMIC BLOCK{19220
*
*      LOOP THROUGH BLOCKS IN DYNAMIC STORAGE
*
{DMP14{BEQ{7,XR{3,DNAMP{6,DMP27{JUMP IF END OF USED REGION{19224
{{MOV{8,WA{9,(XR){{ELSE LOAD FIRST WORD OF BLOCK{19225
{{BEQ{8,WA{22,=B_VCT{6,DMP16{JUMP IF VECTOR{19226
{{BEQ{8,WA{22,=B_ART{6,DMP17{JUMP IF ARRAY{19227
{{BEQ{8,WA{22,=B_PDT{6,DMP18{JUMP IF PROGRAM DEFINED{19228
{{BEQ{8,WA{22,=B_TBT{6,DMP19{JUMP IF TABLE{19229
*
*      MERGE HERE TO MOVE TO NEXT BLOCK
*
{DMP15{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{19237
{{ADD{7,XR{8,WA{{POINT PAST THIS BLOCK{19238
{{BRN{6,DMP14{{{LOOP BACK FOR NEXT BLOCK{19239
{{EJC{{{{{19240
*
*      DUMPR (CONTINUED)
*
*      HERE FOR VECTOR
*
{DMP16{MOV{8,WB{19,*VCVLS{{SET OFFSET TO FIRST VALUE{19246
{{BRN{6,DMP19{{{JUMP TO MERGE{19247
*
*      HERE FOR ARRAY
*
{DMP17{MOV{8,WB{13,AROFS(XR){{SET OFFSET TO ARPRO FIELD{19251
{{ICA{8,WB{{{BUMP TO GET OFFSET TO VALUES{19252
{{BRN{6,DMP19{{{JUMP TO MERGE{19253
*
*      HERE FOR PROGRAM DEFINED
*
{DMP18{MOV{8,WB{19,*PDFLD{{POINT TO VALUES, MERGE{19257
*
*      HERE FOR TABLE (OTHERS MERGE)
*
{DMP19{BZE{13,IDVAL(XR){6,DMP15{{IGNORE BLOCK IF ZERO ID VALUE{19261
{{JSR{6,BLKLN{{{ELSE GET BLOCK LENGTH{19262
{{MOV{7,XL{7,XR{{COPY BLOCK POINTER{19263
{{MOV{3,DMPSV{8,WA{{SAVE LENGTH{19264
{{MOV{8,WA{8,WB{{COPY OFFSET TO FIRST VALUE{19265
{{JSR{6,PRTNL{{{PRINT BLANK LINE{19266
{{MOV{3,DMPSA{8,WA{{PRESERVE OFFSET{19267
{{JSR{6,PRTVL{{{PRINT BLOCK VALUE (FOR TITLE){19268
{{MOV{8,WA{3,DMPSA{{RECOVER OFFSET{19269
{{JSR{6,PRTNL{{{END PRINT LINE{19270
{{BEQ{9,(XR){22,=B_TBT{6,DMP22{JUMP IF TABLE{19271
{{DCA{8,WA{{{POINT BEFORE FIRST WORD{19272
*
*      LOOP TO PRINT CONTENTS OF ARRAY, VECTOR, OR PROGRAM DEF
*
{DMP20{MOV{7,XR{7,XL{{COPY BLOCK POINTER{19276
{{ICA{8,WA{{{BUMP OFFSET{19277
{{ADD{7,XR{8,WA{{POINT TO NEXT VALUE{19278
{{BEQ{8,WA{3,DMPSV{6,DMP14{EXIT IF END (XR PAST BLOCK){19279
{{SUB{7,XR{19,*VRVAL{{SUBTRACT OFFSET TO MERGE INTO LOOP{19280
*
*      LOOP TO FIND VALUE AND IGNORE NULLS
*
{DMP21{MOV{7,XR{13,VRVAL(XR){{LOAD NEXT VALUE{19284
{{BEQ{3,DMARG{18,=NUM03{6,DMP2B{SKIP NULL VALUE CHECK IF DUMP(3){19285
{{BEQ{7,XR{21,=NULLS{6,DMP20{LOOP BACK IF NULL VALUE{19286
{DMP2B{BEQ{9,(XR){22,=B_TRT{6,DMP21{LOOP BACK IF TRAPPED{19287
{{JSR{6,PRTNV{{{ELSE PRINT NAME = VALUE{19288
{{BRN{6,DMP20{{{LOOP BACK FOR NEXT FIELD{19289
{{EJC{{{{{19290
*
*      DUMPR (CONTINUED)
*
*      HERE TO DUMP A TABLE
*
{DMP22{MOV{8,WC{19,*TBBUK{{SET OFFSET TO FIRST BUCKET{19296
{{MOV{8,WA{19,*TEVAL{{SET NAME OFFSET FOR ALL TEBLKS{19297
*
*      LOOP THROUGH TABLE BUCKETS
*
{DMP23{MOV{11,-(XS){7,XL{{SAVE TBBLK POINTER{19301
{{ADD{7,XL{8,WC{{POINT TO NEXT BUCKET HEADER{19302
{{ICA{8,WC{{{BUMP BUCKET OFFSET{19303
{{SUB{7,XL{19,*TENXT{{SUBTRACT OFFSET TO MERGE INTO LOOP{19304
*
*      LOOP TO PROCESS TEBLKS ON ONE CHAIN
*
{DMP24{MOV{7,XL{13,TENXT(XL){{POINT TO NEXT TEBLK{19308
{{BEQ{7,XL{9,(XS){6,DMP26{JUMP IF END OF CHAIN{19309
{{MOV{7,XR{7,XL{{ELSE COPY TEBLK POINTER{19310
*
*      LOOP TO FIND VALUE AND IGNORE IF NULL
*
{DMP25{MOV{7,XR{13,TEVAL(XR){{LOAD NEXT VALUE{19314
{{BEQ{7,XR{21,=NULLS{6,DMP24{IGNORE IF NULL VALUE{19315
{{BEQ{9,(XR){22,=B_TRT{6,DMP25{LOOP BACK IF TRAPPED{19316
{{MOV{3,DMPSV{8,WC{{ELSE SAVE OFFSET POINTER{19317
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{19318
{{MOV{8,WC{3,DMPSV{{RELOAD OFFSET{19319
{{BRN{6,DMP24{{{LOOP BACK FOR NEXT TEBLK{19320
*
*      HERE TO MOVE TO NEXT HASH CHAIN
*
{DMP26{MOV{7,XL{10,(XS)+{{RESTORE TBBLK POINTER{19324
{{BNE{8,WC{13,TBLEN(XL){6,DMP23{LOOP BACK IF MORE BUCKETS TO GO{19325
{{MOV{7,XR{7,XL{{ELSE COPY TABLE POINTER{19326
{{ADD{7,XR{8,WC{{POINT TO FOLLOWING BLOCK{19327
{{BRN{6,DMP14{{{LOOP BACK TO PROCESS NEXT BLOCK{19328
*
*      HERE AFTER COMPLETING DUMP
*
{DMP27{JSR{6,PRTPG{{{EJECT PRINTER{19332
*
*      MERGE HERE IF NO DUMP GIVEN (DMARG=0)
*
{DMP28{EXI{{{{RETURN TO DUMP CALLER{19336
*
*      CALL SYSTEM CORE DUMP ROUTINE
*
{DMP29{JSR{6,SYSDM{{{CALL IT{19340
{{BRN{6,DMP28{{{RETURN{19341
{{ENP{{{{END PROCEDURE DUMPR{19377
{{EJC{{{{{19378
*
*      ERMSG -- PRINT ERROR CODE AND ERROR MESSAGE
*
*      KVERT                 ERROR CODE
*      JSR  ERMSG            CALL TO PRINT MESSAGE
*      (XR,XL,WA,WB,WC,IA)   DESTROYED
*
{ERMSG{PRC{25,E{1,0{{ENTRY POINT{19386
{{MOV{8,WA{3,KVERT{{LOAD ERROR CODE{19387
{{MOV{7,XR{21,=ERMMS{{POINT TO ERROR MESSAGE /ERROR/{19388
{{JSR{6,PRTST{{{PRINT IT{19389
{{JSR{6,ERTEX{{{GET ERROR MESSAGE TEXT{19390
{{ADD{8,WA{18,=THSND{{BUMP ERROR CODE FOR PRINT{19391
{{MTI{8,WA{{{FAIL CODE IN INT ACC{19392
{{MOV{8,WB{3,PROFS{{SAVE CURRENT BUFFER POSITION{19393
{{JSR{6,PRTIN{{{PRINT CODE (NOW HAVE ERROR1XXX){19394
{{MOV{7,XL{3,PRBUF{{POINT TO PRINT BUFFER{19395
{{PSC{7,XL{8,WB{{POINT TO THE 1{19396
{{MOV{8,WA{18,=CH_BL{{LOAD A BLANK{19397
{{SCH{8,WA{9,(XL){{STORE BLANK OVER 1 (ERROR XXX){19398
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{19399
{{ZER{7,XL{{{CLEAR GARBAGE POINTER IN XL{19400
{{MOV{8,WA{7,XR{{KEEP ERROR TEXT{19401
{{MOV{7,XR{21,=ERMNS{{POINT TO / -- /{19402
{{JSR{6,PRTST{{{PRINT IT{19403
{{MOV{7,XR{8,WA{{GET ERROR TEXT AGAIN{19404
{{JSR{6,PRTST{{{PRINT ERROR MESSAGE TEXT{19405
{{JSR{6,PRTIS{{{PRINT LINE{19406
{{JSR{6,PRTIS{{{PRINT BLANK LINE{19407
{{EXI{{{{RETURN TO ERMSG CALLER{19408
{{ENP{{{{END PROCEDURE ERMSG{19409
{{EJC{{{{{19410
*
*      ERTEX -- GET ERROR MESSAGE TEXT
*
*      (WA)                  ERROR CODE
*      JSR  ERTEX            CALL TO GET ERROR TEXT
*      (XR)                  PTR TO ERROR TEXT IN DYNAMIC
*      (R_ETX)               COPY OF PTR TO ERROR TEXT
*      (XL,WC,IA)            DESTROYED
*
{ERTEX{PRC{25,E{1,0{{ENTRY POINT{19420
{{MOV{3,ERTWA{8,WA{{SAVE WA{19421
{{MOV{3,ERTWB{8,WB{{SAVE WB{19422
{{JSR{6,SYSEM{{{GET FAILURE MESSAGE TEXT{19423
{{MOV{7,XL{7,XR{{COPY POINTER TO IT{19424
{{MOV{8,WA{13,SCLEN(XR){{GET LENGTH OF STRING{19425
{{BZE{8,WA{6,ERT02{{JUMP IF NULL{19426
{{ZER{8,WB{{{OFFSET OF ZERO{19427
{{JSR{6,SBSTR{{{COPY INTO DYNAMIC STORE{19428
{{MOV{3,R_ETX{7,XR{{STORE FOR RELOCATION{19429
*
*      RETURN
*
{ERT01{MOV{8,WB{3,ERTWB{{RESTORE WB{19433
{{MOV{8,WA{3,ERTWA{{RESTORE WA{19434
{{EXI{{{{RETURN TO CALLER{19435
*
*      RETURN ERRTEXT CONTENTS INSTEAD OF NULL
*
{ERT02{MOV{7,XR{3,R_ETX{{GET ERRTEXT{19439
{{BRN{6,ERT01{{{RETURN{19440
{{ENP{{{{{19441
{{EJC{{{{{19442
*
*      EVALI -- EVALUATE INTEGER ARGUMENT
*
*      EVALI IS USED BY PATTERN PRIMITIVES LEN,TAB,RTAB,POS,RPOS
*      WHEN THEIR ARGUMENT IS AN EXPRESSION VALUE.
*
*      (XR)                  NODE POINTER
*      (WB)                  CURSOR
*      JSR  EVALI            CALL TO EVALUATE INTEGER
*      PPM  LOC              TRANSFER LOC FOR NON-INTEGER ARG
*      PPM  LOC              TRANSFER LOC FOR OUT OF RANGE ARG
*      PPM  LOC              TRANSFER LOC FOR EVALUATION FAILURE
*      PPM  LOC              TRANSFER LOC FOR SUCCESSFUL EVAL
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XR)                  PTR TO NODE WITH INTEGER ARGUMENT
*      (WC,XL,RA)            DESTROYED
*
*      ON RETURN, THE NODE POINTED TO HAS THE INTEGER ARGUMENT
*      IN PARM1 AND THE PROPER SUCCESSOR POINTER IN PTHEN.
*      THIS ALLOWS MERGING WITH THE NORMAL (INTEGER ARG) CASE.
*
{EVALI{PRC{25,R{1,4{{ENTRY POINT (RECURSIVE){19464
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{19465
{{PPM{6,EVLI1{{{JUMP ON FAILURE{19466
{{MOV{11,-(XS){7,XL{{STACK RESULT FOR GTSMI{19467
{{MOV{7,XL{13,PTHEN(XR){{LOAD SUCCESSOR POINTER{19468
{{MOV{3,EVLIO{7,XR{{SAVE ORIGINAL NODE POINTER{19469
{{MOV{3,EVLIF{8,WC{{ZERO IF SIMPLE ARGUMENT{19470
{{JSR{6,GTSMI{{{CONVERT ARG TO SMALL INTEGER{19471
{{PPM{6,EVLI2{{{JUMP IF NOT INTEGER{19472
{{PPM{6,EVLI3{{{JUMP IF OUT OF RANGE{19473
{{MOV{3,EVLIV{7,XR{{STORE RESULT IN SPECIAL DUMMY NODE{19474
{{MOV{7,XR{20,=EVLIN{{POINT TO DUMMY NODE WITH RESULT{19475
{{MOV{9,(XR){22,=P_LEN{{DUMMY PATTERN BLOCK PCODE{19476
{{MOV{13,PTHEN(XR){7,XL{{STORE SUCCESSOR POINTER{19477
{{EXI{1,4{{{TAKE SUCCESSFUL EXIT{19478
*
*      HERE IF EVALUATION FAILS
*
{EVLI1{EXI{1,3{{{TAKE FAILURE RETURN{19482
*
*      HERE IF ARGUMENT IS NOT INTEGER
*
{EVLI2{EXI{1,1{{{TAKE NON-INTEGER ERROR EXIT{19486
*
*      HERE IF ARGUMENT IS OUT OF RANGE
*
{EVLI3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{19490
{{ENP{{{{END PROCEDURE EVALI{19491
{{EJC{{{{{19492
*
*      EVALP -- EVALUATE EXPRESSION DURING PATTERN MATCH
*
*      EVALP IS USED TO EVALUATE AN EXPRESSION (BY VALUE) DURING
*      A PATTERN MATCH. THE EFFECT IS LIKE EVALX, BUT PATTERN
*      VARIABLES ARE STACKED AND RESTORED IF NECESSARY.
*
*      EVALP ALSO DIFFERS FROM EVALX IN THAT IF THE RESULT IS
*      AN EXPRESSION IT IS REEVALUATED. THIS OCCURS REPEATEDLY.
*
*      TO SUPPORT OPTIMIZATION OF POS AND RPOS, EVALP USES WC
*      TO SIGNAL THE CALLER FOR THE CASE OF A SIMPLE VRBLK
*      THAT IS NOT AN EXPRESSION AND IS NOT TRAPPED.  BECAUSE
*      THIS CASE CANNOT HAVE ANY SIDE EFFECTS, OPTIMIZATION IS
*      POSSIBLE.
*
*      (XR)                  NODE POINTER
*      (WB)                  PATTERN MATCH CURSOR
*      JSR  EVALP            CALL TO EVALUATE EXPRESSION
*      PPM  LOC              TRANSFER LOC IF EVALUATION FAILS
*      (XL)                  RESULT
*      (WA)                  FIRST WORD OF RESULT BLOCK
*      (WC)                  ZERO IF SIMPLE VRBLK, ELSE NON-ZERO
*      (XR,WB)               DESTROYED (FAILURE CASE ONLY)
*      (RA)                  DESTROYED
*
*      THE EXPRESSION POINTER IS STORED IN PARM1 OF THE NODE
*
*      CONTROL RETURNS TO FAILP ON FAILURE OF EVALUATION
*
{EVALP{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){19523
{{MOV{7,XL{13,PARM1(XR){{LOAD EXPRESSION POINTER{19524
{{BEQ{9,(XL){22,=B_EXL{6,EVLP1{JUMP IF EXBLK CASE{19525
*
*      HERE FOR CASE OF SEBLK
*
*      WE CAN GIVE A FAST RETURN IF THE VALUE OF THE VRBLK IS
*      NOT AN EXPRESSION AND IS NOT TRAPPED.
*
{{MOV{7,XL{13,SEVAR(XL){{LOAD VRBLK POINTER{19532
{{MOV{7,XL{13,VRVAL(XL){{LOAD VALUE OF VRBLK{19533
{{MOV{8,WA{9,(XL){{LOAD FIRST WORD OF VALUE{19534
{{BHI{8,WA{22,=B_T__{6,EVLP3{JUMP IF NOT SEBLK, TRBLK OR EXBLK{19535
*
*      HERE FOR EXBLK OR SEBLK WITH EXPR VALUE OR TRAPPED VALUE
*
{EVLP1{CHK{{{{CHECK FOR STACK SPACE{19539
{{MOV{11,-(XS){7,XR{{STACK NODE POINTER{19540
{{MOV{11,-(XS){8,WB{{STACK CURSOR{19541
{{MOV{11,-(XS){3,R_PMS{{STACK SUBJECT STRING POINTER{19542
{{MOV{11,-(XS){3,PMSSL{{STACK SUBJECT STRING LENGTH{19543
{{MOV{11,-(XS){3,PMDFL{{STACK DOT FLAG{19544
{{MOV{11,-(XS){3,PMHBS{{STACK HISTORY STACK BASE POINTER{19545
{{MOV{7,XR{13,PARM1(XR){{LOAD EXPRESSION POINTER{19546
{{EJC{{{{{19547
*
*      EVALP (CONTINUED)
*
*      LOOP BACK HERE TO REEVALUATE EXPRESSION RESULT
*
{EVLP2{ZER{8,WB{{{SET FLAG FOR BY VALUE{19553
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{19554
{{PPM{6,EVLP4{{{JUMP ON FAILURE{19555
{{MOV{8,WA{9,(XR){{ELSE LOAD FIRST WORD OF VALUE{19556
{{BLO{8,WA{22,=B_E__{6,EVLP2{LOOP BACK TO REEVALUATE EXPRESSION{19557
*
*      HERE TO RESTORE PATTERN VALUES AFTER SUCCESSFUL EVAL
*
{{MOV{7,XL{7,XR{{COPY RESULT POINTER{19561
{{MOV{3,PMHBS{10,(XS)+{{RESTORE HISTORY STACK BASE POINTER{19562
{{MOV{3,PMDFL{10,(XS)+{{RESTORE DOT FLAG{19563
{{MOV{3,PMSSL{10,(XS)+{{RESTORE SUBJECT STRING LENGTH{19564
{{MOV{3,R_PMS{10,(XS)+{{RESTORE SUBJECT STRING POINTER{19565
{{MOV{8,WB{10,(XS)+{{RESTORE CURSOR{19566
{{MOV{7,XR{10,(XS)+{{RESTORE NODE POINTER{19567
{{MOV{8,WC{7,XR{{NON-ZERO FOR SIMPLE VRBLK{19568
{{EXI{{{{RETURN TO EVALP CALLER{19569
*
*      HERE TO RETURN AFTER SIMPLE VRBLK CASE
*
{EVLP3{ZER{8,WC{{{SIMPLE VRBLK, NO SIDE EFFECTS{19573
{{EXI{{{{RETURN TO EVALP CALLER{19574
*
*      HERE FOR FAILURE DURING EVALUATION
*
{EVLP4{MOV{3,PMHBS{10,(XS)+{{RESTORE HISTORY STACK BASE POINTER{19578
{{MOV{3,PMDFL{10,(XS)+{{RESTORE DOT FLAG{19579
{{MOV{3,PMSSL{10,(XS)+{{RESTORE SUBJECT STRING LENGTH{19580
{{MOV{3,R_PMS{10,(XS)+{{RESTORE SUBJECT STRING POINTER{19581
{{ADD{7,XS{19,*NUM02{{REMOVE NODE PTR, CURSOR{19582
{{EXI{1,1{{{TAKE FAILURE EXIT{19583
{{ENP{{{{END PROCEDURE EVALP{19584
{{EJC{{{{{19585
*
*      EVALS -- EVALUATE STRING ARGUMENT
*
*      EVALS IS USED BY SPAN, ANY, NOTANY, BREAK, BREAKX WHEN
*      THEY ARE PASSED AN EXPRESSION ARGUMENT.
*
*      (XR)                  NODE POINTER
*      (WB)                  CURSOR
*      JSR  EVALS            CALL TO EVALUATE STRING
*      PPM  LOC              TRANSFER LOC FOR NON-STRING ARG
*      PPM  LOC              TRANSFER LOC FOR EVALUATION FAILURE
*      PPM  LOC              TRANSFER LOC FOR SUCCESSFUL EVAL
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XR)                  PTR TO NODE WITH PARMS SET
*      (XL,WC,RA)            DESTROYED
*
*      ON RETURN, THE NODE POINTED TO HAS A CHARACTER TABLE
*      POINTER IN PARM1 AND A BIT MASK IN PARM2. THE PROPER
*      SUCCESSOR IS STORED IN PTHEN OF THIS NODE. THUS IT IS
*      OK FOR MERGING WITH THE NORMAL (MULTI-CHAR STRING) CASE.
*
{EVALS{PRC{25,R{1,3{{ENTRY POINT (RECURSIVE){19607
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{19608
{{PPM{6,EVLS1{{{JUMP IF EVALUATION FAILS{19609
{{MOV{11,-(XS){13,PTHEN(XR){{SAVE SUCCESSOR POINTER{19610
{{MOV{11,-(XS){8,WB{{SAVE CURSOR{19611
{{MOV{11,-(XS){7,XL{{STACK RESULT PTR FOR PATST{19612
{{ZER{8,WB{{{DUMMY PCODE FOR ONE CHAR STRING{19613
{{ZER{8,WC{{{DUMMY PCODE FOR EXPRESSION ARG{19614
{{MOV{7,XL{22,=P_BRK{{APPROPRIATE PCODE FOR OUR USE{19615
{{JSR{6,PATST{{{CALL ROUTINE TO BUILD NODE{19616
{{PPM{6,EVLS2{{{JUMP IF NOT STRING{19617
{{MOV{8,WB{10,(XS)+{{RESTORE CURSOR{19618
{{MOV{13,PTHEN(XR){10,(XS)+{{STORE SUCCESSOR POINTER{19619
{{EXI{1,3{{{TAKE SUCCESS RETURN{19620
*
*      HERE IF EVALUATION FAILS
*
{EVLS1{EXI{1,2{{{TAKE FAILURE RETURN{19624
*
*      HERE IF ARGUMENT IS NOT STRING
*
{EVLS2{ADD{7,XS{19,*NUM02{{POP SUCCESSOR AND CURSOR{19628
{{EXI{1,1{{{TAKE NON-STRING ERROR EXIT{19629
{{ENP{{{{END PROCEDURE EVALS{19630
{{EJC{{{{{19631
*
*      EVALX -- EVALUATE EXPRESSION
*
*      EVALX IS CALLED TO EVALUATE AN EXPRESSION
*
*      (XR)                  POINTER TO EXBLK OR SEBLK
*      (WB)                  0 IF BY VALUE, 1 IF BY NAME
*      JSR  EVALX            CALL TO EVALUATE EXPRESSION
*      PPM  LOC              TRANSFER LOC IF EVALUATION FAILS
*      (XR)                  RESULT IF CALLED BY VALUE
*      (XL,WA)               RESULT NAME BASE,OFFSET IF BY NAME
*      (XR)                  DESTROYED (NAME CASE ONLY)
*      (XL,WA)               DESTROYED (VALUE CASE ONLY)
*      (WB,WC,RA)            DESTROYED
*
{EVALX{PRC{25,R{1,1{{ENTRY POINT, RECURSIVE{19647
{{BEQ{9,(XR){22,=B_EXL{6,EVLX2{JUMP IF EXBLK CASE{19648
*
*      HERE FOR SEBLK
*
{{MOV{7,XL{13,SEVAR(XR){{LOAD VRBLK POINTER (NAME BASE){19652
{{MOV{8,WA{19,*VRVAL{{SET NAME OFFSET{19653
{{BNZ{8,WB{6,EVLX1{{JUMP IF CALLED BY NAME{19654
{{JSR{6,ACESS{{{CALL ROUTINE TO ACCESS VALUE{19655
{{PPM{6,EVLX9{{{JUMP IF FAILURE ON ACCESS{19656
*
*      MERGE HERE TO EXIT FOR SEBLK CASE
*
{EVLX1{EXI{{{{RETURN TO EVALX CALLER{19660
{{EJC{{{{{19661
*
*      EVALX (CONTINUED)
*
*      HERE FOR FULL EXPRESSION (EXBLK) CASE
*
*      IF AN ERROR OCCURS IN THE EXPRESSION CODE AT EXECUTION
*      TIME, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*      THE FOLLOWING ENTRIES ARE MADE ON THE STACK BEFORE
*      GIVING CONTROL TO THE EXPRESSION CODE
*
*                            EVALX RETURN POINT
*                            SAVED VALUE OF R_COD
*                            CODE POINTER (-R_COD)
*                            SAVED VALUE OF FLPTR
*                            0 IF BY VALUE, 1 IF BY NAME
*      FLPTR --------------- *EXFLC, FAIL OFFSET IN EXBLK
*
{EVLX2{SCP{8,WC{{{GET CODE POINTER{19680
{{MOV{8,WA{3,R_COD{{LOAD CODE BLOCK POINTER{19681
{{SUB{8,WC{8,WA{{GET CODE POINTER AS OFFSET{19682
{{MOV{11,-(XS){8,WA{{STACK OLD CODE BLOCK POINTER{19683
{{MOV{11,-(XS){8,WC{{STACK RELATIVE CODE OFFSET{19684
{{MOV{11,-(XS){3,FLPTR{{STACK OLD FAILURE POINTER{19685
{{MOV{11,-(XS){8,WB{{STACK NAME/VALUE INDICATOR{19686
{{MOV{11,-(XS){19,*EXFLC{{STACK NEW FAIL OFFSET{19687
{{MOV{3,GTCEF{3,FLPTR{{KEEP IN CASE OF ERROR{19688
{{MOV{3,R_GTC{3,R_COD{{KEEP CODE BLOCK POINTER SIMILARLY{19689
{{MOV{3,FLPTR{7,XS{{SET NEW FAILURE POINTER{19690
{{MOV{3,R_COD{7,XR{{SET NEW CODE BLOCK POINTER{19691
{{MOV{13,EXSTM(XR){3,KVSTN{{REMEMBER STMNT NUMBER{19692
{{ADD{7,XR{19,*EXCOD{{POINT TO FIRST CODE WORD{19693
{{LCP{7,XR{{{SET CODE POINTER{19694
{{BNE{3,STAGE{18,=STGXT{6,EVLX0{JUMP IF NOT EXECUTION TIME{19695
{{MOV{3,STAGE{18,=STGEE{{EVALUATING EXPRESSION{19696
*
*      HERE TO EXECUTE FIRST CODE WORD OF EXPRESSION
*
{EVLX0{ZER{7,XL{{{CLEAR GARBAGE XL{19700
{{LCW{7,XR{{{LOAD FIRST CODE WORD{19701
{{BRI{9,(XR){{{EXECUTE IT{19702
{{EJC{{{{{19703
*
*      EVALX (CONTINUED)
*
*      COME HERE IF SUCCESSFUL RETURN BY VALUE (SEE O_RVL)
*
{EVLX3{MOV{7,XR{10,(XS)+{{LOAD VALUE{19709
{{BZE{13,NUM01(XS){6,EVLX5{{JUMP IF CALLED BY VALUE{19710
{{ERB{1,249{26,Expression evaluated by name returned value{{{19711
*
*      HERE FOR EXPRESSION RETURNING BY NAME (SEE O_RNM)
*
{EVLX4{MOV{8,WA{10,(XS)+{{LOAD NAME OFFSET{19715
{{MOV{7,XL{10,(XS)+{{LOAD NAME BASE{19716
{{BNZ{13,NUM01(XS){6,EVLX5{{JUMP IF CALLED BY NAME{19717
{{JSR{6,ACESS{{{ELSE ACCESS VALUE FIRST{19718
{{PPM{6,EVLX6{{{JUMP IF FAILURE DURING ACCESS{19719
*
*      HERE AFTER LOADING CORRECT RESULT INTO XR OR XL,WA
*
{EVLX5{ZER{8,WB{{{NOTE SUCCESSFUL{19723
{{BRN{6,EVLX7{{{MERGE{19724
*
*      HERE FOR FAILURE IN EXPRESSION EVALUATION (SEE O_FEX)
*
{EVLX6{MNZ{8,WB{{{NOTE UNSUCCESSFUL{19728
*
*      RESTORE ENVIRONMENT
*
{EVLX7{BNE{3,STAGE{18,=STGEE{6,EVLX8{SKIP IF WAS NOT PREVIOUSLY XT{19732
{{MOV{3,STAGE{18,=STGXT{{EXECUTE TIME{19733
*
*      MERGE WITH STAGE SET UP
*
{EVLX8{ADD{7,XS{19,*NUM02{{POP NAME/VALUE INDICATOR, *EXFAL{19737
{{MOV{3,FLPTR{10,(XS)+{{RESTORE OLD FAILURE POINTER{19738
{{MOV{8,WC{10,(XS)+{{LOAD CODE OFFSET{19739
{{ADD{8,WC{9,(XS){{MAKE CODE POINTER ABSOLUTE{19740
{{MOV{3,R_COD{10,(XS)+{{RESTORE OLD CODE BLOCK POINTER{19741
{{LCP{8,WC{{{RESTORE OLD CODE POINTER{19742
{{BZE{8,WB{6,EVLX1{{JUMP FOR SUCCESSFUL RETURN{19743
*
*      MERGE HERE FOR FAILURE IN SEBLK CASE
*
{EVLX9{EXI{1,1{{{TAKE FAILURE EXIT{19747
{{ENP{{{{END OF PROCEDURE EVALX{19748
{{EJC{{{{{19749
*
*      EXBLD -- BUILD EXBLK
*
*      EXBLD IS USED TO BUILD AN EXPRESSION BLOCK FROM THE
*      CODE COMPILED MOST RECENTLY IN THE CURRENT CCBLK.
*
*      (XL)                  OFFSET IN CCBLK TO START OF CODE
*      (WB)                  INTEGER IN RANGE 0 LE N LE MXLEN
*      JSR  EXBLD            CALL TO BUILD EXBLK
*      (XR)                  PTR TO CONSTRUCTED EXBLK
*      (WA,WB,XL)            DESTROYED
*
{EXBLD{PRC{25,E{1,0{{ENTRY POINT{19762
{{MOV{8,WA{7,XL{{COPY OFFSET TO START OF CODE{19763
{{SUB{8,WA{19,*EXCOD{{CALC REDUCTION IN OFFSET IN EXBLK{19764
{{MOV{11,-(XS){8,WA{{STACK FOR LATER{19765
{{MOV{8,WA{3,CWCOF{{LOAD FINAL OFFSET{19766
{{SUB{8,WA{7,XL{{COMPUTE LENGTH OF CODE{19767
{{ADD{8,WA{19,*EXSI_{{ADD SPACE FOR STANDARD FIELDS{19768
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR EXBLK{19769
{{MOV{11,-(XS){7,XR{{SAVE POINTER TO EXBLK{19770
{{MOV{13,EXTYP(XR){22,=B_EXL{{STORE TYPE WORD{19771
{{ZER{13,EXSTM(XR){{{ZEROISE STMNT NUMBER FIELD{19772
{{MOV{13,EXSLN(XR){3,CMPLN{{SET LINE NUMBER FIELD{19774
{{MOV{13,EXLEN(XR){8,WA{{STORE LENGTH{19776
{{MOV{13,EXFLC(XR){21,=OFEX_{{STORE FAILURE WORD{19777
{{ADD{7,XR{19,*EXSI_{{SET XR FOR MVW{19778
{{MOV{3,CWCOF{7,XL{{RESET OFFSET TO START OF CODE{19779
{{ADD{7,XL{3,R_CCB{{POINT TO START OF CODE{19780
{{SUB{8,WA{19,*EXSI_{{LENGTH OF CODE TO MOVE{19781
{{MOV{11,-(XS){8,WA{{STACK LENGTH OF CODE{19782
{{MVW{{{{MOVE CODE TO EXBLK{19783
{{MOV{8,WA{10,(XS)+{{GET LENGTH OF CODE{19784
{{BTW{8,WA{{{CONVERT BYTE COUNT TO WORD COUNT{19785
{{LCT{8,WA{8,WA{{PREPARE COUNTER FOR LOOP{19786
{{MOV{7,XL{9,(XS){{COPY EXBLK PTR, DONT UNSTACK{19787
{{ADD{7,XL{19,*EXCOD{{POINT TO CODE ITSELF{19788
{{MOV{8,WB{13,NUM01(XS){{GET REDUCTION IN OFFSET{19789
*
*      THIS LOOP SEARCHES FOR NEGATION AND SELECTION CODE SO
*      THAT THE OFFSETS COMPUTED WHILST CODE WAS IN CODE BLOCK
*      CAN BE TRANSFORMED TO REDUCED VALUES APPLICABLE IN AN
*      EXBLK.
*
{EXBL1{MOV{7,XR{10,(XL)+{{GET NEXT CODE WORD{19796
{{BEQ{7,XR{21,=OSLA_{6,EXBL3{JUMP IF SELECTION FOUND{19797
{{BEQ{7,XR{21,=ONTA_{6,EXBL3{JUMP IF NEGATION FOUND{19798
{{BCT{8,WA{6,EXBL1{{LOOP TO END OF CODE{19799
*
*      NO SELECTION FOUND OR MERGE TO EXIT ON TERMINATION
*
{EXBL2{MOV{7,XR{10,(XS)+{{POP EXBLK PTR INTO XR{19803
{{MOV{7,XL{10,(XS)+{{POP REDUCTION CONSTANT{19804
{{EXI{{{{RETURN TO CALLER{19805
{{EJC{{{{{19806
*
*      EXBLD (CONTINUED)
*
*      SELECTION OR NEGATION FOUND
*      REDUCE THE OFFSETS AS NEEDED. OFFSETS OCCUR IN WORDS
*      FOLLOWING CODE WORDS -
*           =ONTA_, =OSLA_, =OSLB_, =OSLC_
*
{EXBL3{SUB{10,(XL)+{8,WB{{ADJUST OFFSET{19815
{{BCT{8,WA{6,EXBL4{{DECREMENT COUNT{19816
*
{EXBL4{BCT{8,WA{6,EXBL5{{DECREMENT COUNT{19818
*
*      CONTINUE SEARCH FOR MORE OFFSETS
*
{EXBL5{MOV{7,XR{10,(XL)+{{GET NEXT CODE WORD{19822
{{BEQ{7,XR{21,=OSLA_{6,EXBL3{JUMP IF OFFSET FOUND{19823
{{BEQ{7,XR{21,=OSLB_{6,EXBL3{JUMP IF OFFSET FOUND{19824
{{BEQ{7,XR{21,=OSLC_{6,EXBL3{JUMP IF OFFSET FOUND{19825
{{BEQ{7,XR{21,=ONTA_{6,EXBL3{JUMP IF OFFSET FOUND{19826
{{BCT{8,WA{6,EXBL5{{LOOP{19827
{{BRN{6,EXBL2{{{MERGE TO RETURN{19828
{{ENP{{{{END PROCEDURE EXBLD{19829
{{EJC{{{{{19830
*
*      EXPAN -- ANALYZE EXPRESSION
*
*      THE EXPRESSION ANALYZER (EXPAN) PROCEDURE IS USED TO SCAN
*      AN EXPRESSION AND CONVERT IT INTO A TREE REPRESENTATION.
*      SEE THE DESCRIPTION OF CMBLK IN THE STRUCTURES SECTION
*      FOR DETAILED FORMAT OF TREE BLOCKS.
*
*      THE ANALYZER USES A SIMPLE PRECEDENCE SCHEME IN WHICH
*      OPERANDS AND OPERATORS ARE PLACED ON A SINGLE STACK
*      AND CONDENSATIONS ARE MADE WHEN LOW PRECEDENCE OPERATORS
*      ARE STACKED AFTER A HIGHER PRECEDENCE OPERATOR. A GLOBAL
*      VARIABLE (IN WB) KEEPS TRACK OF THE LEVEL AS FOLLOWS.
*
*      0    SCANNING OUTER LEVEL OF STATEMENT OR EXPRESSION
*      1    SCANNING OUTER LEVEL OF NORMAL GOTO
*      2    SCANNING OUTER LEVEL OF DIRECT GOTO
*      3    SCANNING INSIDE ARRAY BRACKETS
*      4    SCANNING INSIDE GROUPING PARENTHESES
*      5    SCANNING INSIDE FUNCTION PARENTHESES
*
*      THIS VARIABLE IS SAVED ON THE STACK ON ENCOUNTERING A
*      GROUPING AND RESTORED AT THE END OF THE GROUPING.
*
*      ANOTHER GLOBAL VARIABLE (IN WC) COUNTS THE NUMBER OF
*      ITEMS AT ONE GROUPING LEVEL AND IS INCREMENTED FOR EACH
*      COMMA ENCOUNTERED. IT IS STACKED WITH THE LEVEL INDICATOR
*
*      THE SCAN IS CONTROLLED BY A THREE STATE FINITE MACHINE.
*      A GLOBAL VARIABLE STORED IN WA IS THE CURRENT STATE.
*
*      WA=0                  NOTHING SCANNED AT THIS LEVEL
*      WA=1                  OPERAND EXPECTED
*      WA=2                  OPERATOR EXPECTED
*
*      (WB)                  CALL TYPE (SEE BELOW)
*      JSR  EXPAN            CALL TO ANALYZE EXPRESSION
*      (XR)                  POINTER TO RESULTING TREE
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      THE ENTRY VALUE OF WB INDICATES THE CALL TYPE AS FOLLOWS.
*
*      0    SCANNING EITHER THE MAIN BODY OF A STATEMENT OR THE
*           TEXT OF AN EXPRESSION (FROM EVAL CALL). VALID
*           TERMINATORS ARE COLON, SEMICOLON. THE RESCAN FLAG IS
*           SET TO RETURN THE TERMINATOR ON THE NEXT SCANE CALL.
*
*      1    SCANNING A NORMAL GOTO. THE ONLY VALID
*           TERMINATOR IS A RIGHT PAREN.
*
*      2    SCANNING A DIRECT GOTO. THE ONLY VALID
*           TERMINATOR IS A RIGHT BRACKET.
{{EJC{{{{{19883
*
*      EXPAN (CONTINUED)
*
*      ENTRY POINT
*
{EXPAN{PRC{25,E{1,0{{ENTRY POINT{19889
{{ZER{11,-(XS){{{SET TOP OF STACK INDICATOR{19890
{{ZER{8,WA{{{SET INITIAL STATE TO ZERO{19891
{{ZER{8,WC{{{ZERO COUNTER VALUE{19892
*
*      LOOP HERE FOR SUCCESSIVE ENTRIES
*
{EXP01{JSR{6,SCANE{{{SCAN NEXT ELEMENT{19896
{{ADD{7,XL{8,WA{{ADD STATE TO SYNTAX CODE{19897
{{BSW{7,XL{2,T_NES{{SWITCH ON ELEMENT TYPE/STATE{19898
{{IFF{2,T_UO0{6,EXP27{{UNOP, S=0{19935
{{IFF{2,T_UO1{6,EXP27{{UNOP, S=1{19935
{{IFF{2,T_UO2{6,EXP04{{UNOP, S=2{19935
{{IFF{2,T_LP0{6,EXP06{{LEFT PAREN, S=0{19935
{{IFF{2,T_LP1{6,EXP06{{LEFT PAREN, S=1{19935
{{IFF{2,T_LP2{6,EXP04{{LEFT PAREN, S=2{19935
{{IFF{2,T_LB0{6,EXP08{{LEFT BRKT, S=0{19935
{{IFF{2,T_LB1{6,EXP08{{LEFT BRKT, S=1{19935
{{IFF{2,T_LB2{6,EXP09{{LEFT BRKT, S=2{19935
{{IFF{2,T_CM0{6,EXP02{{COMMA, S=0{19935
{{IFF{2,T_CM1{6,EXP05{{COMMA, S=1{19935
{{IFF{2,T_CM2{6,EXP11{{COMMA, S=2{19935
{{IFF{2,T_FN0{6,EXP10{{FUNCTION, S=0{19935
{{IFF{2,T_FN1{6,EXP10{{FUNCTION, S=1{19935
{{IFF{2,T_FN2{6,EXP04{{FUNCTION, S=2{19935
{{IFF{2,T_VA0{6,EXP03{{VARIABLE, S=0{19935
{{IFF{2,T_VA1{6,EXP03{{VARIABLE, STATE ONE{19935
{{IFF{2,T_VA2{6,EXP04{{VARIABLE, S=2{19935
{{IFF{2,T_CO0{6,EXP03{{CONSTANT, S=0{19935
{{IFF{2,T_CO1{6,EXP03{{CONSTANT, S=1{19935
{{IFF{2,T_CO2{6,EXP04{{CONSTANT, S=2{19935
{{IFF{2,T_BO0{6,EXP05{{BINOP, S=0{19935
{{IFF{2,T_BO1{6,EXP05{{BINOP, S=1{19935
{{IFF{2,T_BO2{6,EXP26{{BINOP, S=2{19935
{{IFF{2,T_RP0{6,EXP02{{RIGHT PAREN, S=0{19935
{{IFF{2,T_RP1{6,EXP05{{RIGHT PAREN, S=1{19935
{{IFF{2,T_RP2{6,EXP12{{RIGHT PAREN, S=2{19935
{{IFF{2,T_RB0{6,EXP02{{RIGHT BRKT, S=0{19935
{{IFF{2,T_RB1{6,EXP05{{RIGHT BRKT, S=1{19935
{{IFF{2,T_RB2{6,EXP18{{RIGHT BRKT, S=2{19935
{{IFF{2,T_CL0{6,EXP02{{COLON, S=0{19935
{{IFF{2,T_CL1{6,EXP05{{COLON, S=1{19935
{{IFF{2,T_CL2{6,EXP19{{COLON, S=2{19935
{{IFF{2,T_SM0{6,EXP02{{SEMICOLON, S=0{19935
{{IFF{2,T_SM1{6,EXP05{{SEMICOLON, S=1{19935
{{IFF{2,T_SM2{6,EXP19{{SEMICOLON, S=2{19935
{{ESW{{{{END SWITCH ON ELEMENT TYPE/STATE{19935
{{EJC{{{{{19936
*
*      EXPAN (CONTINUED)
*
*      HERE FOR RBR,RPR,COL,SMC,CMA IN STATE 0
*
*      SET TO RESCAN THE TERMINATOR ENCOUNTERED AND CREATE
*      A NULL CONSTANT (CASE OF OMITTED NULL)
*
{EXP02{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT{19945
{{MOV{7,XR{21,=NULLS{{POINT TO NULL, MERGE{19946
*
*      HERE FOR VAR OR CON IN STATES 0,1
*
*      STACK THE VARIABLE/CONSTANT AND SET STATE=2
*
{EXP03{MOV{11,-(XS){7,XR{{STACK POINTER TO OPERAND{19952
{{MOV{8,WA{18,=NUM02{{SET STATE 2{19953
{{BRN{6,EXP01{{{JUMP FOR NEXT ELEMENT{19954
*
*      HERE FOR VAR,CON,LPR,FNC,UOP IN STATE 2
*
*      WE RESCAN THE ELEMENT AND CREATE A CONCATENATION OPERATOR
*      THIS IS THE CASE OF THE BLANK CONCATENATION OPERATOR.
*
{EXP04{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT{19961
{{MOV{7,XR{21,=OPDVC{{POINT TO CONCAT OPERATOR DV{19962
{{BZE{8,WB{6,EXP4A{{OK IF AT TOP LEVEL{19963
{{MOV{7,XR{21,=OPDVP{{ELSE POINT TO UNMISTAKABLE CONCAT.{19964
*
*      MERGE HERE WHEN XR SET UP WITH PROPER CONCATENATION DVBLK
*
{EXP4A{BNZ{3,SCNBL{6,EXP26{{MERGE BOP IF BLANKS, ELSE ERROR{19968
*      DCV  SCNSE            ADJUST START OF ELEMENT LOCATION
{{ERB{1,220{26,Syntax error: Missing operator{{{19970
*
*      HERE FOR CMA,RPR,RBR,COL,SMC,BOP(S=1) BOP(S=0)
*
*      THIS IS AN ERRONOUS CONTRUCTION
*
*EXP05 DCV  SCNSE            ADJUST START OF ELEMENT LOCATION
{EXP05{ERB{1,221{26,Syntax error: Missing operand{{{19978
*
*      HERE FOR LPR (S=0,1)
*
{EXP06{MOV{7,XL{18,=NUM04{{SET NEW LEVEL INDICATOR{19982
{{ZER{7,XR{{{SET ZERO VALUE FOR CMOPN{19983
{{EJC{{{{{19984
*
*      EXPAN (CONTINUED)
*
*      MERGE HERE TO STORE OLD LEVEL ON STACK AND START NEW ONE
*
{EXP07{MOV{11,-(XS){7,XR{{STACK CMOPN VALUE{19990
{{MOV{11,-(XS){8,WC{{STACK OLD COUNTER{19991
{{MOV{11,-(XS){8,WB{{STACK OLD LEVEL INDICATOR{19992
{{CHK{{{{CHECK FOR STACK OVERFLOW{19993
{{ZER{8,WA{{{SET NEW STATE TO ZERO{19994
{{MOV{8,WB{7,XL{{SET NEW LEVEL INDICATOR{19995
{{MOV{8,WC{18,=NUM01{{INITIALIZE NEW COUNTER{19996
{{BRN{6,EXP01{{{JUMP TO SCAN NEXT ELEMENT{19997
*
*      HERE FOR LBR (S=0,1)
*
*      THIS IS AN ILLEGAL USE OF LEFT BRACKET
*
{EXP08{ERB{1,222{26,Syntax error: Invalid use of left bracket{{{20003
*
*      HERE FOR LBR (S=2)
*
*      SET NEW LEVEL AND START TO SCAN SUBSCRIPTS
*
{EXP09{MOV{7,XR{10,(XS)+{{LOAD ARRAY PTR FOR CMOPN{20009
{{MOV{7,XL{18,=NUM03{{SET NEW LEVEL INDICATOR{20010
{{BRN{6,EXP07{{{JUMP TO STACK OLD AND START NEW{20011
*
*      HERE FOR FNC (S=0,1)
*
*      STACK OLD LEVEL AND START TO SCAN ARGUMENTS
*
{EXP10{MOV{7,XL{18,=NUM05{{SET NEW LEV INDIC (XR=VRBLK=CMOPN){20017
{{BRN{6,EXP07{{{JUMP TO STACK OLD AND START NEW{20018
*
*      HERE FOR CMA (S=2)
*
*      INCREMENT ARGUMENT COUNT AND CONTINUE
*
{EXP11{ICV{8,WC{{{INCREMENT COUNTER{20024
{{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{20025
{{ZER{11,-(XS){{{SET NEW LEVEL FOR PARAMETER{20026
{{ZER{8,WA{{{SET NEW STATE{20027
{{BGT{8,WB{18,=NUM02{6,EXP01{LOOP BACK UNLESS OUTER LEVEL{20028
{{ERB{1,223{26,Syntax error: Invalid use of comma{{{20029
{{EJC{{{{{20030
*
*      EXPAN (CONTINUED)
*
*      HERE FOR RPR (S=2)
*
*      AT OUTER LEVEL IN A NORMAL GOTO THIS IS A TERMINATOR
*      OTHERWISE IT MUST TERMINATE A FUNCTION OR GROUPING
*
{EXP12{BEQ{8,WB{18,=NUM01{6,EXP20{END OF NORMAL GOTO{20039
{{BEQ{8,WB{18,=NUM05{6,EXP13{END OF FUNCTION ARGUMENTS{20040
{{BEQ{8,WB{18,=NUM04{6,EXP14{END OF GROUPING / SELECTION{20041
{{ERB{1,224{26,Syntax error: Unbalanced right parenthesis{{{20042
*
*      HERE AT END OF FUNCTION ARGUMENTS
*
{EXP13{MOV{7,XL{18,=C_FNC{{SET CMTYP VALUE FOR FUNCTION{20046
{{BRN{6,EXP15{{{JUMP TO BUILD CMBLK{20047
*
*      HERE FOR END OF GROUPING
*
{EXP14{BEQ{8,WC{18,=NUM01{6,EXP17{JUMP IF END OF GROUPING{20051
{{MOV{7,XL{18,=C_SEL{{ELSE SET CMTYP FOR SELECTION{20052
*
*      MERGE HERE TO BUILD CMBLK FOR LEVEL JUST SCANNED AND
*      TO POP UP TO THE PREVIOUS SCAN LEVEL BEFORE CONTINUING.
*
{EXP15{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{20057
{{MOV{8,WA{8,WC{{COPY COUNT{20058
{{ADD{8,WA{18,=CMVLS{{ADD FOR STANDARD FIELDS AT START{20059
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{20060
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{20061
{{MOV{9,(XR){22,=B_CMT{{STORE TYPE CODE FOR CMBLK{20062
{{MOV{13,CMTYP(XR){7,XL{{STORE CMBLK NODE TYPE INDICATOR{20063
{{MOV{13,CMLEN(XR){8,WA{{STORE LENGTH{20064
{{ADD{7,XR{8,WA{{POINT PAST END OF BLOCK{20065
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{20066
*
*      LOOP TO MOVE REMAINING WORDS TO CMBLK
*
{EXP16{MOV{11,-(XR){10,(XS)+{{MOVE ONE OPERAND PTR FROM STACK{20070
{{MOV{8,WB{10,(XS)+{{POP TO OLD LEVEL INDICATOR{20071
{{BCT{8,WC{6,EXP16{{LOOP TILL ALL MOVED{20072
{{EJC{{{{{20073
*
*      EXPAN (CONTINUED)
*
*      COMPLETE CMBLK AND STACK POINTER TO IT ON STACK
*
{{SUB{7,XR{19,*CMVLS{{POINT BACK TO START OF BLOCK{20079
{{MOV{8,WC{10,(XS)+{{RESTORE OLD COUNTER{20080
{{MOV{13,CMOPN(XR){9,(XS){{STORE OPERAND PTR IN CMBLK{20081
{{MOV{9,(XS){7,XR{{STACK CMBLK POINTER{20082
{{MOV{8,WA{18,=NUM02{{SET NEW STATE{20083
{{BRN{6,EXP01{{{BACK FOR NEXT ELEMENT{20084
*
*      HERE AT END OF A PARENTHESIZED EXPRESSION
*
{EXP17{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{20088
{{MOV{7,XR{10,(XS)+{{RESTORE XR{20089
{{MOV{8,WB{10,(XS)+{{RESTORE OUTER LEVEL{20090
{{MOV{8,WC{10,(XS)+{{RESTORE OUTER COUNT{20091
{{MOV{9,(XS){7,XR{{STORE OPND OVER UNUSED CMOPN VAL{20092
{{MOV{8,WA{18,=NUM02{{SET NEW STATE{20093
{{BRN{6,EXP01{{{BACK FOR NEXT ELE8ENT{20094
*
*      HERE FOR RBR (S=2)
*
*      AT OUTER LEVEL IN A DIRECT GOTO, THIS IS A TERMINATOR.
*      OTHERWISE IT MUST TERMINATE A SUBSCRIPT LIST.
*
{EXP18{MOV{7,XL{18,=C_ARR{{SET CMTYP FOR ARRAY REFERENCE{20101
{{BEQ{8,WB{18,=NUM03{6,EXP15{JUMP TO BUILD CMBLK IF END ARRAYREF{20102
{{BEQ{8,WB{18,=NUM02{6,EXP20{JUMP IF END OF DIRECT GOTO{20103
{{ERB{1,225{26,Syntax error: Unbalanced right bracket{{{20104
{{EJC{{{{{20105
*
*      EXPAN (CONTINUED)
*
*      HERE FOR COL,SMC (S=2)
*
*      ERROR UNLESS TERMINATING STATEMENT BODY AT OUTER LEVEL
*
{EXP19{MNZ{3,SCNRS{{{RESCAN TERMINATOR{20113
{{MOV{7,XL{8,WB{{COPY LEVEL INDICATOR{20114
{{BSW{7,XL{1,6{{SWITCH ON LEVEL INDICATOR{20115
{{IFF{1,0{6,EXP20{{NORMAL OUTER LEVEL{20122
{{IFF{1,1{6,EXP22{{FAIL IF NORMAL GOTO{20122
{{IFF{1,2{6,EXP23{{FAIL IF DIRECT GOTO{20122
{{IFF{1,3{6,EXP24{{FAIL ARRAY BRACKETS{20122
{{IFF{1,4{6,EXP21{{FAIL IF IN GROUPING{20122
{{IFF{1,5{6,EXP21{{FAIL FUNCTION ARGS{20122
{{ESW{{{{END SWITCH ON LEVEL{20122
*
*      HERE AT NORMAL END OF EXPRESSION
*
{EXP20{JSR{6,EXPDM{{{DUMP REMAINING OPERATORS{20126
{{MOV{7,XR{10,(XS)+{{LOAD TREE POINTER{20127
{{ICA{7,XS{{{POP OFF BOTTOM OF STACK MARKER{20128
{{EXI{{{{RETURN TO EXPAN CALLER{20129
*
*      MISSING RIGHT PAREN
*
{EXP21{ERB{1,226{26,Syntax error: Missing right paren{{{20133
*
*      MISSING RIGHT PAREN IN GOTO FIELD
*
{EXP22{ERB{1,227{26,Syntax error: Right paren missing from goto{{{20137
*
*      MISSING BRACKET IN GOTO
*
{EXP23{ERB{1,228{26,Syntax error: Right bracket missing from goto{{{20141
*
*      MISSING ARRAY BRACKET
*
{EXP24{ERB{1,229{26,Syntax error: Missing right array bracket{{{20145
{{EJC{{{{{20146
*
*      EXPAN (CONTINUED)
*
*      LOOP HERE WHEN AN OPERATOR CAUSES AN OPERATOR DUMP
*
{EXP25{MOV{3,EXPSV{7,XR{{{20152
{{JSR{6,EXPOP{{{POP ONE OPERATOR{20153
{{MOV{7,XR{3,EXPSV{{RESTORE OP DV POINTER AND MERGE{20154
*
*      HERE FOR BOP (S=2)
*
*      REMOVE OPERATORS (CONDENSE) FROM STACK UNTIL NO MORE
*      LEFT AT THIS LEVEL OR TOP ONE HAS LOWER PRECEDENCE.
*      LOOP HERE TILL THIS CONDITION IS MET.
*
{EXP26{MOV{7,XL{13,NUM01(XS){{LOAD OPERATOR DVPTR FROM STACK{20162
{{BLE{7,XL{18,=NUM05{6,EXP27{JUMP IF BOTTOM OF STACK LEVEL{20163
{{BLT{13,DVRPR(XR){13,DVLPR(XL){6,EXP25{ELSE POP IF NEW PREC IS LO{20164
*
*      HERE FOR UOP (S=0,1)
*
*      BINARY OPERATOR MERGES AFTER PRECEDENCE CHECK
*
*      THE OPERATOR DV IS STORED ON THE STACK AND THE SCAN
*      CONTINUES AFTER SETTING THE SCAN STATE TO ONE.
*
{EXP27{MOV{11,-(XS){7,XR{{STACK OPERATOR DVPTR ON STACK{20173
{{CHK{{{{CHECK FOR STACK OVERFLOW{20174
{{MOV{8,WA{18,=NUM01{{SET NEW STATE{20175
{{BNE{7,XR{21,=OPDVS{6,EXP01{BACK FOR NEXT ELEMENT UNLESS ={20176
*
*      HERE FOR SPECIAL CASE OF BINARY =. THE SYNTAX ALLOWS A
*      NULL RIGHT ARGUMENT FOR THIS OPERATOR TO BE LEFT
*      OUT. ACCORDINGLY WE RESET TO STATE ZERO TO GET PROPER
*      ACTION ON A TERMINATOR (SUPPLY A NULL CONSTANT).
*
{{ZER{8,WA{{{SET STATE ZERO{20183
{{BRN{6,EXP01{{{JUMP FOR NEXT ELEMENT{20184
{{ENP{{{{END PROCEDURE EXPAN{20185
{{EJC{{{{{20186
*
*      EXPAP -- TEST FOR PATTERN MATCH TREE
*
*      EXPAP IS PASSED AN EXPRESSION TREE TO DETERMINE IF IT
*      IS A PATTERN MATCH. THE FOLLOWING ARE RECOGIZED AS
*      MATCHES IN THE CONTEXT OF THIS CALL.
*
*      1)   AN EXPLICIT USE OF BINARY QUESTION MARK
*      2)   A CONCATENATION
*      3)   AN ALTERNATION WHOSE LEFT OPERAND IS A CONCATENATION
*
*      (XR)                  PTR TO EXPAN TREE
*      JSR  EXPAP            CALL TO TEST FOR PATTERN MATCH
*      PPM  LOC              TRANSFER LOC IF NOT A PATTERN MATCH
*      (WA)                  DESTROYED
*      (XR)                  UNCHANGED (IF NOT MATCH)
*      (XR)                  PTR TO BINARY OPERATOR BLK IF MATCH
*
{EXPAP{PRC{25,E{1,1{{ENTRY POINT{20205
{{MOV{11,-(XS){7,XL{{SAVE XL{20206
{{BNE{9,(XR){22,=B_CMT{6,EXPP2{NO MATCH IF NOT COMPLEX{20207
{{MOV{8,WA{13,CMTYP(XR){{ELSE LOAD TYPE CODE{20208
{{BEQ{8,WA{18,=C_CNC{6,EXPP1{CONCATENATION IS A MATCH{20209
{{BEQ{8,WA{18,=C_PMT{6,EXPP1{BINARY QUESTION MARK IS A MATCH{20210
{{BNE{8,WA{18,=C_ALT{6,EXPP2{ELSE NOT MATCH UNLESS ALTERNATION{20211
*
*      HERE FOR ALTERNATION. CHANGE (A B) / C TO A QM (B / C)
*
{{MOV{7,XL{13,CMLOP(XR){{LOAD LEFT OPERAND POINTER{20215
{{BNE{9,(XL){22,=B_CMT{6,EXPP2{NOT MATCH IF LEFT OPND NOT COMPLEX{20216
{{BNE{13,CMTYP(XL){18,=C_CNC{6,EXPP2{NOT MATCH IF LEFT OP NOT CONC{20217
{{MOV{13,CMLOP(XR){13,CMROP(XL){{XR POINTS TO (B / C){20218
{{MOV{13,CMROP(XL){7,XR{{SET XL OPNDS TO A, (B / C){20219
{{MOV{7,XR{7,XL{{POINT TO THIS ALTERED NODE{20220
*
*      EXIT HERE FOR PATTERN MATCH
*
{EXPP1{MOV{7,XL{10,(XS)+{{RESTORE ENTRY XL{20224
{{EXI{{{{GIVE PATTERN MATCH RETURN{20225
*
*      EXIT HERE IF NOT PATTERN MATCH
*
{EXPP2{MOV{7,XL{10,(XS)+{{RESTORE ENTRY XL{20229
{{EXI{1,1{{{GIVE NON-MATCH RETURN{20230
{{ENP{{{{END PROCEDURE EXPAP{20231
{{EJC{{{{{20232
*
*      EXPDM -- DUMP OPERATORS AT CURRENT LEVEL (FOR EXPAN)
*
*      EXPDM USES EXPOP TO CONDENSE ALL OPERATORS AT THIS SYNTAX
*      LEVEL. THE STACK BOTTOM IS RECOGNIZED FROM THE LEVEL
*      VALUE WHICH IS SAVED ON THE TOP OF THE STACK.
*
*      JSR  EXPDM            CALL TO DUMP OPERATORS
*      (XS)                  POPPED AS REQUIRED
*      (XR,WA)               DESTROYED
*
{EXPDM{PRC{25,N{1,0{{ENTRY POINT{20244
{{MOV{3,R_EXS{7,XL{{SAVE XL VALUE{20245
*
*      LOOP TO DUMP OPERATORS
*
{EXDM1{BLE{13,NUM01(XS){18,=NUM05{6,EXDM2{JUMP IF STACK BOTTOM (SAVED LEVEL{20249
{{JSR{6,EXPOP{{{ELSE POP ONE OPERATOR{20250
{{BRN{6,EXDM1{{{AND LOOP BACK{20251
*
*      HERE AFTER POPPING ALL OPERATORS
*
{EXDM2{MOV{7,XL{3,R_EXS{{RESTORE XL{20255
{{ZER{3,R_EXS{{{RELEASE SAVE LOCATION{20256
{{EXI{{{{RETURN TO EXPDM CALLER{20257
{{ENP{{{{END PROCEDURE EXPDM{20258
{{EJC{{{{{20259
*
*      EXPOP-- POP OPERATOR (FOR EXPAN)
*
*      EXPOP IS USED BY THE EXPAN ROUTINE TO CONDENSE ONE
*      OPERATOR FROM THE TOP OF THE SYNTAX STACK. AN APPROPRIATE
*      CMBLK IS BUILT FOR THE OPERATOR (UNARY OR BINARY) AND A
*      POINTER TO THIS CMBLK IS STACKED.
*
*      EXPOP IS ALSO USED BY SCNGF (GOTO FIELD SCAN) PROCEDURE
*
*      JSR  EXPOP            CALL TO POP OPERATOR
*      (XS)                  POPPED APPROPRIATELY
*      (XR,XL,WA)            DESTROYED
*
{EXPOP{PRC{25,N{1,0{{ENTRY POINT{20274
{{MOV{7,XR{13,NUM01(XS){{LOAD OPERATOR DV POINTER{20275
{{BEQ{13,DVLPR(XR){18,=LLUNO{6,EXPO2{JUMP IF UNARY{20276
*
*      HERE FOR BINARY OPERATOR
*
{{MOV{8,WA{19,*CMBS_{{SET SIZE OF BINARY OPERATOR CMBLK{20280
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{20281
{{MOV{13,CMROP(XR){10,(XS)+{{POP AND STORE RIGHT OPERAND PTR{20282
{{MOV{7,XL{10,(XS)+{{POP AND LOAD OPERATOR DV PTR{20283
{{MOV{13,CMLOP(XR){9,(XS){{STORE LEFT OPERAND POINTER{20284
*
*      COMMON EXIT POINT
*
{EXPO1{MOV{9,(XR){22,=B_CMT{{STORE TYPE CODE FOR CMBLK{20288
{{MOV{13,CMTYP(XR){13,DVTYP(XL){{STORE CMBLK NODE TYPE CODE{20289
{{MOV{13,CMOPN(XR){7,XL{{STORE DVPTR (=PTR TO DAC O_XXX){20290
{{MOV{13,CMLEN(XR){8,WA{{STORE CMBLK LENGTH{20291
{{MOV{9,(XS){7,XR{{STORE RESULTING NODE PTR ON STACK{20292
{{EXI{{{{RETURN TO EXPOP CALLER{20293
*
*      HERE FOR UNARY OPERATOR
*
{EXPO2{MOV{8,WA{19,*CMUS_{{SET SIZE OF UNARY OPERATOR CMBLK{20297
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{20298
{{MOV{13,CMROP(XR){10,(XS)+{{POP AND STORE OPERAND POINTER{20299
{{MOV{7,XL{9,(XS){{LOAD OPERATOR DV POINTER{20300
{{BRN{6,EXPO1{{{MERGE BACK TO EXIT{20301
{{ENP{{{{END PROCEDURE EXPOP{20302
{{EJC{{{{{20303
*
*      FILNM -- OBTAIN FILE NAME FROM STATEMENT NUMBER
*
*      FILNM TAKES A STATEMENT NUMBER AND EXAMINES THE FILE NAME
*      TABLE POINTED TO BY R_SFN TO FIND THE NAME OF THE FILE
*      CONTAINING THE GIVEN STATEMENT.  TABLE ENTRIES ARE
*      ARRANGED IN ORDER OF ASCENDING STATEMENT NUMBER (THERE
*      IS ONLY ONE HASH BUCKET IN THIS TABLE).  ELEMENTS ARE
*      ADDED TO THE TABLE EACH TIME THERE IS A CHANGE IN
*      FILE NAME, RECORDING THE THEN CURRENT STATEMENT NUMBER.
*
*      TO FIND THE FILE NAME, THE LINKED LIST OF TEBLKS IS
*      SCANNED FOR AN ELEMENT CONTAINING A SUBSCRIPT (STATEMENT
*      NUMBER) GREATER THAN THE ARGUMENT STATEMENT NUMBER, OR
*      THE END OF CHAIN.  WHEN THIS CONDITION IS MET, THE
*      PREVIOUS TEBLK CONTAINS THE DESIRED FILE NAME AS ITS
*      VALUE ENTRY.
*
*      (WC)                  STATEMENT NUMBER
*      JSR  FILNM            CALL TO OBTAIN FILE NAME
*      (XL)                  FILE NAME (SCBLK)
*      (IA)                  DESTROYED
*
{FILNM{PRC{25,E{1,0{{ENTRY POINT{20328
{{MOV{11,-(XS){8,WB{{PRESERVE WB{20329
{{BZE{8,WC{6,FILN3{{RETURN NULLS IF STNO IS ZERO{20330
{{MOV{7,XL{3,R_SFN{{FILE NAME TABLE{20331
{{BZE{7,XL{6,FILN3{{IF NO TABLE{20332
{{MOV{8,WB{13,TBBUK(XL){{GET BUCKET ENTRY{20333
{{BEQ{8,WB{3,R_SFN{6,FILN3{JUMP IF NO TEBLKS ON CHAIN{20334
{{MOV{11,-(XS){7,XR{{PRESERVE XR{20335
{{MOV{7,XR{8,WB{{PREVIOUS BLOCK POINTER{20336
{{MOV{11,-(XS){8,WC{{PRESERVE STMT NUMBER{20337
*
*      LOOP THROUGH TEBLKS ON HASH CHAIN
*
{FILN1{MOV{7,XL{7,XR{{NEXT ELEMENT TO EXAMINE{20341
{{MOV{7,XR{13,TESUB(XL){{LOAD SUBSCRIPT VALUE (AN ICBLK){20342
{{LDI{13,ICVAL(XR){{{LOAD THE STATEMENT NUMBER{20343
{{MFI{8,WC{{{CONVERT TO ADDRESS CONSTANT{20344
{{BLT{9,(XS){8,WC{6,FILN2{COMPARE ARG WITH TEBLK STMT NUMBER{20345
*
*      HERE IF DESIRED STMT NUMBER IS GE TEBLK STMT NUMBER
*
{{MOV{8,WB{7,XL{{SAVE PREVIOUS ENTRY POINTER{20349
{{MOV{7,XR{13,TENXT(XL){{POINT TO NEXT TEBLK ON CHAIN{20350
{{BNE{7,XR{3,R_SFN{6,FILN1{JUMP IF THERE IS ONE{20351
*
*      HERE IF CHAIN EXHAUSTED OR DESIRED BLOCK FOUND.
*
{FILN2{MOV{7,XL{8,WB{{PREVIOUS TEBLK{20355
{{MOV{7,XL{13,TEVAL(XL){{GET PTR TO FILE NAME SCBLK{20356
{{MOV{8,WC{10,(XS)+{{RESTORE STMT NUMBER{20357
{{MOV{7,XR{10,(XS)+{{RESTORE XR{20358
{{MOV{8,WB{10,(XS)+{{RESTORE WB{20359
{{EXI{{{{{20360
*
*      NO TABLE OR NO TABLE ENTRIES
*
{FILN3{MOV{8,WB{10,(XS)+{{RESTORE WB{20364
{{MOV{7,XL{21,=NULLS{{RETURN NULL STRING{20365
{{EXI{{{{{20366
{{ENP{{{{{20367
{{EJC{{{{{20368
*
*
*      FLSTG -- FOLD STRING TO UPPER CASE
*
*      FLSTG FOLDS A CHARACTER STRING CONTAINING LOWER CASE
*      CHARACCTERS TO ONE CONTAINING UPPER CASE CHARACTERS.
*      FOLDING IS ONLY DONE IF &CASE (KVCAS) IS NOT ZERO.
*
*      (XR)                  STRING ARGUMENT
*      (WA)                  LENGTH OF STRING
*      JSR  FLSTG            CALL TO FOLD STRING
*      (XR)                  RESULT STRING (POSSIBLY ORIGINAL)
*      (WC)                  DESTROYED
*
{FLSTG{PRC{25,E{1,0{{ENTRY POINT{20385
{{BZE{3,KVCAS{6,FST99{{SKIP IF &CASE IS 0{20386
{{MOV{11,-(XS){7,XL{{SAVE XL ACROSS CALL{20387
{{MOV{11,-(XS){7,XR{{SAVE ORIGINAL SCBLK PTR{20388
{{JSR{6,ALOCS{{{ALLOCATE NEW STRING BLOCK{20389
{{MOV{7,XL{9,(XS){{POINT TO ORIGINAL SCBLK{20390
{{MOV{11,-(XS){7,XR{{SAVE POINTER TO NEW SCBLK{20391
{{PLC{7,XL{{{POINT TO ORIGINAL CHARS{20392
{{PSC{7,XR{{{POINT TO NEW CHARS{20393
{{ZER{11,-(XS){{{INIT DID FOLD FLAG{20394
{{LCT{8,WC{8,WC{{LOAD LOOP COUNTER{20395
{FST01{LCH{8,WA{10,(XL)+{{LOAD CHARACTER{20396
{{BLT{8,WA{18,=CH__A{6,FST02{SKIP IF LESS THAN LC A{20397
{{BGT{8,WA{18,=CH___{6,FST02{SKIP IF GREATER THAN LC Z{20398
{{FLC{8,WA{{{FOLD CHARACTER TO UPPER CASE{20399
{{MNZ{9,(XS){{{SET DID FOLD CHARACTER FLAG{20400
{FST02{SCH{8,WA{10,(XR)+{{STORE (POSSIBLY FOLDED) CHARACTER{20401
{{BCT{8,WC{6,FST01{{LOOP THRU ENTIRE STRING{20402
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{20403
{{MOV{7,XR{10,(XS)+{{SEE IF ANY CHANGE{20404
{{BNZ{7,XR{6,FST10{{SKIP IF FOLDING DONE (NO CHANGE){20405
{{MOV{3,DNAMP{10,(XS)+{{DO NOT NEED NEW SCBLK{20406
{{MOV{7,XR{10,(XS)+{{RETURN ORIGINAL SCBLK{20407
{{BRN{6,FST20{{{MERGE BELOW{20408
{FST10{MOV{7,XR{10,(XS)+{{RETURN NEW SCBLK{20409
{{ICA{7,XS{{{THROW AWAY ORIGINAL SCBLK POINTER{20410
{FST20{MOV{8,WA{13,SCLEN(XR){{RELOAD STRING LENGTH{20411
{{MOV{7,XL{10,(XS)+{{RESTORE XL{20412
{FST99{EXI{{{{RETURN{20413
{{ENP{{{{{20414
{{EJC{{{{{20415
*
*      GBCOL -- PERFORM GARBAGE COLLECTION
*
*      GBCOL PERFORMS A GARBAGE COLLECTION ON THE DYNAMIC REGION
*      ALL BLOCKS WHICH ARE NO LONGER IN USE ARE ELIMINATED
*      BY MOVING BLOCKS WHICH ARE IN USE DOWN AND RESETTING
*      DNAMP, THE POINTER TO THE NEXT AVAILABLE LOCATION.
*
*      (WB)                  MOVE OFFSET (SEE BELOW)
*      JSR  GBCOL            CALL TO COLLECT GARBAGE
*      (XR)                  SEDIMENT SIZE AFTER COLLECTION
*
*      THE FOLLOWING CONDITIONS MUST BE MET AT THE TIME WHEN
*      GBCOL IS CALLED.
*
*      1)   ALL POINTERS TO BLOCKS IN THE DYNAMIC AREA MUST BE
*           ACCESSIBLE TO THE GARBAGE COLLECTOR. THIS MEANS
*           THAT THEY MUST OCCUR IN ONE OF THE FOLLOWING.
*
*           A)               MAIN STACK, WITH CURRENT TOP
*                            ELEMENT BEING INDICATED BY XS
*
*           B)               IN RELOCATABLE FIELDS OF VRBLKS.
*
*           C)               IN REGISTER XL AT THE TIME OF CALL
*
*           E)               IN THE SPECIAL REGION OF WORKING
*                            STORAGE WHERE NAMES BEGIN WITH R_.
*
*      2)   ALL POINTERS MUST POINT TO THE START OF BLOCKS WITH
*           THE SOLE EXCEPTION OF THE CONTENTS OF THE CODE
*           POINTER REGISTER WHICH POINTS INTO THE R_COD BLOCK.
*
*      3)   NO LOCATION WHICH APPEARS TO CONTAIN A POINTER
*           INTO THE DYNAMIC REGION MAY OCCUR UNLESS IT IS IN
*           FACT A POINTER TO THE START OF THE BLOCK. HOWEVER
*           POINTERS OUTSIDE THIS AREA MAY OCCUR AND WILL
*           NOT BE CHANGED BY THE GARBAGE COLLECTOR.
*           IT IS ESPECIALLY IMPORTANT TO MAKE SURE THAT XL
*           DOES NOT CONTAIN A GARBAGE VALUE FROM SOME PROCESS
*           CARRIED OUT BEFORE THE CALL TO THE COLLECTOR.
*
*      GBCOL HAS THE CAPABILITY OF MOVING THE FINAL COMPACTED
*      RESULT UP IN MEMORY (WITH ADDRESSES ADJUSTED ACCORDINGLY)
*      THIS IS USED TO ADD SPACE TO THE STATIC REGION. THE
*      ENTRY VALUE OF WB IS THE NUMBER OF BYTES TO MOVE UP.
*      THE CALLER MUST GUARANTEE THAT THERE IS ENOUGH ROOM.
*      FURTHERMORE THE VALUE IN WB IF IT IS NON-ZERO, MUST BE AT
*      LEAST 256 SO THAT THE MWB INSTRUCTION CONDITIONS ARE MET.
{{EJC{{{{{20470
*
*      GBCOL (CONTINUED)
*
*      THE ALGORITHM, WHICH IS A MODIFICATION OF THE LISP-2
*      GARBAGE COLLECTOR DEVISED BY R.DEWAR AND K.BELCHER
*      TAKES THREE PASSES AS FOLLOWS.
*
*      1)   ALL POINTERS IN MEMORY ARE SCANNED AND BLOCKS IN USE
*           DETERMINED FROM THIS SCAN. NOTE THAT THIS PROCEDURE
*           IS RECURSIVE AND USES THE MAIN STACK FOR LINKAGE.
*           THE MARKING PROCESS IS THUS SIMILAR TO THAT USED IN
*           A STANDARD LISP COLLECTOR. HOWEVER THE METHOD OF
*           ACTUALLY MARKING THE BLOCKS IS DIFFERENT.
*
*           THE FIRST FIELD OF A BLOCK NORMALLY CONTAINS A
*           CODE ENTRY POINT POINTER. SUCH AN ENTRY POINTER
*           CAN BE DISTINGUISHED FROM THE ADDRESS OF ANY POINTER
*           TO BE PROCESSED BY THE COLLECTOR. DURING GARBAGE
*           COLLECTION, THIS WORD IS USED TO BUILD A BACK CHAIN
*           OF POINTERS THROUGH FIELDS WHICH POINT TO THE BLOCK.
*           THE END OF THE CHAIN IS MARKED BY THE OCCURENCE
*           OF THE WORD WHICH USED TO BE IN THE FIRST WORD OF
*           THE BLOCK. THIS BACKCHAIN SERVES BOTH AS A MARK
*           INDICATING THAT THE BLOCK IS IN USE AND AS A LIST OF
*           REFERENCES FOR THE RELOCATION PHASE.
*
*      2)   STORAGE IS SCANNED SEQUENTIALLY TO DISCOVER WHICH
*           BLOCKS ARE CURRENTLY IN USE AS INDICATED BY THE
*           PRESENCE OF A BACKCHAIN. TWO POINTERS ARE MAINTAINED
*           ONE SCANS THROUGH LOOKING AT EACH BLOCK. THE OTHER
*           IS INCREMENTED ONLY FOR BLOCKS FOUND TO BE IN USE.
*           IN THIS WAY, THE EVENTUAL LOCATION OF EACH BLOCK CAN
*           BE DETERMINED WITHOUT ACTUALLY MOVING ANY BLOCKS.
*           AS EACH BLOCK WHICH IS IN USE IS PROCESSED, THE BACK
*           CHAIN IS USED TO RESET ALL POINTERS WHICH POINT TO
*           THIS BLOCK TO CONTAIN ITS NEW ADDRESS, I.E. THE
*           ADDRESS IT WILL OCCUPY AFTER THE BLOCKS ARE MOVED.
*           THE FIRST WORD OF THE BLOCK, TAKEN FROM THE END OF
*           THE CHAIN IS RESTORED AT THIS POINT.
*
*           DURING PASS 2, THE COLLECTOR BUILDS BLOCKS WHICH
*           DESCRIBE THE REGIONS OF STORAGE WHICH ARE TO BE
*           MOVED IN THE THIRD PASS. THERE IS ONE DESCRIPTOR FOR
*           EACH CONTIGUOUS SET OF GOOD BLOCKS. THE DESCRIPTOR
*           IS BUILT JUST BEHIND THE BLOCK TO BE MOVED AND
*           CONTAINS A POINTER TO THE NEXT BLOCK AND THE NUMBER
*           OF WORDS TO BE MOVED.
*
*      3)   IN THE THIRD AND FINAL PASS, THE MOVE DESCRIPTOR
*           BLOCKS BUILT IN PASS TWO ARE USED TO ACTUALLY MOVE
*           THE BLOCKS DOWN TO THE BOTTOM OF THE DYNAMIC REGION.
*           THE COLLECTION IS THEN COMPLETE AND THE NEXT
*           AVAILABLE LOCATION POINTER IS RESET.
{{EJC{{{{{20524
*
*      GBCOL (CONTINUED)
*
*      THE GARBAGE COLLECTOR ALSO RECOGNIZES THE CONCEPT OF
*      SEDIMENT.  SEDIMENT IS DEFINED AS LONG-LIVED OBJECTS
*      WHICH PERCIPITATE TO THE BOTTOM OF DYNAMIC STORAGE.
*      MOVING THESE OBJECTS DURING REPEATED COLLECTIONS IS
*      INEFFICIENT.  IT ALSO CONTRIBUTES TO THRASHING ON
*      SYSTEMS WITH VIRTUAL MEMORY.  IN A TYPICAL WORST-CASE
*      SITUATION, THERE MAY BE SEVERAL MEGABYTES OF LIVE OBJECTS
*      IN THE SEDIMENT, AND ONLY A FEW DEAD OBJECTS IN NEED OF
*      COLLECTION.  WITHOUT RECOGNISING SEDIMENT, THE STANDARD
*      COLLECTOR WOULD MOVE THOSE MEGABYTES OF OBJECTS DOWNWARD
*      TO SQUEEZE OUT THE DEAD OBJECTS.  THIS TYPE OF MOVE
*      WOULD RESULT IN EXCESSIVE THRASING FOR VERY LITTLE MEMORY
*      GAIN.
*
*      SCANNING OF BLOCKS IN THE SEDIMENT CANNOT BE AVOIDED
*      ENTIRELY, BECAUSE THESE BLOCKS MAY CONTAIN POINTERS TO
*      LIVE OBJECTS ABOVE THE SEDIMENT.  HOWEVER, SEDIMENT
*      BLOCKS NEED NOT BE LINKED TO A BACK CHAIN AS DESCRIBED
*      IN PASS ONE ABOVE.  SINCE THESE BLOCKS WILL NOT BE MOVED,
*      POINTERS TO THEM DO NOT NEED TO BE ADJUSTED.  ELIMINATING
*      UNNECESSARY BACK CHAIN LINKS INCREASES LOCALITY OF
*      REFERENCE, IMPROVING VIRTUAL MEMORY PERFORMANCE.
*
*      BECAUSE BACK CHAINS ARE USED TO MARK BLOCKS WHOSE CON-
*      TENTS HAVE BEEN PROCESSED, A DIFFERENT MARKING SYSTEM
*      IS NEEDED FOR BLOCKS IN THE SEDIMENT.  SINCE BLOCK TYPE
*      WORDS POINT TO ODD-PARITY ENTRY ADDRESSES, MERELY INCRE-
*      MENTING THE TYPE WORD SERVES TO MARK THE BLOCK AS PRO-
*      CESSED.  DURING PASS THREE, THE TYPE WORDS ARE DECRE-
*      MENTED TO RESTORE THEM TO THEIR ORIGINAL VALUE.
{{EJC{{{{{20568
*
*      GBCOL (CONTINUED)
*
*
*      THE VARIABLE DNAMS CONTAINS THE NUMBER OF BYTES OF MEMORY
*      CURRENTLY IN THE SEDIMENT.  SETTING DNAMS TO ZERO WILL
*      ELIMINATE THE SEDIMENT AND FORCE IT TO BE INCLUDED IN A
*      FULL GARBAGE COLLECTION.  GBCOL RETURNS A SUGGESTED NEW
*      VALUE FOR DNAMS (USUALLY DNAMP-DNAMB) IN XR WHICH THE
*      CALLER CAN STORE IN DNAMS IF IT WISHES TO MAINTAIN THE
*      SEDIMENT.  THAT IS, DATA REMAINING AFTER A GARBAGE
*      COLLECTION IS CONSIDERED TO BE SEDIMENT.  IF ONE ACCEPTS
*      THE COMMON LORE THAT MOST OBJECTS ARE EITHER VERY SHORT-
*      OR VERY LONG-LIVED, THEN THIS NAIVE SETTING OF DNAMS
*      PROBABLY INCLUDES SOME SHORT-LIVED OBJECTS TOWARD THE END
*      OF THE SEDIMENT.
*
*      KNOWING WHEN TO RESET DNAMS TO ZERO TO COLLECT THE SEDI-
*      MENT IS NOT PRECISELY KNOWN.  WE FORCE IT TO ZERO PRIOR
*      TO PRODUCING A DUMP, WHEN GBCOL IS INVOKED BY COLLECT()
*      (SO THAT THE SEDIMENT IS INVISIBLE TO THE USER), WHEN
*      SYSMM IS UNABLE TO OBTAIN ADDITIONAL MEMORY, AND WHEN
*      GBCOL IS CALLED TO RELOCATE THE DYNAMIC AREA UP IN MEMORY
*      (TO MAKE ROOM FOR ENLARGING THE STATIC AREA).  IF THERE
*      ARE NO OTHER RESET SITUATIONS, THIS LEADS TO THE INEXO-
*      RABLE GROWTH OF THE SEDIMENT, POSSIBLE FORCING A MODEST
*      PROGRAM TO BEGIN TO USE VIRTUAL MEMORY THAT IT OTHERWISE
*      WOULD NOT.
*
*      AS WE SCAN SEDIMENT BLOCKS IN PASS THREE, WE MAINTAIN
*      AGGREGATE COUNTS OF THE AMOUNT OF DEAD AND LIVE STORAGE,
*      WHICH IS USED TO DECIDE WHEN TO RESET DNAMS.  WHEN THE
*      RATIO OF FREE STORAGE FOUND IN THE SEDIMENT TO TOTAL
*      SEDIMENT SIZE EXCEEDS A THRESHOLD, THE SEDIMENT IS MARKED
*      FOR COLLECTION ON THE NEXT GBCOL CALL.
*
{{EJC{{{{{20606
*
*      GBCOL (CONTINUED)
*
{GBCOL{PRC{25,E{1,0{{ENTRY POINT{20610
*Z-
{{BNZ{3,DMVCH{6,GBC14{{FAIL IF IN MID-DUMP{20612
{{MNZ{3,GBCFL{{{NOTE GBCOL ENTERED{20613
{{MOV{3,GBSVA{8,WA{{SAVE ENTRY WA{20614
{{MOV{3,GBSVB{8,WB{{SAVE ENTRY WB{20615
{{MOV{3,GBSVC{8,WC{{SAVE ENTRY WC{20616
{{MOV{11,-(XS){7,XL{{SAVE ENTRY XL{20617
{{SCP{8,WA{{{GET CODE POINTER VALUE{20618
{{SUB{8,WA{3,R_COD{{MAKE RELATIVE{20619
{{LCP{8,WA{{{AND RESTORE{20620
{{BZE{8,WB{6,GBC0A{{CHECK THERE IS NO MOVE OFFSET{20622
{{ZER{3,DNAMS{{{COLLECT SEDIMENT IF MUST MOVE IT{20623
{GBC0A{MOV{8,WA{3,DNAMB{{START OF DYNAMIC AREA{20624
{{ADD{8,WA{3,DNAMS{{SIZE OF SEDIMENT{20625
{{MOV{3,GBCSD{8,WA{{FIRST LOCATION PAST SEDIMENT{20626
*
*      INFORM SYSGC THAT COLLECTION TO COMMENCE
*
{{MNZ{7,XR{{{NON-ZERO FLAGS START OF COLLECTION{20639
{{MOV{8,WA{3,DNAMB{{START OF DYNAMIC AREA{20640
{{MOV{8,WB{3,DNAMP{{NEXT AVAILABLE LOCATION{20641
{{MOV{8,WC{3,DNAME{{LAST AVAILABLE LOCATION + 1{20642
{{JSR{6,SYSGC{{{INFORM OF COLLECTION{20643
*
*      PROCESS STACK ENTRIES
*
{{MOV{7,XR{7,XS{{POINT TO STACK FRONT{20648
{{MOV{7,XL{3,STBAS{{POINT PAST END OF STACK{20649
{{BGE{7,XL{7,XR{6,GBC00{OK IF D-STACK{20650
{{MOV{7,XR{7,XL{{REVERSE IF ...{20651
{{MOV{7,XL{7,XS{{... U-STACK{20652
*
*      PROCESS THE STACK
*
{GBC00{JSR{6,GBCPF{{{PROCESS POINTERS ON STACK{20656
*
*      PROCESS SPECIAL WORK LOCATIONS
*
{{MOV{7,XR{20,=R_AAA{{POINT TO START OF RELOCATABLE LOCS{20660
{{MOV{7,XL{20,=R_YYY{{POINT PAST END OF RELOCATABLE LOCS{20661
{{JSR{6,GBCPF{{{PROCESS WORK FIELDS{20662
*
*      PREPARE TO PROCESS VARIABLE BLOCKS
*
{{MOV{8,WA{3,HSHTB{{POINT TO FIRST HASH SLOT POINTER{20666
*
*      LOOP THROUGH HASH SLOTS
*
{GBC01{MOV{7,XL{8,WA{{POINT TO NEXT SLOT{20670
{{ICA{8,WA{{{BUMP BUCKET POINTER{20671
{{MOV{3,GBCNM{8,WA{{SAVE BUCKET POINTER{20672
{{EJC{{{{{20673
*
*      GBCOL (CONTINUED)
*
*      LOOP THROUGH VARIABLES ON ONE HASH CHAIN
*
{GBC02{MOV{7,XR{9,(XL){{LOAD PTR TO NEXT VRBLK{20679
{{BZE{7,XR{6,GBC03{{JUMP IF END OF CHAIN{20680
{{MOV{7,XL{7,XR{{ELSE COPY VRBLK POINTER{20681
{{ADD{7,XR{19,*VRVAL{{POINT TO FIRST RELOC FLD{20682
{{ADD{7,XL{19,*VRNXT{{POINT PAST LAST (AND TO LINK PTR){20683
{{JSR{6,GBCPF{{{PROCESS RELOC FIELDS IN VRBLK{20684
{{BRN{6,GBC02{{{LOOP BACK FOR NEXT BLOCK{20685
*
*      HERE AT END OF ONE HASH CHAIN
*
{GBC03{MOV{8,WA{3,GBCNM{{RESTORE BUCKET POINTER{20689
{{BNE{8,WA{3,HSHTE{6,GBC01{LOOP BACK IF MORE BUCKETS TO GO{20690
{{EJC{{{{{20691
*
*      GBCOL (CONTINUED)
*
*      NOW WE ARE READY TO START PASS TWO. REGISTERS ARE USED
*      AS FOLLOWS IN PASS TWO.
*
*      (XR)                  SCANS THROUGH ALL BLOCKS
*      (WC)                  POINTER TO EVENTUAL LOCATION
*
*      THE MOVE DESCRIPTION BLOCKS BUILT IN THIS PASS HAVE
*      THE FOLLOWING FORMAT.
*
*      WORD 1                POINTER TO NEXT MOVE BLOCK,
*                            ZERO IF END OF CHAIN OF BLOCKS
*
*      WORD 2                LENGTH OF BLOCKS TO BE MOVED IN
*                            BYTES. SET TO THE ADDRESS OF THE
*                            FIRST BYTE WHILE ACTUALLY SCANNING
*                            THE BLOCKS.
*
*      THE FIRST ENTRY ON THIS CHAIN IS A SPECIAL ENTRY
*      CONSISTING OF THE TWO WORDS GBCNM AND GBCNS. AFTER
*      BUILDING THE CHAIN OF MOVE DESCRIPTORS, GBCNM POINTS TO
*      THE FIRST REAL MOVE BLOCK, AND GBCNS IS THE LENGTH OF
*      BLOCKS IN USE AT THE START OF STORAGE WHICH NEED NOT
*      BE MOVED SINCE THEY ARE IN THE CORRECT POSITION.
*
{{MOV{7,XR{3,DNAMB{{POINT TO FIRST BLOCK{20720
{{ZER{8,WB{{{ACCUMULATE SIZE OF DEAD BLOCKS{20721
{GBC04{BEQ{7,XR{3,GBCSD{6,GBC4C{JUMP IF END OF SEDIMENT{20722
{{MOV{8,WA{9,(XR){{ELSE GET FIRST WORD{20723
{{BOD{8,WA{6,GBC4B{{JUMP IF ENTRY POINTER (UNUSED){20725
{{DCV{8,WA{{{RESTORE ENTRY POINTER{20726
{{MOV{9,(XR){8,WA{{RESTORE FIRST WORD{20732
{{JSR{6,BLKLN{{{GET LENGTH OF THIS BLOCK{20733
{{ADD{7,XR{8,WA{{BUMP ACTUAL POINTER{20734
{{BRN{6,GBC04{{{CONTINUE SCAN THROUGH SEDIMENT{20735
*
*      HERE FOR UNUSED SEDIMENT BLOCK
*
{GBC4B{JSR{6,BLKLN{{{GET LENGTH OF THIS BLOCK{20739
{{ADD{7,XR{8,WA{{BUMP ACTUAL POINTER{20740
{{ADD{8,WB{8,WA{{COUNT SIZE OF UNUSED BLOCKS{20741
{{BRN{6,GBC04{{{CONTINUE SCAN THROUGH SEDIMENT{20742
*
*      HERE AT END OF SEDIMENT.  REMEMBER SIZE OF FREE BLOCKS
*      WITHIN THE SEDIMENT.  THIS WILL BE USED LATER TO DECIDE
*      HOW TO SET THE SEDIMENT SIZE RETURNED TO CALLER.
*
*      THEN SCAN REST OF DYNAMIC AREA ABOVE SEDIMENT.
*
*      (WB) = AGGREGATE SIZE OF FREE BLOCKS IN SEDIMENT
*      (XR) = FIRST LOCATION PAST SEDIMENT
*
{GBC4C{MOV{3,GBCSF{8,WB{{SIZE OF SEDIMENT FREE SPACE{20753
{{MOV{8,WC{7,XR{{SET AS FIRST EVENTUAL LOCATION{20757
{{ADD{8,WC{3,GBSVB{{ADD OFFSET FOR EVENTUAL MOVE UP{20758
{{ZER{3,GBCNM{{{CLEAR INITIAL FORWARD POINTER{20759
{{MOV{3,GBCLM{20,=GBCNM{{INITIALIZE PTR TO LAST MOVE BLOCK{20760
{{MOV{3,GBCNS{7,XR{{INITIALIZE FIRST ADDRESS{20761
*
*      LOOP THROUGH A SERIES OF BLOCKS IN USE
*
{GBC05{BEQ{7,XR{3,DNAMP{6,GBC07{JUMP IF END OF USED REGION{20765
{{MOV{8,WA{9,(XR){{ELSE GET FIRST WORD{20766
{{BOD{8,WA{6,GBC07{{JUMP IF ENTRY POINTER (UNUSED){20768
*
*      HERE FOR BLOCK IN USE, LOOP TO RELOCATE REFERENCES
*
{GBC06{MOV{7,XL{8,WA{{COPY POINTER{20776
{{MOV{8,WA{9,(XL){{LOAD FORWARD POINTER{20777
{{MOV{9,(XL){8,WC{{RELOCATE REFERENCE{20778
{{BEV{8,WA{6,GBC06{{LOOP BACK IF NOT END OF CHAIN{20780
{{EJC{{{{{20785
*
*      GBCOL (CONTINUED)
*
*      AT END OF CHAIN, RESTORE FIRST WORD AND BUMP PAST
*
{{MOV{9,(XR){8,WA{{RESTORE FIRST WORD{20791
{{JSR{6,BLKLN{{{GET LENGTH OF THIS BLOCK{20792
{{ADD{7,XR{8,WA{{BUMP ACTUAL POINTER{20793
{{ADD{8,WC{8,WA{{BUMP EVENTUAL POINTER{20794
{{BRN{6,GBC05{{{LOOP BACK FOR NEXT BLOCK{20795
*
*      HERE AT END OF A SERIES OF BLOCKS IN USE
*
{GBC07{MOV{8,WA{7,XR{{COPY POINTER PAST LAST BLOCK{20799
{{MOV{7,XL{3,GBCLM{{POINT TO PREVIOUS MOVE BLOCK{20800
{{SUB{8,WA{13,NUM01(XL){{SUBTRACT STARTING ADDRESS{20801
{{MOV{13,NUM01(XL){8,WA{{STORE LENGTH OF BLOCK TO BE MOVED{20802
*
*      LOOP THROUGH A SERIES OF BLOCKS NOT IN USE
*
{GBC08{BEQ{7,XR{3,DNAMP{6,GBC10{JUMP IF END OF USED REGION{20806
{{MOV{8,WA{9,(XR){{ELSE LOAD FIRST WORD OF NEXT BLOCK{20807
{{BEV{8,WA{6,GBC09{{JUMP IF IN USE{20809
{{JSR{6,BLKLN{{{ELSE GET LENGTH OF NEXT BLOCK{20814
{{ADD{7,XR{8,WA{{PUSH POINTER{20815
{{BRN{6,GBC08{{{AND LOOP BACK{20816
*
*      HERE FOR A BLOCK IN USE AFTER PROCESSING A SERIES OF
*      BLOCKS WHICH WERE NOT IN USE, BUILD NEW MOVE BLOCK.
*
{GBC09{SUB{7,XR{19,*NUM02{{POINT 2 WORDS BEHIND FOR MOVE BLOCK{20821
{{MOV{7,XL{3,GBCLM{{POINT TO PREVIOUS MOVE BLOCK{20822
{{MOV{9,(XL){7,XR{{SET FORWARD PTR IN PREVIOUS BLOCK{20823
{{ZER{9,(XR){{{ZERO FORWARD PTR OF NEW BLOCK{20824
{{MOV{3,GBCLM{7,XR{{REMEMBER ADDRESS OF THIS BLOCK{20825
{{MOV{7,XL{7,XR{{COPY PTR TO MOVE BLOCK{20826
{{ADD{7,XR{19,*NUM02{{POINT BACK TO BLOCK IN USE{20827
{{MOV{13,NUM01(XL){7,XR{{STORE STARTING ADDRESS{20828
{{BRN{6,GBC06{{{JUMP TO PROCESS BLOCK IN USE{20829
{{EJC{{{{{20830
*
*      GBCOL (CONTINUED)
*
*      HERE FOR PASS THREE -- ACTUALLY MOVE THE BLOCKS DOWN
*
*      (XL)                  POINTER TO OLD LOCATION
*      (XR)                  POINTER TO NEW LOCATION
*
{GBC10{MOV{7,XR{3,GBCSD{{POINT TO STORAGE ABOVE SEDIMENT{20840
{{ADD{7,XR{3,GBCNS{{BUMP PAST UNMOVED BLOCKS AT START{20844
*
*      LOOP THROUGH MOVE DESCRIPTORS
*
{GBC11{MOV{7,XL{3,GBCNM{{POINT TO NEXT MOVE BLOCK{20848
{{BZE{7,XL{6,GBC12{{JUMP IF END OF CHAIN{20849
{{MOV{3,GBCNM{10,(XL)+{{MOVE POINTER DOWN CHAIN{20850
{{MOV{8,WA{10,(XL)+{{GET LENGTH TO MOVE{20851
{{MVW{{{{PERFORM MOVE{20852
{{BRN{6,GBC11{{{LOOP BACK{20853
*
*      NOW TEST FOR MOVE UP
*
{GBC12{MOV{3,DNAMP{7,XR{{SET NEXT AVAILABLE LOC PTR{20857
{{MOV{8,WB{3,GBSVB{{RELOAD MOVE OFFSET{20858
{{BZE{8,WB{6,GBC13{{JUMP IF NO MOVE REQUIRED{20859
{{MOV{7,XL{7,XR{{ELSE COPY OLD TOP OF CORE{20860
{{ADD{7,XR{8,WB{{POINT TO NEW TOP OF CORE{20861
{{MOV{3,DNAMP{7,XR{{SAVE NEW TOP OF CORE POINTER{20862
{{MOV{8,WA{7,XL{{COPY OLD TOP{20863
{{SUB{8,WA{3,DNAMB{{MINUS OLD BOTTOM = LENGTH{20864
{{ADD{3,DNAMB{8,WB{{BUMP BOTTOM TO GET NEW VALUE{20865
{{MWB{{{{PERFORM MOVE (BACKWARDS){20866
*
*      MERGE HERE TO EXIT
*
{GBC13{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{20870
{{MOV{3,GBCFL{7,XR{{NOTE EXIT FROM GBCOL{20871
{{MOV{8,WA{3,DNAMB{{START OF DYNAMIC AREA{20873
{{MOV{8,WB{3,DNAMP{{NEXT AVAILABLE LOCATION{20874
{{MOV{8,WC{3,DNAME{{LAST AVAILABLE LOCATION + 1{20875
{{JSR{6,SYSGC{{{INFORM SYSGC OF COMPLETION{20876
*
*      DECIDE WHETHER TO MARK SEDIMENT FOR COLLECTION NEXT TIME.
*      THIS IS DONE BY EXAMINING THE RATIO OF PREVIOUS SEDIMENT
*      FREE SPACE TO THE NEW SEDIMENT SIZE.
*
{{STI{3,GBCIA{{{SAVE IA{20884
{{ZER{7,XR{{{PRESUME NO SEDIMENT WILL REMAIN{20885
{{MOV{8,WB{3,GBCSF{{FREE SPACE IN SEDIMENT{20886
{{BTW{8,WB{{{CONVERT BYTES TO WORDS{20887
{{MTI{8,WB{{{PUT SEDIMENT FREE STORE IN IA{20888
{{MLI{3,GBSED{{{MULTIPLY BY SEDIMENT FACTOR{20889
{{IOV{6,GB13A{{{JUMP IF OVERFLOWED{20890
{{MOV{8,WB{3,DNAMP{{END OF DYNAMIC AREA IN USE{20891
{{SUB{8,WB{3,DNAMB{{MINUS START IS SEDIMENT REMAINING{20892
{{BTW{8,WB{{{CONVERT TO WORDS{20893
{{MOV{3,GBCSF{8,WB{{STORE IT{20894
{{SBI{3,GBCSF{{{SUBTRACT FROM SCALED UP FREE STORE{20895
{{IGT{6,GB13A{{{JUMP IF LARGE FREE STORE IN SEDIMNT{20896
{{MOV{7,XR{3,DNAMP{{BELOW THRESHOLD, RETURN SEDIMENT{20897
{{SUB{7,XR{3,DNAMB{{FOR USE BY CALLER{20898
{GB13A{LDI{3,GBCIA{{{RESTORE IA{20899
{{MOV{8,WA{3,GBSVA{{RESTORE WA{20901
{{MOV{8,WB{3,GBSVB{{RESTORE WB{20902
{{SCP{8,WC{{{GET CODE POINTER{20903
{{ADD{8,WC{3,R_COD{{MAKE ABSOLUTE AGAIN{20904
{{LCP{8,WC{{{AND REPLACE ABSOLUTE VALUE{20905
{{MOV{8,WC{3,GBSVC{{RESTORE WC{20906
{{MOV{7,XL{10,(XS)+{{RESTORE ENTRY XL{20907
{{ICV{3,GBCNT{{{INCREMENT COUNT OF COLLECTIONS{20908
{{EXI{{{{EXIT TO GBCOL CALLER{20909
*
*      GARBAGE COLLECTION NOT ALLOWED WHILST DUMPING
*
{GBC14{ICV{3,ERRFT{{{FATAL ERROR{20913
{{ERB{1,250{26,Insufficient memory to complete dump{{{20914
{{ENP{{{{END PROCEDURE GBCOL{20915
{{EJC{{{{{20916
*
*      GBCPF -- PROCESS FIELDS FOR GARBAGE COLLECTOR
*
*      THIS PROCEDURE IS USED BY THE GARBAGE COLLECTOR TO
*      PROCESS FIELDS IN PASS ONE. SEE GBCOL FOR FULL DETAILS.
*
*      (XR)                  PTR TO FIRST LOCATION TO PROCESS
*      (XL)                  PTR PAST LAST LOCATION TO PROCESS
*      JSR  GBCPF            CALL TO PROCESS FIELDS
*      (XR,WA,WB,WC,IA)      DESTROYED
*
*      NOTE THAT ALTHOUGH THIS PROCEDURE USES A RECURSIVE
*      APPROACH, IT CONTROLS ITS OWN STACK AND IS NOT RECURSIVE.
*
{GBCPF{PRC{25,E{1,0{{ENTRY POINT{20931
{{ZER{11,-(XS){{{SET ZERO TO MARK BOTTOM OF STACK{20932
{{MOV{11,-(XS){7,XL{{SAVE END POINTER{20933
*
*      MERGE HERE TO GO DOWN A LEVEL AND START A NEW LOOP
*
*      1(XS)                 NEXT LVL FIELD PTR (0 AT OUTER LVL)
*      0(XS)                 PTR PAST LAST FIELD TO PROCESS
*      (XR)                  PTR TO FIRST FIELD TO PROCESS
*
*      LOOP TO PROCESS SUCCESSIVE FIELDS
*
{GPF01{MOV{7,XL{9,(XR){{LOAD FIELD CONTENTS{20943
{{MOV{8,WC{7,XR{{SAVE FIELD POINTER{20944
{{BLT{7,XL{3,DNAMB{6,GPF2A{JUMP IF NOT PTR INTO DYNAMIC AREA{20948
{{BGE{7,XL{3,DNAMP{6,GPF2A{JUMP IF NOT PTR INTO DYNAMIC AREA{20949
*
*      HERE WE HAVE A PTR TO A BLOCK IN THE DYNAMIC AREA.
*      LINK THIS FIELD ONTO THE REFERENCE BACKCHAIN.
*
{{MOV{8,WA{9,(XL){{LOAD PTR TO CHAIN (OR ENTRY PTR){20954
{{BLT{7,XL{3,GBCSD{6,GPF1A{DO NOT CHAIN IF WITHIN SEDIMENT{20956
{{MOV{9,(XL){7,XR{{SET THIS FIELD AS NEW HEAD OF CHAIN{20958
{{MOV{9,(XR){8,WA{{SET FORWARD POINTER{20959
*
*      NOW SEE IF THIS BLOCK HAS BEEN PROCESSED BEFORE
*
{GPF1A{BOD{8,WA{6,GPF03{{JUMP IF NOT ALREADY PROCESSED{20964
*
*      HERE TO RESTORE POINTER IN XR TO FIELD JUST PROCESSED
*
{GPF02{MOV{7,XR{8,WC{{RESTORE FIELD POINTER{20972
*
*      HERE TO MOVE TO NEXT FIELD
*
{GPF2A{ICA{7,XR{{{BUMP TO NEXT FIELD{20976
{{BNE{7,XR{9,(XS){6,GPF01{LOOP BACK IF MORE TO GO{20977
{{EJC{{{{{20978
*
*      GBCPF (CONTINUED)
*
*      HERE WE POP UP A LEVEL AFTER FINISHING A BLOCK
*
{{MOV{7,XL{10,(XS)+{{RESTORE POINTER PAST END{20984
{{MOV{7,XR{10,(XS)+{{RESTORE BLOCK POINTER{20985
{{BNZ{7,XR{6,GPF2A{{CONTINUE LOOP UNLESS OUTER LEVL{20986
{{EXI{{{{RETURN TO CALLER IF OUTER LEVEL{20987
*
*      HERE TO PROCESS AN ACTIVE BLOCK WHICH HAS NOT BEEN DONE
*
*
*      SINCE SEDIMENT BLOCKS ARE NOT MARKED BY PUTTING THEM ON
*      THE BACK CHAIN, THEY MUST BE EXPLICITLY MARKED IN ANOTHER
*      MANNER.  IF ODD PARITY ENTRY POINTS ARE PRESENT, MARK BY
*      TEMPORARILY CONVERTING TO EVEN PARITY.  IF ODD PARITY NOT
*      AVAILABLE, THE ENTRY POINT IS ADJUSTED BY THE VALUE IN
*      GBCMK.
*
{GPF03{BGE{7,XL{3,GBCSD{6,GPF3A{IF NOT WITHIN SEDIMENT{21000
{{ICV{9,(XL){{{MARK BY MAKING ENTRY POINT EVEN{21002
{GPF3A{MOV{7,XR{7,XL{{COPY BLOCK POINTER{21006
{{MOV{7,XL{8,WA{{COPY FIRST WORD OF BLOCK{21010
{{LEI{7,XL{{{LOAD ENTRY POINT ID (BL_XX){21011
*
*      BLOCK TYPE SWITCH. NOTE THAT BLOCKS WITH NO RELOCATABLE
*      FIELDS JUST RETURN TO GPF02 HERE TO CONTINUE TO NEXT FLD.
*
{{BSW{7,XL{2,BL___{{SWITCH ON BLOCK TYPE{21016
{{IFF{2,BL_AR{6,GPF06{{ARBLK{21054
{{IFF{2,BL_CD{6,GPF19{{CDBLK{21054
{{IFF{2,BL_EX{6,GPF17{{EXBLK{21054
{{IFF{2,BL_IC{6,GPF02{{ICBLK{21054
{{IFF{2,BL_NM{6,GPF10{{NMBLK{21054
{{IFF{2,BL_P0{6,GPF10{{P0BLK{21054
{{IFF{2,BL_P1{6,GPF12{{P1BLK{21054
{{IFF{2,BL_P2{6,GPF12{{P2BLK{21054
{{IFF{2,BL_RC{6,GPF02{{RCBLK{21054
{{IFF{2,BL_SC{6,GPF02{{SCBLK{21054
{{IFF{2,BL_SE{6,GPF02{{SEBLK{21054
{{IFF{2,BL_TB{6,GPF08{{TBBLK{21054
{{IFF{2,BL_VC{6,GPF08{{VCBLK{21054
{{IFF{2,BL_XN{6,GPF02{{XNBLK{21054
{{IFF{2,BL_XR{6,GPF09{{XRBLK{21054
{{IFF{2,BL_BC{6,GPF02{{BCBLK - DUMMY TO FILL OUT IFFS{21054
{{IFF{2,BL_PD{6,GPF13{{PDBLK{21054
{{IFF{2,BL_TR{6,GPF16{{TRBLK{21054
{{IFF{2,BL_BF{6,GPF02{{BFBLK{21054
{{IFF{2,BL_CC{6,GPF07{{CCBLK{21054
{{IFF{2,BL_CM{6,GPF04{{CMBLK{21054
{{IFF{2,BL_CT{6,GPF02{{CTBLK{21054
{{IFF{2,BL_DF{6,GPF02{{DFBLK{21054
{{IFF{2,BL_EF{6,GPF02{{EFBLK{21054
{{IFF{2,BL_EV{6,GPF10{{EVBLK{21054
{{IFF{2,BL_FF{6,GPF11{{FFBLK{21054
{{IFF{2,BL_KV{6,GPF02{{KVBLK{21054
{{IFF{2,BL_PF{6,GPF14{{PFBLK{21054
{{IFF{2,BL_TE{6,GPF15{{TEBLK{21054
{{ESW{{{{END OF JUMP TABLE{21054
{{EJC{{{{{21055
*
*      GBCPF (CONTINUED)
*
*      CMBLK
*
{GPF04{MOV{8,WA{13,CMLEN(XR){{LOAD LENGTH{21061
{{MOV{8,WB{19,*CMTYP{{SET OFFSET{21062
*
*      HERE TO PUSH DOWN TO NEW LEVEL
*
*      (WC)                  FIELD PTR AT PREVIOUS LEVEL
*      (XR)                  PTR TO NEW BLOCK
*      (WA)                  LENGTH (RELOC FLDS + FLDS AT START)
*      (WB)                  OFFSET TO FIRST RELOC FIELD
*
{GPF05{ADD{8,WA{7,XR{{POINT PAST LAST RELOC FIELD{21071
{{ADD{7,XR{8,WB{{POINT TO FIRST RELOC FIELD{21072
{{MOV{11,-(XS){8,WC{{STACK OLD FIELD POINTER{21073
{{MOV{11,-(XS){8,WA{{STACK NEW LIMIT POINTER{21074
{{CHK{{{{CHECK FOR STACK OVERFLOW{21075
{{BRN{6,GPF01{{{IF OK, BACK TO PROCESS{21076
*
*      ARBLK
*
{GPF06{MOV{8,WA{13,ARLEN(XR){{LOAD LENGTH{21080
{{MOV{8,WB{13,AROFS(XR){{SET OFFSET TO 1ST RELOC FLD (ARPRO){21081
{{BRN{6,GPF05{{{ALL SET{21082
*
*      CCBLK
*
{GPF07{MOV{8,WA{13,CCUSE(XR){{SET LENGTH IN USE{21086
{{MOV{8,WB{19,*CCUSE{{1ST WORD (MAKE SURE AT LEAST ONE){21087
{{BRN{6,GPF05{{{ALL SET{21088
{{EJC{{{{{21089
*
*      GBCPF (CONTINUED)
*
*      CDBLK
*
{GPF19{MOV{8,WA{13,CDLEN(XR){{LOAD LENGTH{21096
{{MOV{8,WB{19,*CDFAL{{SET OFFSET{21097
{{BRN{6,GPF05{{{JUMP BACK{21098
*
*      TBBLK, VCBLK
*
{GPF08{MOV{8,WA{13,OFFS2(XR){{LOAD LENGTH{21105
{{MOV{8,WB{19,*OFFS3{{SET OFFSET{21106
{{BRN{6,GPF05{{{JUMP BACK{21107
*
*      XRBLK
*
{GPF09{MOV{8,WA{13,XRLEN(XR){{LOAD LENGTH{21111
{{MOV{8,WB{19,*XRPTR{{SET OFFSET{21112
{{BRN{6,GPF05{{{JUMP BACK{21113
*
*      EVBLK, NMBLK, P0BLK
*
{GPF10{MOV{8,WA{19,*OFFS2{{POINT PAST SECOND FIELD{21117
{{MOV{8,WB{19,*OFFS1{{OFFSET IS ONE (ONLY RELOC FLD IS 2){21118
{{BRN{6,GPF05{{{ALL SET{21119
*
*      FFBLK
*
{GPF11{MOV{8,WA{19,*FFOFS{{SET LENGTH{21123
{{MOV{8,WB{19,*FFNXT{{SET OFFSET{21124
{{BRN{6,GPF05{{{ALL SET{21125
*
*      P1BLK, P2BLK
*
{GPF12{MOV{8,WA{19,*PARM2{{LENGTH (PARM2 IS NON-RELOCATABLE){21129
{{MOV{8,WB{19,*PTHEN{{SET OFFSET{21130
{{BRN{6,GPF05{{{ALL SET{21131
{{EJC{{{{{21132
*
*      GBCPF (CONTINUED)
*
*      PDBLK
*
{GPF13{MOV{7,XL{13,PDDFP(XR){{LOAD PTR TO DFBLK{21138
{{MOV{8,WA{13,DFPDL(XL){{GET PDBLK LENGTH{21139
{{MOV{8,WB{19,*PDFLD{{SET OFFSET{21140
{{BRN{6,GPF05{{{ALL SET{21141
*
*      PFBLK
*
{GPF14{MOV{8,WA{19,*PFARG{{LENGTH PAST LAST RELOC{21145
{{MOV{8,WB{19,*PFCOD{{OFFSET TO FIRST RELOC{21146
{{BRN{6,GPF05{{{ALL SET{21147
*
*      TEBLK
*
{GPF15{MOV{8,WA{19,*TESI_{{SET LENGTH{21151
{{MOV{8,WB{19,*TESUB{{AND OFFSET{21152
{{BRN{6,GPF05{{{ALL SET{21153
*
*      TRBLK
*
{GPF16{MOV{8,WA{19,*TRSI_{{SET LENGTH{21157
{{MOV{8,WB{19,*TRVAL{{AND OFFSET{21158
{{BRN{6,GPF05{{{ALL SET{21159
*
*      EXBLK
*
{GPF17{MOV{8,WA{13,EXLEN(XR){{LOAD LENGTH{21163
{{MOV{8,WB{19,*EXFLC{{SET OFFSET{21164
{{BRN{6,GPF05{{{JUMP BACK{21165
{{ENP{{{{END PROCEDURE GBCPF{21175
{{EJC{{{{{21176
*Z+
*
*      GTARR -- GET ARRAY
*
*      GTARR IS PASSED AN OBJECT AND RETURNS AN ARRAY IF POSSIBL
*
*      (XR)                  VALUE TO BE CONVERTED
*      (WA)                  0 TO PLACE TABLE ADDRESSES IN ARRAY
*                            NON-ZERO FOR KEYS/VALUES IN ARRAY
*      JSR  GTARR            CALL TO GET ARRAY
*      PPM  LOC              TRANSFER LOC FOR ALL NULL TABLE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  RESULTING ARRAY
*      (XL,WA,WB,WC)         DESTROYED
*
{GTARR{PRC{25,E{1,2{{ENTRY POINT{21192
{{MOV{3,GTAWA{8,WA{{SAVE WA INDICATOR{21193
{{MOV{8,WA{9,(XR){{LOAD TYPE WORD{21194
{{BEQ{8,WA{22,=B_ART{6,GTAR8{EXIT IF ALREADY AN ARRAY{21195
{{BEQ{8,WA{22,=B_VCT{6,GTAR8{EXIT IF ALREADY AN ARRAY{21196
{{BNE{8,WA{22,=B_TBT{6,GTA9A{ELSE FAIL IF NOT A TABLE (SGD02){21197
*
*      HERE WE CONVERT A TABLE TO AN ARRAY
*
{{MOV{11,-(XS){7,XR{{REPLACE TBBLK POINTER ON STACK{21201
{{ZER{7,XR{{{SIGNAL FIRST PASS{21202
{{ZER{8,WB{{{ZERO NON-NULL ELEMENT COUNT{21203
*
*      THE FOLLOWING CODE IS EXECUTED TWICE. ON THE FIRST PASS,
*      SIGNALLED BY XR=0, THE NUMBER OF NON-NULL ELEMENTS IN
*      THE TABLE IS COUNTED IN WB. IN THE SECOND PASS, WHERE
*      XR IS A POINTER INTO THE ARBLK, THE NAME AND VALUE ARE
*      ENTERED INTO THE CURRENT ARBLK LOCATION PROVIDED GTAWA
*      IS NON-ZERO.  IF GTAWA IS ZERO, THE ADDRESS OF THE TEBLK
*      IS ENTERED INTO THE ARBLK TWICE (C3.762).
*
{GTAR1{MOV{7,XL{9,(XS){{POINT TO TABLE{21213
{{ADD{7,XL{13,TBLEN(XL){{POINT PAST LAST BUCKET{21214
{{SUB{7,XL{19,*TBBUK{{SET FIRST BUCKET OFFSET{21215
{{MOV{8,WA{7,XL{{COPY ADJUSTED POINTER{21216
*
*      LOOP THROUGH BUCKETS IN TABLE BLOCK
*      NEXT THREE LINES OF CODE RELY ON TENXT HAVING A VALUE
*      1 LESS THAN TBBUK.
*
{GTAR2{MOV{7,XL{8,WA{{COPY BUCKET POINTER{21222
{{DCA{8,WA{{{DECREMENT BUCKET POINTER{21223
*
*      LOOP THROUGH TEBLKS ON ONE BUCKET CHAIN
*
{GTAR3{MOV{7,XL{13,TENXT(XL){{POINT TO NEXT TEBLK{21227
{{BEQ{7,XL{9,(XS){6,GTAR6{JUMP IF CHAIN END (TBBLK PTR){21228
{{MOV{3,CNVTP{7,XL{{ELSE SAVE TEBLK POINTER{21229
*
*      LOOP TO FIND VALUE DOWN TRBLK CHAIN
*
{GTAR4{MOV{7,XL{13,TEVAL(XL){{LOAD VALUE{21233
{{BEQ{9,(XL){22,=B_TRT{6,GTAR4{LOOP TILL VALUE FOUND{21234
{{MOV{8,WC{7,XL{{COPY VALUE{21235
{{MOV{7,XL{3,CNVTP{{RESTORE TEBLK POINTER{21236
{{EJC{{{{{21237
*
*      GTARR (CONTINUED)
*
*      NOW CHECK FOR NULL AND TEST CASES
*
{{BEQ{8,WC{21,=NULLS{6,GTAR3{LOOP BACK TO IGNORE NULL VALUE{21243
{{BNZ{7,XR{6,GTAR5{{JUMP IF SECOND PASS{21244
{{ICV{8,WB{{{FOR THE FIRST PASS, BUMP COUNT{21245
{{BRN{6,GTAR3{{{AND LOOP BACK FOR NEXT TEBLK{21246
*
*      HERE IN SECOND PASS
*
{GTAR5{BZE{3,GTAWA{6,GTA5A{{JUMP IF ADDRESS WANTED{21250
{{MOV{10,(XR)+{13,TESUB(XL){{STORE SUBSCRIPT NAME{21251
{{MOV{10,(XR)+{8,WC{{STORE VALUE IN ARBLK{21252
{{BRN{6,GTAR3{{{LOOP BACK FOR NEXT TEBLK{21253
*
*      HERE TO RECORD TEBLK ADDRESS IN ARBLK.  THIS ALLOWS
*      A SORT ROUTINE TO SORT BY ASCENDING ADDRESS.
*
{GTA5A{MOV{10,(XR)+{7,XL{{STORE TEBLK ADDRESS IN NAME{21258
{{MOV{10,(XR)+{7,XL{{AND VALUE SLOTS{21259
{{BRN{6,GTAR3{{{LOOP BACK FOR NEXT TEBLK{21260
*
*      HERE AFTER SCANNING TEBLKS ON ONE CHAIN
*
{GTAR6{BNE{8,WA{9,(XS){6,GTAR2{LOOP BACK IF MORE BUCKETS TO GO{21264
{{BNZ{7,XR{6,GTAR7{{ELSE JUMP IF SECOND PASS{21265
*
*      HERE AFTER COUNTING NON-NULL ELEMENTS
*
{{BZE{8,WB{6,GTAR9{{FAIL IF NO NON-NULL ELEMENTS{21269
{{MOV{8,WA{8,WB{{ELSE COPY COUNT{21270
{{ADD{8,WA{8,WB{{DOUBLE (TWO WORDS/ELEMENT){21271
{{ADD{8,WA{18,=ARVL2{{ADD SPACE FOR STANDARD FIELDS{21272
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{21273
{{BGT{8,WA{3,MXLEN{6,GTA9B{ERROR IF TOO LONG FOR ARRAY{21274
{{JSR{6,ALLOC{{{ELSE ALLOCATE SPACE FOR ARBLK{21275
{{MOV{9,(XR){22,=B_ART{{STORE TYPE WORD{21276
{{ZER{13,IDVAL(XR){{{ZERO ID FOR THE MOMENT{21277
{{MOV{13,ARLEN(XR){8,WA{{STORE LENGTH{21278
{{MOV{13,ARNDM(XR){18,=NUM02{{SET DIMENSIONS = 2{21279
{{LDI{4,INTV1{{{GET INTEGER ONE{21280
{{STI{13,ARLBD(XR){{{STORE AS LBD 1{21281
{{STI{13,ARLB2(XR){{{STORE AS LBD 2{21282
{{LDI{4,INTV2{{{LOAD INTEGER TWO{21283
{{STI{13,ARDM2(XR){{{STORE AS DIM 2{21284
{{MTI{8,WB{{{GET ELEMENT COUNT AS INTEGER{21285
{{STI{13,ARDIM(XR){{{STORE AS DIM 1{21286
{{ZER{13,ARPR2(XR){{{ZERO PROTOTYPE FIELD FOR NOW{21287
{{MOV{13,AROFS(XR){19,*ARPR2{{SET OFFSET FIELD (SIGNAL PASS 2){21288
{{MOV{8,WB{7,XR{{SAVE ARBLK POINTER{21289
{{ADD{7,XR{19,*ARVL2{{POINT TO FIRST ELEMENT LOCATION{21290
{{BRN{6,GTAR1{{{JUMP BACK TO FILL IN ELEMENTS{21291
{{EJC{{{{{21292
*
*      GTARR (CONTINUED)
*
*      HERE AFTER FILLING IN ELEMENT VALUES
*
{GTAR7{MOV{7,XR{8,WB{{RESTORE ARBLK POINTER{21298
{{MOV{9,(XS){8,WB{{STORE AS RESULT{21299
*
*      NOW WE NEED THE ARRAY PROTOTYPE WHICH IS OF THE FORM NN,2
*      THIS IS OBTAINED BY BUILDING THE STRING FOR NN02 AND
*      CHANGING THE ZERO TO A COMMA BEFORE STORING IT.
*
{{LDI{13,ARDIM(XR){{{GET NUMBER OF ELEMENTS (NN){21305
{{MLI{4,INTVH{{{MULTIPLY BY 100{21306
{{ADI{4,INTV2{{{ADD 2 (NN02){21307
{{JSR{6,ICBLD{{{BUILD INTEGER{21308
{{MOV{11,-(XS){7,XR{{STORE PTR FOR GTSTG{21309
{{JSR{6,GTSTG{{{CONVERT TO STRING{21310
{{PPM{{{{CONVERT FAIL IS IMPOSSIBLE{21311
{{MOV{7,XL{7,XR{{COPY STRING POINTER{21312
{{MOV{7,XR{10,(XS)+{{RELOAD ARBLK POINTER{21313
{{MOV{13,ARPR2(XR){7,XL{{STORE PROTOTYPE PTR (NN02){21314
{{SUB{8,WA{18,=NUM02{{ADJUST LENGTH TO POINT TO ZERO{21315
{{PSC{7,XL{8,WA{{POINT TO ZERO{21316
{{MOV{8,WB{18,=CH_CM{{LOAD A COMMA{21317
{{SCH{8,WB{9,(XL){{STORE A COMMA OVER THE ZERO{21318
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{21319
*
*      NORMAL RETURN
*
{GTAR8{EXI{{{{RETURN TO CALLER{21323
*
*      NULL TABLE NON-CONVERSION RETURN
*
{GTAR9{MOV{7,XR{10,(XS)+{{RESTORE STACK FOR CONV ERR (SGD02){21327
{{EXI{1,1{{{RETURN{21328
*
*      IMPOSSIBLE CONVERSION RETURN
*
{GTA9A{EXI{1,2{{{RETURN{21332
*
*      ARRAY SIZE TOO LARGE
*
{GTA9B{ERB{1,260{26,Conversion array size exceeds maximum permitted{{{21336
{{ENP{{{{PROCEDURE GTARR{21337
{{EJC{{{{{21338
*
*      GTCOD -- CONVERT TO CODE
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTCOD            CALL TO CONVERT TO CODE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING CDBLK
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      IF A SPITBOL ERROR OCCURS DURING COMPILATION OR PRE-
*      EVALUATION, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*
{GTCOD{PRC{25,E{1,1{{ENTRY POINT{21352
{{BEQ{9,(XR){22,=B_CDS{6,GTCD1{JUMP IF ALREADY CODE{21353
{{BEQ{9,(XR){22,=B_CDC{6,GTCD1{JUMP IF ALREADY CODE{21354
*
*      HERE WE MUST GENERATE A CDBLK BY COMPILATION
*
{{MOV{11,-(XS){7,XR{{STACK ARGUMENT FOR GTSTG{21358
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{21359
{{PPM{6,GTCD2{{{JUMP IF NON-CONVERTIBLE{21360
{{MOV{3,GTCEF{3,FLPTR{{SAVE FAIL PTR IN CASE OF ERROR{21361
{{MOV{3,R_GTC{3,R_COD{{ALSO SAVE CODE PTR{21362
{{MOV{3,R_CIM{7,XR{{ELSE SET IMAGE POINTER{21363
{{MOV{3,SCNIL{8,WA{{SET IMAGE LENGTH{21364
{{ZER{3,SCNPT{{{SET SCAN POINTER{21365
{{MOV{3,STAGE{18,=STGXC{{SET STAGE FOR EXECUTE COMPILE{21366
{{MOV{3,LSTSN{3,CMPSN{{IN CASE LISTR CALLED{21367
{{ICV{3,CMPLN{{{BUMP LINE NUMBER{21369
{{JSR{6,CMPIL{{{COMPILE STRING{21371
{{MOV{3,STAGE{18,=STGXT{{RESET STAGE FOR EXECUTE TIME{21372
{{ZER{3,R_CIM{{{CLEAR IMAGE{21373
*
*      MERGE HERE IF NO CONVERT REQUIRED
*
{GTCD1{EXI{{{{GIVE NORMAL GTCOD RETURN{21377
*
*      HERE IF UNCONVERTIBLE
*
{GTCD2{EXI{1,1{{{GIVE ERROR RETURN{21381
{{ENP{{{{END PROCEDURE GTCOD{21382
{{EJC{{{{{21383
*
*      GTEXP -- CONVERT TO EXPRESSION
*
*      (WB)                  0 IF BY VALUE, 1 IF BY NAME
*      (XR)                  INPUT VALUE TO BE CONVERTED
*      JSR  GTEXP            CALL TO CONVERT TO EXPRESSION
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULT EXBLK OR SEBLK
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      IF A SPITBOL ERROR OCCURS DURING COMPILATION OR PRE-
*      EVALUATION, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*
{GTEXP{PRC{25,E{1,1{{ENTRY POINT{21400
{{BLO{9,(XR){22,=B_E__{6,GTEX1{JUMP IF ALREADY AN EXPRESSION{21401
{{MOV{11,-(XS){7,XR{{STORE ARGUMENT FOR GTSTG{21402
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{21403
{{PPM{6,GTEX2{{{JUMP IF UNCONVERTIBLE{21404
*
*      CHECK THE LAST CHARACTER OF THE STRING FOR COLON OR
*      SEMICOLON.  THESE CHARACTERS CAN LEGITIMATELY END AN
*      EXPRESSION IN OPEN CODE, SO EXPAN WILL NOT DETECT THEM
*      AS ERRORS, BUT THEY ARE INVALID AS TERMINATORS FOR A
*      STRING THAT IS BEING CONVERTED TO EXPRESSION FORM.
*
{{MOV{7,XL{7,XR{{COPY INPUT STRING POINTER{21412
{{PLC{7,XL{8,WA{{POINT ONE PAST THE STRING END{21413
{{LCH{7,XL{11,-(XL){{FETCH THE LAST CHARACTER{21414
{{BEQ{7,XL{18,=CH_CL{6,GTEX2{ERROR IF IT IS A SEMICOLON{21415
{{BEQ{7,XL{18,=CH_SM{6,GTEX2{OR IF IT IS A COLON{21416
*
*      HERE WE CONVERT A STRING BY COMPILATION
*
{{MOV{3,R_CIM{7,XR{{SET INPUT IMAGE POINTER{21420
{{ZER{3,SCNPT{{{SET SCAN POINTER{21421
{{MOV{3,SCNIL{8,WA{{SET INPUT IMAGE LENGTH{21422
{{MOV{11,-(XS){8,WB{{SAVE VALUE/NAME FLAG{21424
{{ZER{8,WB{{{SET CODE FOR NORMAL SCAN{21426
{{MOV{3,GTCEF{3,FLPTR{{SAVE FAIL PTR IN CASE OF ERROR{21427
{{MOV{3,R_GTC{3,R_COD{{ALSO SAVE CODE PTR{21428
{{MOV{3,STAGE{18,=STGEV{{ADJUST STAGE FOR COMPILE{21429
{{MOV{3,SCNTP{18,=T_UOK{{INDICATE UNARY OPERATOR ACCEPTABLE{21430
{{JSR{6,EXPAN{{{BUILD TREE FOR EXPRESSION{21431
{{ZER{3,SCNRS{{{RESET RESCAN FLAG{21432
{{MOV{8,WA{10,(XS)+{{RESTORE VALUE/NAME FLAG{21434
{{BNE{3,SCNPT{3,SCNIL{6,GTEX2{ERROR IF NOT END OF IMAGE{21436
{{ZER{8,WB{{{SET OK VALUE FOR CDGEX CALL{21437
{{MOV{7,XL{7,XR{{COPY TREE POINTER{21438
{{JSR{6,CDGEX{{{BUILD EXPRESSION BLOCK{21439
{{ZER{3,R_CIM{{{CLEAR POINTER{21440
{{MOV{3,STAGE{18,=STGXT{{RESTORE STAGE FOR EXECUTE TIME{21441
*
*      MERGE HERE IF NO CONVERSION REQUIRED
*
{GTEX1{EXI{{{{RETURN TO GTEXP CALLER{21445
*
*      HERE IF UNCONVERTIBLE
*
{GTEX2{EXI{1,1{{{TAKE ERROR EXIT{21449
{{ENP{{{{END PROCEDURE GTEXP{21450
{{EJC{{{{{21451
*
*      GTINT -- GET INTEGER VALUE
*
*      GTINT IS PASSED AN OBJECT AND RETURNS AN INTEGER AFTER
*      PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  VALUE TO BE CONVERTED
*      JSR  GTINT            CALL TO CONVERT TO INTEGER
*      PPM  LOC              TRANSFER LOC FOR CONVERT IMPOSSIBLE
*      (XR)                  RESULTING INTEGER
*      (WC,RA)               DESTROYED
*      (WA,WB)               DESTROYED (ONLY ON CONVERSION ERR)
*      (XR)                  UNCHANGED (ON CONVERT ERROR)
*
{GTINT{PRC{25,E{1,1{{ENTRY POINT{21466
{{BEQ{9,(XR){22,=B_ICL{6,GTIN2{JUMP IF ALREADY AN INTEGER{21467
{{MOV{3,GTINA{8,WA{{ELSE SAVE WA{21468
{{MOV{3,GTINB{8,WB{{SAVE WB{21469
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{21470
{{PPM{6,GTIN3{{{JUMP IF UNCONVERTIBLE{21471
{{BEQ{8,WA{22,=B_ICL{6,GTIN1{JUMP IF INTEGER{21474
*
*      HERE WE CONVERT A REAL TO INTEGER
*
{{LDR{13,RCVAL(XR){{{LOAD REAL VALUE{21478
{{RTI{6,GTIN3{{{CONVERT TO INTEGER (ERR IF OVFLOW){21479
{{JSR{6,ICBLD{{{IF OK BUILD ICBLK{21480
*
*      HERE AFTER SUCCESSFUL CONVERSION TO INTEGER
*
{GTIN1{MOV{8,WA{3,GTINA{{RESTORE WA{21485
{{MOV{8,WB{3,GTINB{{RESTORE WB{21486
*
*      COMMON EXIT POINT
*
{GTIN2{EXI{{{{RETURN TO GTINT CALLER{21490
*
*      HERE ON CONVERSION ERROR
*
{GTIN3{EXI{1,1{{{TAKE CONVERT ERROR EXIT{21494
{{ENP{{{{END PROCEDURE GTINT{21495
{{EJC{{{{{21496
*
*      GTNUM -- GET NUMERIC VALUE
*
*      GTNUM IS GIVEN AN OBJECT AND RETURNS EITHER AN INTEGER
*      OR A REAL, PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTNUM            CALL TO CONVERT TO NUMERIC
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULT (INT OR REAL)
*      (WA)                  FIRST WORD OF RESULT BLOCK
*      (WB,WC,RA)            DESTROYED
*      (XR)                  UNCHANGED (ON CONVERT ERROR)
*
{GTNUM{PRC{25,E{1,1{{ENTRY POINT{21511
{{MOV{8,WA{9,(XR){{LOAD FIRST WORD OF BLOCK{21512
{{BEQ{8,WA{22,=B_ICL{6,GTN34{JUMP IF INTEGER (NO CONVERSION){21513
{{BEQ{8,WA{22,=B_RCL{6,GTN34{JUMP IF REAL (NO CONVERSION){21516
*
*      AT THIS POINT THE ONLY POSSIBILITY IS TO CONVERT A STRING
*      TO AN INTEGER OR REAL AS APPROPRIATE.
*
{{MOV{11,-(XS){7,XR{{STACK ARGUMENT IN CASE CONVERT ERR{21522
{{MOV{11,-(XS){7,XR{{STACK ARGUMENT FOR GTSTG{21523
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{21525
{{PPM{6,GTN36{{{JUMP IF UNCONVERTIBLE{21529
*
*      INITIALIZE NUMERIC CONVERSION
*
{{LDI{4,INTV0{{{INITIALIZE INTEGER RESULT TO ZERO{21533
{{BZE{8,WA{6,GTN32{{JUMP TO EXIT WITH ZERO IF NULL{21534
{{LCT{8,WA{8,WA{{SET BCT COUNTER FOR FOLLOWING LOOPS{21535
{{ZER{3,GTNNF{{{TENTATIVELY INDICATE RESULT +{21536
{{STI{3,GTNEX{{{INITIALISE EXPONENT TO ZERO{21539
{{ZER{3,GTNSC{{{ZERO SCALE IN CASE REAL{21540
{{ZER{3,GTNDF{{{RESET FLAG FOR DEC POINT FOUND{21541
{{ZER{3,GTNRD{{{RESET FLAG FOR DIGITS FOUND{21542
{{LDR{4,REAV0{{{ZERO REAL ACCUM IN CASE REAL{21543
{{PLC{7,XR{{{POINT TO ARGUMENT CHARACTERS{21545
*
*      MERGE BACK HERE AFTER IGNORING LEADING BLANK
*
{GTN01{LCH{8,WB{10,(XR)+{{LOAD FIRST CHARACTER{21549
{{BLT{8,WB{18,=CH_D0{6,GTN02{JUMP IF NOT DIGIT{21550
{{BLE{8,WB{18,=CH_D9{6,GTN06{JUMP IF FIRST CHAR IS A DIGIT{21551
{{EJC{{{{{21552
*
*      GTNUM (CONTINUED)
*
*      HERE IF FIRST DIGIT IS NON-DIGIT
*
{GTN02{BNE{8,WB{18,=CH_BL{6,GTN03{JUMP IF NON-BLANK{21558
{GTNA2{BCT{8,WA{6,GTN01{{ELSE DECR COUNT AND LOOP BACK{21559
{{BRN{6,GTN07{{{JUMP TO RETURN ZERO IF ALL BLANKS{21560
*
*      HERE FOR FIRST CHARACTER NON-BLANK, NON-DIGIT
*
{GTN03{BEQ{8,WB{18,=CH_PL{6,GTN04{JUMP IF PLUS SIGN{21564
{{BEQ{8,WB{18,=CH_HT{6,GTNA2{HORIZONTAL TAB EQUIV TO BLANK{21566
{{BNE{8,WB{18,=CH_MN{6,GTN12{JUMP IF NOT MINUS (MAY BE REAL){21574
{{MNZ{3,GTNNF{{{IF MINUS SIGN, SET NEGATIVE FLAG{21576
*
*      MERGE HERE AFTER PROCESSING SIGN
*
{GTN04{BCT{8,WA{6,GTN05{{JUMP IF CHARS LEFT{21580
{{BRN{6,GTN36{{{ELSE ERROR{21581
*
*      LOOP TO FETCH CHARACTERS OF AN INTEGER
*
{GTN05{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{21585
{{BLT{8,WB{18,=CH_D0{6,GTN08{JUMP IF NOT A DIGIT{21586
{{BGT{8,WB{18,=CH_D9{6,GTN08{JUMP IF NOT A DIGIT{21587
*
*      MERGE HERE FOR FIRST DIGIT
*
{GTN06{STI{3,GTNSI{{{SAVE CURRENT VALUE{21591
{{CVM{6,GTN35{{{CURRENT*10-(NEW DIG) JUMP IF OVFLOW{21595
{{MNZ{3,GTNRD{{{SET DIGIT READ FLAG{21596
{{BCT{8,WA{6,GTN05{{ELSE LOOP BACK IF MORE CHARS{21598
*
*      HERE TO EXIT WITH CONVERTED INTEGER VALUE
*
{GTN07{BNZ{3,GTNNF{6,GTN32{{JUMP IF NEGATIVE (ALL SET){21602
{{NGI{{{{ELSE NEGATE{21603
{{INO{6,GTN32{{{JUMP IF NO OVERFLOW{21604
{{BRN{6,GTN36{{{ELSE SIGNAL ERROR{21605
{{EJC{{{{{21606
*
*      GTNUM (CONTINUED)
*
*      HERE FOR A NON-DIGIT CHARACTER WHILE ATTEMPTING TO
*      CONVERT AN INTEGER, CHECK FOR TRAILING BLANKS OR REAL.
*
{GTN08{BEQ{8,WB{18,=CH_BL{6,GTNA9{JUMP IF A BLANK{21613
{{BEQ{8,WB{18,=CH_HT{6,GTNA9{JUMP IF HORIZONTAL TAB{21615
{{ITR{{{{ELSE CONVERT INTEGER TO REAL{21623
{{NGR{{{{NEGATE TO GET POSITIVE VALUE{21624
{{BRN{6,GTN12{{{JUMP TO TRY FOR REAL{21625
*
*      HERE WE SCAN OUT BLANKS TO END OF STRING
*
{GTN09{LCH{8,WB{10,(XR)+{{GET NEXT CHAR{21630
{{BEQ{8,WB{18,=CH_HT{6,GTNA9{JUMP IF HORIZONTAL TAB{21632
{{BNE{8,WB{18,=CH_BL{6,GTN36{ERROR IF NON-BLANK{21637
{GTNA9{BCT{8,WA{6,GTN09{{LOOP BACK IF MORE CHARS TO CHECK{21638
{{BRN{6,GTN07{{{RETURN INTEGER IF ALL BLANKS{21639
*
*      LOOP TO COLLECT MANTISSA OF REAL
*
{GTN10{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{21645
{{BLT{8,WB{18,=CH_D0{6,GTN12{JUMP IF NON-NUMERIC{21646
{{BGT{8,WB{18,=CH_D9{6,GTN12{JUMP IF NON-NUMERIC{21647
*
*      MERGE HERE TO COLLECT FIRST REAL DIGIT
*
{GTN11{SUB{8,WB{18,=CH_D0{{CONVERT DIGIT TO NUMBER{21651
{{MLR{4,REAVT{{{MULTIPLY REAL BY 10.0{21652
{{ROV{6,GTN36{{{CONVERT ERROR IF OVERFLOW{21653
{{STR{3,GTNSR{{{SAVE RESULT{21654
{{MTI{8,WB{{{GET NEW DIGIT AS INTEGER{21655
{{ITR{{{{CONVERT NEW DIGIT TO REAL{21656
{{ADR{3,GTNSR{{{ADD TO GET NEW TOTAL{21657
{{ADD{3,GTNSC{3,GTNDF{{INCREMENT SCALE IF AFTER DEC POINT{21658
{{MNZ{3,GTNRD{{{SET DIGIT FOUND FLAG{21659
{{BCT{8,WA{6,GTN10{{LOOP BACK IF MORE CHARS{21660
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{21661
{{EJC{{{{{21662
*
*      GTNUM (CONTINUED)
*
*      HERE IF NON-DIGIT FOUND WHILE COLLECTING A REAL
*
{GTN12{BNE{8,WB{18,=CH_DT{6,GTN13{JUMP IF NOT DEC POINT{21668
{{BNZ{3,GTNDF{6,GTN36{{IF DEC POINT, ERROR IF ONE ALREADY{21669
{{MOV{3,GTNDF{18,=NUM01{{ELSE SET FLAG FOR DEC POINT{21670
{{BCT{8,WA{6,GTN10{{LOOP BACK IF MORE CHARS{21671
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{21672
*
*      HERE IF NOT DECIMAL POINT
*
{GTN13{BEQ{8,WB{18,=CH_LE{6,GTN15{JUMP IF E FOR EXPONENT{21676
{{BEQ{8,WB{18,=CH_LD{6,GTN15{JUMP IF D FOR EXPONENT{21677
{{BEQ{8,WB{18,=CH__E{6,GTN15{JUMP IF E FOR EXPONENT{21679
{{BEQ{8,WB{18,=CH__D{6,GTN15{JUMP IF D FOR EXPONENT{21680
*
*      HERE CHECK FOR TRAILING BLANKS
*
{GTN14{BEQ{8,WB{18,=CH_BL{6,GTNB4{JUMP IF BLANK{21685
{{BEQ{8,WB{18,=CH_HT{6,GTNB4{JUMP IF HORIZONTAL TAB{21687
{{BRN{6,GTN36{{{ERROR IF NON-BLANK{21692
*
{GTNB4{LCH{8,WB{10,(XR)+{{GET NEXT CHARACTER{21694
{{BCT{8,WA{6,GTN14{{LOOP BACK TO CHECK IF MORE{21695
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{21696
*
*      HERE TO READ AND PROCESS AN EXPONENT
*
{GTN15{ZER{3,GTNES{{{SET EXPONENT SIGN POSITIVE{21700
{{LDI{4,INTV0{{{INITIALIZE EXPONENT TO ZERO{21701
{{MNZ{3,GTNDF{{{RESET NO DEC POINT INDICATION{21702
{{BCT{8,WA{6,GTN16{{JUMP SKIPPING PAST E OR D{21703
{{BRN{6,GTN36{{{ERROR IF NULL EXPONENT{21704
*
*      CHECK FOR EXPONENT SIGN
*
{GTN16{LCH{8,WB{10,(XR)+{{LOAD FIRST EXPONENT CHARACTER{21708
{{BEQ{8,WB{18,=CH_PL{6,GTN17{JUMP IF PLUS SIGN{21709
{{BNE{8,WB{18,=CH_MN{6,GTN19{ELSE JUMP IF NOT MINUS SIGN{21710
{{MNZ{3,GTNES{{{SET SIGN NEGATIVE IF MINUS SIGN{21711
*
*      MERGE HERE AFTER PROCESSING EXPONENT SIGN
*
{GTN17{BCT{8,WA{6,GTN18{{JUMP IF CHARS LEFT{21715
{{BRN{6,GTN36{{{ELSE ERROR{21716
*
*      LOOP TO CONVERT EXPONENT DIGITS
*
{GTN18{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{21720
{{EJC{{{{{21721
*
*      GTNUM (CONTINUED)
*
*      MERGE HERE FOR FIRST EXPONENT DIGIT
*
{GTN19{BLT{8,WB{18,=CH_D0{6,GTN20{JUMP IF NOT DIGIT{21727
{{BGT{8,WB{18,=CH_D9{6,GTN20{JUMP IF NOT DIGIT{21728
{{CVM{6,GTN36{{{ELSE CURRENT*10, SUBTRACT NEW DIGIT{21729
{{BCT{8,WA{6,GTN18{{LOOP BACK IF MORE CHARS{21730
{{BRN{6,GTN21{{{JUMP IF EXPONENT FIELD IS EXHAUSTED{21731
*
*      HERE TO CHECK FOR TRAILING BLANKS AFTER EXPONENT
*
{GTN20{BEQ{8,WB{18,=CH_BL{6,GTNC0{JUMP IF BLANK{21735
{{BEQ{8,WB{18,=CH_HT{6,GTNC0{JUMP IF HORIZONTAL TAB{21737
{{BRN{6,GTN36{{{ERROR IF NON-BLANK{21742
*
{GTNC0{LCH{8,WB{10,(XR)+{{GET NEXT CHARACTER{21744
{{BCT{8,WA{6,GTN20{{LOOP BACK TILL ALL BLANKS SCANNED{21745
*
*      MERGE HERE AFTER COLLECTING EXPONENT
*
{GTN21{STI{3,GTNEX{{{SAVE COLLECTED EXPONENT{21749
{{BNZ{3,GTNES{6,GTN22{{JUMP IF IT WAS NEGATIVE{21750
{{NGI{{{{ELSE COMPLEMENT{21751
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{21752
{{STI{3,GTNEX{{{AND STORE POSITIVE EXPONENT{21753
*
*      MERGE HERE WITH EXPONENT (0 IF NONE GIVEN)
*
{GTN22{BZE{3,GTNRD{6,GTN36{{ERROR IF NOT DIGITS COLLECTED{21757
{{BZE{3,GTNDF{6,GTN36{{ERROR IF NO EXPONENT OR DEC POINT{21758
{{MTI{3,GTNSC{{{ELSE LOAD SCALE AS INTEGER{21759
{{SBI{3,GTNEX{{{SUBTRACT EXPONENT{21760
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{21761
{{ILT{6,GTN26{{{JUMP IF WE MUST SCALE UP{21762
*
*      HERE WE HAVE A NEGATIVE EXPONENT, SO SCALE DOWN
*
{{MFI{8,WA{6,GTN36{{LOAD SCALE FACTOR, ERR IF OVFLOW{21766
*
*      LOOP TO SCALE DOWN IN STEPS OF 10**10
*
{GTN23{BLE{8,WA{18,=NUM10{6,GTN24{JUMP IF 10 OR LESS TO GO{21770
{{DVR{4,REATT{{{ELSE DIVIDE BY 10**10{21771
{{SUB{8,WA{18,=NUM10{{DECREMENT SCALE{21772
{{BRN{6,GTN23{{{AND LOOP BACK{21773
{{EJC{{{{{21774
*
*      GTNUM (CONTINUED)
*
*      HERE SCALE REST OF WAY FROM POWERS OF TEN TABLE
*
{GTN24{BZE{8,WA{6,GTN30{{JUMP IF SCALED{21780
{{LCT{8,WB{18,=CFP_R{{ELSE GET INDEXING FACTOR{21781
{{MOV{7,XR{21,=REAV1{{POINT TO POWERS OF TEN TABLE{21782
{{WTB{8,WA{{{CONVERT REMAINING SCALE TO BYTE OFS{21783
*
*      LOOP TO POINT TO POWERS OF TEN TABLE ENTRY
*
{GTN25{ADD{7,XR{8,WA{{BUMP POINTER{21787
{{BCT{8,WB{6,GTN25{{ONCE FOR EACH VALUE WORD{21788
{{DVR{9,(XR){{{SCALE DOWN AS REQUIRED{21789
{{BRN{6,GTN30{{{AND JUMP{21790
*
*      COME HERE TO SCALE RESULT UP (POSITIVE EXPONENT)
*
{GTN26{NGI{{{{GET ABSOLUTE VALUE OF EXPONENT{21794
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{21795
{{MFI{8,WA{6,GTN36{{ACQUIRE SCALE, ERROR IF OVFLOW{21796
*
*      LOOP TO SCALE UP IN STEPS OF 10**10
*
{GTN27{BLE{8,WA{18,=NUM10{6,GTN28{JUMP IF 10 OR LESS TO GO{21800
{{MLR{4,REATT{{{ELSE MULTIPLY BY 10**10{21801
{{ROV{6,GTN36{{{ERROR IF OVERFLOW{21802
{{SUB{8,WA{18,=NUM10{{ELSE DECREMENT SCALE{21803
{{BRN{6,GTN27{{{AND LOOP BACK{21804
*
*      HERE TO SCALE UP REST OF WAY WITH TABLE
*
{GTN28{BZE{8,WA{6,GTN30{{JUMP IF SCALED{21808
{{LCT{8,WB{18,=CFP_R{{ELSE GET INDEXING FACTOR{21809
{{MOV{7,XR{21,=REAV1{{POINT TO POWERS OF TEN TABLE{21810
{{WTB{8,WA{{{CONVERT REMAINING SCALE TO BYTE OFS{21811
*
*      LOOP TO POINT TO PROPER ENTRY IN POWERS OF TEN TABLE
*
{GTN29{ADD{7,XR{8,WA{{BUMP POINTER{21815
{{BCT{8,WB{6,GTN29{{ONCE FOR EACH WORD IN VALUE{21816
{{MLR{9,(XR){{{SCALE UP{21817
{{ROV{6,GTN36{{{ERROR IF OVERFLOW{21818
{{EJC{{{{{21819
*
*      GTNUM (CONTINUED)
*
*      HERE WITH REAL VALUE SCALED AND READY EXCEPT FOR SIGN
*
{GTN30{BZE{3,GTNNF{6,GTN31{{JUMP IF POSITIVE{21825
{{NGR{{{{ELSE NEGATE{21826
*
*      HERE WITH PROPERLY SIGNED REAL VALUE IN (RA)
*
{GTN31{JSR{6,RCBLD{{{BUILD REAL BLOCK{21830
{{BRN{6,GTN33{{{MERGE TO EXIT{21831
*
*      HERE WITH PROPERLY SIGNED INTEGER VALUE IN (IA)
*
{GTN32{JSR{6,ICBLD{{{BUILD ICBLK{21836
*
*      REAL MERGES HERE
*
{GTN33{MOV{8,WA{9,(XR){{LOAD FIRST WORD OF RESULT BLOCK{21840
{{ICA{7,XS{{{POP ARGUMENT OFF STACK{21841
*
*      COMMON EXIT POINT
*
{GTN34{EXI{{{{RETURN TO GTNUM CALLER{21845
*
*      COME HERE IF OVERFLOW OCCURS DURING COLLECTION OF INTEGER
*      HAVE TO RESTORE WB WHICH CVM MAY HAVE DESTROYED.
*
{GTN35{LCH{8,WB{11,-(XR){{RELOAD CURRENT CHARACTER{21852
{{LCH{8,WB{10,(XR)+{{BUMP CHARACTER POINTER{21853
{{LDI{3,GTNSI{{{RELOAD INTEGER SO FAR{21854
{{ITR{{{{CONVERT TO REAL{21855
{{NGR{{{{MAKE VALUE POSITIVE{21856
{{BRN{6,GTN11{{{MERGE WITH REAL CIRCUIT{21857
*
*      HERE FOR UNCONVERTIBLE TO STRING OR CONVERSION ERROR
*
{GTN36{MOV{7,XR{10,(XS)+{{RELOAD ORIGINAL ARGUMENT{21862
{{EXI{1,1{{{TAKE CONVERT-ERROR EXIT{21863
{{ENP{{{{END PROCEDURE GTNUM{21864
{{EJC{{{{{21865
*
*      GTNVR -- CONVERT TO NATURAL VARIABLE
*
*      GTNVR LOCATES A VARIABLE BLOCK (VRBLK) GIVEN EITHER AN
*      APPROPRIATE NAME (NMBLK) OR A NON-NULL STRING (SCBLK).
*
*      (XR)                  ARGUMENT
*      JSR  GTNVR            CALL TO CONVERT TO NATURAL VARIABLE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO VRBLK
*      (WA,WB)               DESTROYED (CONVERSION ERROR ONLY)
*      (WC)                  DESTROYED
*
{GTNVR{PRC{25,E{1,1{{ENTRY POINT{21879
{{BNE{9,(XR){22,=B_NML{6,GNV02{JUMP IF NOT NAME{21880
{{MOV{7,XR{13,NMBAS(XR){{ELSE LOAD NAME BASE IF NAME{21881
{{BLO{7,XR{3,STATE{6,GNV07{SKIP IF VRBLK (IN STATIC REGION){21882
*
*      COMMON ERROR EXIT
*
{GNV01{EXI{1,1{{{TAKE CONVERT-ERROR EXIT{21886
*
*      HERE IF NOT NAME
*
{GNV02{MOV{3,GNVSA{8,WA{{SAVE WA{21890
{{MOV{3,GNVSB{8,WB{{SAVE WB{21891
{{MOV{11,-(XS){7,XR{{STACK ARGUMENT FOR GTSTG{21892
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{21893
{{PPM{6,GNV01{{{JUMP IF CONVERSION ERROR{21894
{{BZE{8,WA{6,GNV01{{NULL STRING IS AN ERROR{21895
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{21897
{{MOV{11,-(XS){7,XL{{SAVE XL{21899
{{MOV{11,-(XS){7,XR{{STACK STRING PTR FOR LATER{21900
{{MOV{8,WB{7,XR{{COPY STRING POINTER{21901
{{ADD{8,WB{19,*SCHAR{{POINT TO CHARACTERS OF STRING{21902
{{MOV{3,GNVST{8,WB{{SAVE POINTER TO CHARACTERS{21903
{{MOV{8,WB{8,WA{{COPY LENGTH{21904
{{CTW{8,WB{1,0{{GET NUMBER OF WORDS IN NAME{21905
{{MOV{3,GNVNW{8,WB{{SAVE FOR LATER{21906
{{JSR{6,HASHS{{{COMPUTE HASH INDEX FOR STRING{21907
{{RMI{3,HSHNB{{{COMPUTE HASH OFFSET BY TAKING MOD{21908
{{MFI{8,WC{{{GET AS OFFSET{21909
{{WTB{8,WC{{{CONVERT OFFSET TO BYTES{21910
{{ADD{8,WC{3,HSHTB{{POINT TO PROPER HASH CHAIN{21911
{{SUB{8,WC{19,*VRNXT{{SUBTRACT OFFSET TO MERGE INTO LOOP{21912
{{EJC{{{{{21913
*
*      GTNVR (CONTINUED)
*
*      LOOP TO SEARCH HASH CHAIN
*
{GNV03{MOV{7,XL{8,WC{{COPY HASH CHAIN POINTER{21919
{{MOV{7,XL{13,VRNXT(XL){{POINT TO NEXT VRBLK ON CHAIN{21920
{{BZE{7,XL{6,GNV08{{JUMP IF END OF CHAIN{21921
{{MOV{8,WC{7,XL{{SAVE POINTER TO THIS VRBLK{21922
{{BNZ{13,VRLEN(XL){6,GNV04{{JUMP IF NOT SYSTEM VARIABLE{21923
{{MOV{7,XL{13,VRSVP(XL){{ELSE POINT TO SVBLK{21924
{{SUB{7,XL{19,*VRSOF{{ADJUST OFFSET FOR MERGE{21925
*
*      MERGE HERE WITH STRING PTR (LIKE VRBLK) IN XL
*
{GNV04{BNE{8,WA{13,VRLEN(XL){6,GNV03{BACK FOR NEXT VRBLK IF LENGTHS NE{21929
{{ADD{7,XL{19,*VRCHS{{ELSE POINT TO CHARS OF CHAIN ENTRY{21930
{{LCT{8,WB{3,GNVNW{{GET WORD COUNTER TO CONTROL LOOP{21931
{{MOV{7,XR{3,GNVST{{POINT TO CHARS OF NEW NAME{21932
*
*      LOOP TO COMPARE CHARACTERS OF THE TWO NAMES
*
{GNV05{CNE{9,(XR){9,(XL){6,GNV03{JUMP IF NO MATCH FOR NEXT VRBLK{21936
{{ICA{7,XR{{{BUMP NEW NAME POINTER{21937
{{ICA{7,XL{{{BUMP VRBLK IN CHAIN NAME POINTER{21938
{{BCT{8,WB{6,GNV05{{ELSE LOOP TILL ALL COMPARED{21939
{{MOV{7,XR{8,WC{{WE HAVE FOUND A MATCH, GET VRBLK{21940
*
*      EXIT POINT AFTER FINDING VRBLK OR BUILDING NEW ONE
*
{GNV06{MOV{8,WA{3,GNVSA{{RESTORE WA{21944
{{MOV{8,WB{3,GNVSB{{RESTORE WB{21945
{{ICA{7,XS{{{POP STRING POINTER{21946
{{MOV{7,XL{10,(XS)+{{RESTORE XL{21947
*
*      COMMON EXIT POINT
*
{GNV07{EXI{{{{RETURN TO GTNVR CALLER{21951
*
*      NOT FOUND, PREPARE TO SEARCH SYSTEM VARIABLE TABLE
*
{GNV08{ZER{7,XR{{{CLEAR GARBAGE XR POINTER{21955
{{MOV{3,GNVHE{8,WC{{SAVE PTR TO END OF HASH CHAIN{21956
{{BGT{8,WA{18,=NUM09{6,GNV14{CANNOT BE SYSTEM VAR IF LENGTH GT 9{21957
{{MOV{7,XL{8,WA{{ELSE COPY LENGTH{21958
{{WTB{7,XL{{{CONVERT TO BYTE OFFSET{21959
{{MOV{7,XL{14,VSRCH(XL){{POINT TO FIRST SVBLK OF THIS LENGTH{21960
{{EJC{{{{{21961
*
*      GTNVR (CONTINUED)
*
*      LOOP TO SEARCH ENTRIES IN STANDARD VARIABLE TABLE
*
{GNV09{MOV{3,GNVSP{7,XL{{SAVE TABLE POINTER{21967
{{MOV{8,WC{10,(XL)+{{LOAD SVBIT BIT STRING{21968
{{MOV{8,WB{10,(XL)+{{LOAD LENGTH FROM TABLE ENTRY{21969
{{BNE{8,WA{8,WB{6,GNV14{JUMP IF END OF RIGHT LENGTH ENTRIES{21970
{{LCT{8,WB{3,GNVNW{{GET WORD COUNTER TO CONTROL LOOP{21971
{{MOV{7,XR{3,GNVST{{POINT TO CHARS OF NEW NAME{21972
*
*      LOOP TO CHECK FOR MATCHING NAMES
*
{GNV10{CNE{9,(XR){9,(XL){6,GNV11{JUMP IF NAME MISMATCH{21976
{{ICA{7,XR{{{ELSE BUMP NEW NAME POINTER{21977
{{ICA{7,XL{{{BUMP SVBLK POINTER{21978
{{BCT{8,WB{6,GNV10{{ELSE LOOP UNTIL ALL CHECKED{21979
*
*      HERE WE HAVE A MATCH IN THE STANDARD VARIABLE TABLE
*
{{ZER{8,WC{{{SET VRLEN VALUE ZERO{21983
{{MOV{8,WA{19,*VRSI_{{SET STANDARD SIZE{21984
{{BRN{6,GNV15{{{JUMP TO BUILD VRBLK{21985
*
*      HERE IF NO MATCH WITH TABLE ENTRY IN SVBLKS TABLE
*
{GNV11{ICA{7,XL{{{BUMP PAST WORD OF CHARS{21989
{{BCT{8,WB{6,GNV11{{LOOP BACK IF MORE TO GO{21990
{{RSH{8,WC{2,SVNBT{{REMOVE UNINTERESTING BITS{21991
*
*      LOOP TO BUMP TABLE PTR FOR EACH FLAGGED WORD
*
{GNV12{MOV{8,WB{4,BITS1{{LOAD BIT TO TEST{21995
{{ANB{8,WB{8,WC{{TEST FOR WORD PRESENT{21996
{{ZRB{8,WB{6,GNV13{{JUMP IF NOT PRESENT{21997
{{ICA{7,XL{{{ELSE BUMP TABLE POINTER{21998
*
*      HERE AFTER DEALING WITH ONE WORD (ONE BIT)
*
{GNV13{RSH{8,WC{1,1{{REMOVE BIT ALREADY PROCESSED{22002
{{NZB{8,WC{6,GNV12{{LOOP BACK IF MORE BITS TO TEST{22003
{{BRN{6,GNV09{{{ELSE LOOP BACK FOR NEXT SVBLK{22004
*
*      HERE IF NOT SYSTEM VARIABLE
*
{GNV14{MOV{8,WC{8,WA{{COPY VRLEN VALUE{22008
{{MOV{8,WA{18,=VRCHS{{LOAD STANDARD SIZE -CHARS{22009
{{ADD{8,WA{3,GNVNW{{ADJUST FOR CHARS OF NAME{22010
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{22011
{{EJC{{{{{22012
*
*      GTNVR (CONTINUED)
*
*      MERGE HERE TO BUILD VRBLK
*
{GNV15{JSR{6,ALOST{{{ALLOCATE SPACE FOR VRBLK (STATIC){22018
{{MOV{8,WB{7,XR{{SAVE VRBLK POINTER{22019
{{MOV{7,XL{21,=STNVR{{POINT TO MODEL VARIABLE BLOCK{22020
{{MOV{8,WA{19,*VRLEN{{SET LENGTH OF STANDARD FIELDS{22021
{{MVW{{{{SET INITIAL FIELDS OF NEW BLOCK{22022
{{MOV{7,XL{3,GNVHE{{LOAD POINTER TO END OF HASH CHAIN{22023
{{MOV{13,VRNXT(XL){8,WB{{ADD NEW BLOCK TO END OF CHAIN{22024
{{MOV{10,(XR)+{8,WC{{SET VRLEN FIELD, BUMP PTR{22025
{{MOV{8,WA{3,GNVNW{{GET LENGTH IN WORDS{22026
{{WTB{8,WA{{{CONVERT TO LENGTH IN BYTES{22027
{{BZE{8,WC{6,GNV16{{JUMP IF SYSTEM VARIABLE{22028
*
*      HERE FOR NON-SYSTEM VARIABLE -- SET CHARS OF NAME
*
{{MOV{7,XL{9,(XS){{POINT BACK TO STRING NAME{22032
{{ADD{7,XL{19,*SCHAR{{POINT TO CHARS OF NAME{22033
{{MVW{{{{MOVE CHARACTERS INTO PLACE{22034
{{MOV{7,XR{8,WB{{RESTORE VRBLK POINTER{22035
{{BRN{6,GNV06{{{JUMP BACK TO EXIT{22036
*
*      HERE FOR SYSTEM VARIABLE CASE TO FILL IN FIELDS WHERE
*      NECESSARY FROM THE FIELDS PRESENT IN THE SVBLK.
*
{GNV16{MOV{7,XL{3,GNVSP{{LOAD POINTER TO SVBLK{22041
{{MOV{9,(XR){7,XL{{SET SVBLK PTR IN VRBLK{22042
{{MOV{7,XR{8,WB{{RESTORE VRBLK POINTER{22043
{{MOV{8,WB{13,SVBIT(XL){{LOAD BIT INDICATORS{22044
{{ADD{7,XL{19,*SVCHS{{POINT TO CHARACTERS OF NAME{22045
{{ADD{7,XL{8,WA{{POINT PAST CHARACTERS{22046
*
*      SKIP PAST KEYWORD NUMBER (SVKNM) IF PRESENT
*
{{MOV{8,WC{4,BTKNM{{LOAD TEST BIT{22050
{{ANB{8,WC{8,WB{{AND TO TEST{22051
{{ZRB{8,WC{6,GNV17{{JUMP IF NO KEYWORD NUMBER{22052
{{ICA{7,XL{{{ELSE BUMP POINTER{22053
{{EJC{{{{{22054
*
*      GTNVR (CONTINUED)
*
*      HERE TEST FOR FUNCTION (SVFNC AND SVNAR)
*
{GNV17{MOV{8,WC{4,BTFNC{{GET TEST BIT{22060
{{ANB{8,WC{8,WB{{AND TO TEST{22061
{{ZRB{8,WC{6,GNV18{{SKIP IF NO SYSTEM FUNCTION{22062
{{MOV{13,VRFNC(XR){7,XL{{ELSE POINT VRFNC TO SVFNC FIELD{22063
{{ADD{7,XL{19,*NUM02{{AND BUMP PAST SVFNC, SVNAR FIELDS{22064
*
*      NOW TEST FOR LABEL (SVLBL)
*
{GNV18{MOV{8,WC{4,BTLBL{{GET TEST BIT{22068
{{ANB{8,WC{8,WB{{AND TO TEST{22069
{{ZRB{8,WC{6,GNV19{{JUMP IF BIT IS OFF (NO SYSTEM LABL){22070
{{MOV{13,VRLBL(XR){7,XL{{ELSE POINT VRLBL TO SVLBL FIELD{22071
{{ICA{7,XL{{{BUMP PAST SVLBL FIELD{22072
*
*      NOW TEST FOR VALUE (SVVAL)
*
{GNV19{MOV{8,WC{4,BTVAL{{LOAD TEST BIT{22076
{{ANB{8,WC{8,WB{{AND TO TEST{22077
{{ZRB{8,WC{6,GNV06{{ALL DONE IF NO VALUE{22078
{{MOV{13,VRVAL(XR){9,(XL){{ELSE SET INITIAL VALUE{22079
{{MOV{13,VRSTO(XR){22,=B_VRE{{SET ERROR STORE ACCESS{22080
{{BRN{6,GNV06{{{MERGE BACK TO EXIT TO CALLER{22081
{{ENP{{{{END PROCEDURE GTNVR{22082
{{EJC{{{{{22083
*
*      GTPAT -- GET PATTERN
*
*      GTPAT IS PASSED AN OBJECT IN (XR) AND RETURNS A
*      PATTERN AFTER PERFORMING ANY NECESSARY CONVERSIONS
*
*      (XR)                  INPUT ARGUMENT
*      JSR  GTPAT            CALL TO CONVERT TO PATTERN
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  RESULTING PATTERN
*      (WA)                  DESTROYED
*      (WB)                  DESTROYED (ONLY ON CONVERT ERROR)
*      (XR)                  UNCHANGED (ONLY ON CONVERT ERROR)
*
{GTPAT{PRC{25,E{1,1{{ENTRY POINT{22098
{{BHI{9,(XR){22,=P_AAA{6,GTPT5{JUMP IF PATTERN ALREADY{22099
*
*      HERE IF NOT PATTERN, TRY FOR STRING
*
{{MOV{3,GTPSB{8,WB{{SAVE WB{22103
{{MOV{11,-(XS){7,XR{{STACK ARGUMENT FOR GTSTG{22104
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{22105
{{PPM{6,GTPT2{{{JUMP IF IMPOSSIBLE{22106
*
*      HERE WE HAVE A STRING
*
{{BNZ{8,WA{6,GTPT1{{JUMP IF NON-NULL{22110
*
*      HERE FOR NULL STRING. GENERATE POINTER TO NULL PATTERN.
*
{{MOV{7,XR{21,=NDNTH{{POINT TO NOTHEN NODE{22114
{{BRN{6,GTPT4{{{JUMP TO EXIT{22115
{{EJC{{{{{22116
*
*      GTPAT (CONTINUED)
*
*      HERE FOR NON-NULL STRING
*
{GTPT1{MOV{8,WB{22,=P_STR{{LOAD PCODE FOR MULTI-CHAR STRING{22122
{{BNE{8,WA{18,=NUM01{6,GTPT3{JUMP IF MULTI-CHAR STRING{22123
*
*      HERE FOR ONE CHARACTER STRING, SHARE ONE CHARACTER ANY
*
{{PLC{7,XR{{{POINT TO CHARACTER{22127
{{LCH{8,WA{9,(XR){{LOAD CHARACTER{22128
{{MOV{7,XR{8,WA{{SET AS PARM1{22129
{{MOV{8,WB{22,=P_ANS{{POINT TO PCODE FOR 1-CHAR ANY{22130
{{BRN{6,GTPT3{{{JUMP TO BUILD NODE{22131
*
*      HERE IF ARGUMENT IS NOT CONVERTIBLE TO STRING
*
{GTPT2{MOV{8,WB{22,=P_EXA{{SET PCODE FOR EXPRESSION IN CASE{22135
{{BLO{9,(XR){22,=B_E__{6,GTPT3{JUMP TO BUILD NODE IF EXPRESSION{22136
*
*      HERE WE HAVE AN ERROR (CONVERSION IMPOSSIBLE)
*
{{EXI{1,1{{{TAKE CONVERT ERROR EXIT{22140
*
*      MERGE HERE TO BUILD NODE FOR STRING OR EXPRESSION
*
{GTPT3{JSR{6,PBILD{{{CALL ROUTINE TO BUILD PATTERN NODE{22144
*
*      COMMON EXIT AFTER SUCCESSFUL CONVERSION
*
{GTPT4{MOV{8,WB{3,GTPSB{{RESTORE WB{22148
*
*      MERGE HERE TO EXIT IF NO CONVERSION REQUIRED
*
{GTPT5{EXI{{{{RETURN TO GTPAT CALLER{22152
{{ENP{{{{END PROCEDURE GTPAT{22153
{{EJC{{{{{22156
*
*      GTREA -- GET REAL VALUE
*
*      GTREA IS PASSED AN OBJECT AND RETURNS A REAL VALUE
*      PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTREA            CALL TO CONVERT OBJECT TO REAL
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING REAL
*      (WA,WB,WC,RA)         DESTROYED
*      (XR)                  UNCHANGED (CONVERT ERROR ONLY)
*
{GTREA{PRC{25,E{1,1{{ENTRY POINT{22170
{{MOV{8,WA{9,(XR){{GET FIRST WORD OF BLOCK{22171
{{BEQ{8,WA{22,=B_RCL{6,GTRE2{JUMP IF REAL{22172
{{JSR{6,GTNUM{{{ELSE CONVERT ARGUMENT TO NUMERIC{22173
{{PPM{6,GTRE3{{{JUMP IF UNCONVERTIBLE{22174
{{BEQ{8,WA{22,=B_RCL{6,GTRE2{JUMP IF REAL WAS RETURNED{22175
*
*      HERE FOR CASE OF AN INTEGER TO CONVERT TO REAL
*
{GTRE1{LDI{13,ICVAL(XR){{{LOAD INTEGER{22179
{{ITR{{{{CONVERT TO REAL{22180
{{JSR{6,RCBLD{{{BUILD RCBLK{22181
*
*      EXIT WITH REAL
*
{GTRE2{EXI{{{{RETURN TO GTREA CALLER{22185
*
*      HERE ON CONVERSION ERROR
*
{GTRE3{EXI{1,1{{{TAKE CONVERT ERROR EXIT{22189
{{ENP{{{{END PROCEDURE GTREA{22190
{{EJC{{{{{22192
*
*      GTSMI -- GET SMALL INTEGER
*
*      GTSMI IS PASSED A SNOBOL OBJECT AND RETURNS AN ADDRESS
*      INTEGER IN THE RANGE (0 LE N LE DNAMB). SUCH A VALUE CAN
*      ONLY BE DERIVED FROM AN INTEGER IN THE APPROPRIATE RANGE.
*      SMALL INTEGERS NEVER APPEAR AS SNOBOL VALUES. HOWEVER,
*      THEY ARE USED INTERNALLY FOR A VARIETY OF PURPOSES.
*
*      -(XS)                 ARGUMENT TO CONVERT (ON STACK)
*      JSR  GTSMI            CALL TO CONVERT TO SMALL INTEGER
*      PPM  LOC              TRANSFER LOC FOR NOT INTEGER
*      PPM  LOC              TRANSFER LOC FOR LT 0, GT DNAMB
*      (XR,WC)               RESULTING SMALL INT (TWO COPIES)
*      (XS)                  POPPED
*      (RA)                  DESTROYED
*      (WA,WB)               DESTROYED (ON CONVERT ERROR ONLY)
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTSMI{PRC{25,N{1,2{{ENTRY POINT{22212
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT{22213
{{BEQ{9,(XR){22,=B_ICL{6,GTSM1{SKIP IF ALREADY AN INTEGER{22214
*
*      HERE IF NOT AN INTEGER
*
{{JSR{6,GTINT{{{CONVERT ARGUMENT TO INTEGER{22218
{{PPM{6,GTSM2{{{JUMP IF CONVERT IS IMPOSSIBLE{22219
*
*      MERGE HERE WITH INTEGER
*
{GTSM1{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{22223
{{MFI{8,WC{6,GTSM3{{MOVE AS ONE WORD, JUMP IF OVFLOW{22224
{{BGT{8,WC{3,MXLEN{6,GTSM3{OR IF TOO LARGE{22225
{{MOV{7,XR{8,WC{{COPY RESULT TO XR{22226
{{EXI{{{{RETURN TO GTSMI CALLER{22227
*
*      HERE IF UNCONVERTIBLE TO INTEGER
*
{GTSM2{EXI{1,1{{{TAKE NON-INTEGER ERROR EXIT{22231
*
*      HERE IF OUT OF RANGE
*
{GTSM3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{22235
{{ENP{{{{END PROCEDURE GTSMI{22236
{{EJC{{{{{22237
*
*      GTSTG -- GET STRING
*
*      GTSTG IS PASSED AN OBJECT AND RETURNS A STRING WITH
*      ANY NECESSARY CONVERSIONS PERFORMED.
*
*      -(XS)                 INPUT ARGUMENT (ON STACK)
*      JSR  GTSTG            CALL TO CONVERT TO STRING
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING STRING
*      (WA)                  LENGTH OF STRING IN CHARACTERS
*      (XS)                  POPPED
*      (RA)                  DESTROYED
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTSTG{PRC{25,N{1,1{{ENTRY POINT{22303
{{MOV{7,XR{10,(XS)+{{LOAD ARGUMENT, POP STACK{22304
{{BEQ{9,(XR){22,=B_SCL{6,GTS30{JUMP IF ALREADY A STRING{22305
*
*      HERE IF NOT A STRING ALREADY
*
{GTS01{MOV{11,-(XS){7,XR{{RESTACK ARGUMENT IN CASE ERROR{22309
{{MOV{11,-(XS){7,XL{{SAVE XL{22310
{{MOV{3,GTSVB{8,WB{{SAVE WB{22311
{{MOV{3,GTSVC{8,WC{{SAVE WC{22312
{{MOV{8,WA{9,(XR){{LOAD FIRST WORD OF BLOCK{22313
{{BEQ{8,WA{22,=B_ICL{6,GTS05{JUMP TO CONVERT INTEGER{22314
{{BEQ{8,WA{22,=B_RCL{6,GTS10{JUMP TO CONVERT REAL{22317
{{BEQ{8,WA{22,=B_NML{6,GTS03{JUMP TO CONVERT NAME{22319
*
*      HERE ON CONVERSION ERROR
*
{GTS02{MOV{7,XL{10,(XS)+{{RESTORE XL{22327
{{MOV{7,XR{10,(XS)+{{RELOAD INPUT ARGUMENT{22328
{{EXI{1,1{{{TAKE CONVERT ERROR EXIT{22329
{{EJC{{{{{22330
*
*      GTSTG (CONTINUED)
*
*      HERE TO CONVERT A NAME (ONLY POSSIBLE IF NATURAL VAR)
*
{GTS03{MOV{7,XL{13,NMBAS(XR){{LOAD NAME BASE{22336
{{BHI{7,XL{3,STATE{6,GTS02{ERROR IF NOT NATURAL VAR (STATIC){22337
{{ADD{7,XL{19,*VRSOF{{ELSE POINT TO POSSIBLE STRING NAME{22338
{{MOV{8,WA{13,SCLEN(XL){{LOAD LENGTH{22339
{{BNZ{8,WA{6,GTS04{{JUMP IF NOT SYSTEM VARIABLE{22340
{{MOV{7,XL{13,VRSVO(XL){{ELSE POINT TO SVBLK{22341
{{MOV{8,WA{13,SVLEN(XL){{AND LOAD NAME LENGTH{22342
*
*      MERGE HERE WITH STRING IN XR, LENGTH IN WA
*
{GTS04{ZER{8,WB{{{SET OFFSET TO ZERO{22346
{{JSR{6,SBSTR{{{USE SBSTR TO COPY STRING{22347
{{BRN{6,GTS29{{{JUMP TO EXIT{22348
*
*      COME HERE TO CONVERT AN INTEGER
*
{GTS05{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{22352
{{MOV{3,GTSSF{18,=NUM01{{SET SIGN FLAG NEGATIVE{22360
{{ILT{6,GTS06{{{SKIP IF INTEGER IS NEGATIVE{22361
{{NGI{{{{ELSE NEGATE INTEGER{22362
{{ZER{3,GTSSF{{{AND RESET NEGATIVE FLAG{22363
{{EJC{{{{{22364
*
*      GTSTG (CONTINUED)
*
*      HERE WITH SIGN FLAG SET AND SIGN FORCED NEGATIVE AS
*      REQUIRED BY THE CVD INSTRUCTION.
*
{GTS06{MOV{7,XR{3,GTSWK{{POINT TO RESULT WORK AREA{22371
{{MOV{8,WB{18,=NSTMX{{INITIALIZE COUNTER TO MAX LENGTH{22372
{{PSC{7,XR{8,WB{{PREPARE TO STORE (RIGHT-LEFT){22373
*
*      LOOP TO CONVERT DIGITS INTO WORK AREA
*
{GTS07{CVD{{{{CONVERT ONE DIGIT INTO WA{22377
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{22378
{{DCV{8,WB{{{DECREMENT COUNTER{22379
{{INE{6,GTS07{{{LOOP IF MORE DIGITS TO GO{22380
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{22381
*
*      MERGE HERE AFTER CONVERTING INTEGER OR REAL INTO WORK
*      AREA. WB IS SET TO NSTMX - (NUMBER OF CHARS IN RESULT).
*
{GTS08{MOV{8,WA{18,=NSTMX{{GET MAX NUMBER OF CHARACTERS{22387
{{SUB{8,WA{8,WB{{COMPUTE LENGTH OF RESULT{22388
{{MOV{7,XL{8,WA{{REMEMBER LENGTH FOR MOVE LATER ON{22389
{{ADD{8,WA{3,GTSSF{{ADD ONE FOR NEGATIVE SIGN IF NEEDED{22390
{{JSR{6,ALOCS{{{ALLOCATE STRING FOR RESULT{22391
{{MOV{8,WC{7,XR{{SAVE RESULT POINTER FOR THE MOMENT{22392
{{PSC{7,XR{{{POINT TO CHARS OF RESULT BLOCK{22393
{{BZE{3,GTSSF{6,GTS09{{SKIP IF POSITIVE{22394
{{MOV{8,WA{18,=CH_MN{{ELSE LOAD NEGATIVE SIGN{22395
{{SCH{8,WA{10,(XR)+{{AND STORE IT{22396
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{22397
*
*      HERE AFTER DEALING WITH SIGN
*
{GTS09{MOV{8,WA{7,XL{{RECALL LENGTH TO MOVE{22401
{{MOV{7,XL{3,GTSWK{{POINT TO RESULT WORK AREA{22402
{{PLC{7,XL{8,WB{{POINT TO FIRST RESULT CHARACTER{22403
{{MVC{{{{MOVE CHARS TO RESULT STRING{22404
{{MOV{7,XR{8,WC{{RESTORE RESULT POINTER{22405
{{BRN{6,GTS29{{{JUMP TO EXIT{22408
{{EJC{{{{{22409
*
*      GTSTG (CONTINUED)
*
*      HERE TO CONVERT A REAL
*
{GTS10{LDR{13,RCVAL(XR){{{LOAD REAL{22415
{{ZER{3,GTSSF{{{RESET NEGATIVE FLAG{22427
{{REQ{6,GTS31{{{SKIP IF ZERO{22428
{{RGE{6,GTS11{{{JUMP IF REAL IS POSITIVE{22429
{{MOV{3,GTSSF{18,=NUM01{{ELSE SET NEGATIVE FLAG{22430
{{NGR{{{{AND GET ABSOLUTE VALUE OF REAL{22431
*
*      NOW SCALE THE REAL TO THE RANGE (0.1 LE X LT 1.0)
*
{GTS11{LDI{4,INTV0{{{INITIALIZE EXPONENT TO ZERO{22435
*
*      LOOP TO SCALE UP IN STEPS OF 10**10
*
{GTS12{STR{3,GTSRS{{{SAVE REAL VALUE{22439
{{SBR{4,REAP1{{{SUBTRACT 0.1 TO COMPARE{22440
{{RGE{6,GTS13{{{JUMP IF SCALE UP NOT REQUIRED{22441
{{LDR{3,GTSRS{{{ELSE RELOAD VALUE{22442
{{MLR{4,REATT{{{MULTIPLY BY 10**10{22443
{{SBI{4,INTVT{{{DECREMENT EXPONENT BY 10{22444
{{BRN{6,GTS12{{{LOOP BACK TO TEST AGAIN{22445
*
*      TEST FOR SCALE DOWN REQUIRED
*
{GTS13{LDR{3,GTSRS{{{RELOAD VALUE{22449
{{SBR{4,REAV1{{{SUBTRACT 1.0{22450
{{RLT{6,GTS17{{{JUMP IF NO SCALE DOWN REQUIRED{22451
{{LDR{3,GTSRS{{{ELSE RELOAD VALUE{22452
*
*      LOOP TO SCALE DOWN IN STEPS OF 10**10
*
{GTS14{SBR{4,REATT{{{SUBTRACT 10**10 TO COMPARE{22456
{{RLT{6,GTS15{{{JUMP IF LARGE STEP NOT REQUIRED{22457
{{LDR{3,GTSRS{{{ELSE RESTORE VALUE{22458
{{DVR{4,REATT{{{DIVIDE BY 10**10{22459
{{STR{3,GTSRS{{{STORE NEW VALUE{22460
{{ADI{4,INTVT{{{INCREMENT EXPONENT BY 10{22461
{{BRN{6,GTS14{{{LOOP BACK{22462
{{EJC{{{{{22463
*
*      GTSTG (CONTINUED)
*
*      AT THIS POINT WE HAVE (1.0 LE X LT 10**10)
*      COMPLETE SCALING WITH POWERS OF TEN TABLE
*
{GTS15{MOV{7,XR{21,=REAV1{{POINT TO POWERS OF TEN TABLE{22470
*
*      LOOP TO LOCATE CORRECT ENTRY IN TABLE
*
{GTS16{LDR{3,GTSRS{{{RELOAD VALUE{22474
{{ADI{4,INTV1{{{INCREMENT EXPONENT{22475
{{ADD{7,XR{19,*CFP_R{{POINT TO NEXT ENTRY IN TABLE{22476
{{SBR{9,(XR){{{SUBTRACT IT TO COMPARE{22477
{{RGE{6,GTS16{{{LOOP TILL WE FIND A LARGER ENTRY{22478
{{LDR{3,GTSRS{{{THEN RELOAD THE VALUE{22479
{{DVR{9,(XR){{{AND COMPLETE SCALING{22480
{{STR{3,GTSRS{{{STORE VALUE{22481
*
*      WE ARE NOW SCALED, SO ROUND BY ADDING 0.5 * 10**(-CFP_S)
*
{GTS17{LDR{3,GTSRS{{{GET VALUE AGAIN{22485
{{ADR{3,GTSRN{{{ADD ROUNDING FACTOR{22486
{{STR{3,GTSRS{{{STORE RESULT{22487
*
*      THE ROUNDING OPERATION MAY HAVE PUSHED US UP PAST
*      1.0 AGAIN, SO CHECK ONE MORE TIME.
*
{{SBR{4,REAV1{{{SUBTRACT 1.0 TO COMPARE{22492
{{RLT{6,GTS18{{{SKIP IF OK{22493
{{ADI{4,INTV1{{{ELSE INCREMENT EXPONENT{22494
{{LDR{3,GTSRS{{{RELOAD VALUE{22495
{{DVR{4,REAVT{{{DIVIDE BY 10.0 TO RESCALE{22496
{{BRN{6,GTS19{{{JUMP TO MERGE{22497
*
*      HERE IF ROUNDING DID NOT MUCK UP SCALING
*
{GTS18{LDR{3,GTSRS{{{RELOAD ROUNDED VALUE{22501
{{EJC{{{{{22502
*
*      GTSTG (CONTINUED)
*
*      NOW WE HAVE COMPLETED THE SCALING AS FOLLOWS
*
*      (IA)                  SIGNED EXPONENT
*      (RA)                  SCALED REAL (ABSOLUTE VALUE)
*
*      IF THE EXPONENT IS NEGATIVE OR GREATER THAN CFP_S, THEN
*      WE CONVERT THE NUMBER IN THE FORM.
*
*      (NEG SIGN) 0 . (CPF_S DIGITS) E (EXP SIGN) (EXP DIGITS)
*
*      IF THE EXPONENT IS POSITIVE AND LESS THAN OR EQUAL TO
*      CFP_S, THE NUMBER IS CONVERTED IN THE FORM.
*
*      (NEG SIGN) (EXPONENT DIGITS) . (CFP_S-EXPONENT DIGITS)
*
*      IN BOTH CASES, THE FORMATS OBTAINED FROM THE ABOVE
*      RULES ARE MODIFIED BY DELETING TRAILING ZEROS AFTER THE
*      DECIMAL POINT. THERE ARE NO LEADING ZEROS IN THE EXPONENT
*      AND THE EXPONENT SIGN IS ALWAYS PRESENT.
*
{GTS19{MOV{7,XL{18,=CFP_S{{SET NUM DEC DIGITS = CFP_S{22526
{{MOV{3,GTSES{18,=CH_MN{{SET EXPONENT SIGN NEGATIVE{22527
{{ILT{6,GTS21{{{ALL SET IF EXPONENT IS NEGATIVE{22528
{{MFI{8,WA{{{ELSE FETCH EXPONENT{22529
{{BLE{8,WA{18,=CFP_S{6,GTS20{SKIP IF WE CAN USE SPECIAL FORMAT{22530
{{MTI{8,WA{{{ELSE RESTORE EXPONENT{22531
{{NGI{{{{SET NEGATIVE FOR CVD{22532
{{MOV{3,GTSES{18,=CH_PL{{SET PLUS SIGN FOR EXPONENT SIGN{22533
{{BRN{6,GTS21{{{JUMP TO GENERATE EXPONENT{22534
*
*      HERE IF WE CAN USE THE FORMAT WITHOUT AN EXPONENT
*
{GTS20{SUB{7,XL{8,WA{{COMPUTE DIGITS AFTER DECIMAL POINT{22538
{{LDI{4,INTV0{{{RESET EXPONENT TO ZERO{22539
{{EJC{{{{{22540
*
*      GTSTG (CONTINUED)
*
*      MERGE HERE AS FOLLOWS
*
*      (IA)                  EXPONENT ABSOLUTE VALUE
*      GTSES                 CHARACTER FOR EXPONENT SIGN
*      (RA)                  POSITIVE FRACTION
*      (XL)                  NUMBER OF DIGITS AFTER DEC POINT
*
{GTS21{MOV{7,XR{3,GTSWK{{POINT TO WORK AREA{22551
{{MOV{8,WB{18,=NSTMX{{SET CHARACTER CTR TO MAX LENGTH{22552
{{PSC{7,XR{8,WB{{PREPARE TO STORE (RIGHT TO LEFT){22553
{{IEQ{6,GTS23{{{SKIP EXPONENT IF IT IS ZERO{22554
*
*      LOOP TO GENERATE DIGITS OF EXPONENT
*
{GTS22{CVD{{{{CONVERT A DIGIT INTO WA{22558
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{22559
{{DCV{8,WB{{{DECREMENT COUNTER{22560
{{INE{6,GTS22{{{LOOP BACK IF MORE DIGITS TO GO{22561
*
*      HERE GENERATE EXPONENT SIGN AND E
*
{{MOV{8,WA{3,GTSES{{LOAD EXPONENT SIGN{22565
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{22566
{{MOV{8,WA{18,=CH_LE{{GET CHARACTER LETTER E{22567
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{22568
{{SUB{8,WB{18,=NUM02{{DECREMENT COUNTER FOR SIGN AND E{22569
*
*      HERE TO GENERATE THE FRACTION
*
{GTS23{MLR{3,GTSSC{{{CONVERT REAL TO INTEGER (10**CFP_S){22573
{{RTI{{{{GET INTEGER (OVERFLOW IMPOSSIBLE){22574
{{NGI{{{{NEGATE AS REQUIRED BY CVD{22575
*
*      LOOP TO SUPPRESS TRAILING ZEROS
*
{GTS24{BZE{7,XL{6,GTS27{{JUMP IF NO DIGITS LEFT TO DO{22579
{{CVD{{{{ELSE CONVERT ONE DIGIT{22580
{{BNE{8,WA{18,=CH_D0{6,GTS26{JUMP IF NOT A ZERO{22581
{{DCV{7,XL{{{DECREMENT COUNTER{22582
{{BRN{6,GTS24{{{LOOP BACK FOR NEXT DIGIT{22583
{{EJC{{{{{22584
*
*      GTSTG (CONTINUED)
*
*      LOOP TO GENERATE DIGITS AFTER DECIMAL POINT
*
{GTS25{CVD{{{{CONVERT A DIGIT INTO WA{22590
*
*      MERGE HERE FIRST TIME
*
{GTS26{SCH{8,WA{11,-(XR){{STORE DIGIT{22594
{{DCV{8,WB{{{DECREMENT COUNTER{22595
{{DCV{7,XL{{{DECREMENT COUNTER{22596
{{BNZ{7,XL{6,GTS25{{LOOP BACK IF MORE TO GO{22597
*
*      HERE GENERATE THE DECIMAL POINT
*
{GTS27{MOV{8,WA{18,=CH_DT{{LOAD DECIMAL POINT{22601
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{22602
{{DCV{8,WB{{{DECREMENT COUNTER{22603
*
*      HERE GENERATE THE DIGITS BEFORE THE DECIMAL POINT
*
{GTS28{CVD{{{{CONVERT A DIGIT INTO WA{22607
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{22608
{{DCV{8,WB{{{DECREMENT COUNTER{22609
{{INE{6,GTS28{{{LOOP BACK IF MORE TO GO{22610
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{22611
{{BRN{6,GTS08{{{ELSE JUMP BACK TO EXIT{22612
*
*      EXIT POINT AFTER SUCCESSFUL CONVERSION
*
{GTS29{MOV{7,XL{10,(XS)+{{RESTORE XL{22618
{{ICA{7,XS{{{POP ARGUMENT{22619
{{MOV{8,WB{3,GTSVB{{RESTORE WB{22620
{{MOV{8,WC{3,GTSVC{{RESTORE WC{22621
*
*      MERGE HERE IF NO CONVERSION REQUIRED
*
{GTS30{MOV{8,WA{13,SCLEN(XR){{LOAD STRING LENGTH{22625
{{EXI{{{{RETURN TO CALLER{22626
*
*      HERE TO RETURN STRING FOR REAL ZERO
*
{GTS31{MOV{7,XL{21,=SCRE0{{POINT TO STRING{22632
{{MOV{8,WA{18,=NUM02{{2 CHARS{22633
{{ZER{8,WB{{{ZERO OFFSET{22634
{{JSR{6,SBSTR{{{COPY STRING{22635
{{BRN{6,GTS29{{{RETURN{22636
{{ENP{{{{END PROCEDURE GTSTG{22663
{{EJC{{{{{22664
*
*      GTVAR -- GET VARIABLE FOR I/O/TRACE ASSOCIATION
*
*      GTVAR IS USED TO POINT TO AN ACTUAL VARIABLE LOCATION
*      FOR THE DETACH,INPUT,OUTPUT,TRACE,STOPTR SYSTEM FUNCTIONS
*
*      (XR)                  ARGUMENT TO FUNCTION
*      JSR  GTVAR            CALL TO LOCATE VARIABLE POINTER
*      PPM  LOC              TRANSFER LOC IF NOT OK VARIABLE
*      (XL,WA)               NAME BASE,OFFSET OF VARIABLE
*      (XR,RA)               DESTROYED
*      (WB,WC)               DESTROYED (CONVERT ERROR ONLY)
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTVAR{PRC{25,E{1,1{{ENTRY POINT{22679
{{BNE{9,(XR){22,=B_NML{6,GTVR2{JUMP IF NOT A NAME{22680
{{MOV{8,WA{13,NMOFS(XR){{ELSE LOAD NAME OFFSET{22681
{{MOV{7,XL{13,NMBAS(XR){{LOAD NAME BASE{22682
{{BEQ{9,(XL){22,=B_EVT{6,GTVR1{ERROR IF EXPRESSION VARIABLE{22683
{{BNE{9,(XL){22,=B_KVT{6,GTVR3{ALL OK IF NOT KEYWORD VARIABLE{22684
*
*      HERE ON CONVERSION ERROR
*
{GTVR1{EXI{1,1{{{TAKE CONVERT ERROR EXIT{22688
*
*      HERE IF NOT A NAME, TRY CONVERT TO NATURAL VARIABLE
*
{GTVR2{MOV{3,GTVRC{8,WC{{SAVE WC{22692
{{JSR{6,GTNVR{{{LOCATE VRBLK IF POSSIBLE{22693
{{PPM{6,GTVR1{{{JUMP IF CONVERT ERROR{22694
{{MOV{7,XL{7,XR{{ELSE COPY VRBLK NAME BASE{22695
{{MOV{8,WA{19,*VRVAL{{AND SET OFFSET{22696
{{MOV{8,WC{3,GTVRC{{RESTORE WC{22697
*
*      HERE FOR NAME OBTAINED
*
{GTVR3{BHI{7,XL{3,STATE{6,GTVR4{ALL OK IF NOT NATURAL VARIABLE{22701
{{BEQ{13,VRSTO(XL){22,=B_VRE{6,GTVR1{ERROR IF PROTECTED VARIABLE{22702
*
*      COMMON EXIT POINT
*
{GTVR4{EXI{{{{RETURN TO CALLER{22706
{{ENP{{{{END PROCEDURE GTVAR{22707
{{EJC{{{{{22708
{{EJC{{{{{22709
*
*      HASHS -- COMPUTE HASH INDEX FOR STRING
*
*      HASHS IS USED TO CONVERT A STRING TO A UNIQUE INTEGER
*      VALUE. THE RESULTING HASH VALUE IS A POSITIVE INTEGER
*      IN THE RANGE 0 TO CFP_M
*
*      (XR)                  STRING TO BE HASHED
*      JSR  HASHS            CALL TO HASH STRING
*      (IA)                  HASH VALUE
*      (XR,WB,WC)            DESTROYED
*
*      THE HASH FUNCTION USED IS AS FOLLOWS.
*
*      START WITH THE LENGTH OF THE STRING.
*
*      IF THERE IS MORE THAN ONE CHARACTER IN A WORD,
*      TAKE THE FIRST E_HNW WORDS OF THE CHARACTERS FROM
*      THE STRING OR ALL THE WORDS IF FEWER THAN E_HNW.
*
*      COMPUTE THE EXCLUSIVE OR OF ALL THESE WORDS TREATING
*      THEM AS ONE WORD BIT STRING VALUES.
*
*      IF THERE IS JUST ONE CHARACTER IN A WORD,
*      THEN MIMIC THE WORD BY WORD HASH BY SHIFTING
*      SUCCESSIVE CHARACTERS TO GET A SIMILAR EFFECT.
*
*      E_HNW IS SET TO ZERO IN CASE ONLY ONE CHARACTER PER WORD.
*
*      MOVE THE RESULT AS AN INTEGER WITH THE MTI INSTRUCTION.
*
*      THE TEST ON E_HNW IS DONE DYNAMICALLY. THIS SHOULD BE DONE
*      EVENTUALLY USING CONDITIONAL ASSEMBLY, BUT THAT WOULD REQUIRE
*      CHANGES TO THE BUILD PROCESS (DS 8 May 2013).
*
{HASHS{PRC{25,E{1,0{{ENTRY POINT{22745
{{MOV{8,WC{18,=E_HNW{{GET NUMBER OF WORDS TO USE{22746
{{BZE{8,WC{6,HSHSA{{BRANCH IF ONE CHARACTER PER WORD{22747
{{MOV{8,WC{13,SCLEN(XR){{LOAD STRING LENGTH IN CHARACTERS{22748
{{MOV{8,WB{8,WC{{INITIALIZE WITH LENGTH{22749
{{BZE{8,WC{6,HSHS3{{JUMP IF NULL STRING{22750
{{ZGB{8,WB{{{CORRECT BYTE ORDERING IF NECESSARY{22751
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS OF CHARS{22752
{{ADD{7,XR{19,*SCHAR{{POINT TO CHARACTERS OF STRING{22753
{{BLO{8,WC{18,=E_HNW{6,HSHS1{USE WHOLE STRING IF SHORT{22754
{{MOV{8,WC{18,=E_HNW{{ELSE SET TO INVOLVE FIRST E_HNW WDS{22755
*
*      HERE WITH COUNT OF WORDS TO CHECK IN WC
*
{HSHS1{LCT{8,WC{8,WC{{SET COUNTER TO CONTROL LOOP{22759
*
*      LOOP TO COMPUTE EXCLUSIVE OR
*
{HSHS2{XOB{8,WB{10,(XR)+{{EXCLUSIVE OR NEXT WORD OF CHARS{22763
{{BCT{8,WC{6,HSHS2{{LOOP TILL ALL PROCESSED{22764
*
*      MERGE HERE WITH EXCLUSIVE OR IN WB
*
{HSHS3{ZGB{8,WB{{{ZEROISE UNDEFINED BITS{22768
{{ANB{8,WB{4,BITSM{{ENSURE IN RANGE 0 TO CFP_M{22769
{{MTI{8,WB{{{MOVE RESULT AS INTEGER{22770
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{22771
{{EXI{{{{RETURN TO HASHS CALLER{22772
*
*      HERE IF JUST ONE CHARACTER PER WORD
*
{HSHSA{MOV{8,WC{13,SCLEN(XR){{LOAD STRING LENGTH IN CHARACTERS{22776
{{MOV{8,WB{8,WC{{INITIALIZE WITH LENGTH{22777
{{BZE{8,WC{6,HSHS3{{JUMP IF NULL STRING{22778
{{ZGB{8,WB{{{CORRECT BYTE ORDERING IF NECESSARY{22779
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS OF CHARS{22780
{{PLC{7,XR{{{{22781
{{MOV{11,-(XS){7,XL{{SAVE XL{22782
{{MOV{7,XL{8,WC{{LOAD LENGTH FOR BRANCH{22783
{{BGE{7,XL{18,=NUM25{6,HSH24{USE FIRST CHARACTERS IF LONGER{22784
{{BSW{7,XL{1,25{{MERGE TO COMPUTE HASH{22785
{{IFF{1,0{6,HSH00{{{22811
{{IFF{1,1{6,HSH01{{{22811
{{IFF{1,2{6,HSH02{{{22811
{{IFF{1,3{6,HSH03{{{22811
{{IFF{1,4{6,HSH04{{{22811
{{IFF{1,5{6,HSH05{{{22811
{{IFF{1,6{6,HSH06{{{22811
{{IFF{1,7{6,HSH07{{{22811
{{IFF{1,8{6,HSH08{{{22811
{{IFF{1,9{6,HSH09{{{22811
{{IFF{1,10{6,HSH10{{{22811
{{IFF{1,11{6,HSH11{{{22811
{{IFF{1,12{6,HSH12{{{22811
{{IFF{1,13{6,HSH13{{{22811
{{IFF{1,14{6,HSH14{{{22811
{{IFF{1,15{6,HSH15{{{22811
{{IFF{1,16{6,HSH16{{{22811
{{IFF{1,17{6,HSH17{{{22811
{{IFF{1,18{6,HSH18{{{22811
{{IFF{1,19{6,HSH19{{{22811
{{IFF{1,20{6,HSH20{{{22811
{{IFF{1,21{6,HSH21{{{22811
{{IFF{1,22{6,HSH22{{{22811
{{IFF{1,23{6,HSH23{{{22811
{{IFF{1,24{6,HSH24{{{22811
{{ESW{{{{{22811
{HSH24{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22812
{{LSH{8,WC{1,24{{SHIFT FOR HASH{22813
{{XOB{8,WB{8,WC{{HASH CHARACTER{22814
{HSH23{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22815
{{LSH{8,WC{1,16{{SHIFT FOR HASH{22816
{{XOB{8,WB{8,WC{{HASH CHARACTER{22817
{HSH22{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22818
{{LSH{8,WC{1,8{{SHIFT FOR HASH{22819
{{XOB{8,WB{8,WC{{HASH CHARACTER{22820
{HSH21{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22821
{{XOB{8,WB{8,WC{{HASH CHARACTER{22822
{HSH20{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22823
{{LSH{8,WC{1,24{{SHIFT FOR HASH{22824
{{XOB{8,WB{8,WC{{HASH CHARACTER{22825
{HSH19{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22826
{{LSH{8,WC{1,16{{SHIFT FOR HASH{22827
{{XOB{8,WB{8,WC{{HASH CHARACTER{22828
{HSH18{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22829
{{LSH{8,WC{1,8{{SHIFT FOR HASH{22830
{{XOB{8,WB{8,WC{{HASH CHARACTER{22831
{HSH17{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22832
{{XOB{8,WB{8,WC{{HASH CHARACTER{22833
{HSH16{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22834
{{LSH{8,WC{1,24{{SHIFT FOR HASH{22835
{{XOB{8,WB{8,WC{{HASH CHARACTER{22836
{HSH15{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22837
{{LSH{8,WC{1,16{{SHIFT FOR HASH{22838
{{XOB{8,WB{8,WC{{HASH CHARACTER{22839
{HSH14{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22840
{{LSH{8,WC{1,8{{SHIFT FOR HASH{22841
{{XOB{8,WB{8,WC{{HASH CHARACTER{22842
{HSH13{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22843
{{XOB{8,WB{8,WC{{HASH CHARACTER{22844
{HSH12{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22845
{{LSH{8,WC{1,24{{SHIFT FOR HASH{22846
{{XOB{8,WB{8,WC{{HASH CHARACTER{22847
{HSH11{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22848
{{LSH{8,WC{1,16{{SHIFT FOR HASH{22849
{{XOB{8,WB{8,WC{{HASH CHARACTER{22850
{HSH10{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22851
{{LSH{8,WC{1,8{{SHIFT FOR HASH{22852
{{XOB{8,WB{8,WC{{HASH CHARACTER{22853
{HSH09{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22854
{{XOB{8,WB{8,WC{{HASH CHARACTER{22855
{HSH08{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22856
{{LSH{8,WC{1,24{{SHIFT FOR HASH{22857
{{XOB{8,WB{8,WC{{HASH CHARACTER{22858
{HSH07{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22859
{{LSH{8,WC{1,16{{SHIFT FOR HASH{22860
{{XOB{8,WB{8,WC{{HASH CHARACTER{22861
{HSH06{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22862
{{LSH{8,WC{1,8{{SHIFT FOR HASH{22863
{{XOB{8,WB{8,WC{{HASH CHARACTER{22864
{HSH05{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22865
{{XOB{8,WB{8,WC{{HASH CHARACTER{22866
{HSH04{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22867
{{LSH{8,WC{1,24{{SHIFT FOR HASH{22868
{{XOB{8,WB{8,WC{{HASH CHARACTER{22869
{HSH03{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22870
{{LSH{8,WC{1,16{{SHIFT FOR HASH{22871
{{XOB{8,WB{8,WC{{HASH CHARACTER{22872
{HSH02{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22873
{{LSH{8,WC{1,8{{SHIFT FOR HASH{22874
{{XOB{8,WB{8,WC{{HASH CHARACTER{22875
{HSH01{LCH{8,WC{10,(XR)+{{LOAD NEXT CHARACTER{22876
{{XOB{8,WB{8,WC{{HASH CHARACTER{22877
{HSH00{MOV{7,XL{10,(XS)+{{RESTORE XL{22878
{{BRN{6,HSHS3{{{MERGE TO COMPLETE HASH{22879
{{ENP{{{{END PROCEDURE HASHS{22880
*
*      ICBLD -- BUILD INTEGER BLOCK
*
*      (IA)                  INTEGER VALUE FOR ICBLK
*      JSR  ICBLD            CALL TO BUILD INTEGER BLOCK
*      (XR)                  POINTER TO RESULT ICBLK
*      (WA)                  DESTROYED
*
{ICBLD{PRC{25,E{1,0{{ENTRY POINT{22889
{{MFI{7,XR{6,ICBL1{{COPY SMALL INTEGERS{22890
{{BLE{7,XR{18,=NUM02{6,ICBL3{JUMP IF 0,1 OR 2{22891
*
*      CONSTRUCT ICBLK
*
{ICBL1{MOV{7,XR{3,DNAMP{{LOAD POINTER TO NEXT AVAILABLE LOC{22895
{{ADD{7,XR{19,*ICSI_{{POINT PAST NEW ICBLK{22896
{{BLO{7,XR{3,DNAME{6,ICBL2{JUMP IF THERE IS ROOM{22897
{{MOV{8,WA{19,*ICSI_{{ELSE LOAD LENGTH OF ICBLK{22898
{{JSR{6,ALLOC{{{USE STANDARD ALLOCATOR TO GET BLOCK{22899
{{ADD{7,XR{8,WA{{POINT PAST BLOCK TO MERGE{22900
*
*      MERGE HERE WITH XR POINTING PAST THE BLOCK OBTAINED
*
{ICBL2{MOV{3,DNAMP{7,XR{{SET NEW POINTER{22904
{{SUB{7,XR{19,*ICSI_{{POINT BACK TO START OF BLOCK{22905
{{MOV{9,(XR){22,=B_ICL{{STORE TYPE WORD{22906
{{STI{13,ICVAL(XR){{{STORE INTEGER VALUE IN ICBLK{22907
{{EXI{{{{RETURN TO ICBLD CALLER{22908
*
*      OPTIMISE BY NOT BUILDING ICBLKS FOR SMALL INTEGERS
*
{ICBL3{WTB{7,XR{{{CONVERT INTEGER TO OFFSET{22912
{{MOV{7,XR{14,INTAB(XR){{POINT TO PRE-BUILT ICBLK{22913
{{EXI{{{{RETURN{22914
{{ENP{{{{END PROCEDURE ICBLD{22915
{{EJC{{{{{22916
*
*      IDENT -- COMPARE TWO VALUES
*
*      IDENT COMPARES TWO VALUES IN THE SENSE OF THE IDENT
*      DIFFER FUNCTIONS AVAILABLE AT THE SNOBOL LEVEL.
*
*      (XR)                  FIRST ARGUMENT
*      (XL)                  SECOND ARGUMENT
*      JSR  IDENT            CALL TO COMPARE ARGUMENTS
*      PPM  LOC              TRANSFER LOC IF IDENT
*      (NORMAL RETURN IF DIFFER)
*      (XR,XL,WC,RA)         DESTROYED
*
{IDENT{PRC{25,E{1,1{{ENTRY POINT{22930
{{BEQ{7,XR{7,XL{6,IDEN7{JUMP IF SAME POINTER (IDENT){22931
{{MOV{8,WC{9,(XR){{ELSE LOAD ARG 1 TYPE WORD{22932
{{BNE{8,WC{9,(XL){6,IDEN1{DIFFER IF ARG 2 TYPE WORD DIFFER{22934
{{BEQ{8,WC{22,=B_SCL{6,IDEN2{JUMP IF STRINGS{22938
{{BEQ{8,WC{22,=B_ICL{6,IDEN4{JUMP IF INTEGERS{22939
{{BEQ{8,WC{22,=B_RCL{6,IDEN5{JUMP IF REALS{22942
{{BEQ{8,WC{22,=B_NML{6,IDEN6{JUMP IF NAMES{22944
*
*      FOR ALL OTHER DATATYPES, MUST BE DIFFER IF XR NE XL
*
*      MERGE HERE FOR DIFFER
*
{IDEN1{EXI{{{{TAKE DIFFER EXIT{22987
*
*      HERE FOR STRINGS, IDENT ONLY IF LENGTHS AND CHARS SAME
*
{IDEN2{MOV{8,WC{13,SCLEN(XR){{LOAD ARG 1 LENGTH{22991
{{BNE{8,WC{13,SCLEN(XL){6,IDEN1{DIFFER IF LENGTHS DIFFER{22992
*
*      BUFFER AND STRING COMPARISONS MERGE HERE
*
{IDN2A{ADD{7,XR{19,*SCHAR{{POINT TO CHARS OF ARG 1{22996
{{ADD{7,XL{19,*SCHAR{{POINT TO CHARS OF ARG 2{22997
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS IN STRINGS{22998
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{22999
*
*      LOOP TO COMPARE CHARACTERS. NOTE THAT WC CANNOT BE ZERO
*      SINCE ALL NULL STRINGS POINT TO NULLS AND GIVE XL=XR.
*
{IDEN3{CNE{9,(XR){9,(XL){6,IDEN8{DIFFER IF CHARS DO NOT MATCH{23004
{{ICA{7,XR{{{ELSE BUMP ARG ONE POINTER{23005
{{ICA{7,XL{{{BUMP ARG TWO POINTER{23006
{{BCT{8,WC{6,IDEN3{{LOOP BACK TILL ALL CHECKED{23007
{{EJC{{{{{23008
*
*      IDENT (CONTINUED)
*
*      HERE TO EXIT FOR CASE OF TWO IDENT STRINGS
*
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{23014
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{23015
{{EXI{1,1{{{TAKE IDENT EXIT{23016
*
*      HERE FOR INTEGERS, IDENT IF SAME VALUES
*
{IDEN4{LDI{13,ICVAL(XR){{{LOAD ARG 1{23020
{{SBI{13,ICVAL(XL){{{SUBTRACT ARG 2 TO COMPARE{23021
{{IOV{6,IDEN1{{{DIFFER IF OVERFLOW{23022
{{INE{6,IDEN1{{{DIFFER IF RESULT IS NOT ZERO{23023
{{EXI{1,1{{{TAKE IDENT EXIT{23024
*
*      HERE FOR REALS, IDENT IF SAME VALUES
*
{IDEN5{LDR{13,RCVAL(XR){{{LOAD ARG 1{23030
{{SBR{13,RCVAL(XL){{{SUBTRACT ARG 2 TO COMPARE{23031
{{ROV{6,IDEN1{{{DIFFER IF OVERFLOW{23032
{{RNE{6,IDEN1{{{DIFFER IF RESULT IS NOT ZERO{23033
{{EXI{1,1{{{TAKE IDENT EXIT{23034
*
*      HERE FOR NAMES, IDENT IF BASES AND OFFSETS SAME
*
{IDEN6{BNE{13,NMOFS(XR){13,NMOFS(XL){6,IDEN1{DIFFER IF DIFFERENT OFFSET{23039
{{BNE{13,NMBAS(XR){13,NMBAS(XL){6,IDEN1{DIFFER IF DIFFERENT BASE{23040
*
*      MERGE HERE TO SIGNAL IDENT FOR IDENTICAL POINTERS
*
{IDEN7{EXI{1,1{{{TAKE IDENT EXIT{23044
*
*      HERE FOR DIFFER STRINGS
*
{IDEN8{ZER{7,XR{{{CLEAR GARBAGE PTR IN XR{23048
{{ZER{7,XL{{{CLEAR GARBAGE PTR IN XL{23049
{{EXI{{{{RETURN TO CALLER (DIFFER){23050
{{ENP{{{{END PROCEDURE IDENT{23051
{{EJC{{{{{23052
*
*      INOUT - USED TO INITIALISE INPUT AND OUTPUT VARIABLES
*
*      (XL)                  POINTER TO VBL NAME STRING
*      (WB)                  TRBLK TYPE
*      JSR  INOUT            CALL TO PERFORM INITIALISATION
*      (XL)                  VRBLK PTR
*      (XR)                  TRBLK PTR
*      (WA,WC)               DESTROYED
*
*      NOTE THAT TRTER (= TRTRF) FIELD OF STANDARD I/O VARIABLES
*      POINTS TO CORRESPONDING SVBLK NOT TO A TRBLK AS IS THE
*      CASE FOR ORDINARY VARIABLES.
*
{INOUT{PRC{25,E{1,0{{ENTRY POINT{23067
{{MOV{11,-(XS){8,WB{{STACK TRBLK TYPE{23068
{{MOV{8,WA{13,SCLEN(XL){{GET NAME LENGTH{23069
{{ZER{8,WB{{{POINT TO START OF NAME{23070
{{JSR{6,SBSTR{{{BUILD A PROPER SCBLK{23071
{{JSR{6,GTNVR{{{BUILD VRBLK{23072
{{PPM{{{{NO ERROR RETURN{23073
{{MOV{8,WC{7,XR{{SAVE VRBLK POINTER{23074
{{MOV{8,WB{10,(XS)+{{GET TRTER FIELD{23075
{{ZER{7,XL{{{ZERO TRFPT{23076
{{JSR{6,TRBLD{{{BUILD TRBLK{23077
{{MOV{7,XL{8,WC{{RECALL VRBLK POINTER{23078
{{MOV{13,TRTER(XR){13,VRSVP(XL){{STORE SVBLK POINTER{23079
{{MOV{13,VRVAL(XL){7,XR{{STORE TRBLK PTR IN VRBLK{23080
{{MOV{13,VRGET(XL){22,=B_VRA{{SET TRAPPED ACCESS{23081
{{MOV{13,VRSTO(XL){22,=B_VRV{{SET TRAPPED STORE{23082
{{EXI{{{{RETURN TO CALLER{23083
{{ENP{{{{END PROCEDURE INOUT{23084
{{EJC{{{{{23085
*
*      INSTA - USED TO INITIALIZE STRUCTURES IN STATIC REGION
*
*      (XR)                  POINTER TO STARTING STATIC LOCATION
*      JSR  INSTA            CALL TO INITIALIZE STATIC STRUCTURE
*      (XR)                  PTR TO NEXT FREE STATIC LOCATION
*      (WA,WB,WC)            DESTROYED
*
*      NOTE THAT THIS PROCEDURE ESTABLISHES THE POINTERS
*      PRBUF, GTSWK, AND KVALP.
*
{INSTA{PRC{25,E{1,0{{ENTRY POINT{23264
*
*      INITIALIZE PRINT BUFFER WITH BLANK WORDS
*
*Z-
{{MOV{8,WC{3,PRLEN{{NO. OF CHARS IN PRINT BFR{23269
{{MOV{3,PRBUF{7,XR{{PRINT BFR IS PUT AT STATIC START{23270
{{MOV{10,(XR)+{22,=B_SCL{{STORE STRING TYPE CODE{23271
{{MOV{10,(XR)+{8,WC{{AND STRING LENGTH{23272
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS IN BUFFER{23273
{{MOV{3,PRLNW{8,WC{{STORE FOR BUFFER CLEAR{23274
{{LCT{8,WC{8,WC{{WORDS TO CLEAR{23275
*
*      LOOP TO CLEAR BUFFER
*
{INST1{MOV{10,(XR)+{4,NULLW{{STORE BLANK{23279
{{BCT{8,WC{6,INST1{{LOOP{23280
*
*      ALLOCATE WORK AREA FOR GTSTG CONVERSION PROCEDURE
*
{{MOV{8,WA{18,=NSTMX{{GET MAX NUM CHARS IN OUTPUT NUMBER{23284
{{CTB{8,WA{2,SCSI_{{NO OF BYTES NEEDED{23285
{{MOV{3,GTSWK{7,XR{{STORE BFR ADRS{23286
{{ADD{7,XR{8,WA{{BUMP FOR WORK BFR{23287
*
*      BUILD ALPHABET STRING FOR ALPHABET KEYWORD AND REPLACE
*
{{MOV{3,KVALP{7,XR{{SAVE ALPHABET POINTER{23291
{{MOV{9,(XR){22,=B_SCL{{STRING BLK TYPE{23292
{{MOV{8,WC{18,=CFP_A{{NO OF CHARS IN ALPHABET{23293
{{MOV{13,SCLEN(XR){8,WC{{STORE AS STRING LENGTH{23294
{{MOV{8,WB{8,WC{{COPY CHAR COUNT{23295
{{CTB{8,WB{2,SCSI_{{NO. OF BYTES NEEDED{23296
{{ADD{8,WB{7,XR{{CURRENT END ADDRESS FOR STATIC{23297
{{MOV{8,WA{8,WB{{SAVE ADRS PAST ALPHABET STRING{23298
{{LCT{8,WC{8,WC{{LOOP COUNTER{23299
{{PSC{7,XR{{{POINT TO CHARS OF STRING{23300
{{ZER{8,WB{{{SET INITIAL CHARACTER VALUE{23301
*
*      LOOP TO ENTER CHARACTER CODES IN ORDER
*
{INST2{SCH{8,WB{10,(XR)+{{STORE NEXT CODE{23305
{{ICV{8,WB{{{BUMP CODE VALUE{23306
{{BCT{8,WC{6,INST2{{LOOP TILL ALL STORED{23307
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{23308
{{MOV{7,XR{8,WA{{RETURN CURRENT STATIC PTR{23309
*Z+
{{EXI{{{{RETURN TO CALLER{23311
{{ENP{{{{END PROCEDURE INSTA{23312
{{EJC{{{{{23313
*
*      IOFCB -- GET INPUT/OUTPUT FCBLK POINTER
*
*      USED BY ENDFILE, EJECT AND REWIND TO FIND THE FCBLK
*      (IF ANY) CORRESPONDING TO THEIR ARGUMENT.
*
*      -(XS)                 ARGUMENT
*      JSR  IOFCB            CALL TO FIND FCBLK
*      PPM  LOC              ARG IS AN UNSUITABLE NAME
*      PPM  LOC              ARG IS NULL STRING
*      PPM  LOC              ARG FILE NOT FOUND
*      (XS)                  POPPED
*      (XL)                  PTR TO FILEARG1 VRBLK
*      (XR)                  ARGUMENT
*      (WA)                  FCBLK PTR OR 0
*      (WB,WC)               DESTROYED
*
{IOFCB{PRC{25,N{1,3{{ENTRY POINT{23331
{{JSR{6,GTSTG{{{GET ARG AS STRING{23332
{{PPM{6,IOFC2{{{FAIL{23333
{{MOV{7,XL{7,XR{{COPY STRING PTR{23334
{{JSR{6,GTNVR{{{GET AS NATURAL VARIABLE{23335
{{PPM{6,IOFC3{{{FAIL IF NULL{23336
{{MOV{8,WB{7,XL{{COPY STRING POINTER AGAIN{23337
{{MOV{7,XL{7,XR{{COPY VRBLK PTR FOR RETURN{23338
{{ZER{8,WA{{{IN CASE NO TRBLK FOUND{23339
*
*      LOOP TO FIND FILE ARG1 TRBLK
*
{IOFC1{MOV{7,XR{13,VRVAL(XR){{GET POSSIBLE TRBLK PTR{23343
{{BNE{9,(XR){22,=B_TRT{6,IOFC4{FAIL IF END OF CHAIN{23344
{{BNE{13,TRTYP(XR){18,=TRTFC{6,IOFC1{LOOP IF NOT FILE ARG TRBLK{23345
{{MOV{8,WA{13,TRFPT(XR){{GET FCBLK PTR{23346
{{MOV{7,XR{8,WB{{COPY ARG{23347
{{EXI{{{{RETURN{23348
*
*      FAIL RETURN
*
{IOFC2{EXI{1,1{{{FAIL{23352
*
*      NULL ARG
*
{IOFC3{EXI{1,2{{{NULL ARG RETURN{23356
*
*      FILE NOT FOUND
*
{IOFC4{EXI{1,3{{{FILE NOT FOUND RETURN{23360
{{ENP{{{{END PROCEDURE IOFCB{23361
{{EJC{{{{{23362
*
*      IOPPF -- PROCESS FILEARG2 FOR IOPUT
*
*      (R_XSC)               FILEARG2 PTR
*      JSR  IOPPF            CALL TO PROCESS FILEARG2
*      (XL)                  FILEARG1 PTR
*      (XR)                  FILE ARG2 PTR
*      -(XS)...-(XS)         FIELDS EXTRACTED FROM FILEARG2
*      (WC)                  NO. OF FIELDS EXTRACTED
*      (WB)                  INPUT/OUTPUT FLAG
*      (WA)                  FCBLK PTR OR 0
*
{IOPPF{PRC{25,N{1,0{{ENTRY POINT{23375
{{ZER{8,WB{{{TO COUNT FIELDS EXTRACTED{23376
*
*      LOOP TO EXTRACT FIELDS
*
{IOPP1{MOV{7,XL{18,=IODEL{{GET DELIMITER{23380
{{MOV{8,WC{7,XL{{COPY IT{23381
{{ZER{8,WA{{{RETAIN LEADING BLANKS IN FILEARG2{23382
{{JSR{6,XSCAN{{{GET NEXT FIELD{23383
{{MOV{11,-(XS){7,XR{{STACK IT{23384
{{ICV{8,WB{{{INCREMENT COUNT{23385
{{BNZ{8,WA{6,IOPP1{{LOOP{23386
{{MOV{8,WC{8,WB{{COUNT OF FIELDS{23387
{{MOV{8,WB{3,IOPTT{{I/O MARKER{23388
{{MOV{8,WA{3,R_IOF{{FCBLK PTR OR 0{23389
{{MOV{7,XR{3,R_IO2{{FILE ARG2 PTR{23390
{{MOV{7,XL{3,R_IO1{{FILEARG1{23391
{{EXI{{{{RETURN{23392
{{ENP{{{{END PROCEDURE IOPPF{23393
{{EJC{{{{{23394
*
*      IOPUT -- ROUTINE USED BY INPUT AND OUTPUT
*
*      IOPUT SETS UP INPUT/OUTPUT  ASSOCIATIONS. IT BUILDS
*      SUCH TRACE AND FILE CONTROL BLOCKS AS ARE NECESSARY AND
*      CALLS SYSFC,SYSIO TO PERFORM CHECKS ON THE
*      ARGUMENTS AND TO OPEN THE FILES.
*
*         +-----------+   +---------------+       +-----------+
*      +-.I           I   I               I------.I   =B_XRT  I
*      I  +-----------+   +---------------+       +-----------+
*      I  /           /        (R_FCB)            I    *4     I
*      I  /           /                           +-----------+
*      I  +-----------+   +---------------+       I           I-
*      I  I   NAME    +--.I    =B_TRT     I       +-----------+
*      I  /           /   +---------------+       I           I
*      I   (FIRST ARG)    I =TRTIN/=TRTOU I       +-----------+
*      I                  +---------------+             I
*      I                  I     VALUE     I             I
*      I                  +---------------+             I
*      I                  I(TRTRF) 0   OR I--+          I
*      I                  +---------------+  I          I
*      I                  I(TRFPT) 0   OR I----+        I
*      I                  +---------------+  I I        I
*      I                     (I/O TRBLK)     I I        I
*      I  +-----------+                      I I        I
*      I  I           I                      I I        I
*      I  +-----------+                      I I        I
*      I  I           I                      I I        I
*      I  +-----------+   +---------------+  I I        I
*      I  I           +--.I    =B_TRT     I.-+ I        I
*      I  +-----------+   +---------------+    I        I
*      I  /           /   I    =TRTFC     I    I        I
*      I  /           /   +---------------+    I        I
*      I    (FILEARG1     I     VALUE     I    I        I
*      I         VRBLK)   +---------------+    I        I
*      I                  I(TRTRF) 0   OR I--+ I        .
*      I                  +---------------+  I .  +-----------+
*      I                  I(TRFPT) 0   OR I------./   FCBLK   /
*      I                  +---------------+  I    +-----------+
*      I                       (TRTRF)       I
*      I                                     I
*      I                                     I
*      I                  +---------------+  I
*      I                  I    =B_XRT     I.-+
*      I                  +---------------+
*      I                  I      *5       I
*      I                  +---------------+
*      +------------------I               I
*                         +---------------+       +-----------+
*                         I(TRTRF) O   OR I------.I  =B_XRT   I
*                         +---------------+       +-----------+
*                         I  NAME OFFSET  I       I    ETC    I
*                         +---------------+
*                           (IOCHN - CHAIN OF NAME POINTERS)
{{EJC{{{{{23450
*
*      IOPUT (CONTINUED)
*
*      NO ADDITIONAL TRAP BLOCKS ARE USED FOR STANDARD INPUT/OUT
*      FILES. OTHERWISE AN I/O TRAP BLOCK IS ATTACHED TO SECOND
*      ARG (FILEARG1) VRBLK. SEE DIAGRAM ABOVE FOR DETAILS OF
*      THE STRUCTURE BUILT.
*
*      -(XS)                 1ST ARG (VBL TO BE ASSOCIATED)
*      -(XS)                 2ND ARG (FILE ARG1)
*      -(XS)                 3RD ARG (FILE ARG2)
*      (WB)                  0 FOR INPUT, 3 FOR OUTPUT ASSOC.
*      JSR  IOPUT            CALL FOR INPUT/OUTPUT ASSOCIATION
*      PPM  LOC              3RD ARG NOT A STRING
*      PPM  LOC              2ND ARG NOT A SUITABLE NAME
*      PPM  LOC              1ST ARG NOT A SUITABLE NAME
*      PPM  LOC              INAPPROPRIATE FILE SPEC FOR I/O
*      PPM  LOC              I/O FILE DOES NOT EXIST
*      PPM  LOC              I/O FILE CANNOT BE READ/WRITTEN
*      PPM  LOC              I/O FCBLK CURRENTLY IN USE
*      (XS)                  POPPED
*      (XL,XR,WA,WB,WC)      DESTROYED
*
{IOPUT{PRC{25,N{1,7{{ENTRY POINT{23474
{{ZER{3,R_IOT{{{IN CASE NO TRTRF BLOCK USED{23475
{{ZER{3,R_IOF{{{IN CASE NO FCBLK ALOCATED{23476
{{ZER{3,R_IOP{{{IN CASE SYSIO FAILS{23477
{{MOV{3,IOPTT{8,WB{{STORE I/O TRACE TYPE{23478
{{JSR{6,XSCNI{{{PREPARE TO SCAN FILEARG2{23479
{{PPM{6,IOP13{{{FAIL{23480
{{PPM{6,IOPA0{{{NULL FILE ARG2{23481
*
{IOPA0{MOV{3,R_IO2{7,XR{{KEEP FILE ARG2{23483
{{MOV{7,XL{8,WA{{COPY LENGTH{23484
{{JSR{6,GTSTG{{{CONVERT FILEARG1 TO STRING{23485
{{PPM{6,IOP14{{{FAIL{23486
{{MOV{3,R_IO1{7,XR{{KEEP FILEARG1 PTR{23487
{{JSR{6,GTNVR{{{CONVERT TO NATURAL VARIABLE{23488
{{PPM{6,IOP00{{{JUMP IF NULL{23489
{{BRN{6,IOP04{{{JUMP TO PROCESS NON-NULL ARGS{23490
*
*      NULL FILEARG1
*
{IOP00{BZE{7,XL{6,IOP01{{SKIP IF BOTH ARGS NULL{23494
{{JSR{6,IOPPF{{{PROCESS FILEARG2{23495
{{JSR{6,SYSFC{{{CALL FOR FILEARG2 CHECK{23496
{{PPM{6,IOP16{{{FAIL{23497
{{PPM{6,IOP26{{{FAIL{23498
{{BRN{6,IOP11{{{COMPLETE FILE ASSOCIATION{23499
{{EJC{{{{{23500
*
*      IOPUT (CONTINUED)
*
*      HERE WITH 0 OR FCBLK PTR IN (XL)
*
{IOP01{MOV{8,WB{3,IOPTT{{GET TRACE TYPE{23506
{{MOV{7,XR{3,R_IOT{{GET 0 OR TRTRF PTR{23507
{{JSR{6,TRBLD{{{BUILD TRBLK{23508
{{MOV{8,WC{7,XR{{COPY TRBLK POINTER{23509
{{MOV{7,XR{10,(XS)+{{GET VARIABLE FROM STACK{23510
{{MOV{11,-(XS){8,WC{{MAKE TRBLK COLLECTABLE{23511
{{JSR{6,GTVAR{{{POINT TO VARIABLE{23512
{{PPM{6,IOP15{{{FAIL{23513
{{MOV{8,WC{10,(XS)+{{RECOVER TRBLK POINTER{23514
{{MOV{3,R_ION{7,XL{{SAVE NAME POINTER{23515
{{MOV{7,XR{7,XL{{COPY NAME POINTER{23516
{{ADD{7,XR{8,WA{{POINT TO VARIABLE{23517
{{SUB{7,XR{19,*VRVAL{{SUBTRACT OFFSET,MERGE INTO LOOP{23518
*
*      LOOP TO END OF TRBLK CHAIN IF ANY
*
{IOP02{MOV{7,XL{7,XR{{COPY BLK PTR{23522
{{MOV{7,XR{13,VRVAL(XR){{LOAD PTR TO NEXT TRBLK{23523
{{BNE{9,(XR){22,=B_TRT{6,IOP03{JUMP IF NOT TRAPPED{23524
{{BNE{13,TRTYP(XR){3,IOPTT{6,IOP02{LOOP IF NOT SAME ASSOCN{23525
{{MOV{7,XR{13,TRNXT(XR){{GET VALUE AND DELETE OLD TRBLK{23526
*
*      IOPUT (CONTINUED)
*
*      STORE NEW ASSOCIATION
*
{IOP03{MOV{13,VRVAL(XL){8,WC{{LINK TO THIS TRBLK{23532
{{MOV{7,XL{8,WC{{COPY POINTER{23533
{{MOV{13,TRNXT(XL){7,XR{{STORE VALUE IN TRBLK{23534
{{MOV{7,XR{3,R_ION{{RESTORE POSSIBLE VRBLK POINTER{23535
{{MOV{8,WB{8,WA{{KEEP OFFSET TO NAME{23536
{{JSR{6,SETVR{{{IF VRBLK, SET VRGET,VRSTO{23537
{{MOV{7,XR{3,R_IOT{{GET 0 OR TRTRF PTR{23538
{{BNZ{7,XR{6,IOP19{{JUMP IF TRTRF BLOCK EXISTS{23539
{{EXI{{{{RETURN TO CALLER{23540
*
*      NON STANDARD FILE
*      SEE IF AN FCBLK HAS ALREADY BEEN ALLOCATED.
*
{IOP04{ZER{8,WA{{{IN CASE NO FCBLK FOUND{23545
{{EJC{{{{{23546
*
*      IOPUT (CONTINUED)
*
*      SEARCH POSSIBLE TRBLK CHAIN TO PICK UP THE FCBLK
*
{IOP05{MOV{8,WB{7,XR{{REMEMBER BLK PTR{23552
{{MOV{7,XR{13,VRVAL(XR){{CHAIN ALONG{23553
{{BNE{9,(XR){22,=B_TRT{6,IOP06{JUMP IF END OF TRBLK CHAIN{23554
{{BNE{13,TRTYP(XR){18,=TRTFC{6,IOP05{LOOP IF MORE TO GO{23555
{{MOV{3,R_IOT{7,XR{{POINT TO FILE ARG1 TRBLK{23556
{{MOV{8,WA{13,TRFPT(XR){{GET FCBLK PTR FROM TRBLK{23557
*
*      WA = 0 OR FCBLK PTR
*      WB = PTR TO PRECEDING BLK TO WHICH ANY TRTRF BLOCK
*           FOR FILE ARG1 MUST BE CHAINED.
*
{IOP06{MOV{3,R_IOF{8,WA{{KEEP POSSIBLE FCBLK PTR{23563
{{MOV{3,R_IOP{8,WB{{KEEP PRECEDING BLK PTR{23564
{{JSR{6,IOPPF{{{PROCESS FILEARG2{23565
{{JSR{6,SYSFC{{{SEE IF FCBLK REQUIRED{23566
{{PPM{6,IOP16{{{FAIL{23567
{{PPM{6,IOP26{{{FAIL{23568
{{BZE{8,WA{6,IOP12{{SKIP IF NO NEW FCBLK WANTED{23569
{{BLT{8,WC{18,=NUM02{6,IOP6A{JUMP IF FCBLK IN DYNAMIC{23570
{{JSR{6,ALOST{{{GET IT IN STATIC{23571
{{BRN{6,IOP6B{{{SKIP{23572
*
*      OBTAIN FCBLK IN DYNAMIC
*
{IOP6A{JSR{6,ALLOC{{{GET SPACE FOR FCBLK{23576
*
*      MERGE
*
{IOP6B{MOV{7,XL{7,XR{{POINT TO FCBLK{23580
{{MOV{8,WB{8,WA{{COPY ITS LENGTH{23581
{{BTW{8,WB{{{GET COUNT AS WORDS (SGD APR80){23582
{{LCT{8,WB{8,WB{{LOOP COUNTER{23583
*
*      CLEAR FCBLK
*
{IOP07{ZER{10,(XR)+{{{CLEAR A WORD{23587
{{BCT{8,WB{6,IOP07{{LOOP{23588
{{BEQ{8,WC{18,=NUM02{6,IOP09{SKIP IF IN STATIC - DONT SET FIELDS{23589
{{MOV{9,(XL){22,=B_XNT{{STORE XNBLK CODE IN CASE{23590
{{MOV{13,NUM01(XL){8,WA{{STORE LENGTH{23591
{{BNZ{8,WC{6,IOP09{{JUMP IF XNBLK WANTED{23592
{{MOV{9,(XL){22,=B_XRT{{XRBLK CODE REQUESTED{23593
*
{{EJC{{{{{23595
*      IOPUT (CONTINUED)
*
*      COMPLETE FCBLK INITIALISATION
*
{IOP09{MOV{7,XR{3,R_IOT{{GET POSSIBLE TRBLK PTR{23600
{{MOV{3,R_IOF{7,XL{{STORE FCBLK PTR{23601
{{BNZ{7,XR{6,IOP10{{JUMP IF TRBLK ALREADY FOUND{23602
*
*      A NEW TRBLK IS NEEDED
*
{{MOV{8,WB{18,=TRTFC{{TRTYP FOR FCBLK TRAP BLK{23606
{{JSR{6,TRBLD{{{MAKE THE BLOCK{23607
{{MOV{3,R_IOT{7,XR{{COPY TRTRF PTR{23608
{{MOV{7,XL{3,R_IOP{{POINT TO PRECEDING BLK{23609
{{MOV{13,VRVAL(XR){13,VRVAL(XL){{COPY VALUE FIELD TO TRBLK{23610
{{MOV{13,VRVAL(XL){7,XR{{LINK NEW TRBLK INTO CHAIN{23611
{{MOV{7,XR{7,XL{{POINT TO PREDECESSOR BLK{23612
{{JSR{6,SETVR{{{SET TRACE INTERCEPTS{23613
{{MOV{7,XR{13,VRVAL(XR){{RECOVER TRBLK PTR{23614
{{BRN{6,IOP1A{{{STORE FCBLK PTR{23615
*
*      HERE IF EXISTING TRBLK
*
{IOP10{ZER{3,R_IOP{{{DO NOT RELEASE IF SYSIO FAILS{23619
*
*      XR IS PTR TO TRBLK, XL IS FCBLK PTR OR 0
*
{IOP1A{MOV{13,TRFPT(XR){3,R_IOF{{STORE FCBLK PTR{23623
*
*      CALL SYSIO TO COMPLETE FILE ACCESSING
*
{IOP11{MOV{8,WA{3,R_IOF{{COPY FCBLK PTR OR 0{23627
{{MOV{8,WB{3,IOPTT{{GET INPUT/OUTPUT FLAG{23628
{{MOV{7,XR{3,R_IO2{{GET FILE ARG2{23629
{{MOV{7,XL{3,R_IO1{{GET FILE ARG1{23630
{{JSR{6,SYSIO{{{ASSOCIATE TO THE FILE{23631
{{PPM{6,IOP17{{{FAIL{23632
{{PPM{6,IOP18{{{FAIL{23633
{{BNZ{3,R_IOT{6,IOP01{{NOT STD INPUT IF NON-NULL TRTRF BLK{23634
{{BNZ{3,IOPTT{6,IOP01{{JUMP IF OUTPUT{23635
{{BZE{8,WC{6,IOP01{{NO CHANGE TO STANDARD READ LENGTH{23636
{{MOV{3,CSWIN{8,WC{{STORE NEW READ LENGTH FOR STD FILE{23637
{{BRN{6,IOP01{{{MERGE TO FINISH THE TASK{23638
*
*      SYSFC MAY HAVE RETURNED A POINTER TO A PRIVATE FCBLK
*
{IOP12{BNZ{7,XL{6,IOP09{{JUMP IF PRIVATE FCBLK{23642
{{BRN{6,IOP11{{{FINISH THE ASSOCIATION{23643
*
*      FAILURE RETURNS
*
{IOP13{EXI{1,1{{{3RD ARG NOT A STRING{23647
{IOP14{EXI{1,2{{{2ND ARG UNSUITABLE{23648
{IOP15{ICA{7,XS{{{DISCARD TRBLK POINTER{23649
{{EXI{1,3{{{1ST ARG UNSUITABLE{23650
{IOP16{EXI{1,4{{{FILE SPEC WRONG{23651
{IOP26{EXI{1,7{{{FCBLK IN USE{23652
*
*      I/O FILE DOES NOT EXIST
*
{IOP17{MOV{7,XR{3,R_IOP{{IS THERE A TRBLK TO RELEASE{23656
{{BZE{7,XR{6,IOPA7{{IF NOT{23657
{{MOV{7,XL{13,VRVAL(XR){{POINT TO TRBLK{23658
{{MOV{13,VRVAL(XR){13,VRVAL(XL){{UNSPLICE IT{23659
{{JSR{6,SETVR{{{ADJUST TRACE INTERCEPTS{23660
{IOPA7{EXI{1,5{{{I/O FILE DOES NOT EXIST{23661
*
*      I/O FILE CANNOT BE READ/WRITTEN
*
{IOP18{MOV{7,XR{3,R_IOP{{IS THERE A TRBLK TO RELEASE{23665
{{BZE{7,XR{6,IOPA7{{IF NOT{23666
{{MOV{7,XL{13,VRVAL(XR){{POINT TO TRBLK{23667
{{MOV{13,VRVAL(XR){13,VRVAL(XL){{UNSPLICE IT{23668
{{JSR{6,SETVR{{{ADJUST TRACE INTERCEPTS{23669
{IOPA8{EXI{1,6{{{I/O FILE CANNOT BE READ/WRITTEN{23670
{{EJC{{{{{23671
*
*      IOPUT (CONTINUED)
*
*      ADD TO IOCHN CHAIN OF ASSOCIATED VARIABLES UNLESS
*      ALREADY PRESENT.
*
{IOP19{MOV{8,WC{3,R_ION{{WC = NAME BASE, WB = NAME OFFSET{23678
*
*      SEARCH LOOP
*
{IOP20{MOV{7,XR{13,TRTRF(XR){{NEXT LINK OF CHAIN{23682
{{BZE{7,XR{6,IOP21{{NOT FOUND{23683
{{BNE{8,WC{13,IONMB(XR){6,IOP20{NO MATCH{23684
{{BEQ{8,WB{13,IONMO(XR){6,IOP22{EXIT IF MATCHED{23685
{{BRN{6,IOP20{{{LOOP{23686
*
*      NOT FOUND
*
{IOP21{MOV{8,WA{19,*NUM05{{SPACE NEEDED{23690
{{JSR{6,ALLOC{{{GET IT{23691
{{MOV{9,(XR){22,=B_XRT{{STORE XRBLK CODE{23692
{{MOV{13,NUM01(XR){8,WA{{STORE LENGTH{23693
{{MOV{13,IONMB(XR){8,WC{{STORE NAME BASE{23694
{{MOV{13,IONMO(XR){8,WB{{STORE NAME OFFSET{23695
{{MOV{7,XL{3,R_IOT{{POINT TO TRTRF BLK{23696
{{MOV{8,WA{13,TRTRF(XL){{GET PTR FIELD CONTENTS{23697
{{MOV{13,TRTRF(XL){7,XR{{STORE PTR TO NEW BLOCK{23698
{{MOV{13,TRTRF(XR){8,WA{{COMPLETE THE LINKING{23699
*
*      INSERT FCBLK ON FCBLK CHAIN FOR SYSEJ, SYSXI
*
{IOP22{BZE{3,R_IOF{6,IOP25{{SKIP IF NO FCBLK{23703
{{MOV{7,XL{3,R_FCB{{PTR TO HEAD OF EXISTING CHAIN{23704
*
*      SEE IF FCBLK ALREADY ON CHAIN
*
{IOP23{BZE{7,XL{6,IOP24{{NOT ON IF END OF CHAIN{23708
{{BEQ{13,NUM03(XL){3,R_IOF{6,IOP25{DONT DUPLICATE IF FIND IT{23709
{{MOV{7,XL{13,NUM02(XL){{GET NEXT LINK{23710
{{BRN{6,IOP23{{{LOOP{23711
*
*      NOT FOUND SO ADD AN ENTRY FOR THIS FCBLK
*
{IOP24{MOV{8,WA{19,*NUM04{{SPACE NEEDED{23715
{{JSR{6,ALLOC{{{GET IT{23716
{{MOV{9,(XR){22,=B_XRT{{STORE BLOCK CODE{23717
{{MOV{13,NUM01(XR){8,WA{{STORE LENGTH{23718
{{MOV{13,NUM02(XR){3,R_FCB{{STORE PREVIOUS LINK IN THIS NODE{23719
{{MOV{13,NUM03(XR){3,R_IOF{{STORE FCBLK PTR{23720
{{MOV{3,R_FCB{7,XR{{INSERT NODE INTO FCBLK CHAIN{23721
*
*      RETURN
*
{IOP25{EXI{{{{RETURN TO CALLER{23725
{{ENP{{{{END PROCEDURE IOPUT{23726
{{EJC{{{{{23727
*
*      KTREX -- EXECUTE KEYWORD TRACE
*
*      KTREX IS USED TO EXECUTE A POSSIBLE KEYWORD TRACE. IT
*      INCLUDES THE TEST ON TRACE AND TESTS FOR TRACE ACTIVE.
*
*      (XL)                  PTR TO TRBLK (OR 0 IF UNTRACED)
*      JSR  KTREX            CALL TO EXECUTE KEYWORD TRACE
*      (XL,WA,WB,WC)         DESTROYED
*      (RA)                  DESTROYED
*
{KTREX{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE){23739
{{BZE{7,XL{6,KTRX3{{IMMEDIATE EXIT IF KEYWORD UNTRACED{23740
{{BZE{3,KVTRA{6,KTRX3{{IMMEDIATE EXIT IF TRACE = 0{23741
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE{23742
{{MOV{11,-(XS){7,XR{{SAVE XR{23743
{{MOV{7,XR{7,XL{{COPY TRBLK POINTER{23744
{{MOV{7,XL{13,TRKVR(XR){{LOAD VRBLK POINTER (NMBAS){23745
{{MOV{8,WA{19,*VRVAL{{SET NAME OFFSET{23746
{{BZE{13,TRFNC(XR){6,KTRX1{{JUMP IF PRINT TRACE{23747
{{JSR{6,TRXEQ{{{ELSE EXECUTE FULL TRACE{23748
{{BRN{6,KTRX2{{{AND JUMP TO EXIT{23749
*
*      HERE FOR PRINT TRACE
*
{KTRX1{MOV{11,-(XS){7,XL{{STACK VRBLK PTR FOR KWNAM{23753
{{MOV{11,-(XS){8,WA{{STACK OFFSET FOR KWNAM{23754
{{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{23755
{{MOV{8,WA{18,=CH_AM{{LOAD AMPERSAND{23756
{{JSR{6,PRTCH{{{PRINT AMPERSAND{23757
{{JSR{6,PRTNM{{{PRINT KEYWORD NAME{23758
{{MOV{7,XR{21,=TMBEB{{POINT TO BLANK-EQUAL-BLANK{23759
{{JSR{6,PRTST{{{PRINT BLANK-EQUAL-BLANK{23760
{{JSR{6,KWNAM{{{GET KEYWORD PSEUDO-VARIABLE NAME{23761
{{MOV{3,DNAMP{7,XR{{RESET PTR TO DELETE KVBLK{23762
{{JSR{6,ACESS{{{GET KEYWORD VALUE{23763
{{PPM{{{{FAILURE IS IMPOSSIBLE{23764
{{JSR{6,PRTVL{{{PRINT KEYWORD VALUE{23765
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{23766
*
*      HERE TO EXIT AFTER COMPLETING TRACE
*
{KTRX2{MOV{7,XR{10,(XS)+{{RESTORE ENTRY XR{23770
*
*      MERGE HERE TO EXIT IF NO TRACE REQUIRED
*
{KTRX3{EXI{{{{RETURN TO KTREX CALLER{23774
{{ENP{{{{END PROCEDURE KTREX{23775
{{EJC{{{{{23776
*
*      KWNAM -- GET PSEUDO-VARIABLE NAME FOR KEYWORD
*
*      1(XS)                 NAME BASE FOR VRBLK
*      0(XS)                 OFFSET (SHOULD BE *VRVAL)
*      JSR  KWNAM            CALL TO GET PSEUDO-VARIABLE NAME
*      (XS)                  POPPED TWICE
*      (XL,WA)               RESULTING PSEUDO-VARIABLE NAME
*      (XR,WA,WB)            DESTROYED
*
{KWNAM{PRC{25,N{1,0{{ENTRY POINT{23787
{{ICA{7,XS{{{IGNORE NAME OFFSET{23788
{{MOV{7,XR{10,(XS)+{{LOAD NAME BASE{23789
{{BGE{7,XR{3,STATE{6,KWNM1{JUMP IF NOT NATURAL VARIABLE NAME{23790
{{BNZ{13,VRLEN(XR){6,KWNM1{{ERROR IF NOT SYSTEM VARIABLE{23791
{{MOV{7,XR{13,VRSVP(XR){{ELSE POINT TO SVBLK{23792
{{MOV{8,WA{13,SVBIT(XR){{LOAD BIT MASK{23793
{{ANB{8,WA{4,BTKNM{{AND WITH KEYWORD BIT{23794
{{ZRB{8,WA{6,KWNM1{{ERROR IF NO KEYWORD ASSOCIATION{23795
{{MOV{8,WA{13,SVLEN(XR){{ELSE LOAD NAME LENGTH IN CHARACTERS{23796
{{CTB{8,WA{2,SVCHS{{COMPUTE OFFSET TO FIELD WE WANT{23797
{{ADD{7,XR{8,WA{{POINT TO SVKNM FIELD{23798
{{MOV{8,WB{9,(XR){{LOAD SVKNM VALUE{23799
{{MOV{8,WA{19,*KVSI_{{SET SIZE OF KVBLK{23800
{{JSR{6,ALLOC{{{ALLOCATE KVBLK{23801
{{MOV{9,(XR){22,=B_KVT{{STORE TYPE WORD{23802
{{MOV{13,KVNUM(XR){8,WB{{STORE KEYWORD NUMBER{23803
{{MOV{13,KVVAR(XR){21,=TRBKV{{SET DUMMY TRBLK POINTER{23804
{{MOV{7,XL{7,XR{{COPY KVBLK POINTER{23805
{{MOV{8,WA{19,*KVVAR{{SET PROPER OFFSET{23806
{{EXI{{{{RETURN TO KVNAM CALLER{23807
*
*      HERE IF NOT KEYWORD NAME
*
{KWNM1{ERB{1,251{26,Keyword operand is not name of defined keyword{{{23811
{{ENP{{{{END PROCEDURE KWNAM{23812
{{EJC{{{{{23813
*
*      LCOMP-- COMPARE TWO STRINGS LEXICALLY
*
*      1(XS)                 FIRST ARGUMENT
*      0(XS)                 SECOND ARGUMENT
*      JSR  LCOMP            CALL TO COMPARE ARUMENTS
*      PPM  LOC              TRANSFER LOC FOR ARG1 NOT STRING
*      PPM  LOC              TRANSFER LOC FOR ARG2 NOT STRING
*      PPM  LOC              TRANSFER LOC IF ARG1 LLT ARG2
*      PPM  LOC              TRANSFER LOC IF ARG1 LEQ ARG2
*      PPM  LOC              TRANSFER LOC IF ARG1 LGT ARG2
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XS)                  POPPED TWICE
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
{LCOMP{PRC{25,N{1,5{{ENTRY POINT{23830
{{JSR{6,GTSTG{{{CONVERT SECOND ARG TO STRING{23832
{{PPM{6,LCMP6{{{JUMP IF SECOND ARG NOT STRING{23836
{{MOV{7,XL{7,XR{{ELSE SAVE POINTER{23837
{{MOV{8,WC{8,WA{{AND LENGTH{23838
{{JSR{6,GTSTG{{{CONVERT FIRST ARGUMENT TO STRING{23840
{{PPM{6,LCMP5{{{JUMP IF NOT STRING{23844
{{MOV{8,WB{8,WA{{SAVE ARG 1 LENGTH{23845
{{PLC{7,XR{{{POINT TO CHARS OF ARG 1{23846
{{PLC{7,XL{{{POINT TO CHARS OF ARG 2{23847
{{BLO{8,WA{8,WC{6,LCMP1{JUMP IF ARG 1 LENGTH IS SMALLER{23859
{{MOV{8,WA{8,WC{{ELSE SET ARG 2 LENGTH AS SMALLER{23860
*
*      HERE WITH SMALLER LENGTH IN (WA)
*
{LCMP1{BZE{8,WA{6,LCMP7{{IF NULL STRING, COMPARE LENGTHS{23864
{{CMC{6,LCMP4{6,LCMP3{{COMPARE STRINGS, JUMP IF UNEQUAL{23865
{LCMP7{BNE{8,WB{8,WC{6,LCMP2{IF EQUAL, JUMP IF LENGTHS UNEQUAL{23866
{{EXI{1,4{{{ELSE IDENTICAL STRINGS, LEQ EXIT{23867
{{EJC{{{{{23868
*
*      LCOMP (CONTINUED)
*
*      HERE IF INITIAL STRINGS IDENTICAL, BUT LENGTHS UNEQUAL
*
{LCMP2{BHI{8,WB{8,WC{6,LCMP4{JUMP IF ARG 1 LENGTH GT ARG 2 LENG{23874
*
*      HERE IF FIRST ARG LLT SECOND ARG
*
{LCMP3{EXI{1,3{{{TAKE LLT EXIT{23879
*
*      HERE IF FIRST ARG LGT SECOND ARG
*
{LCMP4{EXI{1,5{{{TAKE LGT EXIT{23883
*
*      HERE IF FIRST ARG IS NOT A STRING
*
{LCMP5{EXI{1,1{{{TAKE BAD FIRST ARG EXIT{23887
*
*      HERE FOR SECOND ARG NOT A STRING
*
{LCMP6{EXI{1,2{{{TAKE BAD SECOND ARG ERROR EXIT{23891
{{ENP{{{{END PROCEDURE LCOMP{23892
{{EJC{{{{{23893
*
*      LISTR -- LIST SOURCE LINE
*
*      LISTR IS USED TO LIST A SOURCE LINE DURING THE INITIAL
*      COMPILATION. IT IS CALLED FROM SCANE AND SCANL.
*
*      JSR  LISTR            CALL TO LIST LINE
*      (XR,XL,WA,WB,WC)      DESTROYED
*
*      GLOBAL LOCATIONS USED BY LISTR
*
*      CNTTL                 FLAG FOR -TITLE, -STITL
*
*      ERLST                 IF LISTING ON ACCOUNT OF AN ERROR
*
*      LSTID                 INCLUDE DEPTH OF CURRENT IMAGE
*
*      LSTLC                 COUNT LINES ON CURRENT PAGE
*
*      LSTNP                 MAX NUMBER OF LINES/PAGE
*
*      LSTPF                 SET NON-ZERO IF THE CURRENT SOURCE
*                            LINE HAS BEEN LISTED, ELSE ZERO.
*
*      LSTPG                 COMPILER LISTING PAGE NUMBER
*
*      LSTSN                 SET IF STMNT NUM TO BE LISTED
*
*      R_CIM                 POINTER TO CURRENT INPUT LINE.
*
*      R_TTL                 TITLE FOR SOURCE LISTING
*
*      R_STL                 PTR TO SUB-TITLE STRING
*
*      ENTRY POINT
*
{LISTR{PRC{25,E{1,0{{ENTRY POINT{23932
{{BNZ{3,CNTTL{6,LIST5{{JUMP IF -TITLE OR -STITL{23933
{{BNZ{3,LSTPF{6,LIST4{{IMMEDIATE EXIT IF ALREADY LISTED{23934
{{BGE{3,LSTLC{3,LSTNP{6,LIST6{JUMP IF NO ROOM{23935
*
*      HERE AFTER PRINTING TITLE (IF NEEDED)
*
{LIST0{MOV{7,XR{3,R_CIM{{LOAD POINTER TO CURRENT IMAGE{23939
{{BZE{7,XR{6,LIST4{{JUMP IF NO IMAGE TO PRINT{23940
{{PLC{7,XR{{{POINT TO CHARACTERS{23941
{{LCH{8,WA{9,(XR){{LOAD FIRST CHARACTER{23942
{{MOV{7,XR{3,LSTSN{{LOAD STATEMENT NUMBER{23943
{{BZE{7,XR{6,LIST2{{JUMP IF NO STATEMENT NUMBER{23944
{{MTI{7,XR{{{ELSE GET STMNT NUMBER AS INTEGER{23945
{{BNE{3,STAGE{18,=STGIC{6,LIST1{SKIP IF EXECUTE TIME{23946
{{BEQ{8,WA{18,=CH_AS{6,LIST2{NO STMNT NUMBER LIST IF COMMENT{23947
{{BEQ{8,WA{18,=CH_MN{6,LIST2{NO STMNT NO. IF CONTROL CARD{23948
*
*      PRINT STATEMENT NUMBER
*
{LIST1{JSR{6,PRTIN{{{ELSE PRINT STATEMENT NUMBER{23952
{{ZER{3,LSTSN{{{AND CLEAR FOR NEXT TIME IN{23953
*
*      HERE TO TEST FOR PRINTING INCLUDE DEPTH
*
{LIST2{MOV{7,XR{3,LSTID{{INCLUDE DEPTH OF IMAGE{23958
{{BZE{7,XR{6,LIST8{{IF NOT FROM AN INCLUDE FILE{23959
{{MOV{8,WA{18,=STNPD{{POSITION FOR START OF STATEMENT{23960
{{SUB{8,WA{18,=NUM03{{POSITION TO PLACE INCLUDE DEPTH{23961
{{MOV{3,PROFS{8,WA{{SET AS STARTING POSITION{23962
{{MTI{7,XR{{{INCLUDE DEPTH AS INTEGER{23963
{{JSR{6,PRTIN{{{PRINT INCLUDE DEPTH{23964
{{EJC{{{{{23965
*
*      LISTR (CONTINUED)
*
*      HERE AFTER PRINTING STATEMENT NUMBER AND INCLUDE DEPTH
*
{LIST8{MOV{3,PROFS{18,=STNPD{{POINT PAST STATEMENT NUMBER{23971
{{MOV{7,XR{3,R_CIM{{LOAD POINTER TO CURRENT IMAGE{23981
{{JSR{6,PRTST{{{PRINT IT{23982
{{ICV{3,LSTLC{{{BUMP LINE COUNTER{23983
{{BNZ{3,ERLST{6,LIST3{{JUMP IF ERROR COPY TO INT.CH.{23984
{{JSR{6,PRTNL{{{TERMINATE LINE{23985
{{BZE{3,CSWDB{6,LIST3{{JUMP IF -SINGLE MODE{23986
{{JSR{6,PRTNL{{{ELSE ADD A BLANK LINE{23987
{{ICV{3,LSTLC{{{AND BUMP LINE COUNTER{23988
*
*      HERE AFTER PRINTING SOURCE IMAGE
*
{LIST3{MNZ{3,LSTPF{{{SET FLAG FOR LINE PRINTED{23992
*
*      MERGE HERE TO EXIT
*
{LIST4{EXI{{{{RETURN TO LISTR CALLER{23996
*
*      PRINT TITLE AFTER -TITLE OR -STITL CARD
*
{LIST5{ZER{3,CNTTL{{{CLEAR FLAG{24000
*
*      EJECT TO NEW PAGE AND LIST TITLE
*
{LIST6{JSR{6,PRTPS{{{EJECT{24004
{{BZE{3,PRICH{6,LIST7{{SKIP IF LISTING TO REGULAR PRINTER{24005
{{BEQ{3,R_TTL{21,=NULLS{6,LIST0{TERMINAL LISTING OMITS NULL TITLE{24006
*
*      LIST TITLE
*
{LIST7{JSR{6,LISTT{{{LIST TITLE{24010
{{BRN{6,LIST0{{{MERGE{24011
{{ENP{{{{END PROCEDURE LISTR{24012
{{EJC{{{{{24013
*
*      LISTT -- LIST TITLE AND SUBTITLE
*
*      USED DURING COMPILATION TO PRINT PAGE HEADING
*
*      JSR  LISTT            CALL TO LIST TITLE
*      (XR,WA)               DESTROYED
*
{LISTT{PRC{25,E{1,0{{ENTRY POINT{24022
{{MOV{7,XR{3,R_TTL{{POINT TO SOURCE LISTING TITLE{24023
{{JSR{6,PRTST{{{PRINT TITLE{24024
{{MOV{3,PROFS{3,LSTPO{{SET OFFSET{24025
{{MOV{7,XR{21,=LSTMS{{SET PAGE MESSAGE{24026
{{JSR{6,PRTST{{{PRINT PAGE MESSAGE{24027
{{ICV{3,LSTPG{{{BUMP PAGE NUMBER{24028
{{MTI{3,LSTPG{{{LOAD PAGE NUMBER AS INTEGER{24029
{{JSR{6,PRTIN{{{PRINT PAGE NUMBER{24030
{{JSR{6,PRTNL{{{TERMINATE TITLE LINE{24031
{{ADD{3,LSTLC{18,=NUM02{{COUNT TITLE LINE AND BLANK LINE{24032
*
*      PRINT SUB-TITLE (IF ANY)
*
{{MOV{7,XR{3,R_STL{{LOAD POINTER TO SUB-TITLE{24036
{{BZE{7,XR{6,LSTT1{{JUMP IF NO SUB-TITLE{24037
{{JSR{6,PRTST{{{ELSE PRINT SUB-TITLE{24038
{{JSR{6,PRTNL{{{TERMINATE LINE{24039
{{ICV{3,LSTLC{{{BUMP LINE COUNT{24040
*
*      RETURN POINT
*
{LSTT1{JSR{6,PRTNL{{{PRINT A BLANK LINE{24044
{{EXI{{{{RETURN TO CALLER{24045
{{ENP{{{{END PROCEDURE LISTT{24046
{{EJC{{{{{24047
*
*      NEWFN -- RECORD NEW SOURCE FILE NAME
*
*      NEWFN IS USED AFTER SWITCHING TO A NEW INCLUDE FILE, OR
*      AFTER A -LINE STATEMENT WHICH CONTAINS A FILE NAME.
*
*      (XR)                  FILE NAME SCBLK
*      JSR  NEWFN
*      (WA,WB,WC,XL,XR,RA)   DESTROYED
*
*      ON RETURN, THE TABLE THAT MAPS STATEMENT NUMBERS TO FILE
*      NAMES HAS BEEN UPDATED TO INCLUDE THIS NEW FILE NAME AND
*      THE CURRENT STATEMENT NUMBER.  THE ENTRY IS MADE ONLY IF
*      THE FILE NAME HAD CHANGED FROM ITS PREVIOUS VALUE.
*
{NEWFN{PRC{25,E{1,0{{ENTRY POINT{24064
{{MOV{11,-(XS){7,XR{{SAVE NEW NAME{24065
{{MOV{7,XL{3,R_SFC{{LOAD PREVIOUS NAME{24066
{{JSR{6,IDENT{{{CHECK FOR EQUALITY{24067
{{PPM{6,NWFN1{{{JUMP IF IDENTICAL{24068
{{MOV{7,XR{10,(XS)+{{DIFFERENT, RESTORE NAME{24069
{{MOV{3,R_SFC{7,XR{{RECORD CURRENT FILE NAME{24070
{{MOV{8,WB{3,CMPSN{{GET CURRENT STATEMENT{24071
{{MTI{8,WB{{{CONVERT TO INTEGER{24072
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{24073
{{MOV{7,XL{3,R_SFN{{FILE NAME TABLE{24074
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{24075
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{24076
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{24077
{{MOV{13,TEVAL(XL){3,R_SFC{{RECORD FILE NAME AS ENTRY VALUE{24078
{{EXI{{{{{24079
*
*     HERE IF NEW NAME AND OLD NAME IDENTICAL
*
{NWFN1{ICA{7,XS{{{POP STACK{24083
{{EXI{{{{{24084
{{EJC{{{{{24085
*
*      NEXTS -- ACQUIRE NEXT SOURCE IMAGE
*
*      NEXTS IS USED TO ACQUIRE THE NEXT SOURCE IMAGE AT COMPILE
*      TIME. IT ASSUMES THAT A PRIOR CALL TO READR HAS INPUT
*      A LINE IMAGE (SEE PROCEDURE READR). BEFORE THE CURRENT
*      IMAGE IS FINALLY LOST IT MAY BE LISTED HERE.
*
*      JSR  NEXTS            CALL TO ACQUIRE NEXT INPUT LINE
*      (XR,XL,WA,WB,WC)      DESTROYED
*
*      GLOBAL VALUES AFFECTED
*
*      LSTID                 INCLUDE DEPTH OF NEXT IMAGE
*
*      R_CNI                 ON INPUT, NEXT IMAGE. ON
*                            EXIT RESET TO ZERO
*
*      R_CIM                 ON EXIT, SET TO POINT TO IMAGE
*
*      RDCLN                 CURRENT LN SET FROM NEXT LINE NUM
*
*      SCNIL                 INPUT IMAGE LENGTH ON EXIT
*
*      SCNSE                 RESET TO ZERO ON EXIT
*
*      LSTPF                 SET ON EXIT IF LINE IS LISTED
*
{NEXTS{PRC{25,E{1,0{{ENTRY POINT{24117
{{BZE{3,CSWLS{6,NXTS2{{JUMP IF -NOLIST{24118
{{MOV{7,XR{3,R_CIM{{POINT TO IMAGE{24119
{{BZE{7,XR{6,NXTS2{{JUMP IF NO IMAGE{24120
{{PLC{7,XR{{{GET CHAR PTR{24121
{{LCH{8,WA{9,(XR){{GET FIRST CHAR{24122
{{BNE{8,WA{18,=CH_MN{6,NXTS1{JUMP IF NOT CTRL CARD{24123
{{BZE{3,CSWPR{6,NXTS2{{JUMP IF -NOPRINT{24124
*
*      HERE TO CALL LISTER
*
{NXTS1{JSR{6,LISTR{{{LIST LINE{24128
*
*      HERE AFTER POSSIBLE LISTING
*
{NXTS2{MOV{7,XR{3,R_CNI{{POINT TO NEXT IMAGE{24132
{{MOV{3,R_CIM{7,XR{{SET AS NEXT IMAGE{24133
{{MOV{3,RDCLN{3,RDNLN{{SET AS CURRENT LINE NUMBER{24134
{{MOV{3,LSTID{3,CNIND{{SET AS CURRENT INCLUDE DEPTH{24136
{{ZER{3,R_CNI{{{CLEAR NEXT IMAGE POINTER{24138
{{MOV{8,WA{13,SCLEN(XR){{GET INPUT IMAGE LENGTH{24139
{{MOV{8,WB{3,CSWIN{{GET MAX ALLOWABLE LENGTH{24140
{{BLO{8,WA{8,WB{6,NXTS3{SKIP IF NOT TOO LONG{24141
{{MOV{8,WA{8,WB{{ELSE TRUNCATE{24142
*
*      HERE WITH LENGTH IN (WA)
*
{NXTS3{MOV{3,SCNIL{8,WA{{USE AS RECORD LENGTH{24146
{{ZER{3,SCNSE{{{RESET SCNSE{24147
{{ZER{3,LSTPF{{{SET LINE NOT LISTED YET{24148
{{EXI{{{{RETURN TO NEXTS CALLER{24149
{{ENP{{{{END PROCEDURE NEXTS{24150
{{EJC{{{{{24151
*
*      PATIN -- PATTERN CONSTRUCTION FOR LEN,POS,RPOS,TAB,RTAB
*
*      THESE PATTERN TYPES ALL GENERATE A SIMILAR NODE TYPE. SO
*      THE CONSTRUCTION CODE IS SHARED. SEE FUNCTIONS SECTION
*      FOR ACTUAL ENTRY POINTS FOR THESE FIVE FUNCTIONS.
*
*      (WA)                  PCODE FOR EXPRESSION ARG CASE
*      (WB)                  PCODE FOR INTEGER ARG CASE
*      JSR  PATIN            CALL TO BUILD PATTERN NODE
*      PPM  LOC              TRANSFER LOC FOR NOT INTEGER OR EXP
*      PPM  LOC              TRANSFER LOC FOR INT OUT OF RANGE
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (XL,WA,WB,WC,IA)      DESTROYED
*
{PATIN{PRC{25,N{1,2{{ENTRY POINT{24167
{{MOV{7,XL{8,WA{{PRESERVE EXPRESSION ARG PCODE{24168
{{JSR{6,GTSMI{{{TRY TO CONVERT ARG AS SMALL INTEGER{24169
{{PPM{6,PTIN2{{{JUMP IF NOT INTEGER{24170
{{PPM{6,PTIN3{{{JUMP IF OUT OF RANGE{24171
*
*      COMMON SUCCESSFUL EXIT POINT
*
{PTIN1{JSR{6,PBILD{{{BUILD PATTERN NODE{24175
{{EXI{{{{RETURN TO CALLER{24176
*
*      HERE IF ARGUMENT IS NOT AN INTEGER
*
{PTIN2{MOV{8,WB{7,XL{{COPY EXPR ARG CASE PCODE{24180
{{BLO{9,(XR){22,=B_E__{6,PTIN1{ALL OK IF EXPRESSION ARG{24181
{{EXI{1,1{{{ELSE TAKE ERROR EXIT FOR WRONG TYPE{24182
*
*      HERE FOR ERROR OF OUT OF RANGE INTEGER ARGUMENT
*
{PTIN3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{24186
{{ENP{{{{END PROCEDURE PATIN{24187
{{EJC{{{{{24188
*
*      PATST -- PATTERN CONSTRUCTION FOR ANY,NOTANY,
*               BREAK,SPAN AND BREAKX PATTERN FUNCTIONS.
*
*      THESE PATTERN FUNCTIONS BUILD SIMILAR TYPES OF NODES AND
*      THE CONSTRUCTION CODE IS SHARED. SEE FUNCTIONS SECTION
*      FOR ACTUAL ENTRY POINTS FOR THESE FIVE PATTERN FUNCTIONS.
*
*      0(XS)                 STRING ARGUMENT
*      (WB)                  PCODE FOR ONE CHAR ARGUMENT
*      (XL)                  PCODE FOR MULTI-CHAR ARGUMENT
*      (WC)                  PCODE FOR EXPRESSION ARGUMENT
*      JSR  PATST            CALL TO BUILD NODE
*      PPM  LOC              IF NOT STRING OR EXPR (OR NULL)
*      (XS)                  POPPED PAST STRING ARGUMENT
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (XL)                  DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
*      NOTE THAT THERE IS A SPECIAL CALL TO PATST IN THE EVALS
*      PROCEDURE WITH A SLIGHTLY DIFFERENT FORM. SEE EVALS
*      FOR DETAILS OF THE FORM OF THIS CALL.
*
{PATST{PRC{25,N{1,1{{ENTRY POINT{24212
{{JSR{6,GTSTG{{{CONVERT ARGUMENT AS STRING{24213
{{PPM{6,PATS7{{{JUMP IF NOT STRING{24214
{{BZE{8,WA{6,PATS7{{JUMP IF NULL STRING (CATSPAW){24215
{{BNE{8,WA{18,=NUM01{6,PATS2{JUMP IF NOT ONE CHAR STRING{24216
*
*      HERE FOR ONE CHAR STRING CASE
*
{{BZE{8,WB{6,PATS2{{TREAT AS MULTI-CHAR IF EVALS CALL{24220
{{PLC{7,XR{{{POINT TO CHARACTER{24221
{{LCH{7,XR{9,(XR){{LOAD CHARACTER{24222
*
*      COMMON EXIT POINT AFTER SUCCESSFUL CONSTRUCTION
*
{PATS1{JSR{6,PBILD{{{CALL ROUTINE TO BUILD NODE{24226
{{EXI{{{{RETURN TO PATST CALLER{24227
{{EJC{{{{{24228
*
*      PATST (CONTINUED)
*
*      HERE FOR MULTI-CHARACTER STRING CASE
*
{PATS2{MOV{11,-(XS){7,XL{{SAVE MULTI-CHAR PCODE{24234
{{MOV{8,WC{3,CTMSK{{LOAD CURRENT MASK BIT{24235
{{BEQ{7,XR{3,R_CTS{6,PATS6{JUMP IF SAME AS LAST STRING C3.738{24236
{{MOV{11,-(XS){7,XR{{SAVE STRING POINTER{24237
{{LSH{8,WC{1,1{{SHIFT TO NEXT POSITION{24238
{{NZB{8,WC{6,PATS4{{SKIP IF POSITION LEFT IN THIS TBL{24239
*
*      HERE WE MUST ALLOCATE A NEW CHARACTER TABLE
*
{{MOV{8,WA{19,*CTSI_{{SET SIZE OF CTBLK{24243
{{JSR{6,ALLOC{{{ALLOCATE CTBLK{24244
{{MOV{3,R_CTP{7,XR{{STORE PTR TO NEW CTBLK{24245
{{MOV{10,(XR)+{22,=B_CTT{{STORE TYPE CODE, BUMP PTR{24246
{{LCT{8,WB{18,=CFP_A{{SET NUMBER OF WORDS TO CLEAR{24247
{{MOV{8,WC{4,BITS0{{LOAD ALL ZERO BITS{24248
*
*      LOOP TO CLEAR ALL BITS IN TABLE TO ZEROS
*
{PATS3{MOV{10,(XR)+{8,WC{{MOVE WORD OF ZERO BITS{24252
{{BCT{8,WB{6,PATS3{{LOOP TILL ALL CLEARED{24253
{{MOV{8,WC{4,BITS1{{SET INITIAL BIT POSITION{24254
*
*      MERGE HERE WITH BIT POSITION AVAILABLE
*
{PATS4{MOV{3,CTMSK{8,WC{{SAVE PARM2 (NEW BIT POSITION){24258
{{MOV{7,XL{10,(XS)+{{RESTORE POINTER TO ARGUMENT STRING{24259
{{MOV{3,R_CTS{7,XL{{SAVE FOR NEXT TIME   C3.738{24260
{{MOV{8,WB{13,SCLEN(XL){{LOAD STRING LENGTH{24261
{{BZE{8,WB{6,PATS6{{JUMP IF NULL STRING CASE{24262
{{LCT{8,WB{8,WB{{ELSE SET LOOP COUNTER{24263
{{PLC{7,XL{{{POINT TO CHARACTERS IN ARGUMENT{24264
{{EJC{{{{{24265
*
*      PATST (CONTINUED)
*
*      LOOP TO SET BITS IN COLUMN OF TABLE
*
{PATS5{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER{24271
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{24272
{{MOV{7,XR{3,R_CTP{{POINT TO CTBLK{24273
{{ADD{7,XR{8,WA{{POINT TO CTBLK ENTRY{24274
{{MOV{8,WA{8,WC{{COPY BIT MASK{24275
{{ORB{8,WA{13,CTCHS(XR){{OR IN BITS ALREADY SET{24276
{{MOV{13,CTCHS(XR){8,WA{{STORE RESULTING BIT STRING{24277
{{BCT{8,WB{6,PATS5{{LOOP TILL ALL BITS SET{24278
*
*      COMPLETE PROCESSING FOR MULTI-CHAR STRING CASE
*
{PATS6{MOV{7,XR{3,R_CTP{{LOAD CTBLK PTR AS PARM1 FOR PBILD{24282
{{ZER{7,XL{{{CLEAR GARBAGE PTR IN XL{24283
{{MOV{8,WB{10,(XS)+{{LOAD PCODE FOR MULTI-CHAR STR CASE{24284
{{BRN{6,PATS1{{{BACK TO EXIT (WC=BITSTRING=PARM2){24285
*
*      HERE IF ARGUMENT IS NOT A STRING
*
*      NOTE THAT THE CALL FROM EVALS CANNOT PASS AN EXPRESSION
*      SINCE EVALP ALWAYS REEVALUATES EXPRESSIONS.
*
{PATS7{MOV{8,WB{8,WC{{SET PCODE FOR EXPRESSION ARGUMENT{24292
{{BLO{9,(XR){22,=B_E__{6,PATS1{JUMP TO EXIT IF EXPRESSION ARG{24293
{{EXI{1,1{{{ELSE TAKE WRONG TYPE ERROR EXIT{24294
{{ENP{{{{END PROCEDURE PATST{24295
{{EJC{{{{{24296
*
*      PBILD -- BUILD PATTERN NODE
*
*      (XR)                  PARM1 (ONLY IF REQUIRED)
*      (WB)                  PCODE FOR NODE
*      (WC)                  PARM2 (ONLY IF REQUIRED)
*      JSR  PBILD            CALL TO BUILD NODE
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (WA)                  DESTROYED
*
{PBILD{PRC{25,E{1,0{{ENTRY POINT{24307
{{MOV{11,-(XS){7,XR{{STACK POSSIBLE PARM1{24308
{{MOV{7,XR{8,WB{{COPY PCODE{24309
{{LEI{7,XR{{{LOAD ENTRY POINT ID (BL_PX){24310
{{BEQ{7,XR{18,=BL_P1{6,PBLD1{JUMP IF ONE PARAMETER{24311
{{BEQ{7,XR{18,=BL_P0{6,PBLD3{JUMP IF NO PARAMETERS{24312
*
*      HERE FOR TWO PARAMETER CASE
*
{{MOV{8,WA{19,*PCSI_{{SET SIZE OF P2BLK{24316
{{JSR{6,ALLOC{{{ALLOCATE BLOCK{24317
{{MOV{13,PARM2(XR){8,WC{{STORE SECOND PARAMETER{24318
{{BRN{6,PBLD2{{{MERGE WITH ONE PARM CASE{24319
*
*      HERE FOR ONE PARAMETER CASE
*
{PBLD1{MOV{8,WA{19,*PBSI_{{SET SIZE OF P1BLK{24323
{{JSR{6,ALLOC{{{ALLOCATE NODE{24324
*
*      MERGE HERE FROM TWO PARM CASE
*
{PBLD2{MOV{13,PARM1(XR){9,(XS){{STORE FIRST PARAMETER{24328
{{BRN{6,PBLD4{{{MERGE WITH NO PARAMETER CASE{24329
*
*      HERE FOR CASE OF NO PARAMETERS
*
{PBLD3{MOV{8,WA{19,*PASI_{{SET SIZE OF P0BLK{24333
{{JSR{6,ALLOC{{{ALLOCATE NODE{24334
*
*      MERGE HERE FROM OTHER CASES
*
{PBLD4{MOV{9,(XR){8,WB{{STORE PCODE{24338
{{ICA{7,XS{{{POP FIRST PARAMETER{24339
{{MOV{13,PTHEN(XR){21,=NDNTH{{SET NOTHEN SUCCESSOR POINTER{24340
{{EXI{{{{RETURN TO PBILD CALLER{24341
{{ENP{{{{END PROCEDURE PBILD{24342
{{EJC{{{{{24343
*
*      PCONC -- CONCATENATE TWO PATTERNS
*
*      (XL)                  PTR TO RIGHT PATTERN
*      (XR)                  PTR TO LEFT PATTERN
*      JSR  PCONC            CALL TO CONCATENATE PATTERNS
*      (XR)                  PTR TO CONCATENATED PATTERN
*      (XL,WA,WB,WC)         DESTROYED
*
*
*      TO CONCATENATE TWO PATTERNS, ALL SUCCESSORS IN THE LEFT
*      PATTERN WHICH POINT TO THE NOTHEN NODE MUST BE CHANGED TO
*      POINT TO THE RIGHT PATTERN. HOWEVER, THIS MODIFICATION
*      MUST BE PERFORMED ON A COPY OF THE LEFT ARGUMENT RATHER
*      THAN THE LEFT ARGUMENT ITSELF, SINCE THE LEFT ARGUMENT
*      MAY BE POINTED TO BY SOME OTHER VARIABLE VALUE.
*
*      ACCORDINGLY, IT IS NECESSARY TO COPY THE LEFT ARGUMENT.
*      THIS IS NOT A TRIVIAL PROCESS SINCE WE MUST AVOID COPYING
*      NODES MORE THAN ONCE AND THE PATTERN IS A GRAPH STRUCTURE
*      THE FOLLOWING ALGORITHM IS EMPLOYED.
*
*      THE STACK IS USED TO STORE A LIST OF NODES WHICH
*      HAVE ALREADY BEEN COPIED. THE FORMAT OF THE ENTRIES ON
*      THIS LIST CONSISTS OF A TWO WORD BLOCK. THE FIRST WORD
*      IS THE OLD ADDRESS AND THE SECOND WORD IS THE ADDRESS
*      OF THE COPY. THIS LIST IS SEARCHED BY THE PCOPY
*      ROUTINE TO AVOID MAKING DUPLICATE COPIES. A TRICK IS
*      USED TO ACCOMPLISH THE CONCATENATION AT THE SAME TIME.
*      A SPECIAL ENTRY IS MADE TO START WITH ON THE STACK. THIS
*      ENTRY RECORDS THAT THE NOTHEN NODE HAS BEEN COPIED
*      ALREADY AND THE ADDRESS OF ITS COPY IS THE RIGHT PATTERN.
*      THIS AUTOMATICALLY PERFORMS THE CORRECT REPLACEMENTS.
*
{PCONC{PRC{25,E{1,0{{ENTRY POINT{24378
{{ZER{11,-(XS){{{MAKE ROOM FOR ONE ENTRY AT BOTTOM{24379
{{MOV{8,WC{7,XS{{STORE POINTER TO START OF LIST{24380
{{MOV{11,-(XS){21,=NDNTH{{STACK NOTHEN NODE AS OLD NODE{24381
{{MOV{11,-(XS){7,XL{{STORE RIGHT ARG AS COPY OF NOTHEN{24382
{{MOV{7,XT{7,XS{{INITIALIZE POINTER TO STACK ENTRIES{24383
{{JSR{6,PCOPY{{{COPY FIRST NODE OF LEFT ARG{24384
{{MOV{13,NUM02(XT){8,WA{{STORE AS RESULT UNDER LIST{24385
{{EJC{{{{{24386
*
*      PCONC (CONTINUED)
*
*      THE FOLLOWING LOOP SCANS ENTRIES IN THE LIST AND MAKES
*      SURE THAT THEIR SUCCESSORS HAVE BEEN COPIED.
*
{PCNC1{BEQ{7,XT{7,XS{6,PCNC2{JUMP IF ALL ENTRIES PROCESSED{24393
{{MOV{7,XR{11,-(XT){{ELSE LOAD NEXT OLD ADDRESS{24394
{{MOV{7,XR{13,PTHEN(XR){{LOAD POINTER TO SUCCESSOR{24395
{{JSR{6,PCOPY{{{COPY SUCCESSOR NODE{24396
{{MOV{7,XR{11,-(XT){{LOAD POINTER TO NEW NODE (COPY){24397
{{MOV{13,PTHEN(XR){8,WA{{STORE PTR TO NEW SUCCESSOR{24398
*
*      NOW CHECK FOR SPECIAL CASE OF ALTERNATION NODE WHERE
*      PARM1 POINTS TO A NODE AND MUST BE COPIED LIKE PTHEN.
*
{{BNE{9,(XR){22,=P_ALT{6,PCNC1{LOOP BACK IF NOT{24403
{{MOV{7,XR{13,PARM1(XR){{ELSE LOAD POINTER TO ALTERNATIVE{24404
{{JSR{6,PCOPY{{{COPY IT{24405
{{MOV{7,XR{9,(XT){{RESTORE PTR TO NEW NODE{24406
{{MOV{13,PARM1(XR){8,WA{{STORE PTR TO COPIED ALTERNATIVE{24407
{{BRN{6,PCNC1{{{LOOP BACK FOR NEXT ENTRY{24408
*
*      HERE AT END OF COPY PROCESS
*
{PCNC2{MOV{7,XS{8,WC{{RESTORE STACK POINTER{24412
{{MOV{7,XR{10,(XS)+{{LOAD POINTER TO COPY{24413
{{EXI{{{{RETURN TO PCONC CALLER{24414
{{ENP{{{{END PROCEDURE PCONC{24415
{{EJC{{{{{24416
*
*      PCOPY -- COPY A PATTERN NODE
*
*      PCOPY IS CALLED FROM THE PCONC PROCEDURE TO COPY A SINGLE
*      PATTERN NODE. THE COPY IS ONLY CARRIED OUT IF THE NODE
*      HAS NOT BEEN COPIED ALREADY.
*
*      (XR)                  POINTER TO NODE TO BE COPIED
*      (XT)                  PTR TO CURRENT LOC IN COPY LIST
*      (WC)                  POINTER TO LIST OF COPIED NODES
*      JSR  PCOPY            CALL TO COPY A NODE
*      (WA)                  POINTER TO COPY
*      (WB,XR)               DESTROYED
*
{PCOPY{PRC{25,N{1,0{{ENTRY POINT{24431
{{MOV{8,WB{7,XT{{SAVE XT{24432
{{MOV{7,XT{8,WC{{POINT TO START OF LIST{24433
*
*      LOOP TO SEARCH LIST OF NODES COPIED ALREADY
*
{PCOP1{DCA{7,XT{{{POINT TO NEXT ENTRY ON LIST{24437
{{BEQ{7,XR{9,(XT){6,PCOP2{JUMP IF MATCH{24438
{{DCA{7,XT{{{ELSE SKIP OVER COPIED ADDRESS{24439
{{BNE{7,XT{7,XS{6,PCOP1{LOOP BACK IF MORE TO TEST{24440
*
*      HERE IF NOT IN LIST, PERFORM COPY
*
{{MOV{8,WA{9,(XR){{LOAD FIRST WORD OF BLOCK{24444
{{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{24445
{{MOV{7,XL{7,XR{{SAVE POINTER TO OLD NODE{24446
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR COPY{24447
{{MOV{11,-(XS){7,XL{{STORE OLD ADDRESS ON LIST{24448
{{MOV{11,-(XS){7,XR{{STORE NEW ADDRESS ON LIST{24449
{{CHK{{{{CHECK FOR STACK OVERFLOW{24450
{{MVW{{{{MOVE WORDS FROM OLD BLOCK TO COPY{24451
{{MOV{8,WA{9,(XS){{LOAD POINTER TO COPY{24452
{{BRN{6,PCOP3{{{JUMP TO EXIT{24453
*
*      HERE IF WE FIND ENTRY IN LIST
*
{PCOP2{MOV{8,WA{11,-(XT){{LOAD ADDRESS OF COPY FROM LIST{24457
*
*      COMMON EXIT POINT
*
{PCOP3{MOV{7,XT{8,WB{{RESTORE XT{24461
{{EXI{{{{RETURN TO PCOPY CALLER{24462
{{ENP{{{{END PROCEDURE PCOPY{24463
{{EJC{{{{{24464
*
*      PRFLR -- PRINT PROFILE
*      PRFLR IS CALLED TO PRINT THE CONTENTS OF THE PROFILE
*      TABLE IN A FAIRLY READABLE TABULAR FORMAT.
*
*      JSR  PRFLR            CALL TO PRINT PROFILE
*      (WA,IA)               DESTROYED
*
{PRFLR{PRC{25,E{1,0{{{24475
{{BZE{3,PFDMP{6,PRFL4{{NO PRINTING IF NO PROFILING DONE{24476
{{MOV{11,-(XS){7,XR{{PRESERVE ENTRY XR{24477
{{MOV{3,PFSVW{8,WB{{AND ALSO WB{24478
{{JSR{6,PRTPG{{{EJECT{24479
{{MOV{7,XR{21,=PFMS1{{LOAD MSG /PROGRAM PROFILE/{24480
{{JSR{6,PRTST{{{AND PRINT IT{24481
{{JSR{6,PRTNL{{{FOLLOWED BY NEWLINE{24482
{{JSR{6,PRTNL{{{AND ANOTHER{24483
{{MOV{7,XR{21,=PFMS2{{POINT TO FIRST HDR{24484
{{JSR{6,PRTST{{{PRINT IT{24485
{{JSR{6,PRTNL{{{NEW LINE{24486
{{MOV{7,XR{21,=PFMS3{{SECOND HDR{24487
{{JSR{6,PRTST{{{PRINT IT{24488
{{JSR{6,PRTNL{{{NEW LINE{24489
{{JSR{6,PRTNL{{{AND ANOTHER BLANK LINE{24490
{{ZER{8,WB{{{INITIAL STMT COUNT{24491
{{MOV{7,XR{3,PFTBL{{POINT TO TABLE ORIGIN{24492
{{ADD{7,XR{19,*XNDTA{{BIAS PAST XNBLK HEADER (SGD07){24493
*
*      LOOP HERE TO PRINT SUCCESSIVE ENTRIES
*
{PRFL1{ICV{8,WB{{{BUMP STMT NR{24497
{{LDI{9,(XR){{{LOAD NR OF EXECUTIONS{24498
{{IEQ{6,PRFL3{{{NO PRINTING IF ZERO{24499
{{MOV{3,PROFS{18,=PFPD1{{POINT WHERE TO PRINT{24500
{{JSR{6,PRTIN{{{AND PRINT IT{24501
{{ZER{3,PROFS{{{BACK TO START OF LINE{24502
{{MTI{8,WB{{{LOAD STMT NR{24503
{{JSR{6,PRTIN{{{PRINT IT THERE{24504
{{MOV{3,PROFS{18,=PFPD2{{AND PAD PAST COUNT{24505
{{LDI{13,CFP_I(XR){{{LOAD TOTAL EXEC TIME{24506
{{JSR{6,PRTIN{{{PRINT THAT TOO{24507
{{LDI{13,CFP_I(XR){{{RELOAD TIME{24508
{{MLI{4,INTTH{{{CONVERT TO MICROSEC{24509
{{IOV{6,PRFL2{{{OMIT NEXT BIT IF OVERFLOW{24510
{{DVI{9,(XR){{{DIVIDE BY EXECUTIONS{24511
{{MOV{3,PROFS{18,=PFPD3{{PAD LAST PRINT{24512
{{JSR{6,PRTIN{{{AND PRINT MCSEC/EXECN{24513
*
*      MERGE AFTER PRINTING TIME
*
{PRFL2{JSR{6,PRTNL{{{THATS ANOTHER LINE{24517
*
*      HERE TO GO TO NEXT ENTRY
*
{PRFL3{ADD{7,XR{19,*PF_I2{{BUMP INDEX PTR (SGD07){24521
{{BLT{8,WB{3,PFNTE{6,PRFL1{LOOP IF MORE STMTS{24522
{{MOV{7,XR{10,(XS)+{{RESTORE CALLERS XR{24523
{{MOV{8,WB{3,PFSVW{{AND WB TOO{24524
*
*      HERE TO EXIT
*
{PRFL4{EXI{{{{RETURN{24528
{{ENP{{{{END OF PRFLR{24529
{{EJC{{{{{24530
*
*      PRFLU -- UPDATE AN ENTRY IN THE PROFILE TABLE
*
*      ON ENTRY, KVSTN CONTAINS NR OF STMT TO PROFILE
*
*      JSR  PRFLU            CALL TO UPDATE ENTRY
*      (IA)                  DESTROYED
*
{PRFLU{PRC{25,E{1,0{{{24539
{{BNZ{3,PFFNC{6,PFLU4{{SKIP IF JUST ENTERED FUNCTION{24540
{{MOV{11,-(XS){7,XR{{PRESERVE ENTRY XR{24541
{{MOV{3,PFSVW{8,WA{{SAVE WA (SGD07){24542
{{BNZ{3,PFTBL{6,PFLU2{{BRANCH IF TABLE ALLOCATED{24543
*
*      HERE IF SPACE FOR PROFILE TABLE NOT YET ALLOCATED.
*      CALCULATE SIZE NEEDED, ALLOCATE A STATIC XNBLK, AND
*      INITIALIZE IT ALL TO ZERO.
*      THE TIME TAKEN FOR THIS WILL BE ATTRIBUTED TO THE CURRENT
*      STATEMENT (ASSIGNMENT TO KEYWD PROFILE), BUT SINCE THE
*      TIMING FOR THIS STATEMENT IS UP THE POLE ANYWAY, THIS
*      DOESNT REALLY MATTER...
*
{{SUB{3,PFNTE{18,=NUM01{{ADJUST FOR EXTRA COUNT (SGD07){24553
{{MTI{4,PFI2A{{{CONVRT ENTRY SIZE TO INT{24554
{{STI{3,PFSTE{{{AND STORE SAFELY FOR LATER{24555
{{MTI{3,PFNTE{{{LOAD TABLE LENGTH AS INTEGER{24556
{{MLI{3,PFSTE{{{MULTIPLY BY ENTRY SIZE{24557
{{MFI{8,WA{{{GET BACK ADDRESS-STYLE{24558
{{ADD{8,WA{18,=NUM02{{ADD ON 2 WORD OVERHEAD{24559
{{WTB{8,WA{{{CONVERT THE WHOLE LOT TO BYTES{24560
{{JSR{6,ALOST{{{GIMME THE SPACE{24561
{{MOV{3,PFTBL{7,XR{{SAVE BLOCK POINTER{24562
{{MOV{10,(XR)+{22,=B_XNT{{PUT BLOCK TYPE AND ...{24563
{{MOV{10,(XR)+{8,WA{{... LENGTH INTO HEADER{24564
{{MFI{8,WA{{{GET BACK NR OF WDS IN DATA AREA{24565
{{LCT{8,WA{8,WA{{LOAD THE COUNTER{24566
*
*      LOOP HERE TO ZERO THE BLOCK DATA
*
{PFLU1{ZER{10,(XR)+{{{BLANK A WORD{24570
{{BCT{8,WA{6,PFLU1{{AND ALLLLLLL THE REST{24571
*
*      END OF ALLOCATION. MERGE BACK INTO ROUTINE
*
{PFLU2{MTI{3,KVSTN{{{LOAD NR OF STMT JUST ENDED{24575
{{SBI{4,INTV1{{{MAKE INTO INDEX OFFSET{24576
{{MLI{3,PFSTE{{{MAKE OFFSET OF TABLE ENTRY{24577
{{MFI{8,WA{{{CONVERT TO ADDRESS{24578
{{WTB{8,WA{{{GET AS BAUS{24579
{{ADD{8,WA{19,*NUM02{{OFFSET INCLUDES TABLE HEADER{24580
{{MOV{7,XR{3,PFTBL{{GET TABLE START{24581
{{BGE{8,WA{13,NUM01(XR){6,PFLU3{IF OUT OF TABLE, SKIP IT{24582
{{ADD{7,XR{8,WA{{ELSE POINT TO ENTRY{24583
{{LDI{9,(XR){{{GET NR OF EXECUTIONS SO FAR{24584
{{ADI{4,INTV1{{{NUDGE UP ONE{24585
{{STI{9,(XR){{{AND PUT BACK{24586
{{JSR{6,SYSTM{{{GET TIME NOW{24587
{{STI{3,PFETM{{{STASH ENDING TIME{24588
{{SBI{3,PFSTM{{{SUBTRACT START TIME{24589
{{ADI{13,CFP_I(XR){{{ADD CUMULATIVE TIME SO FAR{24590
{{STI{13,CFP_I(XR){{{AND PUT BACK NEW TOTAL{24591
{{LDI{3,PFETM{{{LOAD END TIME OF THIS STMT ...{24592
{{STI{3,PFSTM{{{... WHICH IS START TIME OF NEXT{24593
*
*      MERGE HERE TO EXIT
*
{PFLU3{MOV{7,XR{10,(XS)+{{RESTORE CALLERS XR{24597
{{MOV{8,WA{3,PFSVW{{RESTORE SAVED REG{24598
{{EXI{{{{AND RETURN{24599
*
*      HERE IF PROFILE IS SUPPRESSED BECAUSE A PROGRAM DEFINED
*      FUNCTION IS ABOUT TO BE ENTERED, AND SO THE CURRENT STMT
*      HAS NOT YET FINISHED
*
{PFLU4{ZER{3,PFFNC{{{RESET THE CONDITION FLAG{24605
{{EXI{{{{AND IMMEDIATE RETURN{24606
{{ENP{{{{END OF PROCEDURE PRFLU{24607
{{EJC{{{{{24608
*
*      PRPAR - PROCESS PRINT PARAMETERS
*
*      (WC)                  IF NONZERO ASSOCIATE TERMINAL ONLY
*      JSR  PRPAR            CALL TO PROCESS PRINT PARAMETERS
*      (XL,XR,WA,WB,WC)      DESTROYED
*
*      SINCE MEMORY ALLOCATION IS UNDECIDED ON INITIAL CALL,
*      TERMINAL CANNOT BE ASSOCIATED. THE ENTRY WITH WC NON-ZERO
*      IS PROVIDED SO A LATER CALL CAN BE MADE TO COMPLETE THIS.
*
{PRPAR{PRC{25,E{1,0{{ENTRY POINT{24621
{{BNZ{8,WC{6,PRPA8{{JUMP TO ASSOCIATE TERMINAL{24622
{{JSR{6,SYSPP{{{GET PRINT PARAMETERS{24623
{{BNZ{8,WB{6,PRPA1{{JUMP IF LINES/PAGE SPECIFIED{24624
{{MOV{8,WB{18,=CFP_M{{ELSE USE A LARGE VALUE{24625
{{RSH{8,WB{1,1{{BUT NOT TOO LARGE{24626
*
*      STORE LINE COUNT/PAGE
*
{PRPA1{MOV{3,LSTNP{8,WB{{STORE NUMBER OF LINES/PAGE{24630
{{MOV{3,LSTLC{8,WB{{PRETEND PAGE IS FULL INITIALLY{24631
{{ZER{3,LSTPG{{{CLEAR PAGE NUMBER{24632
{{MOV{8,WB{3,PRLEN{{GET PRIOR LENGTH IF ANY{24633
{{BZE{8,WB{6,PRPA2{{SKIP IF NO LENGTH{24634
{{BGT{8,WA{8,WB{6,PRPA3{SKIP STORING IF TOO BIG{24635
*
*      STORE PRINT BUFFER LENGTH
*
{PRPA2{MOV{3,PRLEN{8,WA{{STORE VALUE{24639
*
*      PROCESS BITS OPTIONS
*
{PRPA3{MOV{8,WB{4,BITS3{{BIT 3 MASK{24643
{{ANB{8,WB{8,WC{{GET -NOLIST BIT{24644
{{ZRB{8,WB{6,PRPA4{{SKIP IF CLEAR{24645
{{ZER{3,CSWLS{{{SET -NOLIST{24646
*
*      CHECK IF FAIL REPORTS GOTO INTERACTIVE CHANNEL
*
{PRPA4{MOV{8,WB{4,BITS1{{BIT 1 MASK{24650
{{ANB{8,WB{8,WC{{GET BIT{24651
{{MOV{3,ERICH{8,WB{{STORE INT. CHAN. ERROR FLAG{24652
{{MOV{8,WB{4,BITS2{{BIT 2 MASK{24653
{{ANB{8,WB{8,WC{{GET BIT{24654
{{MOV{3,PRICH{8,WB{{FLAG FOR STD PRINTER ON INT. CHAN.{24655
{{MOV{8,WB{4,BITS4{{BIT 4 MASK{24656
{{ANB{8,WB{8,WC{{GET BIT{24657
{{MOV{3,CPSTS{8,WB{{FLAG FOR COMPILE STATS SUPPRESSN.{24658
{{MOV{8,WB{4,BITS5{{BIT 5 MASK{24659
{{ANB{8,WB{8,WC{{GET BIT{24660
{{MOV{3,EXSTS{8,WB{{FLAG FOR EXEC STATS SUPPRESSION{24661
{{EJC{{{{{24662
*
*      PRPAR (CONTINUED)
*
{{MOV{8,WB{4,BITS6{{BIT 6 MASK{24666
{{ANB{8,WB{8,WC{{GET BIT{24667
{{MOV{3,PRECL{8,WB{{EXTENDED/COMPACT LISTING FLAG{24668
{{SUB{8,WA{18,=NUM08{{POINT 8 CHARS FROM LINE END{24669
{{ZRB{8,WB{6,PRPA5{{JUMP IF NOT EXTENDED{24670
{{MOV{3,LSTPO{8,WA{{STORE FOR LISTING PAGE HEADINGS{24671
*
*       CONTINUE OPTION PROCESSING
*
{PRPA5{MOV{8,WB{4,BITS7{{BIT 7 MASK{24675
{{ANB{8,WB{8,WC{{GET BIT 7{24676
{{MOV{3,CSWEX{8,WB{{SET -NOEXECUTE IF NON-ZERO{24677
{{MOV{8,WB{4,BIT10{{BIT 10 MASK{24678
{{ANB{8,WB{8,WC{{GET BIT 10{24679
{{MOV{3,HEADP{8,WB{{PRETEND PRINTED TO OMIT HEADERS{24680
{{MOV{8,WB{4,BITS9{{BIT 9 MASK{24681
{{ANB{8,WB{8,WC{{GET BIT 9{24682
{{MOV{3,PRSTO{8,WB{{KEEP IT AS STD LISTING OPTION{24683
{{MOV{8,WB{8,WC{{COPY FLAGS{24685
{{RSH{8,WB{1,12{{RIGHT JUSTIFY BIT 13{24686
{{ANB{8,WB{4,BITS1{{GET BIT{24687
{{MOV{3,KVCAS{8,WB{{SET -CASE{24688
{{MOV{8,WB{4,BIT12{{BIT 12 MASK{24690
{{ANB{8,WB{8,WC{{GET BIT 12{24691
{{MOV{3,CSWER{8,WB{{KEEP IT AS ERRORS/NOERRORS OPTION{24692
{{ZRB{8,WB{6,PRPA6{{SKIP IF CLEAR{24693
{{MOV{8,WA{3,PRLEN{{GET PRINT BUFFER LENGTH{24694
{{SUB{8,WA{18,=NUM08{{POINT 8 CHARS FROM LINE END{24695
{{MOV{3,LSTPO{8,WA{{STORE PAGE OFFSET{24696
*
*      CHECK FOR -PRINT/-NOPRINT
*
{PRPA6{MOV{8,WB{4,BIT11{{BIT 11 MASK{24700
{{ANB{8,WB{8,WC{{GET BIT 11{24701
{{MOV{3,CSWPR{8,WB{{SET -PRINT IF NON-ZERO{24702
*
*      CHECK FOR TERMINAL
*
{{ANB{8,WC{4,BITS8{{SEE IF TERMINAL TO BE ACTIVATED{24706
{{BNZ{8,WC{6,PRPA8{{JUMP IF TERMINAL REQUIRED{24707
{{BZE{3,INITR{6,PRPA9{{JUMP IF NO TERMINAL TO DETACH{24708
{{MOV{7,XL{21,=V_TER{{PTR TO /TERMINAL/{24709
{{JSR{6,GTNVR{{{GET VRBLK POINTER{24710
{{PPM{{{{CANT FAIL{24711
{{MOV{13,VRVAL(XR){21,=NULLS{{CLEAR VALUE OF TERMINAL{24712
{{JSR{6,SETVR{{{REMOVE ASSOCIATION{24713
{{BRN{6,PRPA9{{{RETURN{24714
*
*      ASSOCIATE TERMINAL
*
{PRPA8{MNZ{3,INITR{{{NOTE TERMINAL ASSOCIATED{24718
{{BZE{3,DNAMB{6,PRPA9{{CANT IF MEMORY NOT ORGANISED{24719
{{MOV{7,XL{21,=V_TER{{POINT TO TERMINAL STRING{24720
{{MOV{8,WB{18,=TRTOU{{OUTPUT TRACE TYPE{24721
{{JSR{6,INOUT{{{ATTACH OUTPUT TRBLK TO VRBLK{24722
{{MOV{11,-(XS){7,XR{{STACK TRBLK PTR{24723
{{MOV{7,XL{21,=V_TER{{POINT TO TERMINAL STRING{24724
{{MOV{8,WB{18,=TRTIN{{INPUT TRACE TYPE{24725
{{JSR{6,INOUT{{{ATTACH INPUT TRACE BLK{24726
{{MOV{13,VRVAL(XR){10,(XS)+{{ADD OUTPUT TRBLK TO CHAIN{24727
*
*      RETURN POINT
*
{PRPA9{EXI{{{{RETURN{24731
{{ENP{{{{END PROCEDURE PRPAR{24732
{{EJC{{{{{24733
*
*      PRTCH -- PRINT A CHARACTER
*
*      PRTCH IS USED TO PRINT A SINGLE CHARACTER
*
*      (WA)                  CHARACTER TO BE PRINTED
*      JSR  PRTCH            CALL TO PRINT CHARACTER
*
{PRTCH{PRC{25,E{1,0{{ENTRY POINT{24742
{{MOV{11,-(XS){7,XR{{SAVE XR{24743
{{BNE{3,PROFS{3,PRLEN{6,PRCH1{JUMP IF ROOM IN BUFFER{24744
{{JSR{6,PRTNL{{{ELSE PRINT THIS LINE{24745
*
*      HERE AFTER MAKING SURE WE HAVE ROOM
*
{PRCH1{MOV{7,XR{3,PRBUF{{POINT TO PRINT BUFFER{24749
{{PSC{7,XR{3,PROFS{{POINT TO NEXT CHARACTER LOCATION{24750
{{SCH{8,WA{9,(XR){{STORE NEW CHARACTER{24751
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{24752
{{ICV{3,PROFS{{{BUMP POINTER{24753
{{MOV{7,XR{10,(XS)+{{RESTORE ENTRY XR{24754
{{EXI{{{{RETURN TO PRTCH CALLER{24755
{{ENP{{{{END PROCEDURE PRTCH{24756
{{EJC{{{{{24757
*
*      PRTIC -- PRINT TO INTERACTIVE CHANNEL
*
*      PRTIC IS CALLED TO PRINT THE CONTENTS OF THE STANDARD
*      PRINT BUFFER TO THE INTERACTIVE CHANNEL. IT IS ONLY
*      CALLED AFTER PRTST HAS SET UP THE STRING FOR PRINTING.
*      IT DOES NOT CLEAR THE BUFFER.
*
*      JSR  PRTIC            CALL FOR PRINT
*      (WA,WB)               DESTROYED
*
{PRTIC{PRC{25,E{1,0{{ENTRY POINT{24769
{{MOV{11,-(XS){7,XR{{SAVE XR{24770
{{MOV{7,XR{3,PRBUF{{POINT TO BUFFER{24771
{{MOV{8,WA{3,PROFS{{NO OF CHARS{24772
{{JSR{6,SYSPI{{{PRINT{24773
{{PPM{6,PRTC2{{{FAIL RETURN{24774
*
*      RETURN
*
{PRTC1{MOV{7,XR{10,(XS)+{{RESTORE XR{24778
{{EXI{{{{RETURN{24779
*
*      ERROR OCCURED
*
{PRTC2{ZER{3,ERICH{{{PREVENT LOOPING{24783
{{ERB{1,252{26,Error on printing to interactive channel{{{24784
{{BRN{6,PRTC1{{{RETURN{24785
{{ENP{{{{PROCEDURE PRTIC{24786
{{EJC{{{{{24787
*
*      PRTIS -- PRINT TO INTERACTIVE AND STANDARD PRINTER
*
*      PRTIS PUTS A LINE FROM THE PRINT BUFFER ONTO THE
*      INTERACTIVE CHANNEL (IF ANY) AND THE STANDARD PRINTER.
*      IT ALWAYS PRINTS TO THE STANDARD PRINTER BUT DOES
*      NOT DUPLICATE LINES IF THE STANDARD PRINTER IS
*      INTERACTIVE.  IT CLEARS DOWN THE PRINT BUFFER.
*
*      JSR  PRTIS            CALL FOR PRINTING
*      (WA,WB)               DESTROYED
*
{PRTIS{PRC{25,E{1,0{{ENTRY POINT{24800
{{BNZ{3,PRICH{6,PRTS1{{JUMP IF STANDARD PRINTER IS INT.CH.{24801
{{BZE{3,ERICH{6,PRTS1{{SKIP IF NOT DOING INT. ERROR REPS.{24802
{{JSR{6,PRTIC{{{PRINT TO INTERACTIVE CHANNEL{24803
*
*      MERGE AND EXIT
*
{PRTS1{JSR{6,PRTNL{{{PRINT TO STANDARD PRINTER{24807
{{EXI{{{{RETURN{24808
{{ENP{{{{END PROCEDURE PRTIS{24809
{{EJC{{{{{24810
*
*      PRTIN -- PRINT AN INTEGER
*
*      PRTIN PRINTS THE INTEGER VALUE WHICH IS IN THE INTEGER
*      ACCUMULATOR. BLOCKS BUILT IN DYNAMIC STORAGE
*      DURING THIS PROCESS ARE IMMEDIATELY DELETED.
*
*      (IA)                  INTEGER VALUE TO BE PRINTED
*      JSR  PRTIN            CALL TO PRINT INTEGER
*      (IA,RA)               DESTROYED
*
{PRTIN{PRC{25,E{1,0{{ENTRY POINT{24822
{{MOV{11,-(XS){7,XR{{SAVE XR{24823
{{JSR{6,ICBLD{{{BUILD INTEGER BLOCK{24824
{{BLO{7,XR{3,DNAMB{6,PRTI1{JUMP IF ICBLK BELOW DYNAMIC{24825
{{BHI{7,XR{3,DNAMP{6,PRTI1{JUMP IF ABOVE DYNAMIC{24826
{{MOV{3,DNAMP{7,XR{{IMMEDIATELY DELETE IT{24827
*
*      DELETE ICBLK FROM DYNAMIC STORE
*
{PRTI1{MOV{11,-(XS){7,XR{{STACK PTR FOR GTSTG{24831
{{JSR{6,GTSTG{{{CONVERT TO STRING{24832
{{PPM{{{{CONVERT ERROR IS IMPOSSIBLE{24833
{{MOV{3,DNAMP{7,XR{{RESET POINTER TO DELETE SCBLK{24834
{{JSR{6,PRTST{{{PRINT INTEGER STRING{24835
{{MOV{7,XR{10,(XS)+{{RESTORE ENTRY XR{24836
{{EXI{{{{RETURN TO PRTIN CALLER{24837
{{ENP{{{{END PROCEDURE PRTIN{24838
{{EJC{{{{{24839
*
*      PRTMI -- PRINT MESSAGE AND INTEGER
*
*      PRTMI IS USED TO PRINT MESSAGES TOGETHER WITH AN INTEGER
*      VALUE STARTING IN COLUMN 15 (USED BY THE ROUTINES AT
*      THE END OF COMPILATION).
*
*      JSR  PRTMI            CALL TO PRINT MESSAGE AND INTEGER
*
{PRTMI{PRC{25,E{1,0{{ENTRY POINT{24849
{{JSR{6,PRTST{{{PRINT STRING MESSAGE{24850
{{MOV{3,PROFS{18,=PRTMF{{SET COLUMN OFFSET{24851
{{JSR{6,PRTIN{{{PRINT INTEGER{24852
{{JSR{6,PRTNL{{{PRINT LINE{24853
{{EXI{{{{RETURN TO PRTMI CALLER{24854
{{ENP{{{{END PROCEDURE PRTMI{24855
{{EJC{{{{{24856
*
*      PRTMM -- PRINT MEMORY USED AND AVAILABLE
*
*      PRTMM IS USED TO PROVIDE MEMORY USAGE INFORMATION IN
*      BOTH THE END-OF-COMPILE AND END-OF-RUN STATISTICS.
*
*      JSR  PRTMM            CALL TO PRINT MEMORY STATS
*
{PRTMM{PRC{25,E{1,0{{{24865
{{MOV{8,WA{3,DNAMP{{NEXT AVAILABLE LOC{24866
{{SUB{8,WA{3,STATB{{MINUS START{24867
{{MTI{8,WA{{{CONVERT TO INTEGER{24872
{{MOV{7,XR{21,=ENCM1{{POINT TO /MEMORY USED (WORDS)/{24873
{{JSR{6,PRTMI{{{PRINT MESSAGE{24874
{{MOV{8,WA{3,DNAME{{END OF MEMORY{24875
{{SUB{8,WA{3,DNAMP{{MINUS NEXT AVAILABLE LOC{24876
{{MTI{8,WA{{{CONVERT TO INTEGER{24881
{{MOV{7,XR{21,=ENCM2{{POINT TO /MEMORY AVAILABLE (WORDS)/{24882
{{JSR{6,PRTMI{{{PRINT LINE{24883
{{EXI{{{{RETURN TO PRTMM CALLER{24884
{{ENP{{{{END OF PROCEDURE PRTMM{24885
{{EJC{{{{{24886
*
*      PRTMX  -- AS PRTMI WITH EXTRA COPY TO INTERACTIVE CHAN.
*
*      JSR  PRTMX            CALL FOR PRINTING
*      (WA,WB)               DESTROYED
*
{PRTMX{PRC{25,E{1,0{{ENTRY POINT{24893
{{JSR{6,PRTST{{{PRINT STRING MESSAGE{24894
{{MOV{3,PROFS{18,=PRTMF{{SET COLUMN OFFSET{24895
{{JSR{6,PRTIN{{{PRINT INTEGER{24896
{{JSR{6,PRTIS{{{PRINT LINE{24897
{{EXI{{{{RETURN{24898
{{ENP{{{{END PROCEDURE PRTMX{24899
{{EJC{{{{{24900
*
*      PRTNL -- PRINT NEW LINE (END PRINT LINE)
*
*      PRTNL PRINTS THE CONTENTS OF THE PRINT BUFFER, RESETS
*      THE BUFFER TO ALL BLANKS AND RESETS THE PRINT POINTER.
*
*      JSR  PRTNL            CALL TO PRINT LINE
*
{PRTNL{PRC{25,R{1,0{{ENTRY POINT{24909
{{BNZ{3,HEADP{6,PRNL0{{WERE HEADERS PRINTED{24910
{{JSR{6,PRTPS{{{NO - PRINT THEM{24911
*
*      CALL SYSPR
*
{PRNL0{MOV{11,-(XS){7,XR{{SAVE ENTRY XR{24915
{{MOV{3,PRTSA{8,WA{{SAVE WA{24916
{{MOV{3,PRTSB{8,WB{{SAVE WB{24917
{{MOV{7,XR{3,PRBUF{{LOAD POINTER TO BUFFER{24918
{{MOV{8,WA{3,PROFS{{LOAD NUMBER OF CHARS IN BUFFER{24919
{{JSR{6,SYSPR{{{CALL SYSTEM PRINT ROUTINE{24920
{{PPM{6,PRNL2{{{JUMP IF FAILED{24921
{{LCT{8,WA{3,PRLNW{{LOAD LENGTH OF BUFFER IN WORDS{24922
{{ADD{7,XR{19,*SCHAR{{POINT TO CHARS OF BUFFER{24923
{{MOV{8,WB{4,NULLW{{GET WORD OF BLANKS{24924
*
*      LOOP TO BLANK BUFFER
*
{PRNL1{MOV{10,(XR)+{8,WB{{STORE WORD OF BLANKS, BUMP PTR{24928
{{BCT{8,WA{6,PRNL1{{LOOP TILL ALL BLANKED{24929
*
*      EXIT POINT
*
{{MOV{8,WB{3,PRTSB{{RESTORE WB{24933
{{MOV{8,WA{3,PRTSA{{RESTORE WA{24934
{{MOV{7,XR{10,(XS)+{{RESTORE ENTRY XR{24935
{{ZER{3,PROFS{{{RESET PRINT BUFFER POINTER{24936
{{EXI{{{{RETURN TO PRTNL CALLER{24937
*
*      FILE FULL OR NO OUTPUT FILE FOR LOAD MODULE
*
{PRNL2{BNZ{3,PRTEF{6,PRNL3{{JUMP IF NOT FIRST TIME{24941
{{MNZ{3,PRTEF{{{MARK FIRST OCCURRENCE{24942
{{ERB{1,253{26,Print limit exceeded on standard output channel{{{24943
*
*      STOP AT ONCE
*
{PRNL3{MOV{8,WB{18,=NINI8{{ENDING CODE{24947
{{MOV{8,WA{3,KVSTN{{STATEMENT NUMBER{24948
{{MOV{7,XL{3,R_FCB{{GET FCBLK CHAIN HEAD{24949
{{JSR{6,SYSEJ{{{STOP{24950
{{ENP{{{{END PROCEDURE PRTNL{24951
{{EJC{{{{{24952
*
*      PRTNM -- PRINT VARIABLE NAME
*
*      PRTNM IS USED TO PRINT A CHARACTER REPRESENTATION OF THE
*      NAME OF A VARIABLE (NOT A VALUE OF DATATYPE NAME)
*      NAMES OF PSEUDO-VARIABLES MAY NOT BE PASSED TO PRTNM.
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      JSR  PRTNM            CALL TO PRINT NAME
*      (WB,WC,RA)            DESTROYED
*
{PRTNM{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE, SEE PRTVL){24965
{{MOV{11,-(XS){8,WA{{SAVE WA (OFFSET IS COLLECTABLE){24966
{{MOV{11,-(XS){7,XR{{SAVE ENTRY XR{24967
{{MOV{11,-(XS){7,XL{{SAVE NAME BASE{24968
{{BHI{7,XL{3,STATE{6,PRN02{JUMP IF NOT NATURAL VARIABLE{24969
*
*      HERE FOR NATURAL VARIABLE NAME, RECOGNIZED BY THE FACT
*      THAT THE NAME BASE POINTS INTO THE STATIC AREA.
*
{{MOV{7,XR{7,XL{{POINT TO VRBLK{24974
{{JSR{6,PRTVN{{{PRINT NAME OF VARIABLE{24975
*
*      COMMON EXIT POINT
*
{PRN01{MOV{7,XL{10,(XS)+{{RESTORE NAME BASE{24979
{{MOV{7,XR{10,(XS)+{{RESTORE ENTRY VALUE OF XR{24980
{{MOV{8,WA{10,(XS)+{{RESTORE WA{24981
{{EXI{{{{RETURN TO PRTNM CALLER{24982
*
*      HERE FOR CASE OF NON-NATURAL VARIABLE
*
{PRN02{MOV{8,WB{8,WA{{COPY NAME OFFSET{24986
{{BNE{9,(XL){22,=B_PDT{6,PRN03{JUMP IF ARRAY OR TABLE{24987
*
*      FOR PROGRAM DEFINED DATATYPE, PRT FLD NAME, LEFT PAREN
*
{{MOV{7,XR{13,PDDFP(XL){{LOAD POINTER TO DFBLK{24991
{{ADD{7,XR{8,WA{{ADD NAME OFFSET{24992
{{MOV{7,XR{13,PDFOF(XR){{LOAD VRBLK POINTER FOR FIELD{24993
{{JSR{6,PRTVN{{{PRINT FIELD NAME{24994
{{MOV{8,WA{18,=CH_PP{{LOAD LEFT PAREN{24995
{{JSR{6,PRTCH{{{PRINT CHARACTER{24996
{{EJC{{{{{24997
*
*      PRTNM (CONTINUED)
*
*      NOW WE PRINT AN IDENTIFYING NAME FOR THE OBJECT IF ONE
*      CAN BE FOUND. THE FOLLOWING CODE SEARCHES FOR A NATURAL
*      VARIABLE WHICH CONTAINS THIS OBJECT AS VALUE. IF SUCH A
*      VARIABLE IS FOUND, ITS NAME IS PRINTED, ELSE THE VALUE
*      OF THE OBJECT (AS PRINTED BY PRTVL) IS USED INSTEAD.
*
*      FIRST WE POINT TO THE PARENT TBBLK IF THIS IS THE CASE OF
*      A TABLE ELEMENT. TO DO THIS, CHASE DOWN THE TRNXT CHAIN.
*
{PRN03{BNE{9,(XL){22,=B_TET{6,PRN04{JUMP IF WE GOT THERE (OR NOT TE){25010
{{MOV{7,XL{13,TENXT(XL){{ELSE MOVE OUT ON CHAIN{25011
{{BRN{6,PRN03{{{AND LOOP BACK{25012
*
*      NOW WE ARE READY FOR THE SEARCH. TO SPEED THINGS UP IN
*      THE CASE OF CALLS FROM DUMP WHERE THE SAME NAME BASE
*      WILL OCCUR REPEATEDLY WHILE DUMPING AN ARRAY OR TABLE,
*      WE REMEMBER THE LAST VRBLK POINTER FOUND IN PRNMV. SO
*      FIRST CHECK TO SEE IF WE HAVE THIS ONE AGAIN.
*
{PRN04{MOV{7,XR{3,PRNMV{{POINT TO VRBLK WE FOUND LAST TIME{25020
{{MOV{8,WA{3,HSHTB{{POINT TO HASH TABLE IN CASE NOT{25021
{{BRN{6,PRN07{{{JUMP INTO SEARCH FOR SPECIAL CHECK{25022
*
*      LOOP THROUGH HASH SLOTS
*
{PRN05{MOV{7,XR{8,WA{{COPY SLOT POINTER{25026
{{ICA{8,WA{{{BUMP SLOT POINTER{25027
{{SUB{7,XR{19,*VRNXT{{INTRODUCE STANDARD VRBLK OFFSET{25028
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
{PRN06{MOV{7,XR{13,VRNXT(XR){{POINT TO NEXT VRBLK ON HASH CHAIN{25032
*
*      MERGE HERE FIRST TIME TO CHECK BLOCK WE FOUND LAST TIME
*
{PRN07{MOV{8,WC{7,XR{{COPY VRBLK POINTER{25036
{{BZE{8,WC{6,PRN09{{JUMP IF CHAIN END (OR PRNMV ZERO){25037
{{EJC{{{{{25038
*
*      PRTNM (CONTINUED)
*
*      LOOP TO FIND VALUE (CHASE DOWN POSSIBLE TRBLK CHAIN)
*
{PRN08{MOV{7,XR{13,VRVAL(XR){{LOAD VALUE{25044
{{BEQ{9,(XR){22,=B_TRT{6,PRN08{LOOP IF THAT WAS A TRBLK{25045
*
*      NOW WE HAVE THE VALUE, IS THIS THE BLOCK WE WANT
*
{{BEQ{7,XR{7,XL{6,PRN10{JUMP IF THIS MATCHES THE NAME BASE{25049
{{MOV{7,XR{8,WC{{ELSE POINT BACK TO THAT VRBLK{25050
{{BRN{6,PRN06{{{AND LOOP BACK{25051
*
*      HERE TO MOVE TO NEXT HASH SLOT
*
{PRN09{BLT{8,WA{3,HSHTE{6,PRN05{LOOP BACK IF MORE TO GO{25055
{{MOV{7,XR{7,XL{{ELSE NOT FOUND, COPY VALUE POINTER{25056
{{JSR{6,PRTVL{{{PRINT VALUE{25057
{{BRN{6,PRN11{{{AND MERGE AHEAD{25058
*
*      HERE WHEN WE FIND A MATCHING ENTRY
*
{PRN10{MOV{7,XR{8,WC{{COPY VRBLK POINTER{25062
{{MOV{3,PRNMV{7,XR{{SAVE FOR NEXT TIME IN{25063
{{JSR{6,PRTVN{{{PRINT VARIABLE NAME{25064
*
*      MERGE HERE IF NO ENTRY FOUND
*
{PRN11{MOV{8,WC{9,(XL){{LOAD FIRST WORD OF NAME BASE{25068
{{BNE{8,WC{22,=B_PDT{6,PRN13{JUMP IF NOT PROGRAM DEFINED{25069
*
*      FOR PROGRAM DEFINED DATATYPE, ADD RIGHT PAREN AND EXIT
*
{{MOV{8,WA{18,=CH_RP{{LOAD RIGHT PAREN, MERGE{25073
*
*      MERGE HERE TO PRINT FINAL RIGHT PAREN OR BRACKET
*
{PRN12{JSR{6,PRTCH{{{PRINT FINAL CHARACTER{25077
{{MOV{8,WA{8,WB{{RESTORE NAME OFFSET{25078
{{BRN{6,PRN01{{{MERGE BACK TO EXIT{25079
{{EJC{{{{{25080
*
*      PRTNM (CONTINUED)
*
*      HERE FOR ARRAY OR TABLE
*
{PRN13{MOV{8,WA{18,=CH_BB{{LOAD LEFT BRACKET{25086
{{JSR{6,PRTCH{{{AND PRINT IT{25087
{{MOV{7,XL{9,(XS){{RESTORE BLOCK POINTER{25088
{{MOV{8,WC{9,(XL){{LOAD TYPE WORD AGAIN{25089
{{BNE{8,WC{22,=B_TET{6,PRN15{JUMP IF NOT TABLE{25090
*
*      HERE FOR TABLE, PRINT SUBSCRIPT VALUE
*
{{MOV{7,XR{13,TESUB(XL){{LOAD SUBSCRIPT VALUE{25094
{{MOV{7,XL{8,WB{{SAVE NAME OFFSET{25095
{{JSR{6,PRTVL{{{PRINT SUBSCRIPT VALUE{25096
{{MOV{8,WB{7,XL{{RESTORE NAME OFFSET{25097
*
*      MERGE HERE FROM ARRAY CASE TO PRINT RIGHT BRACKET
*
{PRN14{MOV{8,WA{18,=CH_RB{{LOAD RIGHT BRACKET{25101
{{BRN{6,PRN12{{{MERGE BACK TO PRINT IT{25102
*
*      HERE FOR ARRAY OR VECTOR, TO PRINT SUBSCRIPT(S)
*
{PRN15{MOV{8,WA{8,WB{{COPY NAME OFFSET{25106
{{BTW{8,WA{{{CONVERT TO WORDS{25107
{{BEQ{8,WC{22,=B_ART{6,PRN16{JUMP IF ARBLK{25108
*
*      HERE FOR VECTOR
*
{{SUB{8,WA{18,=VCVLB{{ADJUST FOR STANDARD FIELDS{25112
{{MTI{8,WA{{{MOVE TO INTEGER ACCUM{25113
{{JSR{6,PRTIN{{{PRINT LINEAR SUBSCRIPT{25114
{{BRN{6,PRN14{{{MERGE BACK FOR RIGHT BRACKET{25115
{{EJC{{{{{25116
*
*      PRTNM (CONTINUED)
*
*      HERE FOR ARRAY. FIRST CALCULATE ABSOLUTE SUBSCRIPT
*      OFFSETS BY SUCCESSIVE DIVISIONS BY THE DIMENSION VALUES.
*      THIS MUST BE DONE RIGHT TO LEFT SINCE THE ELEMENTS ARE
*      STORED ROW-WISE. THE SUBSCRIPTS ARE STACKED AS INTEGERS.
*
{PRN16{MOV{8,WC{13,AROFS(XL){{LOAD LENGTH OF BOUNDS INFO{25125
{{ICA{8,WC{{{ADJUST FOR ARPRO FIELD{25126
{{BTW{8,WC{{{CONVERT TO WORDS{25127
{{SUB{8,WA{8,WC{{GET LINEAR ZERO-ORIGIN SUBSCRIPT{25128
{{MTI{8,WA{{{GET INTEGER VALUE{25129
{{LCT{8,WA{13,ARNDM(XL){{SET NUM OF DIMENSIONS AS LOOP COUNT{25130
{{ADD{7,XL{13,AROFS(XL){{POINT PAST BOUNDS INFORMATION{25131
{{SUB{7,XL{19,*ARLBD{{SET OK OFFSET FOR PROPER PTR LATER{25132
*
*      LOOP TO STACK SUBSCRIPT OFFSETS
*
{PRN17{SUB{7,XL{19,*ARDMS{{POINT TO NEXT SET OF BOUNDS{25136
{{STI{3,PRNSI{{{SAVE CURRENT OFFSET{25137
{{RMI{13,ARDIM(XL){{{GET REMAINDER ON DIVIDING BY DIMENS{25138
{{MFI{11,-(XS){{{STORE ON STACK (ONE WORD){25139
{{LDI{3,PRNSI{{{RELOAD ARGUMENT{25140
{{DVI{13,ARDIM(XL){{{DIVIDE TO GET QUOTIENT{25141
{{BCT{8,WA{6,PRN17{{LOOP TILL ALL STACKED{25142
{{ZER{7,XR{{{SET OFFSET TO FIRST SET OF BOUNDS{25143
{{LCT{8,WB{13,ARNDM(XL){{LOAD COUNT OF DIMS TO CONTROL LOOP{25144
{{BRN{6,PRN19{{{JUMP INTO PRINT LOOP{25145
*
*      LOOP TO PRINT SUBSCRIPTS FROM STACK ADJUSTING BY ADDING
*      THE APPROPRIATE LOW BOUND VALUE FROM THE ARBLK
*
{PRN18{MOV{8,WA{18,=CH_CM{{LOAD A COMMA{25150
{{JSR{6,PRTCH{{{PRINT IT{25151
*
*      MERGE HERE FIRST TIME IN (NO COMMA REQUIRED)
*
{PRN19{MTI{10,(XS)+{{{LOAD SUBSCRIPT OFFSET AS INTEGER{25155
{{ADD{7,XL{7,XR{{POINT TO CURRENT LBD{25156
{{ADI{13,ARLBD(XL){{{ADD LBD TO GET SIGNED SUBSCRIPT{25157
{{SUB{7,XL{7,XR{{POINT BACK TO START OF ARBLK{25158
{{JSR{6,PRTIN{{{PRINT SUBSCRIPT{25159
{{ADD{7,XR{19,*ARDMS{{BUMP OFFSET TO NEXT BOUNDS{25160
{{BCT{8,WB{6,PRN18{{LOOP BACK TILL ALL PRINTED{25161
{{BRN{6,PRN14{{{MERGE BACK TO PRINT RIGHT BRACKET{25162
{{ENP{{{{END PROCEDURE PRTNM{25163
{{EJC{{{{{25164
*
*      PRTNV -- PRINT NAME VALUE
*
*      PRTNV IS USED BY THE TRACE AND DUMP ROUTINES TO PRINT
*      A LINE OF THE FORM
*
*      NAME = VALUE
*
*      NOTE THAT THE NAME INVOLVED CAN NEVER BE A PSEUDO-VAR
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      JSR  PRTNV            CALL TO PRINT NAME = VALUE
*      (WB,WC,RA)            DESTROYED
*
{PRTNV{PRC{25,E{1,0{{ENTRY POINT{25180
{{JSR{6,PRTNM{{{PRINT ARGUMENT NAME{25181
{{MOV{11,-(XS){7,XR{{SAVE ENTRY XR{25182
{{MOV{11,-(XS){8,WA{{SAVE NAME OFFSET (COLLECTABLE){25183
{{MOV{7,XR{21,=TMBEB{{POINT TO BLANK EQUAL BLANK{25184
{{JSR{6,PRTST{{{PRINT IT{25185
{{MOV{7,XR{7,XL{{COPY NAME BASE{25186
{{ADD{7,XR{8,WA{{POINT TO VALUE{25187
{{MOV{7,XR{9,(XR){{LOAD VALUE POINTER{25188
{{JSR{6,PRTVL{{{PRINT VALUE{25189
{{JSR{6,PRTNL{{{TERMINATE LINE{25190
{{MOV{8,WA{10,(XS)+{{RESTORE NAME OFFSET{25191
{{MOV{7,XR{10,(XS)+{{RESTORE ENTRY XR{25192
{{EXI{{{{RETURN TO CALLER{25193
{{ENP{{{{END PROCEDURE PRTNV{25194
{{EJC{{{{{25195
*
*      PRTPG  -- PRINT A PAGE THROW
*
*      PRINTS A PAGE THROW OR A FEW BLANK LINES ON THE STANDARD
*      LISTING CHANNEL DEPENDING ON THE LISTING OPTIONS CHOSEN.
*
*      JSR  PRTPG            CALL FOR PAGE EJECT
*
{PRTPG{PRC{25,E{1,0{{ENTRY POINT{25204
{{BEQ{3,STAGE{18,=STGXT{6,PRP01{JUMP IF EXECUTION TIME{25205
{{BZE{3,LSTLC{6,PRP06{{RETURN IF TOP OF PAGE ALREADY{25206
{{ZER{3,LSTLC{{{CLEAR LINE COUNT{25207
*
*      CHECK TYPE OF LISTING
*
{PRP01{MOV{11,-(XS){7,XR{{PRESERVE XR{25211
{{BNZ{3,PRSTD{6,PRP02{{EJECT IF FLAG SET{25212
{{BNZ{3,PRICH{6,PRP03{{JUMP IF INTERACTIVE LISTING CHANNEL{25213
{{BZE{3,PRECL{6,PRP03{{JUMP IF COMPACT LISTING{25214
*
*      PERFORM AN EJECT
*
{PRP02{JSR{6,SYSEP{{{EJECT{25218
{{BRN{6,PRP04{{{MERGE{25219
*
*      COMPACT OR INTERACTIVE CHANNEL LISTING. CANT PRINT
*      BLANKS UNTIL CHECK MADE FOR HEADERS PRINTED AND FLAG SET.
*
*
{PRP03{MOV{7,XR{3,HEADP{{REMEMBER HEADP{25225
{{MNZ{3,HEADP{{{SET TO AVOID REPEATED PRTPG CALLS{25226
{{JSR{6,PRTNL{{{PRINT BLANK LINE{25227
{{JSR{6,PRTNL{{{PRINT BLANK LINE{25228
{{JSR{6,PRTNL{{{PRINT BLANK LINE{25229
{{MOV{3,LSTLC{18,=NUM03{{COUNT BLANK LINES{25230
{{MOV{3,HEADP{7,XR{{RESTORE HEADER FLAG{25231
{{EJC{{{{{25232
*
*      PRPTG (CONTINUED)
*
*      PRINT THE HEADING
*
{PRP04{BNZ{3,HEADP{6,PRP05{{JUMP IF HEADER LISTED{25238
{{MNZ{3,HEADP{{{MARK HEADERS PRINTED{25239
{{MOV{11,-(XS){7,XL{{KEEP XL{25240
{{MOV{7,XR{21,=HEADR{{POINT TO LISTING HEADER{25241
{{JSR{6,PRTST{{{PLACE IT{25242
{{JSR{6,SYSID{{{GET SYSTEM IDENTIFICATION{25243
{{JSR{6,PRTST{{{APPEND EXTRA CHARS{25244
{{JSR{6,PRTNL{{{PRINT IT{25245
{{MOV{7,XR{7,XL{{EXTRA HEADER LINE{25246
{{JSR{6,PRTST{{{PLACE IT{25247
{{JSR{6,PRTNL{{{PRINT IT{25248
{{JSR{6,PRTNL{{{PRINT A BLANK{25249
{{JSR{6,PRTNL{{{AND ANOTHER{25250
{{ADD{3,LSTLC{18,=NUM04{{FOUR HEADER LINES PRINTED{25251
{{MOV{7,XL{10,(XS)+{{RESTORE XL{25252
*
*      MERGE IF HEADER NOT PRINTED
*
{PRP05{MOV{7,XR{10,(XS)+{{RESTORE XR{25256
*
*      RETURN
*
{PRP06{EXI{{{{RETURN{25260
{{ENP{{{{END PROCEDURE PRTPG{25261
{{EJC{{{{{25262
*
*      PRTPS - PRINT PAGE WITH TEST FOR STANDARD LISTING OPTION
*
*      IF THE STANDARD LISTING OPTION IS SELECTED, INSIST THAT
*      AN EJECT BE DONE
*
*      JSR  PRTPS            CALL FOR EJECT
*
{PRTPS{PRC{25,E{1,0{{ENTRY POINT{25271
{{MOV{3,PRSTD{3,PRSTO{{COPY OPTION FLAG{25272
{{JSR{6,PRTPG{{{PRINT PAGE{25273
{{ZER{3,PRSTD{{{CLEAR FLAG{25274
{{EXI{{{{RETURN{25275
{{ENP{{{{END PROCEDURE PRTPS{25276
{{EJC{{{{{25277
*
*      PRTSN -- PRINT STATEMENT NUMBER
*
*      PRTSN IS USED TO INITIATE A PRINT TRACE LINE BY PRINTING
*      ASTERISKS AND THE CURRENT STATEMENT NUMBER. THE ACTUAL
*      FORMAT OF THE OUTPUT GENERATED IS.
*
*      ***NNNNN**** III.....IIII
*
*      NNNNN IS THE STATEMENT NUMBER WITH LEADING ZEROS REPLACED
*      BY ASTERISKS (E.G. *******9****)
*
*      III...III REPRESENTS A VARIABLE LENGTH OUTPUT CONSISTING
*      OF A NUMBER OF LETTER I CHARACTERS EQUAL TO FNCLEVEL.
*
*      JSR  PRTSN            CALL TO PRINT STATEMENT NUMBER
*      (WC)                  DESTROYED
*
{PRTSN{PRC{25,E{1,0{{ENTRY POINT{25296
{{MOV{11,-(XS){7,XR{{SAVE ENTRY XR{25297
{{MOV{3,PRSNA{8,WA{{SAVE ENTRY WA{25298
{{MOV{7,XR{21,=TMASB{{POINT TO ASTERISKS{25299
{{JSR{6,PRTST{{{PRINT ASTERISKS{25300
{{MOV{3,PROFS{18,=NUM04{{POINT INTO MIDDLE OF ASTERISKS{25301
{{MTI{3,KVSTN{{{LOAD STATEMENT NUMBER AS INTEGER{25302
{{JSR{6,PRTIN{{{PRINT INTEGER STATEMENT NUMBER{25303
{{MOV{3,PROFS{18,=PRSNF{{POINT PAST ASTERISKS PLUS BLANK{25304
{{MOV{7,XR{3,KVFNC{{GET FNCLEVEL{25305
{{MOV{8,WA{18,=CH_LI{{SET LETTER I{25306
*
*      LOOP TO GENERATE LETTER I FNCLEVEL TIMES
*
{PRSN1{BZE{7,XR{6,PRSN2{{JUMP IF ALL SET{25310
{{JSR{6,PRTCH{{{ELSE PRINT AN I{25311
{{DCV{7,XR{{{DECREMENT COUNTER{25312
{{BRN{6,PRSN1{{{LOOP BACK{25313
*
*      MERGE WITH ALL LETTER I CHARACTERS GENERATED
*
{PRSN2{MOV{8,WA{18,=CH_BL{{GET BLANK{25317
{{JSR{6,PRTCH{{{PRINT BLANK{25318
{{MOV{8,WA{3,PRSNA{{RESTORE ENTRY WA{25319
{{MOV{7,XR{10,(XS)+{{RESTORE ENTRY XR{25320
{{EXI{{{{RETURN TO PRTSN CALLER{25321
{{ENP{{{{END PROCEDURE PRTSN{25322
{{EJC{{{{{25323
*
*      PRTST -- PRINT STRING
*
*      PRTST PLACES A STRING OF CHARACTERS IN THE PRINT BUFFER
*
*      SEE PRTNL FOR GLOBAL LOCATIONS USED
*
*      NOTE THAT THE FIRST WORD OF THE BLOCK (NORMALLY B_SCL)
*      IS NOT USED AND NEED NOT BE SET CORRECTLY (SEE PRTVN)
*
*      (XR)                  STRING TO BE PRINTED
*      JSR  PRTST            CALL TO PRINT STRING
*      (PROFS)               UPDATED PAST CHARS PLACED
*
{PRTST{PRC{25,R{1,0{{ENTRY POINT{25338
{{BNZ{3,HEADP{6,PRST0{{WERE HEADERS PRINTED{25339
{{JSR{6,PRTPS{{{NO - PRINT THEM{25340
*
*      CALL SYSPR
*
{PRST0{MOV{3,PRSVA{8,WA{{SAVE WA{25344
{{MOV{3,PRSVB{8,WB{{SAVE WB{25345
{{ZER{8,WB{{{SET CHARS PRINTED COUNT TO ZERO{25346
*
*      LOOP TO PRINT SUCCESSIVE LINES FOR LONG STRING
*
{PRST1{MOV{8,WA{13,SCLEN(XR){{LOAD STRING LENGTH{25350
{{SUB{8,WA{8,WB{{SUBTRACT COUNT OF CHARS ALREADY OUT{25351
{{BZE{8,WA{6,PRST4{{JUMP TO EXIT IF NONE LEFT{25352
{{MOV{11,-(XS){7,XL{{ELSE STACK ENTRY XL{25353
{{MOV{11,-(XS){7,XR{{SAVE ARGUMENT{25354
{{MOV{7,XL{7,XR{{COPY FOR EVENTUAL MOVE{25355
{{MOV{7,XR{3,PRLEN{{LOAD PRINT BUFFER LENGTH{25356
{{SUB{7,XR{3,PROFS{{GET CHARS LEFT IN PRINT BUFFER{25357
{{BNZ{7,XR{6,PRST2{{SKIP IF ROOM LEFT ON THIS LINE{25358
{{JSR{6,PRTNL{{{ELSE PRINT THIS LINE{25359
{{MOV{7,XR{3,PRLEN{{AND SET FULL WIDTH AVAILABLE{25360
{{EJC{{{{{25361
*
*      PRTST (CONTINUED)
*
*      HERE WITH CHARS TO PRINT AND SOME ROOM IN BUFFER
*
{PRST2{BLO{8,WA{7,XR{6,PRST3{JUMP IF ROOM FOR REST OF STRING{25367
{{MOV{8,WA{7,XR{{ELSE SET TO FILL LINE{25368
*
*      MERGE HERE WITH CHARACTER COUNT IN WA
*
{PRST3{MOV{7,XR{3,PRBUF{{POINT TO PRINT BUFFER{25372
{{PLC{7,XL{8,WB{{POINT TO LOCATION IN STRING{25373
{{PSC{7,XR{3,PROFS{{POINT TO LOCATION IN BUFFER{25374
{{ADD{8,WB{8,WA{{BUMP STRING CHARS COUNT{25375
{{ADD{3,PROFS{8,WA{{BUMP BUFFER POINTER{25376
{{MOV{3,PRSVC{8,WB{{PRESERVE CHAR COUNTER{25377
{{MVC{{{{MOVE CHARACTERS TO BUFFER{25378
{{MOV{8,WB{3,PRSVC{{RECOVER CHAR COUNTER{25379
{{MOV{7,XR{10,(XS)+{{RESTORE ARGUMENT POINTER{25380
{{MOV{7,XL{10,(XS)+{{RESTORE ENTRY XL{25381
{{BRN{6,PRST1{{{LOOP BACK TO TEST FOR MORE{25382
*
*      HERE TO EXIT AFTER PRINTING STRING
*
{PRST4{MOV{8,WB{3,PRSVB{{RESTORE ENTRY WB{25386
{{MOV{8,WA{3,PRSVA{{RESTORE ENTRY WA{25387
{{EXI{{{{RETURN TO PRTST CALLER{25388
{{ENP{{{{END PROCEDURE PRTST{25389
{{EJC{{{{{25390
*
*      PRTTR -- PRINT TO TERMINAL
*
*      CALLED TO PRINT CONTENTS OF STANDARD PRINT BUFFER TO
*      ONLINE TERMINAL. CLEARS BUFFER DOWN AND RESETS PROFS.
*
*      JSR  PRTTR            CALL FOR PRINT
*      (WA,WB)               DESTROYED
*
{PRTTR{PRC{25,E{1,0{{ENTRY POINT{25400
{{MOV{11,-(XS){7,XR{{SAVE XR{25401
{{JSR{6,PRTIC{{{PRINT BUFFER CONTENTS{25402
{{MOV{7,XR{3,PRBUF{{POINT TO PRINT BFR TO CLEAR IT{25403
{{LCT{8,WA{3,PRLNW{{GET BUFFER LENGTH{25404
{{ADD{7,XR{19,*SCHAR{{POINT PAST SCBLK HEADER{25405
{{MOV{8,WB{4,NULLW{{GET BLANKS{25406
*
*      LOOP TO CLEAR BUFFER
*
{PRTT1{MOV{10,(XR)+{8,WB{{CLEAR A WORD{25410
{{BCT{8,WA{6,PRTT1{{LOOP{25411
{{ZER{3,PROFS{{{RESET PROFS{25412
{{MOV{7,XR{10,(XS)+{{RESTORE XR{25413
{{EXI{{{{RETURN{25414
{{ENP{{{{END PROCEDURE PRTTR{25415
{{EJC{{{{{25416
*
*      PRTVL -- PRINT A VALUE
*
*      PRTVL PLACES AN APPROPRIATE CHARACTER REPRESENTATION OF
*      A DATA VALUE IN THE PRINT BUFFER FOR DUMP/TRACE USE.
*
*      (XR)                  VALUE TO BE PRINTED
*      JSR  PRTVL            CALL TO PRINT VALUE
*      (WA,WB,WC,RA)         DESTROYED
*
{PRTVL{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{25427
{{MOV{11,-(XS){7,XL{{SAVE ENTRY XL{25428
{{MOV{11,-(XS){7,XR{{SAVE ARGUMENT{25429
{{CHK{{{{CHECK FOR STACK OVERFLOW{25430
*
*      LOOP BACK HERE AFTER FINDING A TRAP BLOCK (TRBLK)
*
{PRV01{MOV{3,PRVSI{13,IDVAL(XR){{COPY IDVAL (IF ANY){25434
{{MOV{7,XL{9,(XR){{LOAD FIRST WORD OF BLOCK{25435
{{LEI{7,XL{{{LOAD ENTRY POINT ID{25436
{{BSW{7,XL{2,BL__T{6,PRV02{SWITCH ON BLOCK TYPE{25437
{{IFF{2,BL_AR{6,PRV05{{ARBLK{25455
{{IFF{1,1{6,PRV02{{{25455
{{IFF{1,2{6,PRV02{{{25455
{{IFF{2,BL_IC{6,PRV08{{ICBLK{25455
{{IFF{2,BL_NM{6,PRV09{{NMBLK{25455
{{IFF{1,5{6,PRV02{{{25455
{{IFF{1,6{6,PRV02{{{25455
{{IFF{1,7{6,PRV02{{{25455
{{IFF{2,BL_RC{6,PRV08{{RCBLK{25455
{{IFF{2,BL_SC{6,PRV11{{SCBLK{25455
{{IFF{2,BL_SE{6,PRV12{{SEBLK{25455
{{IFF{2,BL_TB{6,PRV13{{TBBLK{25455
{{IFF{2,BL_VC{6,PRV13{{VCBLK{25455
{{IFF{1,13{6,PRV02{{{25455
{{IFF{1,14{6,PRV02{{{25455
{{IFF{1,15{6,PRV02{{{25455
{{IFF{2,BL_PD{6,PRV10{{PDBLK{25455
{{IFF{2,BL_TR{6,PRV04{{TRBLK{25455
{{ESW{{{{END OF SWITCH ON BLOCK TYPE{25455
*
*      HERE FOR BLOCKS FOR WHICH WE JUST PRINT DATATYPE NAME
*
{PRV02{JSR{6,DTYPE{{{GET DATATYPE NAME{25459
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{25460
*
*      COMMON EXIT POINT
*
{PRV03{MOV{7,XR{10,(XS)+{{RELOAD ARGUMENT{25464
{{MOV{7,XL{10,(XS)+{{RESTORE XL{25465
{{EXI{{{{RETURN TO PRTVL CALLER{25466
*
*      HERE FOR TRBLK
*
{PRV04{MOV{7,XR{13,TRVAL(XR){{LOAD REAL VALUE{25470
{{BRN{6,PRV01{{{AND LOOP BACK{25471
{{EJC{{{{{25472
*
*      PRTVL (CONTINUED)
*
*      HERE FOR ARRAY (ARBLK)
*
*      PRINT ARRAY ( PROTOTYPE ) BLANK NUMBER IDVAL
*
{PRV05{MOV{7,XL{7,XR{{PRESERVE ARGUMENT{25480
{{MOV{7,XR{21,=SCARR{{POINT TO DATATYPE NAME (ARRAY){25481
{{JSR{6,PRTST{{{PRINT IT{25482
{{MOV{8,WA{18,=CH_PP{{LOAD LEFT PAREN{25483
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{25484
{{ADD{7,XL{13,AROFS(XL){{POINT TO PROTOTYPE{25485
{{MOV{7,XR{9,(XL){{LOAD PROTOTYPE{25486
{{JSR{6,PRTST{{{PRINT PROTOTYPE{25487
*
*      VCBLK, TBBLK, BCBLK MERGE HERE FOR ) BLANK NUMBER IDVAL
*
{PRV06{MOV{8,WA{18,=CH_RP{{LOAD RIGHT PAREN{25491
{{JSR{6,PRTCH{{{PRINT RIGHT PAREN{25492
*
*      PDBLK MERGES HERE TO PRINT BLANK NUMBER IDVAL
*
{PRV07{MOV{8,WA{18,=CH_BL{{LOAD BLANK{25496
{{JSR{6,PRTCH{{{PRINT IT{25497
{{MOV{8,WA{18,=CH_NM{{LOAD NUMBER SIGN{25498
{{JSR{6,PRTCH{{{PRINT IT{25499
{{MTI{3,PRVSI{{{GET IDVAL{25500
{{JSR{6,PRTIN{{{PRINT ID NUMBER{25501
{{BRN{6,PRV03{{{BACK TO EXIT{25502
*
*      HERE FOR INTEGER (ICBLK), REAL (RCBLK)
*
*      PRINT CHARACTER REPRESENTATION OF VALUE
*
{PRV08{MOV{11,-(XS){7,XR{{STACK ARGUMENT FOR GTSTG{25508
{{JSR{6,GTSTG{{{CONVERT TO STRING{25509
{{PPM{{{{ERROR RETURN IS IMPOSSIBLE{25510
{{JSR{6,PRTST{{{PRINT THE STRING{25511
{{MOV{3,DNAMP{7,XR{{DELETE GARBAGE STRING FROM STORAGE{25512
{{BRN{6,PRV03{{{BACK TO EXIT{25513
{{EJC{{{{{25514
*
*      PRTVL (CONTINUED)
*
*      NAME (NMBLK)
*
*      FOR PSEUDO-VARIABLE, JUST PRINT DATATYPE NAME (NAME)
*      FOR ALL OTHER NAMES, PRINT DOT FOLLOWED BY NAME REP
*
{PRV09{MOV{7,XL{13,NMBAS(XR){{LOAD NAME BASE{25523
{{MOV{8,WA{9,(XL){{LOAD FIRST WORD OF BLOCK{25524
{{BEQ{8,WA{22,=B_KVT{6,PRV02{JUST PRINT NAME IF KEYWORD{25525
{{BEQ{8,WA{22,=B_EVT{6,PRV02{JUST PRINT NAME IF EXPRESSION VAR{25526
{{MOV{8,WA{18,=CH_DT{{ELSE GET DOT{25527
{{JSR{6,PRTCH{{{AND PRINT IT{25528
{{MOV{8,WA{13,NMOFS(XR){{LOAD NAME OFFSET{25529
{{JSR{6,PRTNM{{{PRINT NAME{25530
{{BRN{6,PRV03{{{BACK TO EXIT{25531
*
*      PROGRAM DATATYPE (PDBLK)
*
*      PRINT DATATYPE NAME CH_BL CH_NM IDVAL
*
{PRV10{JSR{6,DTYPE{{{GET DATATYPE NAME{25537
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{25538
{{BRN{6,PRV07{{{MERGE BACK TO PRINT ID{25539
*
*      HERE FOR STRING (SCBLK)
*
*      PRINT QUOTE STRING-CHARACTERS QUOTE
*
{PRV11{MOV{8,WA{18,=CH_SQ{{LOAD SINGLE QUOTE{25545
{{JSR{6,PRTCH{{{PRINT QUOTE{25546
{{JSR{6,PRTST{{{PRINT STRING VALUE{25547
{{JSR{6,PRTCH{{{PRINT ANOTHER QUOTE{25548
{{BRN{6,PRV03{{{BACK TO EXIT{25549
{{EJC{{{{{25550
*
*      PRTVL (CONTINUED)
*
*      HERE FOR SIMPLE EXPRESSION (SEBLK)
*
*      PRINT ASTERISK VARIABLE-NAME
*
{PRV12{MOV{8,WA{18,=CH_AS{{LOAD ASTERISK{25558
{{JSR{6,PRTCH{{{PRINT ASTERISK{25559
{{MOV{7,XR{13,SEVAR(XR){{LOAD VARIABLE POINTER{25560
{{JSR{6,PRTVN{{{PRINT VARIABLE NAME{25561
{{BRN{6,PRV03{{{JUMP BACK TO EXIT{25562
*
*      HERE FOR TABLE (TBBLK) AND ARRAY (VCBLK)
*
*      PRINT DATATYPE ( PROTOTYPE ) BLANK NUMBER IDVAL
*
{PRV13{MOV{7,XL{7,XR{{PRESERVE ARGUMENT{25568
{{JSR{6,DTYPE{{{GET DATATYPE NAME{25569
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{25570
{{MOV{8,WA{18,=CH_PP{{LOAD LEFT PAREN{25571
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{25572
{{MOV{8,WA{13,TBLEN(XL){{LOAD LENGTH OF BLOCK (=VCLEN){25573
{{BTW{8,WA{{{CONVERT TO WORD COUNT{25574
{{SUB{8,WA{18,=TBSI_{{ALLOW FOR STANDARD FIELDS{25575
{{BEQ{9,(XL){22,=B_TBT{6,PRV14{JUMP IF TABLE{25576
{{ADD{8,WA{18,=VCTBD{{FOR VCBLK, ADJUST SIZE{25577
*
*      PRINT PROTOTYPE
*
{PRV14{MTI{8,WA{{{MOVE AS INTEGER{25581
{{JSR{6,PRTIN{{{PRINT INTEGER PROTOTYPE{25582
{{BRN{6,PRV06{{{MERGE BACK FOR REST{25583
{{ENP{{{{END PROCEDURE PRTVL{25606
{{EJC{{{{{25607
*
*      PRTVN -- PRINT NATURAL VARIABLE NAME
*
*      PRTVN PRINTS THE NAME OF A NATURAL VARIABLE
*
*      (XR)                  POINTER TO VRBLK
*      JSR  PRTVN            CALL TO PRINT VARIABLE NAME
*
{PRTVN{PRC{25,E{1,0{{ENTRY POINT{25616
{{MOV{11,-(XS){7,XR{{STACK VRBLK POINTER{25617
{{ADD{7,XR{19,*VRSOF{{POINT TO POSSIBLE STRING NAME{25618
{{BNZ{13,SCLEN(XR){6,PRVN1{{JUMP IF NOT SYSTEM VARIABLE{25619
{{MOV{7,XR{13,VRSVO(XR){{POINT TO SVBLK WITH NAME{25620
*
*      MERGE HERE WITH DUMMY SCBLK POINTER IN XR
*
{PRVN1{JSR{6,PRTST{{{PRINT STRING NAME OF VARIABLE{25624
{{MOV{7,XR{10,(XS)+{{RESTORE VRBLK POINTER{25625
{{EXI{{{{RETURN TO PRTVN CALLER{25626
{{ENP{{{{END PROCEDURE PRTVN{25627
{{EJC{{{{{25630
*
*      RCBLD -- BUILD A REAL BLOCK
*
*      (RA)                  REAL VALUE FOR RCBLK
*      JSR  RCBLD            CALL TO BUILD REAL BLOCK
*      (XR)                  POINTER TO RESULT RCBLK
*      (WA)                  DESTROYED
*
{RCBLD{PRC{25,E{1,0{{ENTRY POINT{25639
{{MOV{7,XR{3,DNAMP{{LOAD POINTER TO NEXT AVAILABLE LOC{25640
{{ADD{7,XR{19,*RCSI_{{POINT PAST NEW RCBLK{25641
{{BLO{7,XR{3,DNAME{6,RCBL1{JUMP IF THERE IS ROOM{25642
{{MOV{8,WA{19,*RCSI_{{ELSE LOAD RCBLK LENGTH{25643
{{JSR{6,ALLOC{{{USE STANDARD ALLOCATOR TO GET BLOCK{25644
{{ADD{7,XR{8,WA{{POINT PAST BLOCK TO MERGE{25645
*
*      MERGE HERE WITH XR POINTING PAST THE BLOCK OBTAINED
*
{RCBL1{MOV{3,DNAMP{7,XR{{SET NEW POINTER{25649
{{SUB{7,XR{19,*RCSI_{{POINT BACK TO START OF BLOCK{25650
{{MOV{9,(XR){22,=B_RCL{{STORE TYPE WORD{25651
{{STR{13,RCVAL(XR){{{STORE REAL VALUE IN RCBLK{25652
{{EXI{{{{RETURN TO RCBLD CALLER{25653
{{ENP{{{{END PROCEDURE RCBLD{25654
{{EJC{{{{{25656
*
*      READR -- READ NEXT SOURCE IMAGE AT COMPILE TIME
*
*      READR IS USED TO READ THE NEXT SOURCE IMAGE. TO PROCESS
*      CONTINUATION CARDS PROPERLY, THE COMPILER MUST READ ONE
*      LINE AHEAD. THUS READR DOES NOT DESTROY THE CURRENT IMAGE
*      SEE ALSO THE NEXTS ROUTINE WHICH ACTUALLY GETS THE IMAGE.
*
*      JSR  READR            CALL TO READ NEXT IMAGE
*      (XR)                  PTR TO NEXT IMAGE (0 IF NONE)
*      (R_CNI)               COPY OF POINTER
*      (WA,WB,WC,XL)         DESTROYED
*
{READR{PRC{25,E{1,0{{ENTRY POINT{25670
{{MOV{7,XR{3,R_CNI{{GET PTR TO NEXT IMAGE{25671
{{BNZ{7,XR{6,READ3{{EXIT IF ALREADY READ{25672
{{BNZ{3,CNIND{6,READA{{IF WITHIN INCLUDE FILE{25674
{{BNE{3,STAGE{18,=STGIC{6,READ3{EXIT IF NOT INITIAL COMPILE{25676
{READA{MOV{8,WA{3,CSWIN{{MAX READ LENGTH{25677
{{ZER{7,XL{{{CLEAR ANY DUD VALUE IN XL{25678
{{JSR{6,ALOCS{{{ALLOCATE BUFFER{25679
{{JSR{6,SYSRD{{{READ INPUT IMAGE{25680
{{PPM{6,READ4{{{JUMP IF EOF OR NEW FILE NAME{25681
{{ICV{3,RDNLN{{{INCREMENT NEXT LINE NUMBER{25682
{{DCV{3,POLCT{{{TEST IF TIME TO POLL INTERFACE{25684
{{BNZ{3,POLCT{6,READ0{{NOT YET{25685
{{ZER{8,WA{{{=0 FOR POLL{25686
{{MOV{8,WB{3,RDNLN{{LINE NUMBER{25687
{{JSR{6,SYSPL{{{ALLOW INTERACTIVE ACCESS{25688
{{ERR{1,320{26,User interrupt{{{25689
{{PPM{{{{SINGLE STEP{25690
{{PPM{{{{EXPRESSION EVALUATION{25691
{{MOV{3,POLCS{8,WA{{NEW COUNTDOWN START VALUE{25692
{{MOV{3,POLCT{8,WA{{NEW COUNTER VALUE{25693
{READ0{BLE{13,SCLEN(XR){3,CSWIN{6,READ1{USE SMALLER OF STRING LNTH ...{25695
{{MOV{13,SCLEN(XR){3,CSWIN{{... AND XXX OF -INXXX{25696
*
*      PERFORM THE TRIM
*
{READ1{MNZ{8,WB{{{SET TRIMR TO PERFORM TRIM{25700
{{JSR{6,TRIMR{{{TRIM TRAILING BLANKS{25701
*
*      MERGE HERE AFTER READ
*
{READ2{MOV{3,R_CNI{7,XR{{STORE COPY OF POINTER{25705
*
*      MERGE HERE IF NO READ ATTEMPTED
*
{READ3{EXI{{{{RETURN TO READR CALLER{25709
*
*      HERE ON END OF FILE OR NEW SOURCE FILE NAME.
*      IF THIS IS A NEW SOURCE FILE NAME, THE R_SFN TABLE WILL
*      BE AUGMENTED WITH A NEW TABLE ENTRY CONSISTING OF THE
*      CURRENT COMPILER STATEMENT NUMBER AS SUBSCRIPT, AND THE
*      FILE NAME AS VALUE.
*
{READ4{BZE{13,SCLEN(XR){6,READ5{{JUMP IF TRUE END OF FILE{25718
{{ZER{8,WB{{{NEW SOURCE FILE NAME{25719
{{MOV{3,RDNLN{8,WB{{RESTART LINE COUNTER FOR NEW FILE{25720
{{JSR{6,TRIMR{{{REMOVE UNUSED SPACE IN BLOCK{25721
{{JSR{6,NEWFN{{{RECORD NEW FILE NAME{25722
{{BRN{6,READA{{{NOW REISSUE READ FOR RECORD DATA{25723
*
*      HERE ON END OF FILE
*
{READ5{MOV{3,DNAMP{7,XR{{POP UNUSED SCBLK{25727
{{BZE{3,CNIND{6,READ6{{JUMP IF NOT WITHIN AN INCLUDE FILE{25729
{{ZER{7,XL{{{EOF WITHIN INCLUDE FILE{25730
{{JSR{6,SYSIF{{{SWITCH STREAM BACK TO PREVIOUS FILE{25731
{{PPM{{{{{25732
{{MOV{8,WA{3,CNIND{{RESTORE PREV LINE NUMBER, FILE NAME{25733
{{ADD{8,WA{18,=VCVLB{{VECTOR OFFSET IN WORDS{25734
{{WTB{8,WA{{{CONVERT TO BYTES{25735
{{MOV{7,XR{3,R_IFA{{FILE NAME ARRAY{25736
{{ADD{7,XR{8,WA{{PTR TO ELEMENT{25737
{{MOV{3,R_SFC{9,(XR){{CHANGE SOURCE FILE NAME{25738
{{MOV{9,(XR){21,=NULLS{{RELEASE SCBLK{25739
{{MOV{7,XR{3,R_IFL{{LINE NUMBER ARRAY{25740
{{ADD{7,XR{8,WA{{PTR TO ELEMENT{25741
{{MOV{7,XL{9,(XR){{ICBLK CONTAINING SAVED LINE NUMBER{25742
{{LDI{13,ICVAL(XL){{{LINE NUMBER INTEGER{25743
{{MFI{3,RDNLN{{{CHANGE SOURCE LINE NUMBER{25744
{{MOV{9,(XR){21,=INTON{{RELEASE ICBLK{25745
{{DCV{3,CNIND{{{DECREMENT NESTING LEVEL{25746
{{MOV{8,WB{3,CMPSN{{CURRENT STATEMENT NUMBER{25747
{{ICV{8,WB{{{ANTICIPATE END OF PREVIOUS STMT{25748
{{MTI{8,WB{{{CONVERT TO INTEGER{25749
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{25750
{{MOV{7,XL{3,R_SFN{{FILE NAME TABLE{25751
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{25752
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{25753
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{25754
{{MOV{13,TEVAL(XL){3,R_SFC{{RECORD FILE NAME AS ENTRY VALUE{25755
{{BEQ{3,STAGE{18,=STGIC{6,READA{IF INITIAL COMPILE, REISSUE READ{25756
{{BNZ{3,CNIND{6,READA{{STILL READING FROM INCLUDE FILE{25757
*
*      OUTER NESTING OF EXECUTE-TIME COMPILE OF -INCLUDE
*      RESUME WITH ANY STRING REMAINING PRIOR TO -INCLUDE.
*
{{MOV{7,XL{3,R_ICI{{RESTORE CODE ARGUMENT STRING{25762
{{ZER{3,R_ICI{{{RELEASE ORIGINAL STRING{25763
{{MOV{8,WA{3,CNSIL{{GET LENGTH OF STRING{25764
{{MOV{8,WB{3,CNSPT{{OFFSET OF CHARACTERS LEFT{25765
{{SUB{8,WA{8,WB{{NUMBER OF CHARACTERS LEFT{25766
{{MOV{3,SCNIL{8,WA{{SET NEW SCAN LENGTH{25767
{{ZER{3,SCNPT{{{SCAN FROM START OF SUBSTRING{25768
{{JSR{6,SBSTR{{{CREATE SUBSTRING OF REMAINDER{25769
{{MOV{3,R_CIM{7,XR{{SET SCAN IMAGE{25770
{{BRN{6,READ2{{{RETURN{25771
{READ6{ZER{7,XR{{{ZERO PTR AS RESULT{25787
{{BRN{6,READ2{{{MERGE{25788
{{ENP{{{{END PROCEDURE READR{25789
{{EJC{{{{{25790
*
*      SBSTR -- BUILD A SUBSTRING
*
*      (XL)                  PTR TO SCBLK/BFBLK WITH CHARS
*      (WA)                  NUMBER OF CHARS IN SUBSTRING
*      (WB)                  OFFSET TO FIRST CHAR IN SCBLK
*      JSR  SBSTR            CALL TO BUILD SUBSTRING
*      (XR)                  PTR TO NEW SCBLK WITH SUBSTRING
*      (XL)                  ZERO
*      (WA,WB,WC,XL,IA)      DESTROYED
*
*      NOTE THAT SBSTR IS CALLED WITH A DUMMY STRING POINTER
*      (POINTING INTO A VRBLK OR SVBLK) TO COPY THE NAME OF A
*      VARIABLE AS A STANDARD STRING VALUE.
*
{SBSTR{PRC{25,E{1,0{{ENTRY POINT{25885
{{BZE{8,WA{6,SBST2{{JUMP IF NULL SUBSTRING{25886
{{JSR{6,ALOCS{{{ELSE ALLOCATE SCBLK{25887
{{MOV{8,WA{8,WC{{MOVE NUMBER OF CHARACTERS{25888
{{MOV{8,WC{7,XR{{SAVE PTR TO NEW SCBLK{25889
{{PLC{7,XL{8,WB{{PREPARE TO LOAD CHARS FROM OLD BLK{25890
{{PSC{7,XR{{{PREPARE TO STORE CHARS IN NEW BLK{25891
{{MVC{{{{MOVE CHARACTERS TO NEW STRING{25892
{{MOV{7,XR{8,WC{{THEN RESTORE SCBLK POINTER{25893
*
*      RETURN POINT
*
{SBST1{ZER{7,XL{{{CLEAR GARBAGE POINTER IN XL{25897
{{EXI{{{{RETURN TO SBSTR CALLER{25898
*
*      HERE FOR NULL SUBSTRING
*
{SBST2{MOV{7,XR{21,=NULLS{{SET NULL STRING AS RESULT{25902
{{BRN{6,SBST1{{{RETURN{25903
{{ENP{{{{END PROCEDURE SBSTR{25904
{{EJC{{{{{25905
*
*      STGCC -- COMPUTE COUNTERS FOR STMT STARTUP TESTING
*
*      JSR  STGCC            CALL TO RECOMPUTE COUNTERS
*      (WA,WB)               DESTROYED
*
*      ON EXIT, STMCS AND STMCT CONTAIN THE COUNTER VALUE TO
*      TESTED IN STMGO.
*
*
{STGCC{PRC{25,E{1,0{{{25916
{{MOV{8,WA{3,POLCS{{ASSUME NO PROFILING OR STCOUNT TRACING{25918
{{MOV{8,WB{18,=NUM01{{POLL EACH TIME POLCS EXPIRES{25919
{{LDI{3,KVSTL{{{GET STMT LIMIT{25923
{{BNZ{3,KVPFL{6,STGC1{{JUMP IF PROFILING ENABLED{25924
{{ILT{6,STGC3{{{NO STCOUNT TRACING IF NEGATIVE{25925
{{BZE{3,R_STC{6,STGC2{{JUMP IF NOT STCOUNT TRACING{25926
*
*      HERE IF PROFILING OR IF STCOUNT TRACING ENABLED
*
{STGC1{MOV{8,WB{8,WA{{COUNT POLCS TIMES WITHIN STMG{25931
{{MOV{8,WA{18,=NUM01{{BREAK OUT OF STMGO ON EACH STMT{25932
{{BRN{6,STGC3{{{{25936
*
*      CHECK THAT STMCS DOES NOT EXCEED KVSTL
*
{STGC2{MTI{8,WA{{{BREAKOUT COUNT START VALUE{25940
{{SBI{3,KVSTL{{{PROPOSED STMCS MINUS STMT LIMIT{25941
{{ILE{6,STGC3{{{JUMP IF STMT COUNT DOES NOT LIMIT{25942
{{LDI{3,KVSTL{{{STLIMIT LIMITS BREAKCOUNT COUNT{25943
{{MFI{8,WA{{{USE IT INSTEAD{25944
*
*      RE-INITIALIZE COUNTER
*
{STGC3{MOV{3,STMCS{8,WA{{UPDATE BREAKOUT COUNT START VALUE{25948
{{MOV{3,STMCT{8,WA{{RESET BREAKOUT COUNTER{25949
{{MOV{3,POLCT{8,WB{{{25951
{{EXI{{{{{25953
{{EJC{{{{{25954
*
*      TFIND -- LOCATE TABLE ELEMENT
*
*      (XR)                  SUBSCRIPT VALUE FOR ELEMENT
*      (XL)                  POINTER TO TABLE
*      (WB)                  ZERO BY VALUE, NON-ZERO BY NAME
*      JSR  TFIND            CALL TO LOCATE ELEMENT
*      PPM  LOC              TRANSFER LOCATION IF ACCESS FAILS
*      (XR)                  ELEMENT VALUE (IF BY VALUE)
*      (XR)                  DESTROYED (IF BY NAME)
*      (XL,WA)               TEBLK NAME (IF BY NAME)
*      (XL,WA)               DESTROYED (IF BY VALUE)
*      (WC,RA)               DESTROYED
*
*      NOTE THAT IF A CALL BY VALUE SPECIFIES A NON-EXISTENT
*      SUBSCRIPT, THE DEFAULT VALUE IS RETURNED WITHOUT BUILDING
*      A NEW TEBLK.
*
{TFIND{PRC{25,E{1,1{{ENTRY POINT{25973
{{MOV{11,-(XS){8,WB{{SAVE NAME/VALUE INDICATOR{25974
{{MOV{11,-(XS){7,XR{{SAVE SUBSCRIPT VALUE{25975
{{MOV{11,-(XS){7,XL{{SAVE TABLE POINTER{25976
{{MOV{8,WA{13,TBLEN(XL){{LOAD LENGTH OF TBBLK{25977
{{BTW{8,WA{{{CONVERT TO WORD COUNT{25978
{{SUB{8,WA{18,=TBBUK{{GET NUMBER OF BUCKETS{25979
{{MTI{8,WA{{{CONVERT TO INTEGER VALUE{25980
{{STI{3,TFNSI{{{SAVE FOR LATER{25981
{{MOV{7,XL{9,(XR){{LOAD FIRST WORD OF SUBSCRIPT{25982
{{LEI{7,XL{{{LOAD BLOCK ENTRY ID (BL_XX){25983
{{BSW{7,XL{2,BL__D{6,TFN00{SWITCH ON BLOCK TYPE{25984
{{IFF{1,0{6,TFN00{{{25995
{{IFF{1,1{6,TFN00{{{25995
{{IFF{1,2{6,TFN00{{{25995
{{IFF{2,BL_IC{6,TFN02{{JUMP IF INTEGER{25995
{{IFF{2,BL_NM{6,TFN04{{JUMP IF NAME{25995
{{IFF{2,BL_P0{6,TFN03{{JUMP IF PATTERN{25995
{{IFF{2,BL_P1{6,TFN03{{JUMP IF PATTERN{25995
{{IFF{2,BL_P2{6,TFN03{{JUMP IF PATTERN{25995
{{IFF{2,BL_RC{6,TFN02{{REAL{25995
{{IFF{2,BL_SC{6,TFN05{{JUMP IF STRING{25995
{{IFF{1,10{6,TFN00{{{25995
{{IFF{1,11{6,TFN00{{{25995
{{IFF{1,12{6,TFN00{{{25995
{{IFF{1,13{6,TFN00{{{25995
{{IFF{1,14{6,TFN00{{{25995
{{IFF{1,15{6,TFN00{{{25995
{{IFF{1,16{6,TFN00{{{25995
{{ESW{{{{END SWITCH ON BLOCK TYPE{25995
*
*      HERE FOR BLOCKS FOR WHICH WE USE THE SECOND WORD OF THE
*      BLOCK AS THE HASH SOURCE (SEE BLOCK FORMATS FOR DETAILS).
*
{TFN00{MOV{8,WA{12,1(XR){{LOAD SECOND WORD{26000
*
*      MERGE HERE WITH ONE WORD HASH SOURCE IN WA
*
{TFN01{MTI{8,WA{{{CONVERT TO INTEGER{26004
{{BRN{6,TFN06{{{JUMP TO MERGE{26005
{{EJC{{{{{26006
*
*      TFIND (CONTINUED)
*
*      HERE FOR INTEGER OR REAL
*      POSSIBILITY OF OVERFLOW EXIST ON TWOS COMPLEMENT
*      MACHINE IF HASH SOURCE IS MOST NEGATIVE INTEGER OR IS
*      A REAL HAVING THE SAME BIT PATTERN.
*
*
{TFN02{LDI{12,1(XR){{{LOAD VALUE AS HASH SOURCE{26016
{{IGE{6,TFN06{{{OK IF POSITIVE OR ZERO{26017
{{NGI{{{{MAKE POSITIVE{26018
{{IOV{6,TFN06{{{CLEAR POSSIBLE OVERFLOW{26019
{{BRN{6,TFN06{{{MERGE{26020
*
*      FOR PATTERN, USE FIRST WORD (PCODE) AS SOURCE
*
{TFN03{MOV{8,WA{9,(XR){{LOAD FIRST WORD AS HASH SOURCE{26024
{{BRN{6,TFN01{{{MERGE BACK{26025
*
*      FOR NAME, USE OFFSET AS HASH SOURCE
*
{TFN04{MOV{8,WA{13,NMOFS(XR){{LOAD OFFSET AS HASH SOURCE{26029
{{BRN{6,TFN01{{{MERGE BACK{26030
*
*      HERE FOR STRING
*
{TFN05{JSR{6,HASHS{{{CALL ROUTINE TO COMPUTE HASH{26034
*
*      MERGE HERE WITH HASH SOURCE IN (IA)
*
{TFN06{RMI{3,TFNSI{{{COMPUTE HASH INDEX BY REMAINDERING{26038
{{MFI{8,WC{{{GET AS ONE WORD INTEGER{26039
{{WTB{8,WC{{{CONVERT TO BYTE OFFSET{26040
{{MOV{7,XL{9,(XS){{GET TABLE PTR AGAIN{26041
{{ADD{7,XL{8,WC{{POINT TO PROPER BUCKET{26042
{{MOV{7,XR{13,TBBUK(XL){{LOAD FIRST TEBLK POINTER{26043
{{BEQ{7,XR{9,(XS){6,TFN10{JUMP IF NO TEBLKS ON CHAIN{26044
*
*      LOOP THROUGH TEBLKS ON HASH CHAIN
*
{TFN07{MOV{8,WB{7,XR{{SAVE TEBLK POINTER{26048
{{MOV{7,XR{13,TESUB(XR){{LOAD SUBSCRIPT VALUE{26049
{{MOV{7,XL{12,1(XS){{LOAD INPUT ARGUMENT SUBSCRIPT VAL{26050
{{JSR{6,IDENT{{{COMPARE THEM{26051
{{PPM{6,TFN08{{{JUMP IF EQUAL (IDENT){26052
*
*      HERE IF NO MATCH WITH THAT TEBLK
*
{{MOV{7,XL{8,WB{{RESTORE TEBLK POINTER{26056
{{MOV{7,XR{13,TENXT(XL){{POINT TO NEXT TEBLK ON CHAIN{26057
{{BNE{7,XR{9,(XS){6,TFN07{JUMP IF THERE IS ONE{26058
*
*      HERE IF NO MATCH WITH ANY TEBLK ON CHAIN
*
{{MOV{8,WC{19,*TENXT{{SET OFFSET TO LINK FIELD (XL BASE){26062
{{BRN{6,TFN11{{{JUMP TO MERGE{26063
{{EJC{{{{{26064
*
*      TFIND (CONTINUED)
*
*      HERE WE HAVE FOUND A MATCHING ELEMENT
*
{TFN08{MOV{7,XL{8,WB{{RESTORE TEBLK POINTER{26070
{{MOV{8,WA{19,*TEVAL{{SET TEBLK NAME OFFSET{26071
{{MOV{8,WB{12,2(XS){{RESTORE NAME/VALUE INDICATOR{26072
{{BNZ{8,WB{6,TFN09{{JUMP IF CALLED BY NAME{26073
{{JSR{6,ACESS{{{ELSE GET VALUE{26074
{{PPM{6,TFN12{{{JUMP IF REFERENCE FAILS{26075
{{ZER{8,WB{{{RESTORE NAME/VALUE INDICATOR{26076
*
*      COMMON EXIT FOR ENTRY FOUND
*
{TFN09{ADD{7,XS{19,*NUM03{{POP STACK ENTRIES{26080
{{EXI{{{{RETURN TO TFIND CALLER{26081
*
*      HERE IF NO TEBLKS ON THE HASH CHAIN
*
{TFN10{ADD{8,WC{19,*TBBUK{{GET OFFSET TO BUCKET PTR{26085
{{MOV{7,XL{9,(XS){{SET TBBLK PTR AS BASE{26086
*
*      MERGE HERE WITH (XL,WC) BASE,OFFSET OF FINAL LINK
*
{TFN11{MOV{7,XR{9,(XS){{TBBLK POINTER{26090
{{MOV{7,XR{13,TBINV(XR){{LOAD DEFAULT VALUE IN CASE{26091
{{MOV{8,WB{12,2(XS){{LOAD NAME/VALUE INDICATOR{26092
{{BZE{8,WB{6,TFN09{{EXIT WITH DEFAULT IF VALUE CALL{26093
{{MOV{8,WB{7,XR{{COPY DEFAULT VALUE{26094
*
*      HERE WE MUST BUILD A NEW TEBLK
*
{{MOV{8,WA{19,*TESI_{{SET SIZE OF TEBLK{26098
{{JSR{6,ALLOC{{{ALLOCATE TEBLK{26099
{{ADD{7,XL{8,WC{{POINT TO HASH LINK{26100
{{MOV{9,(XL){7,XR{{LINK NEW TEBLK AT END OF CHAIN{26101
{{MOV{9,(XR){22,=B_TET{{STORE TYPE WORD{26102
{{MOV{13,TEVAL(XR){8,WB{{SET DEFAULT AS INITIAL VALUE{26103
{{MOV{13,TENXT(XR){10,(XS)+{{SET TBBLK PTR TO MARK END OF CHAIN{26104
{{MOV{13,TESUB(XR){10,(XS)+{{STORE SUBSCRIPT VALUE{26105
{{MOV{8,WB{10,(XS)+{{RESTORE NAME/VALUE INDICATOR{26106
{{MOV{7,XL{7,XR{{COPY TEBLK POINTER (NAME BASE){26107
{{MOV{8,WA{19,*TEVAL{{SET OFFSET{26108
{{EXI{{{{RETURN TO CALLER WITH NEW TEBLK{26109
*
*      ACESS FAIL RETURN
*
{TFN12{EXI{1,1{{{ALTERNATIVE RETURN{26113
{{ENP{{{{END PROCEDURE TFIND{26114
{{EJC{{{{{26115
*
*      TMAKE -- MAKE NEW TABLE
*
*      (XL)                  INITIAL LOOKUP VALUE
*      (WC)                  NUMBER OF BUCKETS DESIRED
*      JSR  TMAKE            CALL TO MAKE NEW TABLE
*      (XR)                  NEW TABLE
*      (WA,WB)               DESTROYED
*
{TMAKE{PRC{25,E{1,0{{{26125
{{MOV{8,WA{8,WC{{COPY NUMBER OF HEADERS{26126
{{ADD{8,WA{18,=TBSI_{{ADJUST FOR STANDARD FIELDS{26127
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{26128
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR TBBLK{26129
{{MOV{8,WB{7,XR{{COPY POINTER TO TBBLK{26130
{{MOV{10,(XR)+{22,=B_TBT{{STORE TYPE WORD{26131
{{ZER{10,(XR)+{{{ZERO ID FOR THE MOMENT{26132
{{MOV{10,(XR)+{8,WA{{STORE LENGTH (TBLEN){26133
{{MOV{10,(XR)+{7,XL{{STORE INITIAL LOOKUP VALUE{26134
{{LCT{8,WC{8,WC{{SET LOOP COUNTER (NUM HEADERS){26135
*
*      LOOP TO INITIALIZE ALL BUCKET POINTERS
*
{TMA01{MOV{10,(XR)+{8,WB{{STORE TBBLK PTR IN BUCKET HEADER{26139
{{BCT{8,WC{6,TMA01{{LOOP TILL ALL STORED{26140
{{MOV{7,XR{8,WB{{RECALL POINTER TO TBBLK{26141
{{EXI{{{{{26142
{{ENP{{{{{26143
{{EJC{{{{{26144
*
*      VMAKE -- CREATE A VECTOR
*
*      (WA)                  NUMBER OF ELEMENTS IN VECTOR
*      (XL)                  DEFAULT VALUE FOR VECTOR ELEMENTS
*      JSR  VMAKE            CALL TO CREATE VECTOR
*      PPM  LOC              IF VECTOR TOO LARGE
*
*      (XR)                  POINTER TO VCBLK
*      (WA,WB,WC,XL)         DESTROYED
*
{VMAKE{PRC{25,E{1,1{{ENTRY POINT{26156
{{LCT{8,WB{8,WA{{COPY ELEMENTS FOR LOOP LATER ON{26157
{{ADD{8,WA{18,=VCSI_{{ADD SPACE FOR STANDARD FIELDS{26158
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{26159
{{BGT{8,WA{3,MXLEN{6,VMAK2{FAIL IF TOO LARGE{26160
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR VCBLK{26161
{{MOV{9,(XR){22,=B_VCT{{STORE TYPE WORD{26162
{{ZER{13,IDVAL(XR){{{INITIALIZE IDVAL{26163
{{MOV{13,VCLEN(XR){8,WA{{SET LENGTH{26164
{{MOV{8,WC{7,XL{{COPY DEFAULT VALUE{26165
{{MOV{7,XL{7,XR{{COPY VCBLK POINTER{26166
{{ADD{7,XL{19,*VCVLS{{POINT TO FIRST ELEMENT VALUE{26167
*
*      LOOP TO SET VECTOR ELEMENTS TO DEFAULT VALUE
*
{VMAK1{MOV{10,(XL)+{8,WC{{STORE ONE VALUE{26171
{{BCT{8,WB{6,VMAK1{{LOOP TILL ALL STORED{26172
{{EXI{{{{SUCCESS RETURN{26173
*
*      HERE IF DESIRED VECTOR SIZE TOO LARGE
*
{VMAK2{EXI{1,1{{{FAIL RETURN{26177
{{ENP{{{{{26178
{{EJC{{{{{26179
*
*      SCANE -- SCAN AN ELEMENT
*
*      SCANE IS CALLED AT COMPILE TIME (BY EXPAN ,CMPIL,CNCRD)
*      TO SCAN ONE ELEMENT FROM THE INPUT IMAGE.
*
*      (SCNCC)               NON-ZERO IF CALLED FROM CNCRD
*      JSR  SCANE            CALL TO SCAN ELEMENT
*      (XR)                  RESULT POINTER (SEE BELOW)
*      (XL)                  SYNTAX TYPE CODE (T_XXX)
*
*      THE FOLLOWING GLOBAL LOCATIONS ARE USED.
*
*      R_CIM                 POINTER TO STRING BLOCK (SCBLK)
*                            FOR CURRENT INPUT IMAGE.
*
*      R_CNI                 POINTER TO NEXT INPUT IMAGE STRING
*                            POINTER (ZERO IF NONE).
*
*      R_SCP                 SAVE POINTER (EXIT XR) FROM LAST
*                            CALL IN CASE RESCAN IS SET.
*
*      SCNBL                 THIS LOCATION IS SET NON-ZERO ON
*                            EXIT IF SCANE SCANNED PAST BLANKS
*                            BEFORE LOCATING THE CURRENT ELEMENT
*                            THE END OF A LINE COUNTS AS BLANKS.
*
*      SCNCC                 CNCRD SETS THIS NON-ZERO TO SCAN
*                            CONTROL CARD NAMES AND CLEARS IT
*                            ON RETURN
*
*      SCNIL                 LENGTH OF CURRENT INPUT IMAGE
*
*      SCNGO                 IF SET NON-ZERO ON ENTRY, F AND S
*                            ARE RETURNED AS SEPARATE SYNTAX
*                            TYPES (NOT LETTERS) (GOTO PRO-
*                            CESSING). SCNGO IS RESET ON EXIT.
*
*      SCNPT                 OFFSET TO CURRENT LOC IN R_CIM
*
*      SCNRS                 IF SET NON-ZERO ON ENTRY, SCANE
*                            RETURNS THE SAME RESULT AS ON THE
*                            LAST CALL (RESCAN). SCNRS IS RESET
*                            ON EXIT FROM ANY CALL TO SCANE.
*
*      SCNTP                 SAVE SYNTAX TYPE FROM LAST
*                            CALL (IN CASE RESCAN IS SET).
{{EJC{{{{{26227
*
*      SCANE (CONTINUED)
*
*
*
*      ELEMENT SCANNED       XL        XR
*      ---------------       --        --
*
*      CONTROL CARD NAME     0         POINTER TO SCBLK FOR NAME
*
*      UNARY OPERATOR        T_UOP     PTR TO OPERATOR DVBLK
*
*      LEFT PAREN            T_LPR     T_LPR
*
*      LEFT BRACKET          T_LBR     T_LBR
*
*      COMMA                 T_CMA     T_CMA
*
*      FUNCTION CALL         T_FNC     PTR TO FUNCTION VRBLK
*
*      VARIABLE              T_VAR     PTR TO VRBLK
*
*      STRING CONSTANT       T_CON     PTR TO SCBLK
*
*      INTEGER CONSTANT      T_CON     PTR TO ICBLK
*
*      REAL CONSTANT         T_CON     PTR TO RCBLK
*
*      BINARY OPERATOR       T_BOP     PTR TO OPERATOR DVBLK
*
*      RIGHT PAREN           T_RPR     T_RPR
*
*      RIGHT BRACKET         T_RBR     T_RBR
*
*      COLON                 T_COL     T_COL
*
*      SEMI-COLON            T_SMC     T_SMC
*
*      F (SCNGO NE 0)        T_FGO     T_FGO
*
*      S (SCNGO NE 0)        T_SGO     T_SGO
{{EJC{{{{{26272
*
*      SCANE (CONTINUED)
*
*      ENTRY POINT
*
{SCANE{PRC{25,E{1,0{{ENTRY POINT{26278
{{ZER{3,SCNBL{{{RESET BLANKS FLAG{26279
{{MOV{3,SCNSA{8,WA{{SAVE WA{26280
{{MOV{3,SCNSB{8,WB{{SAVE WB{26281
{{MOV{3,SCNSC{8,WC{{SAVE WC{26282
{{BZE{3,SCNRS{6,SCN03{{JUMP IF NO RESCAN{26283
*
*      HERE FOR RESCAN REQUEST
*
{{MOV{7,XL{3,SCNTP{{SET PREVIOUS RETURNED SCAN TYPE{26287
{{MOV{7,XR{3,R_SCP{{SET PREVIOUS RETURNED POINTER{26288
{{ZER{3,SCNRS{{{RESET RESCAN SWITCH{26289
{{BRN{6,SCN13{{{JUMP TO EXIT{26290
*
*      COME HERE TO READ NEW IMAGE TO TEST FOR CONTINUATION
*
{SCN01{JSR{6,READR{{{READ NEXT IMAGE{26294
{{MOV{8,WB{19,*DVUBS{{SET WB FOR NOT READING NAME{26295
{{BZE{7,XR{6,SCN30{{TREAT AS SEMI-COLON IF NONE{26296
{{PLC{7,XR{{{ELSE POINT TO FIRST CHARACTER{26297
{{LCH{8,WC{9,(XR){{LOAD FIRST CHARACTER{26298
{{BEQ{8,WC{18,=CH_DT{6,SCN02{JUMP IF DOT FOR CONTINUATION{26299
{{BNE{8,WC{18,=CH_PL{6,SCN30{ELSE TREAT AS SEMICOLON UNLESS PLUS{26300
*
*      HERE FOR CONTINUATION LINE
*
{SCN02{JSR{6,NEXTS{{{ACQUIRE NEXT SOURCE IMAGE{26304
{{MOV{3,SCNPT{18,=NUM01{{SET SCAN POINTER PAST CONTINUATION{26305
{{MNZ{3,SCNBL{{{SET BLANKS FLAG{26306
{{EJC{{{{{26307
*
*      SCANE (CONTINUED)
*
*      MERGE HERE TO SCAN NEXT ELEMENT ON CURRENT LINE
*
{SCN03{MOV{8,WA{3,SCNPT{{LOAD CURRENT OFFSET{26313
{{BEQ{8,WA{3,SCNIL{6,SCN01{CHECK CONTINUATION IF END{26314
{{MOV{7,XL{3,R_CIM{{POINT TO CURRENT LINE{26315
{{PLC{7,XL{8,WA{{POINT TO CURRENT CHARACTER{26316
{{MOV{3,SCNSE{8,WA{{SET START OF ELEMENT LOCATION{26317
{{MOV{8,WC{21,=OPDVS{{POINT TO OPERATOR DV LIST{26318
{{MOV{8,WB{19,*DVUBS{{SET CONSTANT FOR OPERATOR CIRCUIT{26319
{{BRN{6,SCN06{{{START SCANNING{26320
*
*      LOOP HERE TO IGNORE LEADING BLANKS AND TABS
*
{SCN05{BZE{8,WB{6,SCN10{{JUMP IF TRAILING{26324
{{ICV{3,SCNSE{{{INCREMENT START OF ELEMENT{26325
{{BEQ{8,WA{3,SCNIL{6,SCN01{JUMP IF END OF IMAGE{26326
{{MNZ{3,SCNBL{{{NOTE BLANKS SEEN{26327
*
*      THE FOLLOWING JUMP IS USED REPEATEDLY FOR SCANNING OUT
*      THE CHARACTERS OF A NUMERIC CONSTANT OR VARIABLE NAME.
*      THE REGISTERS ARE USED AS FOLLOWS.
*
*      (XR)                  SCRATCH
*      (XL)                  PTR TO NEXT CHARACTER
*      (WA)                  CURRENT SCAN OFFSET
*      (WB)                  *DVUBS (0 IF SCANNING NAME,CONST)
*      (WC)                  =OPDVS (0 IF SCANNING CONSTANT)
*
{SCN06{LCH{7,XR{10,(XL)+{{GET NEXT CHARACTER{26339
{{ICV{8,WA{{{BUMP SCAN OFFSET{26340
{{MOV{3,SCNPT{8,WA{{STORE OFFSET PAST CHAR SCANNED{26341
{{BSW{7,XR{2,CFP_U{6,SCN07{SWITCH ON SCANNED CHARACTER{26343
*
*      SWITCH TABLE FOR SWITCH ON CHARACTER
*
{{EJC{{{{{26370
*
*      SCANE (CONTINUED)
*
{{EJC{{{{{26426
*
*      SCANE (CONTINUED)
*
{{IFF{1,0{6,SCN07{{{26459
{{IFF{1,1{6,SCN07{{{26459
{{IFF{1,2{6,SCN07{{{26459
{{IFF{1,3{6,SCN07{{{26459
{{IFF{1,4{6,SCN07{{{26459
{{IFF{1,5{6,SCN07{{{26459
{{IFF{1,6{6,SCN07{{{26459
{{IFF{1,7{6,SCN07{{{26459
{{IFF{1,8{6,SCN07{{{26459
{{IFF{2,CH_HT{6,SCN05{{HORIZONTAL TAB{26459
{{IFF{1,10{6,SCN07{{{26459
{{IFF{1,11{6,SCN07{{{26459
{{IFF{1,12{6,SCN07{{{26459
{{IFF{1,13{6,SCN07{{{26459
{{IFF{1,14{6,SCN07{{{26459
{{IFF{1,15{6,SCN07{{{26459
{{IFF{1,16{6,SCN07{{{26459
{{IFF{1,17{6,SCN07{{{26459
{{IFF{1,18{6,SCN07{{{26459
{{IFF{1,19{6,SCN07{{{26459
{{IFF{1,20{6,SCN07{{{26459
{{IFF{1,21{6,SCN07{{{26459
{{IFF{1,22{6,SCN07{{{26459
{{IFF{1,23{6,SCN07{{{26459
{{IFF{1,24{6,SCN07{{{26459
{{IFF{1,25{6,SCN07{{{26459
{{IFF{1,26{6,SCN07{{{26459
{{IFF{1,27{6,SCN07{{{26459
{{IFF{1,28{6,SCN07{{{26459
{{IFF{1,29{6,SCN07{{{26459
{{IFF{1,30{6,SCN07{{{26459
{{IFF{1,31{6,SCN07{{{26459
{{IFF{2,CH_BL{6,SCN05{{BLANK{26459
{{IFF{2,CH_EX{6,SCN37{{EXCLAMATION MARK{26459
{{IFF{2,CH_DQ{6,SCN17{{DOUBLE QUOTE{26459
{{IFF{2,CH_NM{6,SCN41{{NUMBER SIGN{26459
{{IFF{2,CH_DL{6,SCN36{{DOLLAR{26459
{{IFF{2,CH_PC{6,SCN38{{PERCENT{26459
{{IFF{2,CH_AM{6,SCN44{{AMPERSAND{26459
{{IFF{2,CH_SQ{6,SCN16{{SINGLE QUOTE{26459
{{IFF{2,CH_PP{6,SCN25{{LEFT PAREN{26459
{{IFF{2,CH_RP{6,SCN26{{RIGHT PAREN{26459
{{IFF{2,CH_AS{6,SCN49{{ASTERISK{26459
{{IFF{2,CH_PL{6,SCN33{{PLUS{26459
{{IFF{2,CH_CM{6,SCN31{{COMMA{26459
{{IFF{2,CH_MN{6,SCN34{{MINUS{26459
{{IFF{2,CH_DT{6,SCN32{{DOT{26459
{{IFF{2,CH_SL{6,SCN40{{SLASH{26459
{{IFF{2,CH_D0{6,SCN08{{DIGIT 0{26459
{{IFF{2,CH_D1{6,SCN08{{DIGIT 1{26459
{{IFF{2,CH_D2{6,SCN08{{DIGIT 2{26459
{{IFF{2,CH_D3{6,SCN08{{DIGIT 3{26459
{{IFF{2,CH_D4{6,SCN08{{DIGIT 4{26459
{{IFF{2,CH_D5{6,SCN08{{DIGIT 5{26459
{{IFF{2,CH_D6{6,SCN08{{DIGIT 6{26459
{{IFF{2,CH_D7{6,SCN08{{DIGIT 7{26459
{{IFF{2,CH_D8{6,SCN08{{DIGIT 8{26459
{{IFF{2,CH_D9{6,SCN08{{DIGIT 9{26459
{{IFF{2,CH_CL{6,SCN29{{COLON{26459
{{IFF{2,CH_SM{6,SCN30{{SEMI-COLON{26459
{{IFF{2,CH_BB{6,SCN28{{LEFT BRACKET{26459
{{IFF{2,CH_EQ{6,SCN46{{EQUAL{26459
{{IFF{2,CH_RB{6,SCN27{{RIGHT BRACKET{26459
{{IFF{2,CH_QU{6,SCN45{{QUESTION MARK{26459
{{IFF{2,CH_AT{6,SCN42{{AT{26459
{{IFF{2,CH_LA{6,SCN09{{LETTER A{26459
{{IFF{2,CH_LB{6,SCN09{{LETTER B{26459
{{IFF{2,CH_LC{6,SCN09{{LETTER C{26459
{{IFF{2,CH_LD{6,SCN09{{LETTER D{26459
{{IFF{2,CH_LE{6,SCN09{{LETTER E{26459
{{IFF{2,CH_LF{6,SCN20{{LETTER F{26459
{{IFF{2,CH_LG{6,SCN09{{LETTER G{26459
{{IFF{2,CH_LH{6,SCN09{{LETTER H{26459
{{IFF{2,CH_LI{6,SCN09{{LETTER I{26459
{{IFF{2,CH_LJ{6,SCN09{{LETTER J{26459
{{IFF{2,CH_LK{6,SCN09{{LETTER K{26459
{{IFF{2,CH_LL{6,SCN09{{LETTER L{26459
{{IFF{2,CH_LM{6,SCN09{{LETTER M{26459
{{IFF{2,CH_LN{6,SCN09{{LETTER N{26459
{{IFF{2,CH_LO{6,SCN09{{LETTER O{26459
{{IFF{2,CH_LP{6,SCN09{{LETTER P{26459
{{IFF{2,CH_LQ{6,SCN09{{LETTER Q{26459
{{IFF{2,CH_LR{6,SCN09{{LETTER R{26459
{{IFF{2,CH_LS{6,SCN21{{LETTER S{26459
{{IFF{2,CH_LT{6,SCN09{{LETTER T{26459
{{IFF{2,CH_LU{6,SCN09{{LETTER U{26459
{{IFF{2,CH_LV{6,SCN09{{LETTER V{26459
{{IFF{2,CH_LW{6,SCN09{{LETTER W{26459
{{IFF{2,CH_LX{6,SCN09{{LETTER X{26459
{{IFF{2,CH_LY{6,SCN09{{LETTER Y{26459
{{IFF{2,CH_L_{6,SCN09{{LETTER Z{26459
{{IFF{2,CH_OB{6,SCN28{{LEFT BRACKET{26459
{{IFF{1,92{6,SCN07{{{26459
{{IFF{2,CH_CB{6,SCN27{{RIGHT BRACKET{26459
{{IFF{2,CH_EY{6,SCN37{{UP ARROW{26459
{{IFF{2,CH_UN{6,SCN24{{UNDERLINE{26459
{{IFF{1,96{6,SCN07{{{26459
{{IFF{2,CH__A{6,SCN09{{SHIFTED A{26459
{{IFF{2,CH__B{6,SCN09{{SHIFTED B{26459
{{IFF{2,CH__C{6,SCN09{{SHIFTED C{26459
{{IFF{2,CH__D{6,SCN09{{SHIFTED D{26459
{{IFF{2,CH__E{6,SCN09{{SHIFTED E{26459
{{IFF{2,CH__F{6,SCN20{{SHIFTED F{26459
{{IFF{2,CH__G{6,SCN09{{SHIFTED G{26459
{{IFF{2,CH__H{6,SCN09{{SHIFTED H{26459
{{IFF{2,CH__I{6,SCN09{{SHIFTED I{26459
{{IFF{2,CH__J{6,SCN09{{SHIFTED J{26459
{{IFF{2,CH__K{6,SCN09{{SHIFTED K{26459
{{IFF{2,CH__L{6,SCN09{{SHIFTED L{26459
{{IFF{2,CH__M{6,SCN09{{SHIFTED M{26459
{{IFF{2,CH__N{6,SCN09{{SHIFTED N{26459
{{IFF{2,CH__O{6,SCN09{{SHIFTED O{26459
{{IFF{2,CH__P{6,SCN09{{SHIFTED P{26459
{{IFF{2,CH__Q{6,SCN09{{SHIFTED Q{26459
{{IFF{2,CH__R{6,SCN09{{SHIFTED R{26459
{{IFF{2,CH__S{6,SCN21{{SHIFTED S{26459
{{IFF{2,CH__T{6,SCN09{{SHIFTED T{26459
{{IFF{2,CH__U{6,SCN09{{SHIFTED U{26459
{{IFF{2,CH__V{6,SCN09{{SHIFTED V{26459
{{IFF{2,CH__W{6,SCN09{{SHIFTED W{26459
{{IFF{2,CH__X{6,SCN09{{SHIFTED X{26459
{{IFF{2,CH__Y{6,SCN09{{SHIFTED Y{26459
{{IFF{2,CH___{6,SCN09{{SHIFTED Z{26459
{{IFF{1,123{6,SCN07{{{26459
{{IFF{2,CH_BR{6,SCN43{{VERTICAL BAR{26459
{{IFF{1,125{6,SCN07{{{26459
{{IFF{2,CH_NT{6,SCN35{{NOT{26459
{{IFF{1,127{6,SCN07{{{26459
{{ESW{{{{END SWITCH ON CHARACTER{26459
*
*      HERE FOR ILLEGAL CHARACTER (UNDERLINE MERGES)
*
{SCN07{BZE{8,WB{6,SCN10{{JUMP IF SCANNING NAME OR CONSTANT{26463
{{ERB{1,230{26,Syntax error: Illegal character{{{26464
{{EJC{{{{{26465
*
*      SCANE (CONTINUED)
*
*      HERE FOR DIGITS 0-9
*
{SCN08{BZE{8,WB{6,SCN09{{KEEP SCANNING IF NAME/CONSTANT{26471
{{ZER{8,WC{{{ELSE SET FLAG FOR SCANNING CONSTANT{26472
*
*      HERE FOR LETTER. LOOP HERE WHEN SCANNING NAME/CONSTANT
*
{SCN09{BEQ{8,WA{3,SCNIL{6,SCN11{JUMP IF END OF IMAGE{26476
{{ZER{8,WB{{{SET FLAG FOR SCANNING NAME/CONST{26477
{{BRN{6,SCN06{{{MERGE BACK TO CONTINUE SCAN{26478
*
*      COME HERE FOR DELIMITER ENDING NAME OR CONSTANT
*
{SCN10{DCV{8,WA{{{RESET OFFSET TO POINT TO DELIMITER{26482
*
*      COME HERE AFTER FINISHING SCAN OF NAME OR CONSTANT
*
{SCN11{MOV{3,SCNPT{8,WA{{STORE UPDATED SCAN OFFSET{26486
{{MOV{8,WB{3,SCNSE{{POINT TO START OF ELEMENT{26487
{{SUB{8,WA{8,WB{{GET NUMBER OF CHARACTERS{26488
{{MOV{7,XL{3,R_CIM{{POINT TO LINE IMAGE{26489
{{BNZ{8,WC{6,SCN15{{JUMP IF NAME{26490
*
*      HERE AFTER SCANNING OUT NUMERIC CONSTANT
*
{{JSR{6,SBSTR{{{GET STRING FOR CONSTANT{26494
{{MOV{3,DNAMP{7,XR{{DELETE FROM STORAGE (NOT NEEDED){26495
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{26496
{{PPM{6,SCN14{{{JUMP IF CONVERSION FAILURE{26497
*
*      MERGE HERE TO EXIT WITH CONSTANT
*
{SCN12{MOV{7,XL{18,=T_CON{{SET RESULT TYPE OF CONSTANT{26501
{{EJC{{{{{26502
*
*      SCANE (CONTINUED)
*
*      COMMON EXIT POINT (XR,XL) SET
*
{SCN13{MOV{8,WA{3,SCNSA{{RESTORE WA{26508
{{MOV{8,WB{3,SCNSB{{RESTORE WB{26509
{{MOV{8,WC{3,SCNSC{{RESTORE WC{26510
{{MOV{3,R_SCP{7,XR{{SAVE XR IN CASE RESCAN{26511
{{MOV{3,SCNTP{7,XL{{SAVE XL IN CASE RESCAN{26512
{{ZER{3,SCNGO{{{RESET POSSIBLE GOTO FLAG{26513
{{EXI{{{{RETURN TO SCANE CALLER{26514
*
*      HERE IF CONVERSION ERROR ON NUMERIC ITEM
*
{SCN14{ERB{1,231{26,Syntax error: Invalid numeric item{{{26518
*
*      HERE AFTER SCANNING OUT VARIABLE NAME
*
{SCN15{JSR{6,SBSTR{{{BUILD STRING NAME OF VARIABLE{26522
{{BNZ{3,SCNCC{6,SCN13{{RETURN IF CNCRD CALL{26523
{{JSR{6,GTNVR{{{LOCATE/BUILD VRBLK{26524
{{PPM{{{{DUMMY (UNUSED) ERROR RETURN{26525
{{MOV{7,XL{18,=T_VAR{{SET TYPE AS VARIABLE{26526
{{BRN{6,SCN13{{{BACK TO EXIT{26527
*
*      HERE FOR SINGLE QUOTE (START OF STRING CONSTANT)
*
{SCN16{BZE{8,WB{6,SCN10{{TERMINATOR IF SCANNING NAME OR CNST{26531
{{MOV{8,WB{18,=CH_SQ{{SET TERMINATOR AS SINGLE QUOTE{26532
{{BRN{6,SCN18{{{MERGE{26533
*
*      HERE FOR DOUBLE QUOTE (START OF STRING CONSTANT)
*
{SCN17{BZE{8,WB{6,SCN10{{TERMINATOR IF SCANNING NAME OR CNST{26537
{{MOV{8,WB{18,=CH_DQ{{SET DOUBLE QUOTE TERMINATOR, MERGE{26538
*
*      LOOP TO SCAN OUT STRING CONSTANT
*
{SCN18{BEQ{8,WA{3,SCNIL{6,SCN19{ERROR IF END OF IMAGE{26542
{{LCH{8,WC{10,(XL)+{{ELSE LOAD NEXT CHARACTER{26543
{{ICV{8,WA{{{BUMP OFFSET{26544
{{BNE{8,WC{8,WB{6,SCN18{LOOP BACK IF NOT TERMINATOR{26545
{{EJC{{{{{26546
*
*      SCANE (CONTINUED)
*
*      HERE AFTER SCANNING OUT STRING CONSTANT
*
{{MOV{8,WB{3,SCNPT{{POINT TO FIRST CHARACTER{26552
{{MOV{3,SCNPT{8,WA{{SAVE OFFSET PAST FINAL QUOTE{26553
{{DCV{8,WA{{{POINT BACK PAST LAST CHARACTER{26554
{{SUB{8,WA{8,WB{{GET NUMBER OF CHARACTERS{26555
{{MOV{7,XL{3,R_CIM{{POINT TO INPUT IMAGE{26556
{{JSR{6,SBSTR{{{BUILD SUBSTRING VALUE{26557
{{BRN{6,SCN12{{{BACK TO EXIT WITH CONSTANT RESULT{26558
*
*      HERE IF NO MATCHING QUOTE FOUND
*
{SCN19{MOV{3,SCNPT{8,WA{{SET UPDATED SCAN POINTER{26562
{{ERB{1,232{26,Syntax error: Unmatched string quote{{{26563
*
*      HERE FOR F (POSSIBLE FAILURE GOTO)
*
{SCN20{MOV{7,XR{18,=T_FGO{{SET RETURN CODE FOR FAIL GOTO{26567
{{BRN{6,SCN22{{{JUMP TO MERGE{26568
*
*      HERE FOR S (POSSIBLE SUCCESS GOTO)
*
{SCN21{MOV{7,XR{18,=T_SGO{{SET SUCCESS GOTO AS RETURN CODE{26572
*
*      SPECIAL GOTO CASES MERGE HERE
*
{SCN22{BZE{3,SCNGO{6,SCN09{{TREAT AS NORMAL LETTER IF NOT GOTO{26576
*
*      MERGE HERE FOR SPECIAL CHARACTER EXIT
*
{SCN23{BZE{8,WB{6,SCN10{{JUMP IF END OF NAME/CONSTANT{26580
{{MOV{7,XL{7,XR{{ELSE COPY CODE{26581
{{BRN{6,SCN13{{{AND JUMP TO EXIT{26582
*
*      HERE FOR UNDERLINE
*
{SCN24{BZE{8,WB{6,SCN09{{PART OF NAME IF SCANNING NAME{26586
{{BRN{6,SCN07{{{ELSE ILLEGAL{26587
{{EJC{{{{{26588
*
*      SCANE (CONTINUED)
*
*      HERE FOR LEFT PAREN
*
{SCN25{MOV{7,XR{18,=T_LPR{{SET LEFT PAREN RETURN CODE{26594
{{BNZ{8,WB{6,SCN23{{RETURN LEFT PAREN UNLESS NAME{26595
{{BZE{8,WC{6,SCN10{{DELIMITER IF SCANNING CONSTANT{26596
*
*      HERE FOR LEFT PAREN AFTER NAME (FUNCTION CALL)
*
{{MOV{8,WB{3,SCNSE{{POINT TO START OF NAME{26600
{{MOV{3,SCNPT{8,WA{{SET POINTER PAST LEFT PAREN{26601
{{DCV{8,WA{{{POINT BACK PAST LAST CHAR OF NAME{26602
{{SUB{8,WA{8,WB{{GET NAME LENGTH{26603
{{MOV{7,XL{3,R_CIM{{POINT TO INPUT IMAGE{26604
{{JSR{6,SBSTR{{{GET STRING NAME FOR FUNCTION{26605
{{JSR{6,GTNVR{{{LOCATE/BUILD VRBLK{26606
{{PPM{{{{DUMMY (UNUSED) ERROR RETURN{26607
{{MOV{7,XL{18,=T_FNC{{SET CODE FOR FUNCTION CALL{26608
{{BRN{6,SCN13{{{BACK TO EXIT{26609
*
*      PROCESSING FOR SPECIAL CHARACTERS
*
{SCN26{MOV{7,XR{18,=T_RPR{{RIGHT PAREN, SET CODE{26613
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{26614
*
{SCN27{MOV{7,XR{18,=T_RBR{{RIGHT BRACKET, SET CODE{26616
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{26617
*
{SCN28{MOV{7,XR{18,=T_LBR{{LEFT BRACKET, SET CODE{26619
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{26620
*
{SCN29{MOV{7,XR{18,=T_COL{{COLON, SET CODE{26622
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{26623
*
{SCN30{MOV{7,XR{18,=T_SMC{{SEMI-COLON, SET CODE{26625
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{26626
*
{SCN31{MOV{7,XR{18,=T_CMA{{COMMA, SET CODE{26628
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{26629
{{EJC{{{{{26630
*
*      SCANE (CONTINUED)
*
*      HERE FOR OPERATORS. ON ENTRY, WC POINTS TO THE TABLE OF
*      OPERATOR DOPE VECTORS AND WB IS THE INCREMENT TO STEP
*      TO THE NEXT PAIR (BINARY/UNARY) OF DOPE VECTORS IN THE
*      LIST. ON REACHING SCN46, THE POINTER HAS BEEN ADJUSTED TO
*      POINT TO THE APPROPRIATE PAIR OF DOPE VECTORS.
*      THE FIRST THREE ENTRIES ARE SPECIAL SINCE THEY CAN OCCUR
*      AS PART OF A VARIABLE NAME (.) OR CONSTANT (.+-).
*
{SCN32{BZE{8,WB{6,SCN09{{DOT CAN BE PART OF NAME OR CONSTANT{26642
{{ADD{8,WC{8,WB{{ELSE BUMP POINTER{26643
*
{SCN33{BZE{8,WC{6,SCN09{{PLUS CAN BE PART OF CONSTANT{26645
{{BZE{8,WB{6,SCN48{{PLUS CANNOT BE PART OF NAME{26646
{{ADD{8,WC{8,WB{{ELSE BUMP POINTER{26647
*
{SCN34{BZE{8,WC{6,SCN09{{MINUS CAN BE PART OF CONSTANT{26649
{{BZE{8,WB{6,SCN48{{MINUS CANNOT BE PART OF NAME{26650
{{ADD{8,WC{8,WB{{ELSE BUMP POINTER{26651
*
{SCN35{ADD{8,WC{8,WB{{NOT{26653
{SCN36{ADD{8,WC{8,WB{{DOLLAR{26654
{SCN37{ADD{8,WC{8,WB{{EXCLAMATION{26655
{SCN38{ADD{8,WC{8,WB{{PERCENT{26656
{SCN39{ADD{8,WC{8,WB{{ASTERISK{26657
{SCN40{ADD{8,WC{8,WB{{SLASH{26658
{SCN41{ADD{8,WC{8,WB{{NUMBER SIGN{26659
{SCN42{ADD{8,WC{8,WB{{AT SIGN{26660
{SCN43{ADD{8,WC{8,WB{{VERTICAL BAR{26661
{SCN44{ADD{8,WC{8,WB{{AMPERSAND{26662
{SCN45{ADD{8,WC{8,WB{{QUESTION MARK{26663
*
*      ALL OPERATORS COME HERE (EQUAL MERGES DIRECTLY)
*      (WC) POINTS TO THE BINARY/UNARY PAIR OF OPERATOR DVBLKS.
*
{SCN46{BZE{8,WB{6,SCN10{{OPERATOR TERMINATES NAME/CONSTANT{26668
{{MOV{7,XR{8,WC{{ELSE COPY DV POINTER{26669
{{LCH{8,WC{9,(XL){{LOAD NEXT CHARACTER{26670
{{MOV{7,XL{18,=T_BOP{{SET BINARY OP IN CASE{26671
{{BEQ{8,WA{3,SCNIL{6,SCN47{SHOULD BE BINARY IF IMAGE END{26672
{{BEQ{8,WC{18,=CH_BL{6,SCN47{SHOULD BE BINARY IF FOLLOWED BY BLK{26673
{{BEQ{8,WC{18,=CH_HT{6,SCN47{JUMP IF HORIZONTAL TAB{26675
{{BEQ{8,WC{18,=CH_SM{6,SCN47{SEMICOLON CAN IMMEDIATELY FOLLOW ={26680
{{BEQ{8,WC{18,=CH_CL{6,SCN47{COLON CAN IMMEDIATELY FOLLOW ={26681
{{BEQ{8,WC{18,=CH_RP{6,SCN47{RIGHT PAREN CAN IMMEDIATELY FOLLOW ={26682
{{BEQ{8,WC{18,=CH_RB{6,SCN47{RIGHT BRACKET CAN IMMEDIATELY FOLLOW ={26683
{{BEQ{8,WC{18,=CH_CB{6,SCN47{RIGHT BRACKET CAN IMMEDIATELY FOLLOW ={26684
*
*      HERE FOR UNARY OPERATOR
*
{{ADD{7,XR{19,*DVBS_{{POINT TO DV FOR UNARY OP{26688
{{MOV{7,XL{18,=T_UOP{{SET TYPE FOR UNARY OPERATOR{26689
{{BLE{3,SCNTP{18,=T_UOK{6,SCN13{OK UNARY IF OK PRECEDING ELEMENT{26690
{{EJC{{{{{26691
*
*      SCANE (CONTINUED)
*
*      MERGE HERE TO REQUIRE PRECEDING BLANKS
*
{SCN47{BNZ{3,SCNBL{6,SCN13{{ALL OK IF PRECEDING BLANKS, EXIT{26697
*
*      FAIL OPERATOR IN THIS POSITION
*
{SCN48{ERB{1,233{26,Syntax error: Invalid use of operator{{{26701
*
*      HERE FOR ASTERISK, COULD BE ** SUBSTITUTE FOR EXCLAMATION
*
{SCN49{BZE{8,WB{6,SCN10{{END OF NAME IF SCANNING NAME{26705
{{BEQ{8,WA{3,SCNIL{6,SCN39{NOT ** IF * AT IMAGE END{26706
{{MOV{7,XR{8,WA{{ELSE SAVE OFFSET PAST FIRST *{26707
{{MOV{3,SCNOF{8,WA{{SAVE ANOTHER COPY{26708
{{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER{26709
{{BNE{8,WA{18,=CH_AS{6,SCN50{NOT ** IF NEXT CHAR NOT *{26710
{{ICV{7,XR{{{ELSE STEP OFFSET PAST SECOND *{26711
{{BEQ{7,XR{3,SCNIL{6,SCN51{OK EXCLAM IF END OF IMAGE{26712
{{LCH{8,WA{9,(XL){{ELSE LOAD NEXT CHARACTER{26713
{{BEQ{8,WA{18,=CH_BL{6,SCN51{EXCLAMATION IF BLANK{26714
{{BEQ{8,WA{18,=CH_HT{6,SCN51{EXCLAMATION IF HORIZONTAL TAB{26716
*
*      UNARY *
*
{SCN50{MOV{8,WA{3,SCNOF{{RECOVER STORED OFFSET{26724
{{MOV{7,XL{3,R_CIM{{POINT TO LINE AGAIN{26725
{{PLC{7,XL{8,WA{{POINT TO CURRENT CHAR{26726
{{BRN{6,SCN39{{{MERGE WITH UNARY *{26727
*
*      HERE FOR ** AS SUBSTITUTE FOR EXCLAMATION
*
{SCN51{MOV{3,SCNPT{7,XR{{SAVE SCAN POINTER PAST 2ND *{26731
{{MOV{8,WA{7,XR{{COPY SCAN POINTER{26732
{{BRN{6,SCN37{{{MERGE WITH EXCLAMATION{26733
{{ENP{{{{END PROCEDURE SCANE{26734
{{EJC{{{{{26735
*
*      SCNGF -- SCAN GOTO FIELD
*
*      SCNGF IS CALLED FROM CMPIL TO SCAN AND ANALYZE A GOTO
*      FIELD INCLUDING THE SURROUNDING BRACKETS OR PARENTHESES.
*      FOR A NORMAL GOTO, THE RESULT RETURNED IS EITHER A VRBLK
*      POINTER FOR A SIMPLE LABEL OPERAND, OR A POINTER TO AN
*      EXPRESSION TREE WITH A SPECIAL OUTER UNARY OPERATOR
*      (O_GOC). FOR A DIRECT GOTO, THE RESULT RETURNED IS A
*      POINTER TO AN EXPRESSION TREE WITH THE SPECIAL OUTER
*      UNARY OPERATOR O_GOD.
*
*      JSR  SCNGF            CALL TO SCAN GOTO FIELD
*      (XR)                  RESULT (SEE ABOVE)
*      (XL,WA,WB,WC)         DESTROYED
*
{SCNGF{PRC{25,E{1,0{{ENTRY POINT{26752
{{JSR{6,SCANE{{{SCAN INITIAL ELEMENT{26753
{{BEQ{7,XL{18,=T_LPR{6,SCNG1{SKIP IF LEFT PAREN (NORMAL GOTO){26754
{{BEQ{7,XL{18,=T_LBR{6,SCNG2{SKIP IF LEFT BRACKET (DIRECT GOTO){26755
{{ERB{1,234{26,Syntax error: Goto field incorrect{{{26756
*
*      HERE FOR LEFT PAREN (NORMAL GOTO)
*
{SCNG1{MOV{8,WB{18,=NUM01{{SET EXPAN FLAG FOR NORMAL GOTO{26760
{{JSR{6,EXPAN{{{ANALYZE GOTO FIELD{26761
{{MOV{8,WA{21,=OPDVN{{POINT TO OPDV FOR COMPLEX GOTO{26762
{{BLE{7,XR{3,STATB{6,SCNG3{JUMP IF NOT IN STATIC (SGD15){26763
{{BLO{7,XR{3,STATE{6,SCNG4{JUMP TO EXIT IF SIMPLE LABEL NAME{26764
{{BRN{6,SCNG3{{{COMPLEX GOTO - MERGE{26765
*
*      HERE FOR LEFT BRACKET (DIRECT GOTO)
*
{SCNG2{MOV{8,WB{18,=NUM02{{SET EXPAN FLAG FOR DIRECT GOTO{26769
{{JSR{6,EXPAN{{{SCAN GOTO FIELD{26770
{{MOV{8,WA{21,=OPDVD{{SET OPDV POINTER FOR DIRECT GOTO{26771
{{EJC{{{{{26772
*
*      SCNGF (CONTINUED)
*
*      MERGE HERE TO BUILD OUTER UNARY OPERATOR BLOCK
*
{SCNG3{MOV{11,-(XS){8,WA{{STACK OPERATOR DV POINTER{26778
{{MOV{11,-(XS){7,XR{{STACK POINTER TO EXPRESSION TREE{26779
{{JSR{6,EXPOP{{{POP OPERATOR OFF{26780
{{MOV{7,XR{10,(XS)+{{RELOAD NEW EXPRESSION TREE POINTER{26781
*
*      COMMON EXIT POINT
*
{SCNG4{EXI{{{{RETURN TO CALLER{26785
{{ENP{{{{END PROCEDURE SCNGF{26786
{{EJC{{{{{26787
*
*      SETVR -- SET VRGET,VRSTO FIELDS OF VRBLK
*
*      SETVR SETS THE PROPER VALUES IN THE VRGET AND VRSTO
*      FIELDS OF A VRBLK. IT IS CALLED WHENEVER TRBLKS ARE
*      ADDED OR SUBTRACTED (TRACE,STOPTR,INPUT,OUTPUT,DETACH)
*
*      (XR)                  POINTER TO VRBLK
*      JSR  SETVR            CALL TO SET FIELDS
*      (XL,WA)               DESTROYED
*
*      NOTE THAT SETVR IGNORES THE CALL IF XR DOES NOT POINT
*      INTO THE STATIC REGION (I.E. IS SOME OTHER NAME BASE)
*
{SETVR{PRC{25,E{1,0{{ENTRY POINT{26802
{{BHI{7,XR{3,STATE{6,SETV1{EXIT IF NOT NATURAL VARIABLE{26803
*
*      HERE IF WE HAVE A VRBLK
*
{{MOV{7,XL{7,XR{{COPY VRBLK POINTER{26807
{{MOV{13,VRGET(XR){22,=B_VRL{{STORE NORMAL GET VALUE{26808
{{BEQ{13,VRSTO(XR){22,=B_VRE{6,SETV1{SKIP IF PROTECTED VARIABLE{26809
{{MOV{13,VRSTO(XR){22,=B_VRS{{STORE NORMAL STORE VALUE{26810
{{MOV{7,XL{13,VRVAL(XL){{POINT TO NEXT ENTRY ON CHAIN{26811
{{BNE{9,(XL){22,=B_TRT{6,SETV1{JUMP IF END OF TRBLK CHAIN{26812
{{MOV{13,VRGET(XR){22,=B_VRA{{STORE TRAPPED ROUTINE ADDRESS{26813
{{MOV{13,VRSTO(XR){22,=B_VRV{{SET TRAPPED ROUTINE ADDRESS{26814
*
*      MERGE HERE TO EXIT TO CALLER
*
{SETV1{EXI{{{{RETURN TO SETVR CALLER{26818
{{ENP{{{{END PROCEDURE SETVR{26819
{{EJC{{{{{26822
*
*      SORTA -- SORT ARRAY
*
*      ROUTINE TO SORT AN ARRAY OR TABLE ON SAME BASIS AS IN
*      SITBOL. A TABLE IS CONVERTED TO AN ARRAY, LEAVING TWO
*      DIMENSIONAL ARRAYS AND VECTORS AS CASES TO BE CONSIDERED.
*      WHOLE ROWS OF ARRAYS ARE PERMUTED ACCORDING TO THE
*      ORDERING OF THE KEYS THEY CONTAIN, AND THE STRIDE
*      REFERRED TO, IS THE THE LENGTH OF A ROW. IT IS ONE
*      FOR A VECTOR.
*      THE SORT USED IS HEAPSORT, FUNDAMENTALS OF DATA STRUCTURE
*      HOROWITZ AND SAHNI, PITMAN 1977, PAGE 347.
*      IT IS AN ORDER N*LOG(N) ALGORITHM. IN ORDER
*      TO MAKE IT STABLE, COMPARANDS MAY NOT COMPARE EQUAL. THIS
*      IS ACHIEVED BY SORTING A COPY ARRAY (REFERRED TO AS THE
*      SORT ARRAY) CONTAINING AT ITS HIGH ADDRESS END, BYTE
*      OFFSETS TO THE ROWS TO BE SORTED HELD IN THE ORIGINAL
*      ARRAY (REFERRED TO AS THE KEY ARRAY). SORTC, THE
*      COMPARISON ROUTINE, ACCESSES THE KEYS THROUGH THESE
*      OFFSETS AND IN THE CASE OF EQUALITY, RESOLVES IT BY
*      COMPARING THE OFFSETS THEMSELVES. THE SORT PERMUTES THE
*      OFFSETS WHICH ARE THEN USED IN A FINAL OPERATION TO COPY
*      THE ACTUAL ITEMS INTO THE NEW ARRAY IN SORTED ORDER.
*      REFERENCES TO ZEROTH ITEM ARE TO NOTIONAL ITEM
*      PRECEDING FIRST ACTUAL ITEM.
*      REVERSE SORTING FOR RSORT IS DONE BY HAVING THE LESS THAN
*      TEST FOR KEYS EFFECTIVELY BE REPLACED BY A
*      GREATER THAN TEST.
*
*      1(XS)                 FIRST ARG - ARRAY OR TABLE
*      0(XS)                 2ND ARG - INDEX OR PDTYPE NAME
*      (WA)                  0 , NON-ZERO FOR SORT , RSORT
*      JSR  SORTA            CALL TO SORT ARRAY
*      PPM  LOC              TRANSFER LOC IF TABLE IS EMPTY
*      (XR)                  SORTED ARRAY
*      (XL,WA,WB,WC)         DESTROYED
{{EJC{{{{{26859
*
*      SORTA (CONTINUED)
*
{SORTA{PRC{25,N{1,1{{ENTRY POINT{26863
{{MOV{3,SRTSR{8,WA{{SORT/RSORT INDICATOR{26864
{{MOV{3,SRTST{19,*NUM01{{DEFAULT STRIDE OF 1{26865
{{ZER{3,SRTOF{{{DEFAULT ZERO OFFSET TO SORT KEY{26866
{{MOV{3,SRTDF{21,=NULLS{{CLEAR DATATYPE FIELD NAME{26867
{{MOV{3,R_SXR{10,(XS)+{{UNSTACK ARGUMENT 2{26868
{{MOV{7,XR{10,(XS)+{{GET FIRST ARGUMENT{26869
{{MNZ{8,WA{{{USE KEY/VALUES OF TABLE ENTRIES{26870
{{JSR{6,GTARR{{{CONVERT TO ARRAY{26871
{{PPM{6,SRT18{{{SIGNAL THAT TABLE IS EMPTY{26872
{{PPM{6,SRT16{{{ERROR IF NON-CONVERTABLE{26873
{{MOV{11,-(XS){7,XR{{STACK PTR TO RESULTING KEY ARRAY{26874
{{MOV{11,-(XS){7,XR{{ANOTHER COPY FOR COPYB{26875
{{JSR{6,COPYB{{{GET COPY ARRAY FOR SORTING INTO{26876
{{PPM{{{{CANT FAIL{26877
{{MOV{11,-(XS){7,XR{{STACK POINTER TO SORT ARRAY{26878
{{MOV{7,XR{3,R_SXR{{GET SECOND ARG{26879
{{MOV{7,XL{13,NUM01(XS){{GET PTR TO KEY ARRAY{26880
{{BNE{9,(XL){22,=B_VCT{6,SRT02{JUMP IF ARBLK{26881
{{BEQ{7,XR{21,=NULLS{6,SRT01{JUMP IF NULL SECOND ARG{26882
{{JSR{6,GTNVR{{{GET VRBLK PTR FOR IT{26883
{{ERR{1,257{26,Erroneous 2nd arg in SORT/RSORT of vector{{{26884
{{MOV{3,SRTDF{7,XR{{STORE DATATYPE FIELD NAME VRBLK{26885
*
*      COMPUTE N AND OFFSET TO ITEM A(0) IN VECTOR CASE
*
{SRT01{MOV{8,WC{19,*VCLEN{{OFFSET TO A(0){26889
{{MOV{8,WB{19,*VCVLS{{OFFSET TO FIRST ITEM{26890
{{MOV{8,WA{13,VCLEN(XL){{GET BLOCK LENGTH{26891
{{SUB{8,WA{19,*VCSI_{{GET NO. OF ENTRIES, N (IN BYTES){26892
{{BRN{6,SRT04{{{MERGE{26893
*
*      HERE FOR ARRAY
*
{SRT02{LDI{13,ARDIM(XL){{{GET POSSIBLE DIMENSION{26897
{{MFI{8,WA{{{CONVERT TO SHORT INTEGER{26898
{{WTB{8,WA{{{FURTHER CONVERT TO BAUS{26899
{{MOV{8,WB{19,*ARVLS{{OFFSET TO FIRST VALUE IF ONE{26900
{{MOV{8,WC{19,*ARPRO{{OFFSET BEFORE VALUES IF ONE DIM.{26901
{{BEQ{13,ARNDM(XL){18,=NUM01{6,SRT04{JUMP IN FACT IF ONE DIM.{26902
{{BNE{13,ARNDM(XL){18,=NUM02{6,SRT16{FAIL UNLESS TWO DIMENS{26903
{{LDI{13,ARLB2(XL){{{GET LOWER BOUND 2 AS DEFAULT{26904
{{BEQ{7,XR{21,=NULLS{6,SRT03{JUMP IF DEFAULT SECOND ARG{26905
{{JSR{6,GTINT{{{CONVERT TO INTEGER{26906
{{PPM{6,SRT17{{{FAIL{26907
{{LDI{13,ICVAL(XR){{{GET ACTUAL INTEGER VALUE{26908
{{EJC{{{{{26909
*
*      SORTA (CONTINUED)
*
*      HERE WITH SORT COLUMN INDEX IN IA IN ARRAY CASE
*
{SRT03{SBI{13,ARLB2(XL){{{SUBTRACT LOW BOUND{26915
{{IOV{6,SRT17{{{FAIL IF OVERFLOW{26916
{{ILT{6,SRT17{{{FAIL IF BELOW LOW BOUND{26917
{{SBI{13,ARDM2(XL){{{CHECK AGAINST DIMENSION{26918
{{IGE{6,SRT17{{{FAIL IF TOO LARGE{26919
{{ADI{13,ARDM2(XL){{{RESTORE VALUE{26920
{{MFI{8,WA{{{GET AS SMALL INTEGER{26921
{{WTB{8,WA{{{OFFSET WITHIN ROW TO KEY{26922
{{MOV{3,SRTOF{8,WA{{KEEP OFFSET{26923
{{LDI{13,ARDM2(XL){{{SECOND DIMENSION IS ROW LENGTH{26924
{{MFI{8,WA{{{CONVERT TO SHORT INTEGER{26925
{{MOV{7,XR{8,WA{{COPY ROW LENGTH{26926
{{WTB{8,WA{{{CONVERT TO BYTES{26927
{{MOV{3,SRTST{8,WA{{STORE AS STRIDE{26928
{{LDI{13,ARDIM(XL){{{GET NUMBER OF ROWS{26929
{{MFI{8,WA{{{AS A SHORT INTEGER{26930
{{WTB{8,WA{{{CONVERT N TO BAUS{26931
{{MOV{8,WC{13,ARLEN(XL){{OFFSET PAST ARRAY END{26932
{{SUB{8,WC{8,WA{{ADJUST, GIVING SPACE FOR N OFFSETS{26933
{{DCA{8,WC{{{POINT TO A(0){26934
{{MOV{8,WB{13,AROFS(XL){{OFFSET TO WORD BEFORE FIRST ITEM{26935
{{ICA{8,WB{{{OFFSET TO FIRST ITEM{26936
*
*      SEPARATE PRE-PROCESSING FOR ARRAYS AND VECTORS DONE.
*      TO SIMPLIFY LATER KEY COMPARISONS, REMOVAL OF ANY TRBLK
*      TRAP BLOCKS FROM ENTRIES IN KEY ARRAY IS EFFECTED.
*
*      (XL) = 1(XS) = POINTER TO KEY ARRAY
*      (XS) = POINTER TO SORT ARRAY
*      WA = NUMBER OF ITEMS, N (CONVERTED TO BYTES).
*      WB = OFFSET TO FIRST ITEM OF ARRAYS.
*      WC = OFFSET TO A(0)
*
{SRT04{BLE{8,WA{19,*NUM01{6,SRT15{RETURN IF ONLY A SINGLE ITEM{26948
{{MOV{3,SRTSN{8,WA{{STORE NUMBER OF ITEMS (IN BAUS){26949
{{MOV{3,SRTSO{8,WC{{STORE OFFSET TO A(0){26950
{{MOV{8,WC{13,ARLEN(XL){{LENGTH OF ARRAY OR VEC (=VCLEN){26951
{{ADD{8,WC{7,XL{{POINT PAST END OF ARRAY OR VECTOR{26952
{{MOV{3,SRTSF{8,WB{{STORE OFFSET TO FIRST ROW{26953
{{ADD{7,XL{8,WB{{POINT TO FIRST ITEM IN KEY ARRAY{26954
*
*      LOOP THROUGH ARRAY
*
{SRT05{MOV{7,XR{9,(XL){{GET AN ENTRY{26958
*
*      HUNT ALONG TRBLK CHAIN
*
{SRT06{BNE{9,(XR){22,=B_TRT{6,SRT07{JUMP OUT IF NOT TRBLK{26962
{{MOV{7,XR{13,TRVAL(XR){{GET VALUE FIELD{26963
{{BRN{6,SRT06{{{LOOP{26964
{{EJC{{{{{26965
*
*      SORTA (CONTINUED)
*
*      XR IS VALUE FROM END OF CHAIN
*
{SRT07{MOV{10,(XL)+{7,XR{{STORE AS ARRAY ENTRY{26971
{{BLT{7,XL{8,WC{6,SRT05{LOOP IF NOT DONE{26972
{{MOV{7,XL{9,(XS){{GET ADRS OF SORT ARRAY{26973
{{MOV{7,XR{3,SRTSF{{INITIAL OFFSET TO FIRST KEY{26974
{{MOV{8,WB{3,SRTST{{GET STRIDE{26975
{{ADD{7,XL{3,SRTSO{{OFFSET TO A(0){26976
{{ICA{7,XL{{{POINT TO A(1){26977
{{MOV{8,WC{3,SRTSN{{GET N{26978
{{BTW{8,WC{{{CONVERT FROM BYTES{26979
{{MOV{3,SRTNR{8,WC{{STORE AS ROW COUNT{26980
{{LCT{8,WC{8,WC{{LOOP COUNTER{26981
*
*      STORE KEY OFFSETS AT TOP OF SORT ARRAY
*
{SRT08{MOV{10,(XL)+{7,XR{{STORE AN OFFSET{26985
{{ADD{7,XR{8,WB{{BUMP OFFSET BY STRIDE{26986
{{BCT{8,WC{6,SRT08{{LOOP THROUGH ROWS{26987
*
*      PERFORM THE SORT ON OFFSETS IN SORT ARRAY.
*
*      (SRTSN)               NUMBER OF ITEMS TO SORT, N (BYTES)
*      (SRTSO)               OFFSET TO A(0)
*
{SRT09{MOV{8,WA{3,SRTSN{{GET N{26994
{{MOV{8,WC{3,SRTNR{{GET NUMBER OF ROWS{26995
{{RSH{8,WC{1,1{{I = N / 2 (WC=I, INDEX INTO ARRAY){26996
{{WTB{8,WC{{{CONVERT BACK TO BYTES{26997
*
*      LOOP TO FORM INITIAL HEAP
*
{SRT10{JSR{6,SORTH{{{SORTH(I,N){27001
{{DCA{8,WC{{{I = I - 1{27002
{{BNZ{8,WC{6,SRT10{{LOOP IF I GT 0{27003
{{MOV{8,WC{8,WA{{I = N{27004
*
*      SORTING LOOP. AT THIS POINT, A(1) IS THE LARGEST
*      ITEM, SINCE ALGORITHM INITIALISES IT AS, AND THEN MAINTAINS
*      IT AS, ROOT OF TREE.
*
{SRT11{DCA{8,WC{{{I = I - 1 (N - 1 INITIALLY){27010
{{BZE{8,WC{6,SRT12{{JUMP IF DONE{27011
{{MOV{7,XR{9,(XS){{GET SORT ARRAY ADDRESS{27012
{{ADD{7,XR{3,SRTSO{{POINT TO A(0){27013
{{MOV{7,XL{7,XR{{A(0) ADDRESS{27014
{{ADD{7,XL{8,WC{{A(I) ADDRESS{27015
{{MOV{8,WB{13,NUM01(XL){{COPY A(I+1){27016
{{MOV{13,NUM01(XL){13,NUM01(XR){{MOVE A(1) TO A(I+1){27017
{{MOV{13,NUM01(XR){8,WB{{COMPLETE EXCHANGE OF A(1), A(I+1){27018
{{MOV{8,WA{8,WC{{N = I FOR SORTH{27019
{{MOV{8,WC{19,*NUM01{{I = 1 FOR SORTH{27020
{{JSR{6,SORTH{{{SORTH(1,N){27021
{{MOV{8,WC{8,WA{{RESTORE WC{27022
{{BRN{6,SRT11{{{LOOP{27023
{{EJC{{{{{27024
*
*      SORTA (CONTINUED)
*
*      OFFSETS HAVE BEEN PERMUTED INTO REQUIRED ORDER BY SORT.
*      COPY ARRAY ELEMENTS OVER THEM.
*
{SRT12{MOV{7,XR{9,(XS){{BASE ADRS OF KEY ARRAY{27031
{{MOV{8,WC{7,XR{{COPY IT{27032
{{ADD{8,WC{3,SRTSO{{OFFSET OF A(0){27033
{{ADD{7,XR{3,SRTSF{{ADRS OF FIRST ROW OF SORT ARRAY{27034
{{MOV{8,WB{3,SRTST{{GET STRIDE{27035
*
*      COPYING LOOP FOR SUCCESSIVE ITEMS. SORTED OFFSETS ARE
*      HELD AT END OF SORT ARRAY.
*
{SRT13{ICA{8,WC{{{ADRS OF NEXT OF SORTED OFFSETS{27040
{{MOV{7,XL{8,WC{{COPY IT FOR ACCESS{27041
{{MOV{7,XL{9,(XL){{GET OFFSET{27042
{{ADD{7,XL{13,NUM01(XS){{ADD KEY ARRAY BASE ADRS{27043
{{MOV{8,WA{8,WB{{GET COUNT OF CHARACTERS IN ROW{27044
{{MVW{{{{COPY A COMPLETE ROW{27045
{{DCV{3,SRTNR{{{DECREMENT ROW COUNT{27046
{{BNZ{3,SRTNR{6,SRT13{{REPEAT TILL ALL ROWS DONE{27047
*
*      RETURN POINT
*
{SRT15{MOV{7,XR{10,(XS)+{{POP RESULT ARRAY PTR{27051
{{ICA{7,XS{{{POP KEY ARRAY PTR{27052
{{ZER{3,R_SXL{{{CLEAR JUNK{27053
{{ZER{3,R_SXR{{{CLEAR JUNK{27054
{{EXI{{{{RETURN{27055
*
*      ERROR POINT
*
{SRT16{ERB{1,256{26,SORT/RSORT 1st arg not suitable ARRAY or TABLE{{{27059
{SRT17{ERB{1,258{26,SORT/RSORT 2nd arg out of range or non-integer{{{27060
*
*      RETURN POINT IF INPUT TABLE IS EMPTY
*
{SRT18{EXI{1,1{{{RETURN INDICATION OF NULL TABLE{27064
{{ENP{{{{END PROCUDURE SORTA{27065
{{EJC{{{{{27066
*
*      SORTC --  COMPARE SORT KEYS
*
*      COMPARE TWO SORT KEYS GIVEN THEIR OFFSETS. IF
*      EQUAL, COMPARE KEY OFFSETS TO GIVE STABLE SORT.
*      NOTE THAT IF SRTSR IS NON-ZERO (REQUEST FOR REVERSE
*      SORT), THE QUOTED RETURNS ARE INVERTED.
*      FOR OBJECTS OF DIFFERING DATATYPES, THE ENTRY POINT
*      IDENTIFICATIONS ARE COMPARED.
*
*      (XL)                  BASE ADRS FOR KEYS
*      (WA)                  OFFSET TO KEY 1 ITEM
*      (WB)                  OFFSET TO KEY 2 ITEM
*      (SRTSR)               ZERO/NON-ZERO FOR SORT/RSORT
*      (SRTOF)               OFFSET WITHIN ROW TO COMPARANDS
*      JSR  SORTC            CALL TO COMPARE KEYS
*      PPM  LOC              KEY1 LESS THAN KEY2
*                            NORMAL RETURN, KEY1 GT THAN KEY2
*      (XL,XR,WA,WB)         DESTROYED
*
{SORTC{PRC{25,E{1,1{{ENTRY POINT{27087
{{MOV{3,SRTS1{8,WA{{SAVE OFFSET 1{27088
{{MOV{3,SRTS2{8,WB{{SAVE OFFSET 2{27089
{{MOV{3,SRTSC{8,WC{{SAVE WC{27090
{{ADD{7,XL{3,SRTOF{{ADD OFFSET TO COMPARAND FIELD{27091
{{MOV{7,XR{7,XL{{COPY BASE + OFFSET{27092
{{ADD{7,XL{8,WA{{ADD KEY1 OFFSET{27093
{{ADD{7,XR{8,WB{{ADD KEY2 OFFSET{27094
{{MOV{7,XL{9,(XL){{GET KEY1{27095
{{MOV{7,XR{9,(XR){{GET KEY2{27096
{{BNE{3,SRTDF{21,=NULLS{6,SRC12{JUMP IF DATATYPE FIELD NAME USED{27097
{{EJC{{{{{27098
*
*      SORTC (CONTINUED)
*
*      MERGE AFTER DEALING WITH FIELD NAME. TRY FOR STRINGS.
*
{SRC01{MOV{8,WC{9,(XL){{GET TYPE CODE{27104
{{BNE{8,WC{9,(XR){6,SRC02{SKIP IF NOT SAME DATATYPE{27105
{{BEQ{8,WC{22,=B_SCL{6,SRC09{JUMP IF BOTH STRINGS{27106
{{BEQ{8,WC{22,=B_ICL{6,SRC14{JUMP IF BOTH INTEGERS{27107
*
*      DATATYPES DIFFERENT.  NOW TRY FOR NUMERIC
*
{SRC02{MOV{3,R_SXL{7,XL{{KEEP ARG1{27115
{{MOV{3,R_SXR{7,XR{{KEEP ARG2{27116
{{BEQ{8,WC{22,=B_SCL{6,SRC11{DO NOT ALLOW CONVERSION TO NUMBER{27119
{{BEQ{9,(XR){22,=B_SCL{6,SRC11{IF EITHER ARG IS A STRING{27120
{SRC14{MOV{11,-(XS){7,XL{{STACK{27163
{{MOV{11,-(XS){7,XR{{ARGS{27164
{{JSR{6,ACOMP{{{COMPARE OBJECTS{27165
{{PPM{6,SRC10{{{NOT NUMERIC{27166
{{PPM{6,SRC10{{{NOT NUMERIC{27167
{{PPM{6,SRC03{{{KEY1 LESS{27168
{{PPM{6,SRC08{{{KEYS EQUAL{27169
{{PPM{6,SRC05{{{KEY1 GREATER{27170
*
*      RETURN IF KEY1 SMALLER (SORT), GREATER (RSORT)
*
{SRC03{BNZ{3,SRTSR{6,SRC06{{JUMP IF RSORT{27174
*
{SRC04{MOV{8,WC{3,SRTSC{{RESTORE WC{27176
{{EXI{1,1{{{RETURN{27177
*
*      RETURN IF KEY1 GREATER (SORT), SMALLER (RSORT)
*
{SRC05{BNZ{3,SRTSR{6,SRC04{{JUMP IF RSORT{27181
*
{SRC06{MOV{8,WC{3,SRTSC{{RESTORE WC{27183
{{EXI{{{{RETURN{27184
*
*      KEYS ARE OF SAME DATATYPE
*
{SRC07{BLT{7,XL{7,XR{6,SRC03{ITEM FIRST CREATED IS LESS{27188
{{BGT{7,XL{7,XR{6,SRC05{ADDRESSES RISE IN ORDER OF CREATION{27189
*
*      DROP THROUGH OR MERGE FOR IDENTICAL OR EQUAL OBJECTS
*
{SRC08{BLT{3,SRTS1{3,SRTS2{6,SRC04{TEST OFFSETS OR KEY ADDRSS INSTEAD{27193
{{BRN{6,SRC06{{{OFFSET 1 GREATER{27194
{{EJC{{{{{27195
*
*      SORTC (CONTINUED)
*
*      STRINGS
*
{SRC09{MOV{11,-(XS){7,XL{{STACK{27205
{{MOV{11,-(XS){7,XR{{ARGS{27206
{{JSR{6,LCOMP{{{COMPARE OBJECTS{27207
{{PPM{{{{CANT{27208
{{PPM{{{{FAIL{27209
{{PPM{6,SRC03{{{KEY1 LESS{27210
{{PPM{6,SRC08{{{KEYS EQUAL{27211
{{PPM{6,SRC05{{{KEY1 GREATER{27212
*
*      ARITHMETIC COMPARISON FAILED - RECOVER ARGS
*
{SRC10{MOV{7,XL{3,R_SXL{{GET ARG1{27216
{{MOV{7,XR{3,R_SXR{{GET ARG2{27217
{{MOV{8,WC{9,(XL){{GET TYPE OF KEY1{27218
{{BEQ{8,WC{9,(XR){6,SRC07{JUMP IF KEYS OF SAME TYPE{27219
*
*      HERE TO COMPARE DATATYPE IDS
*
{SRC11{MOV{7,XL{8,WC{{GET BLOCK TYPE WORD{27223
{{MOV{7,XR{9,(XR){{GET BLOCK TYPE WORD{27224
{{LEI{7,XL{{{ENTRY POINT ID FOR KEY1{27225
{{LEI{7,XR{{{ENTRY POINT ID FOR KEY2{27226
{{BGT{7,XL{7,XR{6,SRC05{JUMP IF KEY1 GT KEY2{27227
{{BRN{6,SRC03{{{KEY1 LT KEY2{27228
*
*      DATATYPE FIELD NAME USED
*
{SRC12{JSR{6,SORTF{{{CALL ROUTINE TO FIND FIELD 1{27232
{{MOV{11,-(XS){7,XL{{STACK ITEM POINTER{27233
{{MOV{7,XL{7,XR{{GET KEY2{27234
{{JSR{6,SORTF{{{FIND FIELD 2{27235
{{MOV{7,XR{7,XL{{PLACE AS KEY2{27236
{{MOV{7,XL{10,(XS)+{{RECOVER KEY1{27237
{{BRN{6,SRC01{{{MERGE{27238
{{ENP{{{{PROCEDURE SORTC{27239
{{EJC{{{{{27240
*
*      SORTF -- FIND FIELD FOR SORTC
*
*      ROUTINE USED BY SORTC TO OBTAIN ITEM CORRESPONDING
*      TO A GIVEN FIELD NAME, IF THIS EXISTS, IN A PROGRAMMER
*      DEFINED OBJECT PASSED AS ARGUMENT.
*      IF SUCH A MATCH OCCURS, RECORD IS KEPT OF DATATYPE
*      NAME, FIELD NAME AND OFFSET TO FIELD IN ORDER TO
*      SHORT-CIRCUIT LATER SEARCHES ON SAME TYPE. NOTE THAT
*      DFBLKS ARE STORED IN STATIC AND HENCE CANNOT BE MOVED.
*
*      (SRTDF)               VRBLK POINTER OF FIELD NAME
*      (XL)                  POSSIBLE PDBLK POINTER
*      JSR  SORTF            CALL TO SEARCH FOR FIELD NAME
*      (XL)                  ITEM FOUND OR ORIGINAL PDBLK PTR
*      (WC)                  DESTROYED
*
{SORTF{PRC{25,E{1,0{{ENTRY POINT{27258
{{BNE{9,(XL){22,=B_PDT{6,SRTF3{RETURN IF NOT PDBLK{27259
{{MOV{11,-(XS){7,XR{{KEEP XR{27260
{{MOV{7,XR{3,SRTFD{{GET POSSIBLE FORMER DFBLK PTR{27261
{{BZE{7,XR{6,SRTF4{{JUMP IF NOT{27262
{{BNE{7,XR{13,PDDFP(XL){6,SRTF4{JUMP IF NOT RIGHT DATATYPE{27263
{{BNE{3,SRTDF{3,SRTFF{6,SRTF4{JUMP IF NOT RIGHT FIELD NAME{27264
{{ADD{7,XL{3,SRTFO{{ADD OFFSET TO REQUIRED FIELD{27265
*
*      HERE WITH XL POINTING TO FOUND FIELD
*
{SRTF1{MOV{7,XL{9,(XL){{GET ITEM FROM FIELD{27269
*
*      RETURN POINT
*
{SRTF2{MOV{7,XR{10,(XS)+{{RESTORE XR{27273
*
{SRTF3{EXI{{{{RETURN{27275
{{EJC{{{{{27276
*
*      SORTF (CONTINUED)
*
*      CONDUCT A SEARCH
*
{SRTF4{MOV{7,XR{7,XL{{COPY ORIGINAL POINTER{27282
{{MOV{7,XR{13,PDDFP(XR){{POINT TO DFBLK{27283
{{MOV{3,SRTFD{7,XR{{KEEP A COPY{27284
{{MOV{8,WC{13,FARGS(XR){{GET NUMBER OF FIELDS{27285
{{WTB{8,WC{{{CONVERT TO BYTES{27286
{{ADD{7,XR{13,DFLEN(XR){{POINT PAST LAST FIELD{27287
*
*      LOOP TO FIND NAME IN PDFBLK
*
{SRTF5{DCA{8,WC{{{COUNT DOWN{27291
{{DCA{7,XR{{{POINT IN FRONT{27292
{{BEQ{9,(XR){3,SRTDF{6,SRTF6{SKIP OUT IF FOUND{27293
{{BNZ{8,WC{6,SRTF5{{LOOP{27294
{{BRN{6,SRTF2{{{RETURN - NOT FOUND{27295
*
*      FOUND
*
{SRTF6{MOV{3,SRTFF{9,(XR){{KEEP FIELD NAME PTR{27299
{{ADD{8,WC{19,*PDFLD{{ADD OFFSET TO FIRST FIELD{27300
{{MOV{3,SRTFO{8,WC{{STORE AS FIELD OFFSET{27301
{{ADD{7,XL{8,WC{{POINT TO FIELD{27302
{{BRN{6,SRTF1{{{RETURN{27303
{{ENP{{{{PROCEDURE SORTF{27304
{{EJC{{{{{27305
*
*      SORTH -- HEAP ROUTINE FOR SORTA
*
*      THIS ROUTINE CONSTRUCTS A HEAP FROM ELEMENTS OF ARRAY, A.
*      IN THIS APPLICATION, THE ELEMENTS ARE OFFSETS TO KEYS IN
*      A KEY ARRAY.
*
*      (XS)                  POINTER TO SORT ARRAY BASE
*      1(XS)                 POINTER TO KEY ARRAY BASE
*      (WA)                  MAX ARRAY INDEX, N (IN BYTES)
*      (WC)                  OFFSET J IN A TO ROOT (IN *1 TO *N)
*      JSR  SORTH            CALL SORTH(J,N) TO MAKE HEAP
*      (XL,XR,WB)            DESTROYED
*
{SORTH{PRC{25,N{1,0{{ENTRY POINT{27320
{{MOV{3,SRTSN{8,WA{{SAVE N{27321
{{MOV{3,SRTWC{8,WC{{KEEP WC{27322
{{MOV{7,XL{9,(XS){{SORT ARRAY BASE ADRS{27323
{{ADD{7,XL{3,SRTSO{{ADD OFFSET TO A(0){27324
{{ADD{7,XL{8,WC{{POINT TO A(J){27325
{{MOV{3,SRTRT{9,(XL){{GET OFFSET TO ROOT{27326
{{ADD{8,WC{8,WC{{DOUBLE J - CANT EXCEED N{27327
*
*      LOOP TO MOVE DOWN TREE USING DOUBLED INDEX J
*
{SRH01{BGT{8,WC{3,SRTSN{6,SRH03{DONE IF J GT N{27331
{{BEQ{8,WC{3,SRTSN{6,SRH02{SKIP IF J EQUALS N{27332
{{MOV{7,XR{9,(XS){{SORT ARRAY BASE ADRS{27333
{{MOV{7,XL{13,NUM01(XS){{KEY ARRAY BASE ADRS{27334
{{ADD{7,XR{3,SRTSO{{POINT TO A(0){27335
{{ADD{7,XR{8,WC{{ADRS OF A(J){27336
{{MOV{8,WA{13,NUM01(XR){{GET A(J+1){27337
{{MOV{8,WB{9,(XR){{GET A(J){27338
*
*      COMPARE SONS. (WA) RIGHT SON, (WB) LEFT SON
*
{{JSR{6,SORTC{{{COMPARE KEYS - LT(A(J+1),A(J)){27342
{{PPM{6,SRH02{{{A(J+1) LT A(J){27343
{{ICA{8,WC{{{POINT TO GREATER SON, A(J+1){27344
{{EJC{{{{{27345
*
*      SORTH (CONTINUED)
*
*      COMPARE ROOT WITH GREATER SON
*
{SRH02{MOV{7,XL{13,NUM01(XS){{KEY ARRAY BASE ADRS{27351
{{MOV{7,XR{9,(XS){{GET SORT ARRAY ADDRESS{27352
{{ADD{7,XR{3,SRTSO{{ADRS OF A(0){27353
{{MOV{8,WB{7,XR{{COPY THIS ADRS{27354
{{ADD{7,XR{8,WC{{ADRS OF GREATER SON, A(J){27355
{{MOV{8,WA{9,(XR){{GET A(J){27356
{{MOV{7,XR{8,WB{{POINT BACK TO A(0){27357
{{MOV{8,WB{3,SRTRT{{GET ROOT{27358
{{JSR{6,SORTC{{{COMPARE THEM - LT(A(J),ROOT){27359
{{PPM{6,SRH03{{{FATHER EXCEEDS SONS - DONE{27360
{{MOV{7,XR{9,(XS){{GET SORT ARRAY ADRS{27361
{{ADD{7,XR{3,SRTSO{{POINT TO A(0){27362
{{MOV{7,XL{7,XR{{COPY IT{27363
{{MOV{8,WA{8,WC{{COPY J{27364
{{BTW{8,WC{{{CONVERT TO WORDS{27365
{{RSH{8,WC{1,1{{GET J/2{27366
{{WTB{8,WC{{{CONVERT BACK TO BYTES{27367
{{ADD{7,XL{8,WA{{POINT TO A(J){27368
{{ADD{7,XR{8,WC{{ADRS OF A(J/2){27369
{{MOV{9,(XR){9,(XL){{A(J/2) = A(J){27370
{{MOV{8,WC{8,WA{{RECOVER J{27371
{{AOV{8,WC{8,WC{6,SRH03{J = J*2. DONE IF TOO BIG{27372
{{BRN{6,SRH01{{{LOOP{27373
*
*      FINISH BY COPYING ROOT OFFSET BACK INTO ARRAY
*
{SRH03{BTW{8,WC{{{CONVERT TO WORDS{27377
{{RSH{8,WC{1,1{{J = J/2{27378
{{WTB{8,WC{{{CONVERT BACK TO BYTES{27379
{{MOV{7,XR{9,(XS){{SORT ARRAY ADRS{27380
{{ADD{7,XR{3,SRTSO{{ADRS OF A(0){27381
{{ADD{7,XR{8,WC{{ADRS OF A(J/2){27382
{{MOV{9,(XR){3,SRTRT{{A(J/2) = ROOT{27383
{{MOV{8,WA{3,SRTSN{{RESTORE WA{27384
{{MOV{8,WC{3,SRTWC{{RESTORE WC{27385
{{EXI{{{{RETURN{27386
{{ENP{{{{END PROCEDURE SORTH{27387
{{EJC{{{{{27389
*
*      TRACE -- SET/RESET A TRACE ASSOCIATION
*
*      THIS PROCEDURE IS SHARED BY TRACE AND STOPTR TO
*      EITHER INITIATE OR STOP A TRACE RESPECTIVELY.
*
*      (XL)                  TRBLK PTR (TRACE) OR ZERO (STOPTR)
*      1(XS)                 FIRST ARGUMENT (NAME)
*      0(XS)                 SECOND ARGUMENT (TRACE TYPE)
*      JSR  TRACE            CALL TO SET/RESET TRACE
*      PPM  LOC              TRANSFER LOC IF 1ST ARG IS BAD NAME
*      PPM  LOC              TRANSFER LOC IF 2ND ARG IS BAD TYPE
*      (XS)                  POPPED
*      (XL,XR,WA,WB,WC,IA)   DESTROYED
*
{TRACE{PRC{25,N{1,2{{ENTRY POINT{27405
{{JSR{6,GTSTG{{{GET TRACE TYPE STRING{27406
{{PPM{6,TRC15{{{JUMP IF NOT STRING{27407
{{PLC{7,XR{{{ELSE POINT TO STRING{27408
{{LCH{8,WA{9,(XR){{LOAD FIRST CHARACTER{27409
{{FLC{8,WA{{{FOLD TO UPPER CASE{27411
{{MOV{7,XR{9,(XS){{LOAD NAME ARGUMENT{27413
{{MOV{9,(XS){7,XL{{STACK TRBLK PTR OR ZERO{27414
{{MOV{8,WC{18,=TRTAC{{SET TRTYP FOR ACCESS TRACE{27415
{{BEQ{8,WA{18,=CH_LA{6,TRC10{JUMP IF A (ACCESS){27416
{{MOV{8,WC{18,=TRTVL{{SET TRTYP FOR VALUE TRACE{27417
{{BEQ{8,WA{18,=CH_LV{6,TRC10{JUMP IF V (VALUE){27418
{{BEQ{8,WA{18,=CH_BL{6,TRC10{JUMP IF BLANK (VALUE){27419
*
*      HERE FOR L,K,F,C,R
*
{{BEQ{8,WA{18,=CH_LF{6,TRC01{JUMP IF F (FUNCTION){27423
{{BEQ{8,WA{18,=CH_LR{6,TRC01{JUMP IF R (RETURN){27424
{{BEQ{8,WA{18,=CH_LL{6,TRC03{JUMP IF L (LABEL){27425
{{BEQ{8,WA{18,=CH_LK{6,TRC06{JUMP IF K (KEYWORD){27426
{{BNE{8,WA{18,=CH_LC{6,TRC15{ELSE ERROR IF NOT C (CALL){27427
*
*      HERE FOR F,C,R
*
{TRC01{JSR{6,GTNVR{{{POINT TO VRBLK FOR NAME{27431
{{PPM{6,TRC16{{{JUMP IF BAD NAME{27432
{{ICA{7,XS{{{POP STACK{27433
{{MOV{7,XR{13,VRFNC(XR){{POINT TO FUNCTION BLOCK{27434
{{BNE{9,(XR){22,=B_PFC{6,TRC17{ERROR IF NOT PROGRAM FUNCTION{27435
{{BEQ{8,WA{18,=CH_LR{6,TRC02{JUMP IF R (RETURN){27436
{{EJC{{{{{27437
*
*      TRACE (CONTINUED)
*
*      HERE FOR F,C TO SET/RESET CALL TRACE
*
{{MOV{13,PFCTR(XR){7,XL{{SET/RESET CALL TRACE{27443
{{BEQ{8,WA{18,=CH_LC{6,EXNUL{EXIT WITH NULL IF C (CALL){27444
*
*      HERE FOR F,R TO SET/RESET RETURN TRACE
*
{TRC02{MOV{13,PFRTR(XR){7,XL{{SET/RESET RETURN TRACE{27448
{{EXI{{{{RETURN{27449
*
*      HERE FOR L TO SET/RESET LABEL TRACE
*
{TRC03{JSR{6,GTNVR{{{POINT TO VRBLK{27453
{{PPM{6,TRC16{{{JUMP IF BAD NAME{27454
{{MOV{7,XL{13,VRLBL(XR){{LOAD LABEL POINTER{27455
{{BNE{9,(XL){22,=B_TRT{6,TRC04{JUMP IF NO OLD TRACE{27456
{{MOV{7,XL{13,TRLBL(XL){{ELSE DELETE OLD TRACE ASSOCIATION{27457
*
*      HERE WITH OLD LABEL TRACE ASSOCIATION DELETED
*
{TRC04{BEQ{7,XL{21,=STNDL{6,TRC16{ERROR IF UNDEFINED LABEL{27461
{{MOV{8,WB{10,(XS)+{{GET TRBLK PTR AGAIN{27462
{{BZE{8,WB{6,TRC05{{JUMP IF STOPTR CASE{27463
{{MOV{13,VRLBL(XR){8,WB{{ELSE SET NEW TRBLK POINTER{27464
{{MOV{13,VRTRA(XR){22,=B_VRT{{SET LABEL TRACE ROUTINE ADDRESS{27465
{{MOV{7,XR{8,WB{{COPY TRBLK POINTER{27466
{{MOV{13,TRLBL(XR){7,XL{{STORE REAL LABEL IN TRBLK{27467
{{EXI{{{{RETURN{27468
*
*      HERE FOR STOPTR CASE FOR LABEL
*
{TRC05{MOV{13,VRLBL(XR){7,XL{{STORE LABEL PTR BACK IN VRBLK{27472
{{MOV{13,VRTRA(XR){22,=B_VRG{{STORE NORMAL TRANSFER ADDRESS{27473
{{EXI{{{{RETURN{27474
{{EJC{{{{{27475
*
*      TRACE (CONTINUED)
*
*      HERE FOR K (KEYWORD)
*
{TRC06{JSR{6,GTNVR{{{POINT TO VRBLK{27481
{{PPM{6,TRC16{{{ERROR IF NOT NATURAL VAR{27482
{{BNZ{13,VRLEN(XR){6,TRC16{{ERROR IF NOT SYSTEM VAR{27483
{{ICA{7,XS{{{POP STACK{27484
{{BZE{7,XL{6,TRC07{{JUMP IF STOPTR CASE{27485
{{MOV{13,TRKVR(XL){7,XR{{STORE VRBLK PTR IN TRBLK FOR KTREX{27486
*
*      MERGE HERE WITH TRBLK SET UP IN WB (OR ZERO)
*
{TRC07{MOV{7,XR{13,VRSVP(XR){{POINT TO SVBLK{27490
{{BEQ{7,XR{21,=V_ERT{6,TRC08{JUMP IF ERRTYPE{27491
{{BEQ{7,XR{21,=V_STC{6,TRC09{JUMP IF STCOUNT{27492
{{BNE{7,XR{21,=V_FNC{6,TRC17{ELSE ERROR IF NOT FNCLEVEL{27493
*
*      FNCLEVEL
*
{{MOV{3,R_FNC{7,XL{{SET/RESET FNCLEVEL TRACE{27497
{{EXI{{{{RETURN{27498
*
*      ERRTYPE
*
{TRC08{MOV{3,R_ERT{7,XL{{SET/RESET ERRTYPE TRACE{27502
{{EXI{{{{RETURN{27503
*
*      STCOUNT
*
{TRC09{MOV{3,R_STC{7,XL{{SET/RESET STCOUNT TRACE{27507
{{JSR{6,STGCC{{{UPDATE COUNTDOWN COUNTERS{27508
{{EXI{{{{RETURN{27509
{{EJC{{{{{27510
*
*      TRACE (CONTINUED)
*
*      A,V MERGE HERE WITH TRTYP VALUE IN WC
*
{TRC10{JSR{6,GTVAR{{{LOCATE VARIABLE{27516
{{PPM{6,TRC16{{{ERROR IF NOT APPROPRIATE NAME{27517
{{MOV{8,WB{10,(XS)+{{GET NEW TRBLK PTR AGAIN{27518
{{ADD{8,WA{7,XL{{POINT TO VARIABLE LOCATION{27519
{{MOV{7,XR{8,WA{{COPY VARIABLE POINTER{27520
*
*      LOOP TO SEARCH TRBLK CHAIN
*
{TRC11{MOV{7,XL{9,(XR){{POINT TO NEXT ENTRY{27524
{{BNE{9,(XL){22,=B_TRT{6,TRC13{JUMP IF NOT TRBLK{27525
{{BLT{8,WC{13,TRTYP(XL){6,TRC13{JUMP IF TOO FAR OUT ON CHAIN{27526
{{BEQ{8,WC{13,TRTYP(XL){6,TRC12{JUMP IF THIS MATCHES OUR TYPE{27527
{{ADD{7,XL{19,*TRNXT{{ELSE POINT TO LINK FIELD{27528
{{MOV{7,XR{7,XL{{COPY POINTER{27529
{{BRN{6,TRC11{{{AND LOOP BACK{27530
*
*      HERE TO DELETE AN OLD TRBLK OF THE TYPE WE WERE GIVEN
*
{TRC12{MOV{7,XL{13,TRNXT(XL){{GET PTR TO NEXT BLOCK OR VALUE{27534
{{MOV{9,(XR){7,XL{{STORE TO DELETE THIS TRBLK{27535
*
*      HERE AFTER DELETING ANY OLD ASSOCIATION OF THIS TYPE
*
{TRC13{BZE{8,WB{6,TRC14{{JUMP IF STOPTR CASE{27539
{{MOV{9,(XR){8,WB{{ELSE LINK NEW TRBLK IN{27540
{{MOV{7,XR{8,WB{{COPY TRBLK POINTER{27541
{{MOV{13,TRNXT(XR){7,XL{{STORE FORWARD POINTER{27542
{{MOV{13,TRTYP(XR){8,WC{{STORE APPROPRIATE TRAP TYPE CODE{27543
*
*      HERE TO MAKE SURE VRGET,VRSTO ARE SET PROPERLY
*
{TRC14{MOV{7,XR{8,WA{{RECALL POSSIBLE VRBLK POINTER{27547
{{SUB{7,XR{19,*VRVAL{{POINT BACK TO VRBLK{27548
{{JSR{6,SETVR{{{SET FIELDS IF VRBLK{27549
{{EXI{{{{RETURN{27550
*
*      HERE FOR BAD TRACE TYPE
*
{TRC15{EXI{1,2{{{TAKE BAD TRACE TYPE ERROR EXIT{27554
*
*      POP STACK BEFORE FAILING
*
{TRC16{ICA{7,XS{{{POP STACK{27558
*
*      HERE FOR BAD NAME ARGUMENT
*
{TRC17{EXI{1,1{{{TAKE BAD NAME ERROR EXIT{27562
{{ENP{{{{END PROCEDURE TRACE{27563
{{EJC{{{{{27564
*
*      TRBLD -- BUILD TRBLK
*
*      TRBLK IS USED BY THE INPUT, OUTPUT AND TRACE FUNCTIONS
*      TO CONSTRUCT A TRBLK (TRAP BLOCK)
*
*      (XR)                  TRTAG OR TRTER
*      (XL)                  TRFNC OR TRFPT
*      (WB)                  TRTYP
*      JSR  TRBLD            CALL TO BUILD TRBLK
*      (XR)                  POINTER TO TRBLK
*      (WA)                  DESTROYED
*
{TRBLD{PRC{25,E{1,0{{ENTRY POINT{27578
{{MOV{11,-(XS){7,XR{{STACK TRTAG (OR TRFNM){27579
{{MOV{8,WA{19,*TRSI_{{SET SIZE OF TRBLK{27580
{{JSR{6,ALLOC{{{ALLOCATE TRBLK{27581
{{MOV{9,(XR){22,=B_TRT{{STORE FIRST WORD{27582
{{MOV{13,TRFNC(XR){7,XL{{STORE TRFNC (OR TRFPT){27583
{{MOV{13,TRTAG(XR){10,(XS)+{{STORE TRTAG (OR TRFNM){27584
{{MOV{13,TRTYP(XR){8,WB{{STORE TYPE{27585
{{MOV{13,TRVAL(XR){21,=NULLS{{FOR NOW, A NULL VALUE{27586
{{EXI{{{{RETURN TO CALLER{27587
{{ENP{{{{END PROCEDURE TRBLD{27588
{{EJC{{{{{27589
*
*      TRIMR -- TRIM TRAILING BLANKS
*
*      TRIMR IS PASSED A POINTER TO AN SCBLK WHICH MUST BE THE
*      LAST BLOCK IN DYNAMIC STORAGE. TRAILING BLANKS ARE
*      TRIMMED OFF AND THE DYNAMIC STORAGE POINTER RESET TO
*      THE END OF THE (POSSIBLY) SHORTENED BLOCK.
*
*      (WB)                  NON-ZERO TO TRIM TRAILING BLANKS
*      (XR)                  POINTER TO STRING TO TRIM
*      JSR  TRIMR            CALL TO TRIM STRING
*      (XR)                  POINTER TO TRIMMED STRING
*      (XL,WA,WB,WC)         DESTROYED
*
*      THE CALL WITH WB ZERO STILL PERFORMS THE END ZERO PAD
*      AND DNAMP READJUSTMENT. IT IS USED FROM ACESS IF KVTRM=0.
*
{TRIMR{PRC{25,E{1,0{{ENTRY POINT{27607
{{MOV{7,XL{7,XR{{COPY STRING POINTER{27608
{{MOV{8,WA{13,SCLEN(XR){{LOAD STRING LENGTH{27609
{{BZE{8,WA{6,TRIM2{{JUMP IF NULL INPUT{27610
{{PLC{7,XL{8,WA{{ELSE POINT PAST LAST CHARACTER{27611
{{BZE{8,WB{6,TRIM3{{JUMP IF NO TRIM{27612
{{MOV{8,WC{18,=CH_BL{{LOAD BLANK CHARACTER{27613
*
*      LOOP THROUGH CHARACTERS FROM RIGHT TO LEFT
*
{TRIM0{LCH{8,WB{11,-(XL){{LOAD NEXT CHARACTER{27617
{{BEQ{8,WB{18,=CH_HT{6,TRIM1{JUMP IF HORIZONTAL TAB{27619
{{BNE{8,WB{8,WC{6,TRIM3{JUMP IF NON-BLANK FOUND{27621
{TRIM1{DCV{8,WA{{{ELSE DECREMENT CHARACTER COUNT{27622
{{BNZ{8,WA{6,TRIM0{{LOOP BACK IF MORE TO CHECK{27623
*
*      HERE IF RESULT IS NULL (NULL OR ALL-BLANK INPUT)
*
{TRIM2{MOV{3,DNAMP{7,XR{{WIPE OUT INPUT STRING BLOCK{27627
{{MOV{7,XR{21,=NULLS{{LOAD NULL RESULT{27628
{{BRN{6,TRIM5{{{MERGE TO EXIT{27629
{{EJC{{{{{27630
*
*      TRIMR (CONTINUED)
*
*      HERE WITH NON-BLANK FOUND (MERGE FOR NO TRIM)
*
{TRIM3{MOV{13,SCLEN(XR){8,WA{{SET NEW LENGTH{27636
{{MOV{7,XL{7,XR{{COPY STRING POINTER{27637
{{PSC{7,XL{8,WA{{READY FOR STORING BLANKS{27638
{{CTB{8,WA{2,SCHAR{{GET LENGTH OF BLOCK IN BYTES{27639
{{ADD{8,WA{7,XR{{POINT PAST NEW BLOCK{27640
{{MOV{3,DNAMP{8,WA{{SET NEW TOP OF STORAGE POINTER{27641
{{LCT{8,WA{18,=CFP_C{{GET COUNT OF CHARS IN WORD{27642
{{ZER{8,WC{{{SET ZERO CHAR{27643
*
*      LOOP TO ZERO PAD LAST WORD OF CHARACTERS
*
{TRIM4{SCH{8,WC{10,(XL)+{{STORE ZERO CHARACTER{27647
{{BCT{8,WA{6,TRIM4{{LOOP BACK TILL ALL STORED{27648
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{27649
*
*      COMMON EXIT POINT
*
{TRIM5{ZER{7,XL{{{CLEAR GARBAGE XL POINTER{27653
{{EXI{{{{RETURN TO CALLER{27654
{{ENP{{{{END PROCEDURE TRIMR{27655
{{EJC{{{{{27656
*
*      TRXEQ -- EXECUTE FUNCTION TYPE TRACE
*
*      TRXEQ IS USED TO EXECUTE A TRACE WHEN A FOURTH ARGUMENT
*      HAS BEEN SUPPLIED. TRACE HAS ALREADY BEEN DECREMENTED.
*
*      (XR)                  POINTER TO TRBLK
*      (XL,WA)               NAME BASE,OFFSET FOR VARIABLE
*      JSR  TRXEQ            CALL TO EXECUTE TRACE
*      (WB,WC,RA)            DESTROYED
*
*      THE FOLLOWING STACK ENTRIES ARE MADE BEFORE PASSING
*      CONTROL TO THE TRACE FUNCTION USING THE CFUNC ROUTINE.
*
*                            TRXEQ RETURN POINT WORD(S)
*                            SAVED VALUE OF TRACE KEYWORD
*                            TRBLK POINTER
*                            NAME BASE
*                            NAME OFFSET
*                            SAVED VALUE OF R_COD
*                            SAVED CODE PTR (-R_COD)
*                            SAVED VALUE OF FLPTR
*      FLPTR --------------- ZERO (DUMMY FAIL OFFSET)
*                            NMBLK FOR VARIABLE NAME
*      XS ------------------ TRACE TAG
*
*      R_COD AND THE CODE PTR ARE SET TO DUMMY VALUES WHICH
*      CAUSE CONTROL TO RETURN TO THE TRXEQ PROCEDURE ON SUCCESS
*      OR FAILURE (TRXEQ IGNORES A FAILURE CONDITION).
*
{TRXEQ{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE){27687
{{MOV{8,WC{3,R_COD{{LOAD CODE BLOCK POINTER{27688
{{SCP{8,WB{{{GET CURRENT CODE POINTER{27689
{{SUB{8,WB{8,WC{{MAKE CODE POINTER INTO OFFSET{27690
{{MOV{11,-(XS){3,KVTRA{{STACK TRACE KEYWORD VALUE{27691
{{MOV{11,-(XS){7,XR{{STACK TRBLK POINTER{27692
{{MOV{11,-(XS){7,XL{{STACK NAME BASE{27693
{{MOV{11,-(XS){8,WA{{STACK NAME OFFSET{27694
{{MOV{11,-(XS){8,WC{{STACK CODE BLOCK POINTER{27695
{{MOV{11,-(XS){8,WB{{STACK CODE POINTER OFFSET{27696
{{MOV{11,-(XS){3,FLPTR{{STACK OLD FAILURE POINTER{27697
{{ZER{11,-(XS){{{SET DUMMY FAIL OFFSET{27698
{{MOV{3,FLPTR{7,XS{{SET NEW FAILURE POINTER{27699
{{ZER{3,KVTRA{{{RESET TRACE KEYWORD TO ZERO{27700
{{MOV{8,WC{21,=TRXDC{{LOAD NEW (DUMMY) CODE BLK POINTER{27701
{{MOV{3,R_COD{8,WC{{SET AS CODE BLOCK POINTER{27702
{{LCP{8,WC{{{AND NEW CODE POINTER{27703
{{EJC{{{{{27704
*
*      TRXEQ (CONTINUED)
*
*      NOW PREPARE ARGUMENTS FOR FUNCTION
*
{{MOV{8,WB{8,WA{{SAVE NAME OFFSET{27710
{{MOV{8,WA{19,*NMSI_{{LOAD NMBLK SIZE{27711
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR NMBLK{27712
{{MOV{9,(XR){22,=B_NML{{SET TYPE WORD{27713
{{MOV{13,NMBAS(XR){7,XL{{STORE NAME BASE{27714
{{MOV{13,NMOFS(XR){8,WB{{STORE NAME OFFSET{27715
{{MOV{7,XL{12,6(XS){{RELOAD POINTER TO TRBLK{27716
{{MOV{11,-(XS){7,XR{{STACK NMBLK POINTER (1ST ARGUMENT){27717
{{MOV{11,-(XS){13,TRTAG(XL){{STACK TRACE TAG (2ND ARGUMENT){27718
{{MOV{7,XL{13,TRFNC(XL){{LOAD TRACE VRBLK POINTER{27719
{{MOV{7,XL{13,VRFNC(XL){{LOAD TRACE FUNCTION POINTER{27720
{{BEQ{7,XL{21,=STNDF{6,TRXQ2{JUMP IF NOT A DEFINED FUNCTION{27721
{{MOV{8,WA{18,=NUM02{{SET NUMBER OF ARGUMENTS TO TWO{27722
{{BRN{6,CFUNC{{{JUMP TO CALL FUNCTION{27723
*
*      SEE O_TXR FOR DETAILS OF RETURN TO THIS POINT
*
{TRXQ1{MOV{7,XS{3,FLPTR{{POINT BACK TO OUR STACK ENTRIES{27727
{{ICA{7,XS{{{POP OFF GARBAGE FAIL OFFSET{27728
{{MOV{3,FLPTR{10,(XS)+{{RESTORE OLD FAILURE POINTER{27729
{{MOV{8,WB{10,(XS)+{{RELOAD CODE OFFSET{27730
{{MOV{8,WC{10,(XS)+{{LOAD OLD CODE BASE POINTER{27731
{{MOV{7,XR{8,WC{{COPY CDBLK POINTER{27732
{{MOV{3,KVSTN{13,CDSTM(XR){{RESTORE STMNT NO{27733
{{MOV{8,WA{10,(XS)+{{RELOAD NAME OFFSET{27734
{{MOV{7,XL{10,(XS)+{{RELOAD NAME BASE{27735
{{MOV{7,XR{10,(XS)+{{RELOAD TRBLK POINTER{27736
{{MOV{3,KVTRA{10,(XS)+{{RESTORE TRACE KEYWORD VALUE{27737
{{ADD{8,WB{8,WC{{RECOMPUTE ABSOLUTE CODE POINTER{27738
{{LCP{8,WB{{{RESTORE CODE POINTER{27739
{{MOV{3,R_COD{8,WC{{AND CODE BLOCK POINTER{27740
{{EXI{{{{RETURN TO TRXEQ CALLER{27741
*
*      HERE IF THE TARGET FUNCTION IS NOT DEFINED
*
{TRXQ2{ERB{1,197{26,TRACE fourth arg is not function name or null{{{27745
*
{{ENP{{{{END PROCEDURE TRXEQ{27747
{{EJC{{{{{27748
*
*      XSCAN -- EXECUTION FUNCTION ARGUMENT SCAN
*
*      XSCAN SCANS OUT ONE TOKEN IN A PROTOTYPE ARGUMENT IN
*      ARRAY,CLEAR,DATA,DEFINE,LOAD FUNCTION CALLS. XSCAN
*      CALLS MUST BE PRECEDED BY A CALL TO THE INITIALIZATION
*      PROCEDURE XSCNI. THE FOLLOWING VARIABLES ARE USED.
*
*      R_XSC                 POINTER TO SCBLK FOR FUNCTION ARG
*      XSOFS                 OFFSET (NUM CHARS SCANNED SO FAR)
*
*      (WA)                  NON-ZERO TO SKIP AND TRIM BLANKS
*      (WC)                  DELIMITER ONE (CH_XX)
*      (XL)                  DELIMITER TWO (CH_XX)
*      JSR  XSCAN            CALL TO SCAN NEXT ITEM
*      (XR)                  POINTER TO SCBLK FOR TOKEN SCANNED
*      (WA)                  COMPLETION CODE (SEE BELOW)
*      (WC,XL)               DESTROYED
*
*      THE SCAN STARTS FROM THE CURRENT POSITION AND CONTINUES
*      UNTIL ONE OF THE FOLLOWING THREE CONDITIONS OCCURS.
*
*      1)   DELIMITER ONE IS ENCOUNTERED  (WA SET TO 1)
*
*      2)   DELIMITER TWO ENCOUNTERED  (WA SET TO 2)
*
*      3)   END OF STRING ENCOUNTERED  (WA SET TO 0)
*
*      THE RESULT IS A STRING CONTAINING ALL CHARACTERS SCANNED
*      UP TO BUT NOT INCLUDING ANY DELIMITER CHARACTER.
*      THE POINTER IS LEFT POINTING PAST THE DELIMITER.
*
*      IF ONLY ONE DELIMITER IS TO BE DETECTED, DELIMITER ONE
*      AND DELIMITER TWO SHOULD BE SET TO THE SAME VALUE.
*
*      IN THE CASE WHERE THE END OF STRING IS ENCOUNTERED, THE
*      STRING INCLUDES ALL THE CHARACTERS TO THE END OF THE
*      STRING. NO FURTHER CALLS CAN BE MADE TO XSCAN UNTIL
*      XSCNI IS CALLED TO INITIALIZE A NEW ARGUMENT SCAN
{{EJC{{{{{27788
*
*      XSCAN (CONTINUED)
*
{XSCAN{PRC{25,E{1,0{{ENTRY POINT{27792
{{MOV{3,XSCWB{8,WB{{PRESERVE WB{27793
{{MOV{11,-(XS){8,WA{{RECORD BLANK SKIP FLAG{27794
{{MOV{11,-(XS){8,WA{{AND SECOND COPY{27795
{{MOV{7,XR{3,R_XSC{{POINT TO ARGUMENT STRING{27796
{{MOV{8,WA{13,SCLEN(XR){{LOAD STRING LENGTH{27797
{{MOV{8,WB{3,XSOFS{{LOAD CURRENT OFFSET{27798
{{SUB{8,WA{8,WB{{GET NUMBER OF REMAINING CHARACTERS{27799
{{BZE{8,WA{6,XSCN3{{JUMP IF NO CHARACTERS LEFT{27800
{{PLC{7,XR{8,WB{{POINT TO CURRENT CHARACTER{27801
*
*      LOOP TO SEARCH FOR DELIMITER
*
{XSCN1{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{27805
{{BEQ{8,WB{8,WC{6,XSCN4{JUMP IF DELIMITER ONE FOUND{27806
{{BEQ{8,WB{7,XL{6,XSCN5{JUMP IF DELIMITER TWO FOUND{27807
{{BZE{9,(XS){6,XSCN2{{JUMP IF NOT SKIPPING BLANKS{27808
{{ICV{3,XSOFS{{{ASSUME BLANK AND DELETE IT{27809
{{BEQ{8,WB{18,=CH_HT{6,XSCN2{JUMP IF HORIZONTAL TAB{27811
{{BEQ{8,WB{18,=CH_BL{6,XSCN2{JUMP IF BLANK{27816
{{DCV{3,XSOFS{{{UNDELETE NON-BLANK CHARACTER{27817
{{ZER{9,(XS){{{AND DISCONTINUE BLANK CHECKING{27818
*
*      HERE AFTER PERFORMING ANY LEADING BLANK TRIMMING.
*
{XSCN2{DCV{8,WA{{{DECREMENT COUNT OF CHARS LEFT{27822
{{BNZ{8,WA{6,XSCN1{{LOOP BACK IF MORE CHARS TO GO{27823
*
*      HERE FOR RUNOUT
*
{XSCN3{MOV{7,XL{3,R_XSC{{POINT TO STRING BLOCK{27827
{{MOV{8,WA{13,SCLEN(XL){{GET STRING LENGTH{27828
{{MOV{8,WB{3,XSOFS{{LOAD OFFSET{27829
{{SUB{8,WA{8,WB{{GET SUBSTRING LENGTH{27830
{{ZER{3,R_XSC{{{CLEAR STRING PTR FOR COLLECTOR{27831
{{ZER{3,XSCRT{{{SET ZERO (RUNOUT) RETURN CODE{27832
{{BRN{6,XSCN7{{{JUMP TO EXIT{27833
{{EJC{{{{{27834
*
*      XSCAN (CONTINUED)
*
*      HERE IF DELIMITER ONE FOUND
*
{XSCN4{MOV{3,XSCRT{18,=NUM01{{SET RETURN CODE{27840
{{BRN{6,XSCN6{{{JUMP TO MERGE{27841
*
*      HERE IF DELIMITER TWO FOUND
*
{XSCN5{MOV{3,XSCRT{18,=NUM02{{SET RETURN CODE{27845
*
*      MERGE HERE AFTER DETECTING A DELIMITER
*
{XSCN6{MOV{7,XL{3,R_XSC{{RELOAD POINTER TO STRING{27849
{{MOV{8,WC{13,SCLEN(XL){{GET ORIGINAL LENGTH OF STRING{27850
{{SUB{8,WC{8,WA{{MINUS CHARS LEFT = CHARS SCANNED{27851
{{MOV{8,WA{8,WC{{MOVE TO REG FOR SBSTR{27852
{{MOV{8,WB{3,XSOFS{{SET OFFSET{27853
{{SUB{8,WA{8,WB{{COMPUTE LENGTH FOR SBSTR{27854
{{ICV{8,WC{{{ADJUST NEW CURSOR PAST DELIMITER{27855
{{MOV{3,XSOFS{8,WC{{STORE NEW OFFSET{27856
*
*      COMMON EXIT POINT
*
{XSCN7{ZER{7,XR{{{CLEAR GARBAGE CHARACTER PTR IN XR{27860
{{JSR{6,SBSTR{{{BUILD SUB-STRING{27861
{{ICA{7,XS{{{REMOVE COPY OF BLANK FLAG{27862
{{MOV{8,WB{10,(XS)+{{ORIGINAL BLANK SKIP/TRIM FLAG{27863
{{BZE{13,SCLEN(XR){6,XSCN8{{CANNOT TRIM THE NULL STRING{27864
{{JSR{6,TRIMR{{{TRIM TRAILING BLANKS IF REQUESTED{27865
*
*      FINAL EXIT POINT
*
{XSCN8{MOV{8,WA{3,XSCRT{{LOAD RETURN CODE{27869
{{MOV{8,WB{3,XSCWB{{RESTORE WB{27870
{{EXI{{{{RETURN TO XSCAN CALLER{27871
{{ENP{{{{END PROCEDURE XSCAN{27872
{{EJC{{{{{27873
*
*      XSCNI -- EXECUTION FUNCTION ARGUMENT SCAN
*
*      XSCNI INITIALIZES THE SCAN USED FOR PROTOTYPE ARGUMENTS
*      IN THE CLEAR, DEFINE, LOAD, DATA, ARRAY FUNCTIONS. SEE
*      XSCAN FOR THE PROCEDURE WHICH IS USED AFTER THIS CALL.
*
*      -(XS)                 ARGUMENT TO BE SCANNED (ON STACK)
*      JSR  XSCNI            CALL TO SCAN ARGUMENT
*      PPM  LOC              TRANSFER LOC IF ARG IS NOT STRING
*      PPM  LOC              TRANSFER LOC IF ARGUMENT IS NULL
*      (XS)                  POPPED
*      (XR,R_XSC)            ARGUMENT (SCBLK PTR)
*      (WA)                  ARGUMENT LENGTH
*      (IA,RA)               DESTROYED
*
{XSCNI{PRC{25,N{1,2{{ENTRY POINT{27890
{{JSR{6,GTSTG{{{FETCH ARGUMENT AS STRING{27891
{{PPM{6,XSCI1{{{JUMP IF NOT CONVERTIBLE{27892
{{MOV{3,R_XSC{7,XR{{ELSE STORE SCBLK PTR FOR XSCAN{27893
{{ZER{3,XSOFS{{{SET OFFSET TO ZERO{27894
{{BZE{8,WA{6,XSCI2{{JUMP IF NULL STRING{27895
{{EXI{{{{RETURN TO XSCNI CALLER{27896
*
*      HERE IF ARGUMENT IS NOT A STRING
*
{XSCI1{EXI{1,1{{{TAKE NOT-STRING ERROR EXIT{27900
*
*      HERE FOR NULL STRING
*
{XSCI2{EXI{1,2{{{TAKE NULL-STRING ERROR EXIT{27904
{{ENP{{{{END PROCEDURE XSCNI{27905
{{TTL{27,S P I T B O L -- STACK OVERFLOW SECTION{{{{27906
*
*      CONTROL COMES HERE IF THE MAIN STACK OVERFLOWS
*
{{SEC{{{{START OF STACK OVERFLOW SECTION{27910
*
{{ADD{3,ERRFT{18,=NUM04{{FORCE CONCLUSIVE FATAL ERROR{27912
{{MOV{7,XS{3,FLPTR{{POP STACK TO AVOID MORE FAILS{27913
{{BNZ{3,GBCFL{6,STAK1{{JUMP IF GARBAGE COLLECTING{27914
{{ERB{1,246{26,Stack overflow{{{27915
*
*      NO CHANCE OF RECOVERY IN MID GARBAGE COLLECTION
*
{STAK1{MOV{7,XR{21,=ENDSO{{POINT TO MESSAGE{27919
{{ZER{3,KVDMP{{{MEMORY IS UNDUMPABLE{27920
{{BRN{6,STOPR{{{GIVE UP{27921
{{TTL{27,S P I T B O L -- ERROR SECTION{{{{27922
*
*      THIS SECTION OF CODE IS ENTERED WHENEVER A PROCEDURE
*      RETURN VIA AN ERR PARAMETER OR AN ERB OPCODE IS OBEYED.
*
*      (WA)                  IS THE ERROR CODE
*
*      THE GLOBAL VARIABLE STAGE INDICATES THE POINT AT WHICH
*      THE ERROR OCCURED AS FOLLOWS.
*
*      STAGE=STGIC           ERROR DURING INITIAL COMPILE
*
*      STAGE=STGXC           ERROR DURING COMPILE AT EXECUTE
*                            TIME (CODE, CONVERT FUNCTION CALLS)
*
*      STAGE=STGEV           ERROR DURING COMPILATION OF
*                            EXPRESSION AT EXECUTION TIME
*                            (EVAL, CONVERT FUNCTION CALL).
*
*      STAGE=STGXT           ERROR AT EXECUTE TIME. COMPILER
*                            NOT ACTIVE.
*
*      STAGE=STGCE           ERROR DURING INITIAL COMPILE AFTER
*                            SCANNING OUT THE END LINE.
*
*      STAGE=STGXE           ERROR DURING COMPILE AT EXECUTE
*                            TIME AFTER SCANNING END LINE.
*
*      STAGE=STGEE           ERROR DURING EXPRESSION EVALUATION
*
{{SEC{{{{START OF ERROR SECTION{27952
*
{ERROR{BEQ{3,R_CIM{20,=CMLAB{6,CMPLE{JUMP IF ERROR IN SCANNING LABEL{27954
{{MOV{3,KVERT{8,WA{{SAVE ERROR CODE{27955
{{ZER{3,SCNRS{{{RESET RESCAN SWITCH FOR SCANE{27956
{{ZER{3,SCNGO{{{RESET GOTO SWITCH FOR SCANE{27957
{{MOV{3,POLCS{18,=NUM01{{RESET POLL COUNT{27959
{{MOV{3,POLCT{18,=NUM01{{RESET POLL COUNT{27960
{{MOV{7,XR{3,STAGE{{LOAD CURRENT STAGE{27962
{{BSW{7,XR{2,STGNO{{JUMP TO APPROPRIATE ERROR CIRCUIT{27963
{{IFF{2,STGIC{6,ERR01{{INITIAL COMPILE{27971
{{IFF{2,STGXC{6,ERR04{{EXECUTE TIME COMPILE{27971
{{IFF{2,STGEV{6,ERR04{{EVAL COMPILING EXPR.{27971
{{IFF{2,STGXT{6,ERR05{{EXECUTE TIME{27971
{{IFF{2,STGCE{6,ERR01{{COMPILE - AFTER END{27971
{{IFF{2,STGXE{6,ERR04{{XEQ COMPILE-PAST END{27971
{{IFF{2,STGEE{6,ERR04{{EVAL EVALUATING EXPR{27971
{{ESW{{{{END SWITCH ON ERROR TYPE{27971
{{EJC{{{{{27972
*
*      ERROR DURING INITIAL COMPILE
*
*      THE ERROR MESSAGE IS PRINTED AS PART OF THE COMPILER
*      OUTPUT. THIS PRINTOUT INCLUDES THE OFFENDING LINE (IF NOT
*      PRINTED ALREADY) AND AN ERROR FLAG UNDER THE APPROPRIATE
*      COLUMN AS INDICATED BY SCNSE UNLESS SCNSE IS SET TO ZERO.
*
*      AFTER PRINTING THE MESSAGE, THE GENERATED CODE IS
*      MODIFIED TO AN ERROR CALL AND CONTROL IS RETURNED TO
*      THE CMPIL PROCEDURE AFTER RESETTING THE STACK POINTER.
*
*      IF THE ERROR OCCURS AFTER THE END LINE, CONTROL RETURNS
*      IN A SLIGHTLY DIFFERENT MANNER TO ENSURE PROPER CLEANUP.
*
{ERR01{MOV{7,XS{3,CMPXS{{RESET STACK POINTER{27988
{{SSL{3,CMPSS{{{RESTORE S-R STACK PTR FOR CMPIL{27989
{{BNZ{3,ERRSP{6,ERR03{{JUMP IF ERROR SUPPRESS FLAG SET{27990
{{MOV{8,WC{3,CMPSN{{CURRENT STATEMENT{27993
{{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STATEMENT{27994
{{MOV{8,WB{3,SCNSE{{COLUMN NUMBER{27996
{{MOV{8,WC{3,RDCLN{{LINE NUMBER{27997
{{MOV{7,XR{3,STAGE{{{27998
{{JSR{6,SYSEA{{{ADVISE SYSTEM OF ERROR{27999
{{PPM{6,ERRA3{{{IF SYSTEM DOES NOT WANT PRINT{28000
{{MOV{11,-(XS){7,XR{{SAVE ANY PROVIDED PRINT MESSAGE{28001
{{MOV{3,ERLST{3,ERICH{{SET FLAG FOR LISTR{28003
{{JSR{6,LISTR{{{LIST LINE{28004
{{JSR{6,PRTIS{{{TERMINATE LISTING{28005
{{ZER{3,ERLST{{{CLEAR LISTR FLAG{28006
{{MOV{8,WA{3,SCNSE{{LOAD SCAN ELEMENT OFFSET{28007
{{BZE{8,WA{6,ERR02{{SKIP IF NOT SET{28008
{{LCT{8,WB{8,WA{{LOOP COUNTER{28010
{{ICV{8,WA{{{INCREASE FOR CH_EX{28011
{{MOV{7,XL{3,R_CIM{{POINT TO BAD STATEMENT{28012
{{JSR{6,ALOCS{{{STRING BLOCK FOR ERROR FLAG{28013
{{MOV{8,WA{7,XR{{REMEMBER STRING PTR{28014
{{PSC{7,XR{{{READY FOR CHARACTER STORING{28015
{{PLC{7,XL{{{READY TO GET CHARS{28016
*
*      LOOP TO REPLACE ALL CHARS BUT TABS BY BLANKS
*
{ERRA1{LCH{8,WC{10,(XL)+{{GET NEXT CHAR{28020
{{BEQ{8,WC{18,=CH_HT{6,ERRA2{SKIP IF TAB{28021
{{MOV{8,WC{18,=CH_BL{{GET A BLANK{28022
{{EJC{{{{{28023
*
*      MERGE TO STORE BLANK OR TAB IN ERROR LINE
*
{ERRA2{SCH{8,WC{10,(XR)+{{STORE CHAR{28027
{{BCT{8,WB{6,ERRA1{{LOOP{28028
{{MOV{7,XL{18,=CH_EX{{EXCLAMATION MARK{28029
{{SCH{7,XL{9,(XR){{STORE AT END OF ERROR LINE{28030
{{CSC{7,XR{{{END OF SCH LOOP{28031
{{MOV{3,PROFS{18,=STNPD{{ALLOW FOR STATEMENT NUMBER{28032
{{MOV{7,XR{8,WA{{POINT TO ERROR LINE{28033
{{JSR{6,PRTST{{{PRINT ERROR LINE{28034
*
*      HERE AFTER PLACING ERROR FLAG AS REQUIRED
*
{ERR02{JSR{6,PRTIS{{{PRINT BLANK LINE{28048
{{MOV{7,XR{10,(XS)+{{RESTORE ANY SYSEA MESSAGE{28050
{{BZE{7,XR{6,ERRA0{{DID SYSEA PROVIDE MESSAGE TO PRINT{28051
{{JSR{6,PRTST{{{PRINT SYSEA MESSAGE{28052
{ERRA0{JSR{6,ERMSG{{{GENERATE FLAG AND ERROR MESSAGE{28054
{{ADD{3,LSTLC{18,=NUM03{{BUMP PAGE CTR FOR BLANK, ERROR, BLK{28055
{ERRA3{ZER{7,XR{{{IN CASE OF FATAL ERROR{28056
{{BHI{3,ERRFT{18,=NUM03{6,STOPR{PACK UP IF SEVERAL FATALS{28057
*
*      COUNT ERROR, INHIBIT EXECUTION IF REQUIRED
*
{{ICV{3,CMERC{{{BUMP ERROR COUNT{28061
{{ADD{3,NOXEQ{3,CSWER{{INHIBIT XEQ IF -NOERRORS{28062
{{BNE{3,STAGE{18,=STGIC{6,CMP10{SPECIAL RETURN IF AFTER END LINE{28063
{{EJC{{{{{28064
*
*      LOOP TO SCAN TO END OF STATEMENT
*
{ERR03{MOV{7,XR{3,R_CIM{{POINT TO START OF IMAGE{28068
{{PLC{7,XR{{{POINT TO FIRST CHAR{28069
{{LCH{7,XR{9,(XR){{GET FIRST CHAR{28070
{{BEQ{7,XR{18,=CH_MN{6,CMPCE{JUMP IF ERROR IN CONTROL CARD{28071
{{ZER{3,SCNRS{{{CLEAR RESCAN FLAG{28072
{{MNZ{3,ERRSP{{{SET ERROR SUPPRESS FLAG{28073
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{28074
{{BNE{7,XL{18,=T_SMC{6,ERR03{LOOP BACK IF NOT STATEMENT END{28075
{{ZER{3,ERRSP{{{CLEAR ERROR SUPPRESS FLAG{28076
*
*      GENERATE ERROR CALL IN CODE AND RETURN TO CMPIL
*
{{MOV{3,CWCOF{19,*CDCOD{{RESET OFFSET IN CCBLK{28080
{{MOV{8,WA{21,=OCER_{{LOAD COMPILE ERROR CALL{28081
{{JSR{6,CDWRD{{{GENERATE IT{28082
{{MOV{13,CMSOC(XS){3,CWCOF{{SET SUCCESS FILL IN OFFSET{28083
{{MNZ{13,CMFFC(XS){{{SET FAILURE FILL IN FLAG{28084
{{JSR{6,CDWRD{{{GENERATE SUCC. FILL IN WORD{28085
{{BRN{6,CMPSE{{{MERGE TO GENERATE ERROR AS CDFAL{28086
*
*      ERROR DURING EXECUTE TIME COMPILE OR EXPRESSION EVALUATIO
*
*      EXECUTE TIME COMPILATION IS INITIATED THROUGH GTCOD OR
*      GTEXP WHICH ARE CALLED BY COMPILE, CODE OR EVAL.
*      BEFORE CAUSING STATEMENT FAILURE THROUGH EXFAL IT IS
*      HELPFUL TO SET KEYWORD ERRTEXT AND FOR GENERALITY
*      THESE ERRORS MAY BE HANDLED BY THE SETEXIT MECHANISM.
*
{ERR04{BGE{3,ERRFT{18,=NUM03{6,LABO1{ABORT IF TOO MANY FATAL ERRORS{28096
{{BEQ{3,KVERT{18,=NM320{6,ERR06{TREAT USER INTERRUPT SPECIALLY{28098
{{ZER{3,R_CCB{{{FORGET GARBAGE CODE BLOCK{28100
{{MOV{3,CWCOF{19,*CCCOD{{SET INITIAL OFFSET (MBE CATSPAW){28101
{{SSL{3,INISS{{{RESTORE MAIN PROG S-R STACK PTR{28102
{{JSR{6,ERTEX{{{GET FAIL MESSAGE TEXT{28103
{{DCA{7,XS{{{ENSURE STACK OK ON LOOP START{28104
*
*      POP STACK UNTIL FIND FLPTR FOR MOST DEEPLY NESTED PROG.
*      DEFINED FUNCTION CALL OR CALL OF EVAL / CODE.
*
{ERRA4{ICA{7,XS{{{POP STACK{28109
{{BEQ{7,XS{3,FLPRT{6,ERRC4{JUMP IF PROG DEFINED FN CALL FOUND{28110
{{BNE{7,XS{3,GTCEF{6,ERRA4{LOOP IF NOT EVAL OR CODE CALL YET{28111
{{MOV{3,STAGE{18,=STGXT{{RE-SET STAGE FOR EXECUTE{28112
{{MOV{3,R_COD{3,R_GTC{{RECOVER CODE PTR{28113
{{MOV{3,FLPTR{7,XS{{RESTORE FAIL POINTER{28114
{{ZER{3,R_CIM{{{FORGET POSSIBLE IMAGE{28115
{{ZER{3,CNIND{{{FORGET POSSIBLE INCLUDE{28117
*
*      TEST ERRLIMIT
*
{ERRB4{BNZ{3,KVERL{6,ERR07{{JUMP IF ERRLIMIT NON-ZERO{28122
{{BRN{6,EXFAL{{{FAIL{28123
*
*      RETURN FROM PROG. DEFINED FUNCTION IS OUTSTANDING
*
{ERRC4{MOV{7,XS{3,FLPTR{{RESTORE STACK FROM FLPTR{28127
{{BRN{6,ERRB4{{{MERGE{28128
{{EJC{{{{{28129
*
*      ERROR AT EXECUTE TIME.
*
*      THE ACTION TAKEN ON AN ERROR IS AS FOLLOWS.
*
*      IF ERRLIMIT KEYWORD IS ZERO, AN ABORT IS SIGNALLED,
*      SEE CODING FOR SYSTEM LABEL ABORT AT L_ABO.
*
*      OTHERWISE, ERRLIMIT IS DECREMENTED AND AN ERRTYPE TRACE
*      GENERATED IF REQUIRED. CONTROL RETURNS EITHER VIA A JUMP
*      TO CONTINUE (TO TAKE THE FAILURE EXIT) OR A SPECIFIED
*      SETEXIT TRAP IS EXECUTED AND CONTROL PASSES TO THE TRAP.
*      IF 3 OR MORE FATAL ERRORS OCCUR AN ABORT IS SIGNALLED
*      REGARDLESS OF ERRLIMIT AND SETEXIT - LOOPING IS ALL TOO
*      PROBABLE OTHERWISE. FATAL ERRORS INCLUDE STACK OVERFLOW
*      AND EXCEEDING STLIMIT.
*
{ERR05{SSL{3,INISS{{{RESTORE MAIN PROG S-R STACK PTR{28147
{{BNZ{3,DMVCH{6,ERR08{{JUMP IF IN MID-DUMP{28148
*
*      MERGE HERE FROM ERR08 AND ERR04 (ERROR 320)
*
{ERR06{BZE{3,KVERL{6,LABO1{{ABORT IF ERRLIMIT IS ZERO{28152
{{JSR{6,ERTEX{{{GET FAIL MESSAGE TEXT{28153
*
*      MERGE FROM ERR04
*
{ERR07{BGE{3,ERRFT{18,=NUM03{6,LABO1{ABORT IF TOO MANY FATAL ERRORS{28157
{{DCV{3,KVERL{{{DECREMENT ERRLIMIT{28158
{{MOV{7,XL{3,R_ERT{{LOAD ERRTYPE TRACE POINTER{28159
{{JSR{6,KTREX{{{GENERATE ERRTYPE TRACE IF REQUIRED{28160
{{MOV{8,WA{3,R_COD{{GET CURRENT CODE BLOCK{28161
{{MOV{3,R_CNT{8,WA{{SET CDBLK PTR FOR CONTINUATION{28162
{{SCP{8,WB{{{CURRENT CODE POINTER{28163
{{SUB{8,WB{8,WA{{OFFSET WITHIN CODE BLOCK{28164
{{MOV{3,STXOC{8,WB{{SAVE CODE PTR OFFSET FOR SCONTINUE{28165
{{MOV{7,XR{3,FLPTR{{SET PTR TO FAILURE OFFSET{28166
{{MOV{3,STXOF{9,(XR){{SAVE FAILURE OFFSET FOR CONTINUE{28167
{{MOV{7,XR{3,R_SXC{{LOAD SETEXIT CDBLK POINTER{28168
{{BZE{7,XR{6,LCNT1{{CONTINUE IF NO SETEXIT TRAP{28169
{{ZER{3,R_SXC{{{ELSE RESET TRAP{28170
{{MOV{3,STXVR{21,=NULLS{{RESET SETEXIT ARG TO NULL{28171
{{MOV{7,XL{9,(XR){{LOAD PTR TO CODE BLOCK ROUTINE{28172
{{BRI{7,XL{{{EXECUTE FIRST TRAP STATEMENT{28173
*
*      INTERRUPTED PARTLY THROUGH A DUMP WHILST STORE IS IN A
*      MESS SO DO A TIDY UP OPERATION. SEE DUMPR FOR DETAILS.
*
{ERR08{MOV{7,XR{3,DMVCH{{CHAIN HEAD FOR AFFECTED VRBLKS{28178
{{BZE{7,XR{6,ERR06{{DONE IF ZERO{28179
{{MOV{3,DMVCH{9,(XR){{SET NEXT LINK AS CHAIN HEAD{28180
{{JSR{6,SETVR{{{RESTORE VRGET FIELD{28181
*
*      LABEL TO MARK END OF CODE
*
{S_YYY{BRN{6,ERR08{{{LOOP THROUGH CHAIN{28185
{{TTL{27,S P I T B O L -- HERE ENDETH THE CODE{{{{28186
*
*      END OF ASSEMBLY
*
{{END{{{{END MACRO-SPITBOL ASSEMBLY{28190
